<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Xueqiu_Forever] 发言时段总结 - 2025-06-14</title>
      <link href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/"/>
      <url>/2025/06/14/Xueqiu_Forever-summary-2025-06-14/</url>
      
        <content type="html"><![CDATA[<!-- AI Summary --><h2 id="🤖-AI-总结"><a href="#🤖-AI-总结" class="headerlink" title="🤖 AI 总结"></a>🤖 AI 总结</h2><ol><li><p><strong>【核心观点】</strong>在投资中采用“底线思维”，即在资产表现极差时介入，可以捕捉到后续股价大幅反弹的机会。 <a href="xueqiu://4138302318/338746724" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[1]</sup></a></p></li><li><p><strong>【操作信号】</strong>[买入] [标的: 周大福(01929)] (信心: 高) - 理由: 股价在极差时大涨，是典型的“底线思维”成功案例；作者此前关注的金风也通过此策略实现了倍增。 <a href="xueqiu://4138302318/338746724" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[2]</sup></a></p></li><li><p><strong>【核心观点】</strong>发现“大牛股”的关键在于观察生活中的行业大趋势和公司发展，并结合财务报告进行验证，印证了彼得·林奇的投资理念。 <a href="xueqiu://4138302318/338749903" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[3]</sup></a></p></li><li><p><strong>【核心观点】</strong>对于长期不涨但具备生存能力的企业，应坚持分红复投策略，长期持有（例如10年），以此积累财富。 <a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[4]</sup></a></p></li><li><p><strong>【核心观点】</strong>（墨子非韩）年轻投资者拥有时间优势，可以承担更长的套牢期，即使短期买早也能通过长期持有（如三年）获得稳健回报，并期待市场对价值资产的重新评估。 <a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[5]</sup></a></p></li><li><p><strong>【操作信号】</strong>[买入/持有] [标的: 泸州老窖(SZ000568), 五粮液(SZ000858), 洋河股份(SZ002304)] (信心: 中) - 理由: 博主已满仓白酒，认为即使买早，长期持有（3年）也可能获得7.5%年化回报，甚至翻倍，并押注后续财报企稳和市场价值重估。 <a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[6]</sup></a></p></li><li><p><strong>【风险警告】</strong>（墨子非韩）博主明确不建议粉丝复制其白酒投资策略，并承认自己可能买早且是在“赌”中报业绩未爆雷和三季报企稳。 <a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[7]</sup></a></p></li><li><p><strong>【风险警告】</strong>（Forever）承认年轻人嘴上说能熬，实际很难长期坚持持有不涨的股票，揭示了长期投资中投资者面临的心理挑战。 <a href="xueqiu://4138302318/338751988" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[8]</sup></a></p></li><li><p><strong>【核心观点】</strong>投资最大化需顺应趋势，避免迷恋单一行业，并利用低估行业的轮动机会。核心策略为：在好行业、好公司、好价格时买入；持续低估时分红加仓；合理时持有享受股息；高估时逐步卖出；泡沫时彻底清仓。 <a href="xueqiu://4138302318/338752448" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[9]</sup></a></p></li><li><p><strong>【风险警告】</strong>不应迷恋单一行业投资，暗示了集中度过高带来的风险。 <a href="xueqiu://4138302318/338752448" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[10]</sup></a><br><br></p></li></ol><h4 id="引用来源"><a href="#引用来源" class="headerlink" title="引用来源"></a>引用来源</h4><ol>  <li id="ref-1">[<a href="xueqiu://4138302318/338746724" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338746724" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338746724</a></li>  <li id="ref-2">[<a href="xueqiu://4138302318/338746724" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338746724" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338746724</a></li>  <li id="ref-3">[<a href="xueqiu://4138302318/338749903" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338749903" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338749903</a></li>  <li id="ref-4">[<a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338750980" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338750980</a></li>  <li id="ref-5">[<a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338750980" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338750980</a></li>  <li id="ref-6">[<a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338750980" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338750980</a></li>  <li id="ref-7">[<a href="xueqiu://4138302318/338750980" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338750980" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338750980</a></li>  <li id="ref-8">[<a href="xueqiu://4138302318/338751988" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338751988" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338751988</a></li>  <li id="ref-9">[<a href="xueqiu://4138302318/338752448" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338752448" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338752448</a></li>  <li id="ref-10">[<a href="xueqiu://4138302318/338752448" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4138302318/338752448" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4138302318/338752448</a></li></ol><p><br></p><!-- Raw Posts --><h2 id="📄-原始博文-5-条"><a href="#📄-原始博文-5-条" class="headerlink" title="📄 原始博文 (5 条)"></a>📄 原始博文 (5 条)</h2><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4138302318/338746724">https://xueqiu.com/4138302318/338746724</a></p><p>来源：雪球App，作者： Forever，（<a href="https://xueqiu.com/4138302318/338746724）投資很簡單，一年一倍多，雪球的股神，韭菜都看不上@Forever：$周大福(01929)$">https://xueqiu.com/4138302318/338746724）投資很簡單，一年一倍多，雪球的股神，韭菜都看不上@Forever：$周大福(01929)$</a> 這是典型的底線思維, 差無可差時, 股價反而大漲了……. 年初留意的金風也是轉眼就1倍多…2024-10-22 19:02 · 讨论 18 · 赞 25</p></blockquote><hr><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4138302318/338749903">https://xueqiu.com/4138302318/338749903</a></p><p>来源：雪球App，作者： Forever，（<a href="https://xueqiu.com/4138302318/338749903）上學時很喜歡看國家">https://xueqiu.com/4138302318/338749903）上學時很喜歡看國家</a>, 行業大趨勢之類的書, 所以林奇說的大牛股來自生活絕對正確, 多留意身邊的事物發展, 才能找出大牛股, 財報說的是否跟身邊觀察的符合.</p></blockquote><hr><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4138302318/338750980">https://xueqiu.com/4138302318/338750980</a></p><p>来源：雪球App，作者： Forever，（<a href="https://xueqiu.com/4138302318/338750980）3年太短">https://xueqiu.com/4138302318/338750980）3年太短</a>, 長時間不漲, 堅持用分紅復投就好, 這類企業死不了, 10年后第一桶金就能存出來了.收起@墨子非韩：看了很多很尊敬的大V们关于白酒的观点，他们现在才开始考虑买一点白酒，而我的白酒仓位已经打满了，换句话说就是我可能买急了，买早了。但那又怎样呢？大V们已经40 50 60岁了，他们当然害怕被套一年两年又三年，我才二十来岁，我怕什么？我没钱，还没时间吗？损失的只可能是机会成本罢了。按照我的估算，老窖，五粮液，洋河放三年，$泸州老窖(SZ000568)$ $五粮液(SZ000858)$ $洋河股份(SZ002304)$最差也是7.5%的年化回报率，最好的情况呢，一年涨个50%，三年翻个一倍，也不是没可能。你可以当我是在赌，赌中报业绩没爆雷，赌三季报业绩企稳，赌市场重新看好真值钱、赚真钱的好资产。但我绝对不建议粉丝们抄我作业，相信关注我的人，也不是为了抄作业来的，而是为了共同学习共同进步来的，你看看那些长期业绩好的大V们，谁还愿意费劲吧啦写长文章呢。只有我这种未来可能长期业绩好的小V，才会坚持学习坚持分享我的学习心得。看了很多很尊敬的大V们关于白酒的观点，他们现在才开始考虑买一点白酒，而我的白酒仓位已经打满了，换句话说就是我可能买急了，买早了。但那又怎样呢？大V们已经40 50 60岁了，他们当然害怕被套一年两年又三年，我才二十来岁，我怕什么？我没钱，还没时间…展开4小时前 · 转发 3 · 讨论 287 · 赞 71</p></blockquote><hr><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4138302318/338751988">https://xueqiu.com/4138302318/338751988</a></p><p>来源：雪球App，作者： Forever，（<a href="https://xueqiu.com/4138302318/338751988）回复@别昔">https://xueqiu.com/4138302318/338751988）回复@别昔</a>: 對, 這點很難, 想學散戶乙不容易//@别昔:回复@Forever:年轻人怕是嘴上能熬实际熬不了多久的查看对话收起@墨子非韩：看了很多很尊敬的大V们关于白酒的观点，他们现在才开始考虑买一点白酒，而我的白酒仓位已经打满了，换句话说就是我可能买急了，买早了。但那又怎样呢？大V们已经40 50 60岁了，他们当然害怕被套一年两年又三年，我才二十来岁，我怕什么？我没钱，还没时间吗？损失的只可能是机会成本罢了。按照我的估算，老窖，五粮液，洋河放三年，$泸州老窖(SZ000568)$ $五粮液(SZ000858)$ $洋河股份(SZ002304)$最差也是7.5%的年化回报率，最好的情况呢，一年涨个50%，三年翻个一倍，也不是没可能。你可以当我是在赌，赌中报业绩没爆雷，赌三季报业绩企稳，赌市场重新看好真值钱、赚真钱的好资产。但我绝对不建议粉丝们抄我作业，相信关注我的人，也不是为了抄作业来的，而是为了共同学习共同进步来的，你看看那些长期业绩好的大V们，谁还愿意费劲吧啦写长文章呢。只有我这种未来可能长期业绩好的小V，才会坚持学习坚持分享我的学习心得。看了很多很尊敬的大V们关于白酒的观点，他们现在才开始考虑买一点白酒，而我的白酒仓位已经打满了，换句话说就是我可能买急了，买早了。但那又怎样呢？大V们已经40 50 60岁了，他们当然害怕被套一年两年又三年，我才二十来岁，我怕什么？我没钱，还没时间…展开5小时前 · 转发 4 · 讨论 327 · 赞 82</p></blockquote><hr><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4138302318/338752448">https://xueqiu.com/4138302318/338752448</a></p><p>前幾天朋友問投資的問題, 怎樣做好一些, 其實來來去去都沒有完美的, 想投資最大化就是要順趨勢而為, 不能迷戀單一行業, 做好低估的行業輪動. 投資簡單版，好行業，好公司，好價格時買入，持續低估時分紅加倉，合理時拿著亨受財息兼收，高估時慢慢賣掉，泡沫時完全清倉. 升級版, 好行業，好…</p></blockquote><p><br></p><!-- Debug Info --><h2 id="⚙️-调试信息"><a href="#⚙️-调试信息" class="headerlink" title="⚙️ 调试信息"></a>⚙️ 调试信息</h2><details><summary>点击展开调试信息</summary>### AI Prompt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">你是一位顶级的金融信息分析师，擅长从海量、零散的言论中，提炼出具有操作价值的投资洞见。</span><br><span class="line"></span><br><span class="line">下面是一系列博主的言论，每篇都以 `--- Post [Link: ...]` 的格式开头，明确标注了其原始链接。</span><br><span class="line"></span><br><span class="line">你的任务是：</span><br><span class="line">1.  **仔细阅读所有言论**，理解其核心观点、主要论据和情绪倾向。</span><br><span class="line">2.  **提取所有关键信息**，并将其归类为以下四种类型之一：【核心观点】、【操作信号】、【风险警告】、【其他提及】。</span><br><span class="line">3.  **为每一条提取出的关键信息，生成一个独立的总结要点**。每个要点都必须：</span><br><span class="line">    *   **a) 关联原文**：找到信息来源的最相关的那一篇博文，并记录其 `Link`。</span><br><span class="line">    *   **b) 添加标签**：在总结句子的开头，必须加上对应的分类标签。</span><br><span class="line">4.  **如果言论中不包含任何明确的操作信号或风险警告**，请专注于提炼【核心观点】和【市场情绪】。</span><br><span class="line">5.  **严格按照下面的JSON格式输出你的分析结果**：</span><br><span class="line">    *   你的最终输出必须是一个严格的JSON对象。</span><br><span class="line">    *   该对象必须只包含一个名为 &quot;summary_points&quot; 的键，其值为一个对象数组。</span><br><span class="line">    *   数组中的每个元素都代表一个总结要点，且必须包含 &quot;text&quot; 和 &quot;source_link&quot; 两个键。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">**【要点格式模板】**</span><br><span class="line">（你生成的 &quot;text&quot; 字符串必须严格遵循此格式）</span><br><span class="line"></span><br><span class="line">*   **对于核心观点**: `【核心观点】[此处概括博主的整体市场情绪和核心投资逻辑]`</span><br><span class="line">*   **对于操作信号**: `【操作信号】[买入/卖出] [标的: XXXX] (信心: 高/中/低) - 理由: [具体理由]`</span><br><span class="line">*   **对于风险警告**: `【风险警告】[博主提到的具体风险点]`</span><br><span class="line">*   **对于其他提及**: `【其他提及】[标的: YYYY] - [博主的简要看法]`</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">这是待总结的博文列表：</span><br><span class="line">&#123;博文列表&#125;</span><br><span class="line">---</span><br><span class="line">请严格按照 &#123;&quot;summary_points&quot;: [&#123;&quot;text&quot;: &quot;...&quot;, &quot;source_link&quot;: &quot;...&quot;&#125;, ...]&#125; 的 JSON 格式输出，不要包含任何额外的解释或根键。</span><br></pre></td></tr></table></figure>### AI 原始返回结果 (JSON)<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;summary_points&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】在投资中采用“底线思维”，即在资产表现极差时介入，可以捕捉到后续股价大幅反弹的机会。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338746724&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【操作信号】[买入] [标的: 周大福(01929)] (信心: 高) - 理由: 股价在极差时大涨，是典型的“底线思维”成功案例；作者此前关注的金风也通过此策略实现了倍增。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338746724&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】发现“大牛股”的关键在于观察生活中的行业大趋势和公司发展，并结合财务报告进行验证，印证了彼得·林奇的投资理念。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338749903&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】对于长期不涨但具备生存能力的企业，应坚持分红复投策略，长期持有（例如10年），以此积累财富。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338750980&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】（墨子非韩）年轻投资者拥有时间优势，可以承担更长的套牢期，即使短期买早也能通过长期持有（如三年）获得稳健回报，并期待市场对价值资产的重新评估。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338750980&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【操作信号】[买入/持有] [标的: 泸州老窖(SZ000568), 五粮液(SZ000858), 洋河股份(SZ002304)] (信心: 中) - 理由: 博主已满仓白酒，认为即使买早，长期持有（3年）也可能获得7.5%年化回报，甚至翻倍，并押注后续财报企稳和市场价值重估。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338750980&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【风险警告】（墨子非韩）博主明确不建议粉丝复制其白酒投资策略，并承认自己可能买早且是在“赌”中报业绩未爆雷和三季报企稳。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338750980&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【风险警告】（Forever）承认年轻人嘴上说能熬，实际很难长期坚持持有不涨的股票，揭示了长期投资中投资者面临的心理挑战。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338751988&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】投资最大化需顺应趋势，避免迷恋单一行业，并利用低估行业的轮动机会。核心策略为：在好行业、好公司、好价格时买入；持续低估时分红加仓；合理时持有享受股息；高估时逐步卖出；泡沫时彻底清仓。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338752448&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【风险警告】不应迷恋单一行业投资，暗示了集中度过高带来的风险。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4138302318/338752448&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> AI 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动生成 </tag>
            
            <tag> Xueqiu_Forever </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14</title>
      <link href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/"/>
      <url>/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/</url>
      
        <content type="html"><![CDATA[<!-- AI Summary --><h2 id="🤖-AI-总结"><a href="#🤖-AI-总结" class="headerlink" title="🤖 AI 总结"></a>🤖 AI 总结</h2><ol><li><p><strong>【核心观点】</strong>博主关注我国首个“沙戈荒”新能源外送基地首批机组的成功投产发电，认为这是一个重要进展，并积极预期该项目能为华润集团每年带来可观利润。 <a href="xueqiu://4111857140/338741519" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[1]</sup></a></p></li><li><p><strong>【其他提及】</strong>标的: 华润集团 - 博主根据华润在“沙戈荒”新能源外送基地项目38%的权益占比，估计该项目全部投产后可为华润集团每年贡献约5亿利润。 <a href="xueqiu://4111857140/338741519" target="_blank" rel="noopener noreferrer" title="跳转至原文"><sup>[2]</sup></a><br><br></p></li></ol><h4 id="引用来源"><a href="#引用来源" class="headerlink" title="引用来源"></a>引用来源</h4><ol>  <li id="ref-1">[<a href="xueqiu://4111857140/338741519" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4111857140/338741519" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4111857140/338741519</a></li>  <li id="ref-2">[<a href="xueqiu://4111857140/338741519" target="_blank" rel="noopener noreferrer">跳转至 App</a>] - <a href="https://xueqiu.com/4111857140/338741519" target="_blank" rel="noopener noreferrer">https://xueqiu.com/4111857140/338741519</a></li></ol><p><br></p><!-- Raw Posts --><h2 id="📄-原始博文-1-条"><a href="#📄-原始博文-1-条" class="headerlink" title="📄 原始博文 (1 条)"></a>📄 原始博文 (1 条)</h2><blockquote><p><strong>来源</strong>: <a href="https://xueqiu.com/4111857140/338741519">https://xueqiu.com/4111857140/338741519</a></p><p>全部投产，200万千瓦火电，410万千瓦新能源，权益占比38%，我估计能给华润带了每年5亿利润7X24快讯: 【我国首个“沙戈荒”新能源外送基地首批机组投产发电】由中国华电、华润集团开发建设的新疆天山北麓戈壁大型风电光伏基地首批2台100万千瓦煤电机组，顺利通过168小时满负荷试运行，标志着我国首个“沙戈荒”新能源外送基地首批机组投产发电。</p></blockquote><p><br></p><!-- Debug Info --><h2 id="⚙️-调试信息"><a href="#⚙️-调试信息" class="headerlink" title="⚙️ 调试信息"></a>⚙️ 调试信息</h2><details><summary>点击展开调试信息</summary>### AI Prompt<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">你是一位顶级的金融信息分析师，擅长从海量、零散的言论中，提炼出具有操作价值的投资洞见。</span><br><span class="line"></span><br><span class="line">下面是一系列博主的言论，每篇都以 `--- Post [Link: ...]` 的格式开头，明确标注了其原始链接。</span><br><span class="line"></span><br><span class="line">你的任务是：</span><br><span class="line">1.  **仔细阅读所有言论**，理解其核心观点、主要论据和情绪倾向。</span><br><span class="line">2.  **提取所有关键信息**，并将其归类为以下四种类型之一：【核心观点】、【操作信号】、【风险警告】、【其他提及】。</span><br><span class="line">3.  **为每一条提取出的关键信息，生成一个独立的总结要点**。每个要点都必须：</span><br><span class="line">    *   **a) 关联原文**：找到信息来源的最相关的那一篇博文，并记录其 `Link`。</span><br><span class="line">    *   **b) 添加标签**：在总结句子的开头，必须加上对应的分类标签。</span><br><span class="line">4.  **如果言论中不包含任何明确的操作信号或风险警告**，请专注于提炼【核心观点】和【市场情绪】。</span><br><span class="line">5.  **严格按照下面的JSON格式输出你的分析结果**：</span><br><span class="line">    *   你的最终输出必须是一个严格的JSON对象。</span><br><span class="line">    *   该对象必须只包含一个名为 &quot;summary_points&quot; 的键，其值为一个对象数组。</span><br><span class="line">    *   数组中的每个元素都代表一个总结要点，且必须包含 &quot;text&quot; 和 &quot;source_link&quot; 两个键。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">**【要点格式模板】**</span><br><span class="line">（你生成的 &quot;text&quot; 字符串必须严格遵循此格式）</span><br><span class="line"></span><br><span class="line">*   **对于核心观点**: `【核心观点】[此处概括博主的整体市场情绪和核心投资逻辑]`</span><br><span class="line">*   **对于操作信号**: `【操作信号】[买入/卖出] [标的: XXXX] (信心: 高/中/低) - 理由: [具体理由]`</span><br><span class="line">*   **对于风险警告**: `【风险警告】[博主提到的具体风险点]`</span><br><span class="line">*   **对于其他提及**: `【其他提及】[标的: YYYY] - [博主的简要看法]`</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">这是待总结的博文列表：</span><br><span class="line">&#123;博文列表&#125;</span><br><span class="line">---</span><br><span class="line">请严格按照 &#123;&quot;summary_points&quot;: [&#123;&quot;text&quot;: &quot;...&quot;, &quot;source_link&quot;: &quot;...&quot;&#125;, ...]&#125; 的 JSON 格式输出，不要包含任何额外的解释或根键。</span><br></pre></td></tr></table></figure>### AI 原始返回结果 (JSON)<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;summary_points&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【核心观点】博主关注我国首个“沙戈荒”新能源外送基地首批机组的成功投产发电，认为这是一个重要进展，并积极预期该项目能为华润集团每年带来可观利润。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4111857140/338741519&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;【其他提及】标的: 华润集团 - 博主根据华润在“沙戈荒”新能源外送基地项目38%的权益占比，估计该项目全部投产后可为华润集团每年贡献约5亿利润。&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;source_link&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://xueqiu.com/4111857140/338741519&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> AI 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动生成 </tag>
            
            <tag> Xueqiu_ShanXing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project2-BPlusTree-Delete-Single-threaded</title>
      <link href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/"/>
      <url>/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/</url>
      
        <content type="html"><![CDATA[<p>单线程版 B+树删除操作</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>在删除时用到两个重要的属性是，也就是node最多有多少个search-key value，最少有多少个，根据这个可以决定采用什么措施去维持整个树的平衡</p><ul><li>Each <strong>leaf</strong> can hold up to <code>n−1</code> search-key values. We allow leaf nodes to contain as few as <code>⌈(n−1)/2⌉</code> search-key values.</li><li>Each <strong>nonleaf node</strong> in the tree (other than the root) has between <code>⌈n/2⌉</code> and <code>n</code> children.</li></ul><p>下面举例课本中的删除过程，粗略了解一下删除的过程：</p><p>已经有一棵B+树如下，从leaf node可知N=4</p><p>所以leaf node最多放3个search-key value，最少2个search-key value；nonleaf node最多4个children，最少2个children。</p><!--对于nonleaf node来讲是按children计算，对于leaf node是search-key value，单位不一样，但是n还是通用的。因为nonleaf node还要指向下一个节点，其实它的search-key value就是children，因为nonleaf node第一个entry的特殊性，所以这里区分开免得混乱。总的来说，对于nonleaf node讲的是多少个children，这样可以记得还有第一个entry的特殊性，对于leaf node则讲有多少个search-key value，因为其不用指向下一个node，对于连接下一个leaf node的实现，有一个next_page_id_属性--><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20231221131829600.png" alt="image-20231221131829600"></p><h2 id="Coalesce"><a href="#Coalesce" class="headerlink" title="Coalesce"></a>Coalesce</h2><p>一开始要删除Srini这个Index，首先查找到Srini位于哪个leaf node，然后将其删除，如下图：</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20231221132730578.png" alt="image-20231221132730578"></p><p>删除后这个leaf node只剩下一个key，不符合树的属性，树的key总共有那么多，为了让每个node都符合上述的属性，有两种方法可以来调整，一个是coalesce，另一个则是redistribute。前者意思是合并兄弟节点，后者意思是节点间重新分配。</p><p>在这里该leaf node可以和左边的兄弟节点合并，然后删除剩下的空leaf node和指向其的parent node<br><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20231221222245038.png" alt="image-20231221222245038"></p><h2 id="Redistribute"><a href="#Redistribute" class="headerlink" title="Redistribute"></a>Redistribute</h2><p>此时有一个internal node（第二层最右边）只有一个entry（key没有用到，value指向下一个节点），不符合树的属性，需要调整。</p><p>如果采用合并的策略，那么明显左边的node已经有4个children了，加上现有一个，总共5个，超出最大值。</p><p>只能是采取兄弟节点间重新分配的策略，以便每个nonleaf节点至少有2个children</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20231221225624417.png" alt="image-20231221225624417"></p><p>如上图，将左边兄弟节点的Gold search-key移动到右边的节点，此时右边节点共有两个children。此时root节点并不能区分其两个children，因为Mozart左边children的范围应该是小于”Mozart”，右边children的范围应该是大于等于”Mozart”，右边的children不符合要求。所以需要将root节点”Mozart”和children节点”Gold”进行交换，如下图所示。其实也挺好理解的，原本要移动的值是小于其父节点的，现在需要移动到右边，那么肯定不能直接移动，移动了就不符合大小定义了，所以可以直接移动到父节点，而父节点移动到右边，就能满足了，因为整体从左到右是增大的顺序，这样移动保持了相对位置没有发生改变。</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240102183725232.png" alt="image-20240102183725232"></p><p>现在接着删除”Singh”和”Wu”，删除”Singh”后还剩下两个search-key value，删除”Wu”后只剩下一个了，该leaf node处于underfull状态。</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106105348700.png" alt="image-20240106105348700"></p><p>由上图可知不能合并兄弟节点，只能执行重新分配策略，将左边兄弟节点的”Kim”移动到右边</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106110905132.png" alt="image-20240106110905132"></p><p>上图中第二层右边的”Mozart”不能区分其children节点，为此需要将其变成”Kim”，如下图：</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106111120522.png" alt="image-20240106111120522"></p><h2 id="Underflow"><a href="#Underflow" class="headerlink" title="Underflow"></a>Underflow</h2><p>接着删除”Gold”，如下图，该leaf node处于underfull状态</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106112032842.png" alt="image-20240106112032842"></p><p>由上图，该leaf node可以和右边的兄弟节点进行合并，同时删除一个parent node：</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106113336923.png" alt="image-20240106113336923"></p><p>树中第二层右边那个internal node只有一个children，处于underfill状态，此时可以执行合并或者重新分配策略，用于演示，在书本中选择的是合并。</p><p>对于nonleaf node的合并来讲，需要将特定的parent key移动到合并的节点。</p><p>这也好理解，因为parent key是区分两个child的关键，现在只剩下一个child了，但是之前的underfill child还有个空的key，但是value有用的item，这个指引功能可以由parent key代替，所以就将parent key移动到合并节点，因为之前得通过parent key能找到那个underfill child，再找到其指向的child，现在underfill child没了，通过parent key直接指引到其指向的child。</p><p>将Gold移动到左边child node，此时root只剩下一个child，但是root至少得两个child，所以root被删除。</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/image-20240106123557237.png" alt="image-20240106123557237"></p><p>需要注意的是，”Gold”从叶子节点中删除了，但是在nonleaf node中还存在。</p><p>删除一个节点，可能还需要递归处理其父节点，极端情况下会处理到root节点，调整了整一棵树。</p><h1 id="Four-Case"><a href="#Four-Case" class="headerlink" title="Four Case"></a>Four Case</h1><p>上面的流程可以大概知道删除过程什么样</p><p>一般来讲可以将删除操作抽象成四个部分：leaf node merge、nonleaf node merge、leaf node redistribute、nonleaf node redistribute</p><p>下面的图来自：<a href="https://zhuanlan.zhihu.com/p/592964493">CMU 15445-2022 P2 B+Tree Insert/Delete - 知乎</a></p><h2 id="Leaf-Node-Merge"><a href="#Leaf-Node-Merge" class="headerlink" title="Leaf Node Merge"></a>Leaf Node Merge</h2><p>最简单就是叶子节点合并了</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-2f751fa1010a96f008287bd5d7da6456_r.jpg" alt="img" style="zoom:60%;"></p><ol><li>删除P1节点的5</li><li>合并右边兄弟节点P2到P1</li><li>删除掉P2</li><li>删除掉指向的P2的节点（P3中的19）</li></ol><h2 id="NonLeaf-Node-Merge"><a href="#NonLeaf-Node-Merge" class="headerlink" title="NonLeaf Node Merge"></a>NonLeaf Node Merge</h2><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-02416fed877cfac996b1148d8b52782c_1440w.webp" alt="img" style="zoom:60%;"></p><ol><li>删除掉P17中的11</li><li>删除掉11后，不满足容量最少为1的条件，需要合并兄弟节点，这里只有一个右边的兄弟节点</li><li>合并完后，P19的12移动到P17中，P19删除掉</li><li>P14中删除掉指向P19的节点</li><li>此时P14处于underfill状态，需要merge（为了举例子暂不考虑redistribute），将P14合并到P3（见下图）</li><li>P7中的parent key移动到P3</li><li>删除P14</li><li>删除P7的指向P14的index</li></ol><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-fbbcdedd4b30ff0c384fc62362b3a114_1440w.webp" alt="img" style="zoom:60%;"></p><p>这里有一个特殊情况就是可能会造成root节点的删除（此时的策略是leaf node merge）</p><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-9818af22ddd3f5b831d76aa717117824_r.jpg" alt="img" style="zoom:60%;"></p><ol><li>删除P2的23这个节点，P2处于underfill状态</li><li>P2合并到P1，删除P2</li><li>在P3中删除指向P2的index</li><li>root节点处于underfill状态，删除掉</li></ol><h2 id="Leaf-Node-Redistribute"><a href="#Leaf-Node-Redistribute" class="headerlink" title="Leaf Node Redistribute"></a>Leaf Node Redistribute</h2><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-fcfc77ed8a53b46432be80de6e14cf40_r.jpg" alt="img" style="zoom:67%;"></p><ol><li>P1中删除2</li><li>触发重新分配</li><li>重新分配完成后，为了能够区分两个child，需要更改parent key</li></ol><h2 id="NonLeaf-Node-Redistribute"><a href="#NonLeaf-Node-Redistribute" class="headerlink" title="NonLeaf Node Redistribute"></a>NonLeaf Node Redistribute</h2><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-ae61f101d6d56911d815f2cedacc3ca8_r.jpg" alt="img" style="zoom:67%;"></p><ol><li>从P1中删除2</li><li>需要和P2进行merge（leaf node merge策略）</li><li>删除掉P2</li><li>在P3中删除掉指向P2的index</li><li>P3处于underfill状态，需要重新分配</li><li>为了保持相对大小的关系不变，这里可以直接将parent key 5移动到P3</li><li>那么相对应的将P9中的7移动到P11</li></ol><p><img src="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/v2-595d80a72c7651793ac5f172f0a14714_r.jpg" alt="img" style="zoom:67%;"></p><hr><p>For more：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/375685969">B+树的删除 - 知乎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> BPlusTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩客云换魔百盒</title>
      <link href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/"/>
      <url>/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/</url>
      
        <content type="html"><![CDATA[<h1 id="魔百盒"><a href="#魔百盒" class="headerlink" title="魔百盒"></a>魔百盒</h1><p>服役了两年的玩客云差不多也该换了，主要是配置方面感觉不够用，特别是当全局代理的情况下，总有断流的情况，而且是32位+1G RAM+8G ROM，小内存有点捉急。</p><p>所以就看了下有没有稍微好的产品，搜索了下发现有个魔百盒还可以，cm311-1a，2G RAM+16G ROM，amlogic s905l3a cpu对比玩客云的s805好点，内存方面也是翻倍，不到70的价格，虽然现在的价格比前一两年贵了十几二十块，但是也能接受。</p><p>买这个便宜性能凑合的盒子主要用来挂一些简单的服务，比如memos，青龙，v2raya等，还有一些内网穿透的需求</p><p><img src="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/image-20231231125838647.png" alt="image-20231231125838647"></p><h1 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>比较安全的内网穿透软件有Cloudflare Warp、Tailscale、Zerotier等，大概都是通过VPN建议连接的，比直接开放端口可外网直接连接安全多了。</p><p>要使用这些软件，server和client都得安装一个程序，因为某些原因，我的某些client不能装类似的软件，所以只能pass了。</p><p>所以只能使用frp之类的，为了避免直接暴露端口，使用stcp/sudp协议。对于stcp/sudp而言，也得在server和client分别安装frps和frpc，但是frpc上连接stcp/sudp是得重新一个监听本地端口的，也就是说，本地frpc启动后，是通过127.0.0.1:2333（假设）访问服务的，所以某些特殊的client，可以通过局域网连接到这些端口实现，具体的配置如下：</p><p>frps: </p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bindPort</span> = <span class="number">12345</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;token1&quot;</span></span><br><span class="line"><span class="comment">#webServer.addr = &quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="comment">#webServer.port = 12346</span></span><br><span class="line"><span class="comment">#webServer.user = &quot;user&quot;</span></span><br><span class="line"><span class="comment">#webServer.password = &quot;password&quot;</span></span><br><span class="line"><span class="attr">transport.tls.certFile</span> = <span class="string">&quot;/home/server.crt&quot;</span></span><br><span class="line"><span class="attr">transport.tls.keyFile</span> = <span class="string">&quot;/home/server.key&quot;</span></span><br><span class="line"><span class="attr">transport.tls.trustedCaFile</span> = <span class="string">&quot;/home/ca.crt&quot;</span></span><br></pre></td></tr></table></figure><p>魔百盒frpc：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;1.2.3.4&quot;</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">12345</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;token1&quot;</span></span><br><span class="line"><span class="attr">transport.tls.certFile</span> = <span class="string">&quot;/home/client.crt&quot;</span></span><br><span class="line"><span class="attr">transport.tls.keyFile</span> = <span class="string">&quot;/home/client.key&quot;</span></span><br><span class="line"><span class="attr">transport.tls.trustedCaFile</span> = <span class="string">&quot;/home/ca.crt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token2&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;rdp&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token3&quot;</span></span><br><span class="line"><span class="attr">localIp</span> = <span class="string">&quot;192.168.18.102&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">3389</span></span><br><span class="line"><span class="attr">transport.useCompression</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;memos&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token4&quot;</span></span><br><span class="line"><span class="attr">localIp</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">5230</span></span><br><span class="line"><span class="attr">transport.useCompression</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;wol&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;sudp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token5&quot;</span></span><br><span class="line"><span class="attr">localIp</span> = <span class="string">&quot;192.168.18.255&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">9</span></span><br></pre></td></tr></table></figure><p>client frpc连接：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;1.2.3.4&quot;</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">12345</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;token1&quot;</span></span><br><span class="line"><span class="attr">transport.tls.certFile</span> = <span class="string">&quot;/home/client.crt&quot;</span></span><br><span class="line"><span class="attr">transport.tls.keyFile</span> = <span class="string">&quot;/home/client.key&quot;</span></span><br><span class="line"><span class="attr">transport.tls.trustedCaFile</span> = <span class="string">&quot;/home/ca.crt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[visitors]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;secret_ssh_visitor&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">serverName</span> = <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token2&quot;</span></span><br><span class="line"><span class="attr">bindAddr</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">6001</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[visitors]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;secret_rdp_visitor&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">serverName</span> = <span class="string">&quot;rdp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token3&quot;</span></span><br><span class="line"><span class="attr">bindAddr</span> = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">6002</span></span><br><span class="line"><span class="attr">transport.useCompression</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[visitors]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;secret_wol_visitor&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;sudp&quot;</span></span><br><span class="line"><span class="attr">serverName</span> = <span class="string">&quot;wol&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token5&quot;</span></span><br><span class="line"><span class="attr">bindAddr</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">6000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client本地启动frpc后，比如rdp服务，因为监听了0.0.0.0:6002，所以另外一个client可以通过其局域网ip连接到rdp服务，不用单独装frpc。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="useEncryption"><a href="#useEncryption" class="headerlink" title="useEncryption"></a>useEncryption</h3><blockquote><p>通过设置 <code>transport.useEncryption = true</code>，将 frpc 与 frps 之间的通信内容加密传输，将会有效防止传输内容被截取。</p><p><a href="https://gofrp.org/zh-cn/docs/features/common/network/network/">通信安全及优化 | frp</a></p></blockquote><p>这个的意思其实是说，它加密的是frpc客户端（提供服务的内网客户端）和frps（公网服务器）之间的连接，但是最终用户和公网服务器之间的传输该是怎么样的还是怎么样的，如果是明文http传输，那么依旧是明文http传输。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;memos&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">5230</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/image-20231231181244116.png" alt="image-20231231181244116"></p><h3 id="stcp"><a href="#stcp" class="headerlink" title="stcp"></a>stcp</h3><blockquote><p>STCP 和 SUDP 的 (S) 的含义是 Secret。其作用是为 TCP 和 UDP 类型的服务提供一种安全访问的能力，避免让端口直接暴露在公网上导致任何人都能访问到。</p><p>frp 会在访问端监听一个端口和服务端的端口做映射。访问端的用户需要提供相同的密钥才能连接成功，从而保证安全性。</p><p><a href="https://gofrp.org/zh-cn/docs/features/stcp-sudp/">STCP &amp; SUDP | frp</a></p></blockquote><p>使用stcp的配置，整个传输过程没有明文的http协议，流量通过tls协议加密。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;memos&quot;</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;stcp&quot;</span></span><br><span class="line"><span class="attr">secretKey</span> = <span class="string">&quot;token4&quot;</span></span><br><span class="line"><span class="attr">localIp</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">5230</span></span><br><span class="line"><span class="attr">transport.useCompression</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/image-20231231182211016.png" alt="image-20231231182211016"></p><p><img src="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/image-20231231182442642.png" alt="image-20231231182442642"></p><h3 id="trustedCaFile"><a href="#trustedCaFile" class="headerlink" title="trustedCaFile"></a>trustedCaFile</h3><blockquote><p><code>transport.useEncryption</code> 和 <code>STCP</code> 等功能能有效防止流量内容在通信过程中被盗取，但是无法判断对方的身份是否合法，存在被中间人攻击的风险。为此 frp 支持 frpc 和 frps 之间的流量通过 TLS 协议加密，并且支持客户端或服务端单向验证，双向验证等功能。<br><a href="https://gofrp.org/zh-cn/docs/features/common/network/network-tls/">自定义 TLS 协议加密 | frp</a></p></blockquote><p>这个措施是为了判断对方身份是否合法，建议还是配置一下，证书生成本地就行，而且能够多提供一层保障。</p><hr><p>For more：<br><a href="https://cui.cc/frp-security-config/">提高 frp 内网穿透的安全性 - 南山崔崔的个人站点</a></p><h2 id="Systemctl重试"><a href="#Systemctl重试" class="headerlink" title="Systemctl重试"></a>Systemctl重试</h2><p>某些情况下机器网络断了后，可以增加一些举措来重连，如果frp用systemctl管理，可使用以下配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span> = frp server</span><br><span class="line"><span class="attr">Wants</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">After</span>=network.target network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="attr">Requires</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span> = simple</span><br><span class="line"><span class="attr">ExecStart</span> = /root/frp_0.<span class="number">53.2</span>_linux_arm64/frpc -c /root/frp_0.<span class="number">53.2</span>_linux_arm64/frpc.toml</span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">StartLimitInterval</span>=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span> = multi-user.target</span><br></pre></td></tr></table></figure><h2 id="WOL"><a href="#WOL" class="headerlink" title="WOL"></a>WOL</h2><p>因为需要用windows进行远程，但是又省电费，所以一个举措就是当要远程的时候才唤醒电脑进行远程，平时睡眠状态，达到省钱的效果，可以使用一个叫做WOL的功能，需要的配置如下：</p><ul><li>Windows和Bios的配置：<a href="https://zhuanlan.zhihu.com/p/29100706"><a href="https://zhuanlan.zhihu.com/p/585076355">家庭实验室系列文章-电脑如何配置网络唤醒 (WOL)? - 知乎</a></a><ul><li>主要就是配置一下windows的网卡、防火墙以及bios的开启wol设置项</li></ul></li><li>frpc的配置：搜索wol，上文有帖配置</li><li>Android的配置：<br><img src="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/d565b00c-bf19-4058-9b9d-4dfb76786694.jpg" style="zoom:25%;"></li></ul><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><p>目前这个内网穿透只在魔百盒里面跑，如果魔百盒出问题了怎么办，比如突然间系统卡死，或者死机，那么肯定会影响到挂的服务。</p><p>这里定义一下哪些服务是必须有容错的，哪些服务挂了也无所谓，等到回到家再处理就行。</p><ul><li>Windows远程：这个必须容错，主要使用的场景是外出图书馆或者回家远程回来</li><li>Memos：主要用来记录和查看之前记录的一些想法<ul><li>部署在魔百盒，所以魔百盒挂了它也挂了，那也没办法，不过这个东西不紧急，记录可以临时记录在notion</li><li>查看的话也不是非常紧急，是用于平时消遣看下以前记录的东西，用别的东西消遣也行，比如看下订阅的RSS，微博等</li><li>其实这里可以部署个服务在手机上，毕竟现在数据备份在github，拉一下就好，不过懒得弄</li></ul></li><li>魔百盒ssh：挂了就连不上了，倒是可以搞个智能插座，挂了重启一下，这下好多服务也恢复了</li><li>wol：这个理论上必须得容错，用于唤醒windows，但是必须得有魔百盒才能在外网使用，所以魔百盒挂了也是没办法。</li></ul><p>其实看下来关键还是Windows远程，其他的都是无关要紧，忍一忍，怎么搞呢，一般分为硬件和软件问题。</p><p>对于硬件问题下面模拟了一些情况：</p><div class="table-container"><table><thead><tr><th>电</th><th>光猫</th><th>路由器</th><th>魔百盒</th><th>是否常见</th><th style="text-align:center">原因</th></tr></thead><tbody><tr><td>✔️</td><td>✔️</td><td>✔️</td><td>❌</td><td>不太常见</td><td style="text-align:center">系统不稳定</td></tr><tr><td>✔️</td><td>✔️</td><td>❌</td><td>❌</td><td>不太常见</td><td style="text-align:center">还是真是不知道啥原因，最常见是插座松了，很小概率是路由器坏了或者温度过高引起死机等问题</td></tr><tr><td>✔️</td><td>❌</td><td>❌</td><td>❌</td><td>不太常见</td><td style="text-align:center">一般是宽带网络出问题了，有概率插座送了，很少是因为硬件坏了</td></tr><tr><td>❌</td><td>❌</td><td>❌</td><td>❌</td><td>常见</td><td style="text-align:center">赶紧充电费吧</td></tr></tbody></table></div><p>没有列出一些其他问题，比如电脑硬盘挂了，系统自动更新挂了，插座烧了的情况。。。</p><p>上面看出，其实主要路由器能正常工作，就还有得救，否则一般都没有得搞了，所以<strong>对于春节回家这种场景，需要检查一下电费是否够，插座是否插好</strong>。</p><p>对于软件问题，一般是针对windows上和魔百盒上的软件来言，有一下措施：</p><ol><li>windows电源和魔百盒电源都通过智能插座连接，出现问题远程重启机器。</li><li>windows上安装别的远程软件或者frpc有用吗，如果需要用wol服务，估计不行，因为睡眠模式下这些软件都连接不上，如果不用wol服务，最好在windows上安装一个frpc和别的远程软件。</li></ol><h1 id="Memos"><a href="#Memos" class="headerlink" title="Memos"></a>Memos</h1><p>部署了memos后，还需要备份一下数据，这里采用的是github的私有仓库，定时提交文件即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker stop memos</span><br><span class="line"><span class="built_in">cd</span> /root/.memos</span><br><span class="line">git add .</span><br><span class="line">message=<span class="string">&quot;<span class="subst">$(date <span class="string">&quot;+%Y%m%d-%H%M%S&quot;</span>)</span>&quot;</span></span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$message</span>&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git config credential.helper <span class="string">&#x27;!f() &#123; sleep 1; echo &quot;username=$&#123;GIT_USER&#125;&quot;; echo &quot;password=$&#123;GIT_PASSWORD&#125;&quot;; &#125;; f&#x27;</span></span><br><span class="line">git push -u origin main -f</span><br><span class="line">docker start memos</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */2 * * * <span class="built_in">export</span> GIT_USER=ghp_xxxx; <span class="built_in">export</span> GIT_PASSWORD=<span class="string">&quot;<span class="variable">$GIT_USER</span>&quot;</span>;bash /root/.memos/backup.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 玩客云 </tag>
            
            <tag> 魔百盒 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project1-BPlusTree-Insert-Single-threaded</title>
      <link href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/"/>
      <url>/2023/12/12/CMU445-Project2-BPlusTree-Insert/</url>
      
        <content type="html"><![CDATA[<p>单线程版 B+树插入操作</p><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><ul><li><strong>Index</strong>: The index in database system is responsible for fast data retrieval without having to search through every row in a database table, providing the basis for both rapid random lookups (<em>快速随机查找</em>) and efficient access of ordered records.</li><li><strong>B+Tree dynamic index structure</strong>:  It is a balanced tree in which the internal pages direct the search and leaf pages contains actual data entries.<h1 id="B-Tree-properties"><a href="#B-Tree-properties" class="headerlink" title="B+ Tree properties"></a>B+ Tree properties</h1></li></ul><ol><li>Each node except root can have a maximum of <code>M</code> children and at least <code>ceil(M/2)</code> children.</li><li>Each node can contain a maximum of <code>M–1</code> keys and a minimum of ceil <code>(M/2)–1</code> keys.</li><li>The root has at least two children and at least one search key.</li><li>While insertion overflow of the node occurs when it contains more than <code>M–1</code> search key values.</li></ol><ul><li><code>M</code> is the order of B+ tree. It means every node of that Tree can have a maximum of N children.<br>For more:<br><a href="https://www.geeksforgeeks.org/introduction-of-b-tree/#">Introduction of B+ Tree - GeeksforGeeks</a><h1 id="Tree-Node"><a href="#Tree-Node" class="headerlink" title="Tree Node"></a>Tree Node</h1>举例一个实现后的 b+ tree 如下（p表示page_id）：</li></ul><p><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231028120216283.png" alt></p><p>如果是更大的树，则如下图所示：<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231103135501993.png" alt="image-20231103135501993"></p><p>设计思考点：<br>如果要实现一个 tree，首先得考虑每个节点在内存中是怎么组织的，也就是有哪些关键属性，怎么在内存中管理这些 node。</p><h2 id="BufferPoolManager"><a href="#BufferPoolManager" class="headerlink" title="BufferPoolManager"></a>BufferPoolManager</h2><p>把 node 再抽象点，其实也不过就是某一块内存数据，在 db 中，内存的管理由BufferPoolManager (bpm) 接管，也就是 lab1 实现的部分。<br>其管理的单位是 page，也就是每次向 bpm 申请一块内存，返回的都是一个 page，其实在 cpp 中表示就是一个 class Page。<br>每个 page 的 data_ 大小都是 4096bytes，node 的数据就存放在此。当然 page 还有其他属性，比如 page_id 等，当作 metadata 好管理各个page。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> BUSTUB_PAGE_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Page</span>() &#123; <span class="built_in">ResetMemory</span>(); &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">size_t</span> OFFSET_PAGE_START = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> data_[BUSTUB_PAGE_SIZE]&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ResetMemory</span><span class="params">()</span> </span>&#123; <span class="built_in">memset</span>(data_, OFFSET_PAGE_START, BUSTUB_PAGE_SIZE); &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h2><ul><li><p>对于 B+Tree 来讲，leaf node 和 internal node 是不一样的，所以这里在 lab 中对应的是 class BPlusTreeInternalPage 和 class BPlusTreeLeafPage，也就是得把从 bpm 申请来的 class Page 中的 data_ 转换为对应 node page。转换的方法是使用 reinterpret_cast：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *page = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(page)-&gt;<span class="built_in">GetData</span>());</span><br></pre></td></tr></table></figure><p>  这里的意思可以简单理解为：不管你是 InternalPage 还是 LeafPage，实际在代码表示就是一串 byte，这些 bytes 存储在 bpm 的 Page 中，在实际使用中才将其表达为是 InternalPage 还是 LeafPage。</p></li><li><p>InternalPage 和 LeafPage 都有一个属性 <code>std::pair&lt;KeyType, ValueType&gt; array_</code></p><ul><li>对 internal node 来讲，这里存储的是 key (search field) 和 child pointer，key 作为一个索引从而能定位到某个 leaf node，child pointer 是为了找到下一级节点。这里 child pointer 其实就是 page_id，因为根据 page_id 能从 bpm 中 fetch 到对应 child page。</li><li>对于 leaf node 来讲，这里存储的是 key (search field) 和 RID，RID 用于定位实际的 tuple 存放位置。</li><li><p>这两个 node KeyType 都是一样的，但是 ValueType 不一样，page_id 实际类型是 size_t，RID 实际类型是 class RID，所以有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_TEMPLATE_ARGUMENTS template <span class="string">&lt;typename KeyType, typename ValueType, typename KeyComparator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MappingType std::pair<span class="string">&lt;KeyType, ValueType&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTreePage</span> &#123;</span><br><span class="line">    <span class="comment">//...common field</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTreeInternalPage</span> : <span class="keyword">public</span> BPlusTreePage &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      MappingType array_[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTreeLeafPage</span> : <span class="keyword">public</span> BPlusTreePage &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      MappingType array_[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> InternalPage = BPlusTreeInternalPage&lt;KeyType, <span class="type">page_id_t</span>, KeyComparator&gt;;</span><br><span class="line">  <span class="keyword">using</span> LeafPage = BPlusTreeLeafPage&lt;KeyType, ValueType, KeyComparator&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>&lt;GenericKey&lt;<span class="number">4</span>&gt;, RID, GenericComparator&lt;<span class="number">4</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>&lt;GenericKey&lt;<span class="number">8</span>&gt;, RID, GenericComparator&lt;<span class="number">8</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>&lt;GenericKey&lt;<span class="number">16</span>&gt;, RID, GenericComparator&lt;<span class="number">16</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>&lt;GenericKey&lt;<span class="number">32</span>&gt;, RID, GenericComparator&lt;<span class="number">32</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">BPlusTree</span>&lt;GenericKey&lt;<span class="number">64</span>&gt;, RID, GenericComparator&lt;<span class="number">64</span>&gt;&gt;;</span><br></pre></td></tr></table></figure><p>class BPlusTree template对应的ValueType是RID，但是InternalPage写的是page_id_t (size_t)，并不是直接沿用ValueType。</p><p>因为KeyType是自定义类型，所以需要提供一个KeyComparator来定义怎么比对两个Key的大小。</p></li><li><p><code>MappingType array_[1];</code>用法是Flexible array，简单来讲就是，当<code>array_</code>写在类属性最后一个时，<code>array_</code>的大小自动指定，不用手动计算，其实就是这样算的：因为一个page是4kb，除去其他属性和元数据的内存开销，剩下的内存全给<code>array_</code>，然后根据<code>array_</code>中每个元素占用多少空间，从而计算出<code>array_</code> size是多少。For more: <a href="https://zhuanlan.zhihu.com/p/580014163">做个数据库：2022 CMU15-445 Project2 B+Tree Index - 知乎</a></p></li></ul></li><li><p>从图上可以看到，internal node array_有一个entry中的key是空的，其value指向下一个节点。至于为什么是空的，其实也很好理解，从第二个node起每个都有特定的范围表示，剩下的有没有key都无所谓，因为其表示的范围可以推算出来。所以对于internal node而言，总共有m个key，m+1个value。具体将这个空的key放在左边（本文）或者右边都可以，这会影响到插入、删除、查找等操作。对于leaf node而言，则没有无用的key，每个key和value都是有用的。<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231103140417199.png" alt="image-20231103140417199"></p></li></ul><h2 id="RootPage"><a href="#RootPage" class="headerlink" title="RootPage"></a>RootPage</h2><p>每个page都是得经过buffer pool manager拿，这些page再转换成对应的node，每个node之间的关系是通过kv array中的v建立连接，也就是v保存了需要连接的page的page_id。</p><p>总有一个开始地方，这个开始的地方就是root_page_id，根据这个page_id可以找到根节点，从而可以找到整棵树，root_page同样也是由buffer pool manager管理。</p><h1 id="Find-Leaf-Node"><a href="#Find-Leaf-Node" class="headerlink" title="Find Leaf Node"></a>Find Leaf Node</h1><p>如何根据一个key找到对应的leaf node呢（key可能在最终找到的leaf node，也可能没有）</p><p><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231103142048397.png" alt="image-20231103142048397"></p><ul><li><p>查找部分分为两个，一个是在internal node里面查找，最终定位到leaf node；另外一个是在leaf node中查找有没有这个key。</p></li><li><p>比如查找11，首先在根节点里面找到对应key，9代表子节点保存的key都符合9&lt;=key<13，那么可以找到9对应的kv，然后根据v是page_id，从buffer pool manager拿到对应的下一个node，也就是p="11的节点。11代表子节点的key都符合key">=11，从而找到P=9的叶子节点，从而在叶子节点找到key=11。</13，那么可以找到9对应的kv，然后根据v是page_id，从buffer></p></li></ul><h2 id="Node-Search"><a href="#Node-Search" class="headerlink" title="Node Search"></a>Node Search</h2><ul><li><p>不管是在internal node还是leaf node，保存的key都是有序的，所以在node里面查找对应的key可以使用二分算法。</p></li><li><p>假定要找的值为v，对于internal node来讲，其实就是要找到第一个大于v的key的前一个节点，比如v=11，节点中有5,9,13，那么找到的key是9，因为9这个节点下面所有的key都是大于等于9的。如果没有大于v的key，那么则选择最后一个key。</p><ul><li>internal node查找的过程可以使用upper_bound，其返回指向范围 [first, last) 中首个大于 value 的元素的迭代器，或若找不到这种元素则返回 last。因为这里需要的是前一个节点，所以减去-1就行。因为node的第一个元素key为空，所以这里从第二个元素开始查找。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pair_comparator = [&amp;](<span class="type">const</span> KeyType &amp;val, <span class="type">const</span> MappingType &amp;pair) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">comparator</span>(val, pair.first) &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">upper_bound</span>(array_ + <span class="number">1</span>, array_ + <span class="built_in">GetSize</span>(), key, pair_comparator) - array_ - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对于leaf node来讲，可以使用lower_bound，其返回的是第一个大于或等于value的元素迭代器，如果要判断元素是否存在，可判断是否等于value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;](<span class="type">const</span> MappingType &amp;element, <span class="type">const</span> KeyType &amp;val) -&gt; <span class="type">bool</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">comparator</span>(element.first, val) &lt; <span class="number">0</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> idx = std::<span class="built_in">lower_bound</span>(array_, array_ + <span class="built_in">GetSize</span>(), key, cmp) - array_;</span><br><span class="line"><span class="keyword">return</span> idx != <span class="built_in">GetSize</span>() &amp;&amp; <span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(idx), key) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Tree-Search"><a href="#Tree-Search" class="headerlink" title="Tree Search"></a>Tree Search</h2><p>在树上搜索比较简单，一般是使用一个指针，从root遍历到leaf，需要注意的一点是这个指针类型可能是internal node或者是leaf node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">current = bpm拿到root_page_id对应的page并<span class="keyword">reinterpret_cast</span>成BPlusTreePage类型;</span><br><span class="line"><span class="keyword">while</span> (!current-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    internal_page = <span class="keyword">reinterpret_cast</span> current成InternalPage类型;</span><br><span class="line">    idx = 使用upper_bound在internal_page找到v的位置;</span><br><span class="line">    next_page_id = array_[idx].second;</span><br><span class="line">    current = bpm拿到next_page_id对应的page并<span class="keyword">reinterpret_cast</span>成BPlusTreePage类型;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>成LeafPage类型;</span><br></pre></td></tr></table></figure><p>需要注意的是记得unpin取出来的page。</p><h1 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h1><h2 id="No-Overflow"><a href="#No-Overflow" class="headerlink" title="No Overflow"></a>No Overflow</h2><h3 id="New-Root"><a href="#New-Root" class="headerlink" title="New Root"></a>New Root</h3><p>如果是第一次插入，那么流程就简单点，等于是建树，不过此时树只有一个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root_page_id_ == INVALID_PAGE_ID)&#123;</span><br><span class="line">    new_page = 从bpm申请一个新的page，<span class="keyword">reinterpret_cast</span>成LeafPage</span><br><span class="line">    new_page-&gt;<span class="built_in">Init</span>();</span><br><span class="line">    array_[<span class="built_in">GetSize</span>()] = &#123;key, value&#125;;</span><br><span class="line">    更新root_page_id;</span><br><span class="line">    <span class="built_in">unpin</span>(new_page_id);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="No-New-Root"><a href="#No-New-Root" class="headerlink" title="No New Root"></a>No New Root</h3><ul><li><p>正常情况下的插入的步骤是先根据key找到leaf node，然后在对应的位置（插入后保持key的有序性）插入key和value就行。</p><ul><li><p>这个前提是插入后不发生overflow，对于leaf node，overflow条件是插入后size等于max_size，所以插入前需要判断下size是否小于max_size-1（极端情况下等于max_size-1，插入后size==max_size，就需要overflow了）。</p></li><li><p>leaf的max_size在初始化BPlusTree时会传入，或者使用默认值。</p></li></ul></li><li><p>lab实现的b+树是不能插入重复key的，所以插入前需要判断一下。</p></li></ul><p>常规情况的插入是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">leaf_page = <span class="built_in">FindLeafNode</span>(key);</span><br><span class="line">idx = 使用lower_bound在leaf_page查找应该插入的位置;</span><br><span class="line"><span class="keyword">if</span>(idx对应的位置的key等于需要插入的key)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (leaf-&gt;<span class="built_in">GetSize</span>() &lt; leaf-&gt;<span class="built_in">GetMaxSize</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">    leaf-&gt;<span class="built_in">Insert</span>(key, value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leaf的插入操作一般是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">idx = 使用lower_bound在leaf_page查找应该插入的位置;</span><br><span class="line">将idx到<span class="built_in">GetSize</span>()的元素都向后移动一位，从而让出一个能插入的空间;</span><br><span class="line">在idx的位置插入key和value;</span><br><span class="line">size++;</span><br></pre></td></tr></table></figure><h2 id="Overflow-In-Leaf-Node"><a href="#Overflow-In-Leaf-Node" class="headerlink" title="Overflow In Leaf Node"></a>Overflow In Leaf Node</h2><p>如果插入后leaf node size == max_size就会发生overflow，需要执行split node操作</p><h3 id="Leaf-Node-Is-Not-The-Root-Node"><a href="#Leaf-Node-Is-Not-The-Root-Node" class="headerlink" title="Leaf Node Is Not The Root Node"></a>Leaf Node Is Not The Root Node</h3><p>如果leaf node不是root node，一般流程如下：</p><ol><li>Split the leaf node into two nodes.</li><li>First node contains ceil((m-1)/2) values.</li><li>Second node contains the remaining values.</li><li>Copy the smallest search key value from second node to the parent node.(Right biased)</li></ol><ul><li><p>example1：<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231114215250806.png" alt="image-20231114215250806"></p></li><li><p>example2：<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231114215807606.png" alt="image-20231114215807606"></p></li></ul><p>这里的逻辑抽出来就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 已经判断出插入后得发生overflow的前提下</span><br><span class="line">leaf_node = <span class="built_in">FindLeafNode</span>();</span><br><span class="line">leaf_node_new = 创建一个新的leaf node节点</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> mid = (n_new-&gt;<span class="built_in">GetSize</span>() + <span class="number">1</span>) / <span class="number">2</span>; # 取出一半，不一定要按照上面写的ceil来，实现类似效果就好了</span><br><span class="line"><span class="type">int</span> left_node_size = mid; </span><br><span class="line"><span class="type">int</span> right_node_size = leaf_node.<span class="built_in">size</span>()-mid;</span><br><span class="line"></span><br><span class="line">leaf_node-&gt;<span class="built_in">SetSize</span>(left_node_size);</span><br><span class="line">leaf_node_new-&gt;<span class="built_in">SetSize</span>(right_node_size);</span><br><span class="line"></span><br><span class="line">#将另外一半移动到另外一个节点</span><br><span class="line">#这里的移动其实就是赋值就好了，并不是真的删除然后新增，这里使用size去控制真正的长度，后面的位置虽然有值，但是插入时候会被覆盖掉</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = left_node_size; i &lt; right_node_size; i++, j++) &#123;</span><br><span class="line">   leaf_node_new-&gt;arr_[i] = leaf_node-&gt;<span class="built_in">IndexAt</span>(j));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">更新leaf_node和leaf_node_new的NextPageId;</span><br><span class="line"></span><br><span class="line"># Copy the smallest search key value from second node to the parent node.(Right biased)</span><br><span class="line">smallest_kv = leaf_node_new-&gt;arr_[<span class="number">0</span>]; <span class="meta"># smallest search key value，因为arr_是有序的，所以直接取第一个就是最小的</span></span><br><span class="line">parent = leaf_node-&gt;parent; #表述比较简单，实际上需要取出parent_id，从buffer pool manager拿</span><br><span class="line"></span><br><span class="line">parent-&gt;<span class="built_in">Insert</span>(smallest_kv, leaf_node_new-&gt;PageId);</span><br><span class="line"></span><br><span class="line">更新leaf_node_new的parent_id;</span><br><span class="line">unpin相关page;</span><br></pre></td></tr></table></figure><h3 id="Leaf-Node-Is-The-Root-Node"><a href="#Leaf-Node-Is-The-Root-Node" class="headerlink" title="Leaf Node Is The Root Node"></a>Leaf Node Is The Root Node</h3><p>只有一个root node的时候，这个node的类型其实是leaf node</p><ul><li><p>example1:<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231203113800829.png" alt="image-20231203113800829"></p></li><li><p>example2:<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231203114024994.png" alt="image-20231203114024994"></p></li></ul><p>可以看出来，其实和上面的流程有一点类似，只是第四步将smallest kv插到parent这一步不一样，root node节点换了一个，所以流程就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Split the leaf node into two nodes.</span><br><span class="line"><span class="function">First node contains <span class="title">ceil</span><span class="params">((m<span class="number">-1</span>)/<span class="number">2</span>)</span> values.</span></span><br><span class="line"><span class="function">Second node contains the remaining values.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">创建一个新的root_node</span>;</span><br><span class="line"><span class="built_in">UpdateRootPageId</span>();</span><br><span class="line">root_node-&gt;<span class="built_in">Insert</span>(空的key, leaf_node-&gt;page_id);</span><br><span class="line">root_node-&gt;<span class="built_in">Insert</span>(smallest_kv, leaf_node_new-&gt;page_id);</span><br><span class="line"></span><br><span class="line">更新leaf_node和leaf_node_new的parent_id;</span><br><span class="line">unpin相关page;</span><br></pre></td></tr></table></figure><h2 id="Overflow-In-Internal-Node"><a href="#Overflow-In-Internal-Node" class="headerlink" title="Overflow In Internal Node"></a>Overflow In Internal Node</h2><p>因为需要将smallest kv插入到parent node，所以这里可能会出现的一种情况就是parent node也得spilt。</p><p>对于internal node，插入之前的size等于max_size的时候需要拆分，所以这里插入前不拆分的极端情况是max_size-1。流程如下：</p><ol><li><p>Split the non leaf node into two nodes.</p></li><li><p>First node contains ceil(m/2)-1 values.</p></li><li><p>Move the smallest among remaining to the parent.</p></li><li><p>Second node contains the remaining keys.</p></li></ol><ul><li><p>example1:</p><p><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231212205441303.png" alt="image-20231212205441303"></p></li><li><p>example2:<br><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231212214338519.png" alt="image-20231212214338519"></p><p>从上面可以看到，insert的时候可能会发生root node节点的变更，从而可能导致重建整个树。</p></li></ul><p>这一块逻辑参考教科书的逻辑即可，比较麻烦，涉及到递归。</p><p><img src="/2023/12/12/CMU445-Project2-BPlusTree-Insert/image-20231212223704765.png" alt="image-20231212223704765"></p><p>递归的逻辑是，如果internal node发生了overflow，向parent node插入key后可能会接着发生overflow，极端情况是一直overflow到root node，然后重建整个树树，这部分的逻辑在上图是insert_in_parent函数里面。</p><hr><p>For more:</p><p><a href="https://zhuanlan.zhihu.com/p/592964493">CMU 15445-2022 P2 B+Tree Insert/Delete - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/618912295">CMU 15-445 Project 2 (Spring 2023) | 关于 B+Tree 的十个问题 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/596067906">CMU 15-445 2022 Project2 B+Tree - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/580014163">做个数据库：2022 CMU15-445 Project2 B+Tree Index - 知乎</a></p><p><a href="https://www.geeksforgeeks.org/insertion-in-a-b-tree/#">Insertion in a B+ tree - GeeksforGeeks</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> BPlusTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project1-BufferPoolManagerInstance总结</title>
      <link href="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h1><h2 id="Disk-Oriented-DBMS"><a href="#Disk-Oriented-DBMS" class="headerlink" title="Disk-Oriented DBMS"></a>Disk-Oriented DBMS</h2><p>什么是buffer pool，buffer pool有什么用（针对Disk-Oriented DBMS）</p><p><img src="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/1.JPG" alt></p><ul><li><p>The database is all on <strong>disk</strong>, and the data in the database files is organized into <strong>pages</strong>.</p></li><li><p>In order to operate on the data the DBMS needs to bring the data into memory. It does this by having a <strong>buffer pool</strong> that <em>manages the movement back and forth between disk and memory</em>.</p></li><li><p>The DBMS also have an <strong>execution engine</strong> that will execute queries.</p></li><li><p>The execution engine will ask the buffer pool for a <strong>specific page</strong>, and the <em>buffer pool will take care of bringing that page into memory and giving the execution engine a pointer to the page in memory</em>.</p></li><li><p>The buffer pool manager will ensure that the page is there while the execution engine is operating on that memory.</p></li></ul><h2 id="Buffer-Pool-Organization"><a href="#Buffer-Pool-Organization" class="headerlink" title="Buffer Pool Organization"></a>Buffer Pool Organization</h2><p>buffer pool是如何利用内存的，组织数据的方式</p><ul><li>Memory region organized as an array of fixed-size pages.An array entry is called a <strong>frame</strong>.</li><li>When the DBMS requests a page, an exact copy is placed into one of these frames.</li></ul><p><img src="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/2.png" alt></p><h2 id="Meta-data-maintained-by-the-buffer-pool"><a href="#Meta-data-maintained-by-the-buffer-pool" class="headerlink" title="Meta-data maintained by the buffer pool"></a>Meta-data maintained by the buffer pool</h2><h3 id="Page-Table"><a href="#Page-Table" class="headerlink" title="Page Table"></a>Page Table</h3><p><img src="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/image-20230701100821339.png" alt="image-20230701100821339"></p><ul><li><p>In-memory <strong>page table</strong> (hash table) that keeps track of pages that are currently in memory. It maps <strong>page ids</strong> to <strong>frame locations</strong> in the buffer pool. </p></li><li><p>其实就是为了根据page id快速找到对应的page data，还可以判断page id对应的数据有没有在buffer pool</p></li></ul><h3 id="Dirty-Flag"><a href="#Dirty-Flag" class="headerlink" title="Dirty Flag"></a>Dirty Flag</h3><ul><li>Threads set this flag when it modifies a page. </li><li>This indicates to storage manager that the page must be written back to disk.</li><li>其实就是判断page data有没有被修改过，如果修改过在某个时候需要将修改写回到磁盘</li></ul><h3 id="Pin-Counter"><a href="#Pin-Counter" class="headerlink" title="Pin Counter"></a>Pin Counter</h3><ul><li>This tracks the number of threads that are currently accessing that page (either reading or modifying it). </li><li><p>A thread has to increment the counter before they access the page.</p></li><li><p>If a page’s count is greater than zero, then the storage manager is not allowed to evict that page from memory.</p></li></ul><h1 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h1><ul><li>buffer pool：<code>BufferPoolManagerInstance</code>，本次lab需要实现的部分</li><li>磁盘读写相关：<code>DiskManager</code>，已经提供，不需要实现</li><li><code>class Page</code><ul><li>Each <code>Page</code> object contains a block of memory that the <code>DiskManager</code> will use as a location to copy the contents of a <strong>physical page</strong> that it reads from disk. 将磁盘中内容读到内存中，放到page对象中</li><li>The <code>BufferPoolManagerInstance</code> will reuse the same <code>Page</code> object to store data as it moves back and forth to disk. This means that the same <code>Page</code> object may contain a different physical page throughout the life of the system. 重复利用page object，所以page object里面的内容不是固定不变的</li><li>The <code>Page</code> object’s identifer (<code>page_id</code>) keeps track of what physical page it contains. page_id代表了里面的数据对应哪个phusical page</li><li>page具体内容存放在<code>data_</code>，metadata对应上面提到的两个<code>is_dirty_</code>,<code>pin_count_</code></li></ul></li><li><p>page table：使用自己实现的<code>ExtendibleHashTable</code>类，maps <code>page_id</code> to <code>frame_id</code></p></li><li><p>buffer pool满了如何evict page：使用LRU-K算法，对应自己实现的<code>LRUKReplacer</code></p></li></ul><h1 id="Buffer-Pool-Manager-Instance"><a href="#Buffer-Pool-Manager-Instance" class="headerlink" title="Buffer Pool Manager Instance"></a>Buffer Pool Manager Instance</h1><ul><li><code>size_t pool_size_</code>代表了buffer pool中能容纳多少个fixed-size page</li><li><p><code>Page *pages_</code>代表了buffer pool中的page，其大小是固定的<code>pages_ = new Page[pool_size_];</code>代表一开始buffer pool有多少个空的page。其实就是下面这个东西，通过frame_id索引到某个page obejct<br><img src="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/image-20230701103902424.png" alt="image-20230701103902424"></p></li><li><p><code>std::list&lt;frame_id_t&gt; free_list_</code>代表有哪些frame_id对应的page object还可以用来存放从磁盘中读取到的page，首先从这里拿，如果free_list满了，代表buffer page中没有多余的空间了，需要evict page到disk从而reuse page承载新的内容（如果可以）</p></li><li><code>ExtendibleHashTable&lt;page_id_t, frame_id_t&gt; *page_table_</code>，根据page<em>id可以拿到frame_id，`pages</em>[frame_id]`可以拿到buffer pool中的某个page</li></ul><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><ol><li><p><code>NewPageImp</code>和<code>FetchPageImp</code>从free_list或者LRUKReplacer拿到一个page后:</p><ol><li>如果page是dirty，需要先将其内容写回到disk，ResetMemory，pin_count需要置为0，is_dirty需要置为false</li><li>需要<code>pin_count++</code></li><li>将该page_id从page_table中移除</li><li>更新page_id（NewPage是新创建一个，FetchPage是传入page_id）</li><li>将page_id和frame_id对应关系存到page_table</li><li>调用replacer的SetEvictable和RecordAccess</li></ol><p>这里其实可以更细化，比如如果是从free_list中拿的，可以不校验dirty，因为只有在<code>DeletePgImp</code>方法中才将frame_id放到free_list，放之前已经将其对应的memory和metadata清空。</p></li><li><p><code>FetchPageImp</code>需要先判断page<em>id对应的数据有没有已经在page table，如果在代表数据在buffer pool已经有了，不需要从disk中拿，直接返回`pages</em>[frame_id]<code>即可。返回前需要</code>pin_count++`并调用replacer的SetEvictable和RecordAccess。</p></li><li><code>UnpinPgImp</code>传入的dirty代表是否改变dirty flag，如果是false代表维持当前page的dirty flag，所以这里需要if判断一下才赋值</li><li><code>FlushPgImp</code>记得将对应的page的dirty flag置为false</li><li><code>DeletePgImp</code>需要将对应page_id从page table，replacer中移除。需要Reset Memory和metadata。</li><li>从上面可以看出，很多地方需要reset page，所以这里可以抽出一个方法，避免忘记初始化某个东西。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> bufferpool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project1-LRU-K总结</title>
      <link href="/2023/06/06/CMU445-Project1-LRU-K%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/06/CMU445-Project1-LRU-K%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">https://15445.courses.cs.cmu.edu/fall2022/project1/</a></p><p>DB的Buffer Replacement Policies中的LRU和Clock算法都容易受到<code>sequential flooding</code>的影响，对于LRU来讲，使用LRU-K算法能够缓解这个问题。</p><h1 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h1><ul><li>This component is responsible for tracking page usage in the buffer pool.</li><li>The LRU-K algorithm evicts a frame whose <strong>backward k-distance</strong> is <strong>maximum</strong> of all frames in the replacer.<ul><li>Backward k-distance is computed as the <strong>difference in time</strong> between <strong>current timestamp</strong> and the <strong>timestamp of kth previous access</strong>.</li><li>A frame with <strong>less than k</strong> historical accesses is given <strong>+inf</strong> as its backward k-distance.</li><li>When multipe frames have +inf backward k-distance, the replacer evicts the frame with the <strong>earliest timestamp</strong>.</li></ul></li></ul><h1 id="Backward-k-distance"><a href="#Backward-k-distance" class="headerlink" title="Backward k-distance"></a>Backward k-distance</h1><p>这个数据很关键，也很容易被理解错，下面举例说明，当k=3时候</p><p><img src="/2023/06/06/CMU445-Project1-LRU-K%E6%80%BB%E7%BB%93/image-20230607080508643.png" alt="image-20230607080508643"></p><p>由上面的定义可知，Backward k-distance为current_timestamp和倒数第k次访问的时间之差，故k=3时候如上面所示</p><p>因为每次current_timestamp都是一样的，所以其实直接看第k次访问的时间点就好，这里可以不用记下每次访问的时间戳，直接记录访问对应的index就好了，也就说记住某个数在第几次出现就好了。</p><h1 id="Evit"><a href="#Evit" class="headerlink" title="Evit"></a>Evit</h1><ul><li><p>每次都选择最大的Backward k-distance驱除(evit)，这里存在两种情况:</p><ol><li><p>某个数已经有了k次访问记录，那么Backward k-distance就是上图所示</p></li><li><p>如果不够k次访问，那么Backward k-distance就是正无穷大</p></li></ol></li><li><p>那么每次evit时候肯定都是优先选择第二种情况，因为是正无穷大</p><ul><li>如果有多个无穷大，则按照FIFO的顺序evit<br>比如访问顺序如下（从左到右依次访问），假设k=3<br><code>1 2 3 4 1 2 3 1 2</code><br>这里无限大的数有3和4，按照FIFO顺序，3第一次出现的时间点和4还早，所以第一次evit时候选择3</li></ul></li><li>第二种情况没有了的话，则按照第一种情况，这里直接看哪个数倒数第k次最早出现就好了，那么就是Backward k-distance最大的</li></ul><h1 id="SetEvictable"><a href="#SetEvictable" class="headerlink" title="SetEvictable"></a>SetEvictable</h1><p>需要注意的是某个数是evitable才能被evit，也就是`这个函数的作用，因为此时某个数据正在被访问，不能evit</p><p>有一种情况是SetEvictable时候，但是这个数还没有被访问过或者是被evit了，那么这个函数直接return就好了</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>我是使用了两个顺序容器和一个map</p><ul><li><p>map记录了某个数第n次访问的index，比如hist(1, 3)，代表1这个数第3次访问的index</p></li><li><p>当某个数还没有访问k次时候，就放到第一个容器，保证容器内的顺序是FIFO的，这样每次从队首或者队尾出队就好了，因为某些数可能不是Evictable的，实际上需要遍历一下容器，找到第一个能够Evictable的。</p></li><li><p>如果达到k次，那么把这个数从第一个容器挪到第二个容器</p></li><li><p>evit时候，如果第一个容器已经是empty的，那么代表没有正无穷的数，需要从第二个容器拿，此时因为map记录了每次容器出现的时间点，按照map对容器排序后直接取好了。这里没有想到一个方法类似第一个容器那么维护状态，考虑一下访问顺序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 2 2 2 1 X</span><br></pre></td></tr></table></figure><p>虽然1是最后evit的，但是按照Backward 3-distance来看，1才是要evit，不能每次访问就更新那个数在第二个容器的位置。</p><p>看了下discord的讨论，有比这个更快的方法，应该使用了堆之类的容器维护</p></li></ul><hr><p>维护某个数是否已经出现，以及其状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LruEntry</span> &#123;</span><br><span class="line">    <span class="type">bool</span> evictable_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="type">size_t</span> access_count_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">std::unordered_map&lt;<span class="type">frame_id_t</span>, LruEntry&gt; lru_entry_hash_;</span><br></pre></td></tr></table></figure><p>第一个容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; less_than_k_frames_;</span><br></pre></td></tr></table></figure><p>第二个容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">frame_id_t</span>&gt; more_than_k_frames_;</span><br></pre></td></tr></table></figure><p>记录每个数每次出现的时间点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PairHash</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">frame_id_t</span>, <span class="type">size_t</span>&gt; &amp;p)</span> <span class="type">const</span> -&gt; std::<span class="type">size_t</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 使用 std::hash 计算哈希值</span></span><br><span class="line">      std::<span class="type">size_t</span> h1 = std::hash&lt;<span class="type">frame_id_t</span>&gt;&#123;&#125;(p.first);</span><br><span class="line">      std::<span class="type">size_t</span> h2 = std::hash&lt;<span class="type">size_t</span>&gt;&#123;&#125;(p.second);</span><br><span class="line">      <span class="keyword">return</span> h1 ^ (h2 &lt;&lt; <span class="number">1</span>);  <span class="comment">// 可以使用异或和位移等运算来组合哈希值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">std::unordered_map&lt;std::pair&lt;<span class="type">frame_id_t</span>, <span class="type">size_t</span>&gt;, <span class="type">size_t</span>, PairHash&gt; hist_;</span><br></pre></td></tr></table></figure><p>获取某个数第k次出现的时间：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">GetLastKAccessTime</span><span class="params">(<span class="type">const</span> <span class="type">frame_id_t</span> x)</span> <span class="type">const</span> -&gt; <span class="type">size_t</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> last_k = lru_entry_hash_.<span class="built_in">at</span>(x).access_count_ - k_ + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> hist_.<span class="built_in">at</span>(std::<span class="built_in">make_pair</span>(x, last_k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照Backward k-distance对第二个容器排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(more_than_k_frames_.<span class="built_in">begin</span>(), more_than_k_frames_.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;](<span class="type">frame_id_t</span> a, <span class="type">frame_id_t</span> b) &#123; <span class="keyword">return</span> <span class="built_in">GetLastKAccessTime</span>(a) &lt; <span class="built_in">GetLastKAccessTime</span>(b); &#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> lru </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project1-ExtendibleHashTable总结</title>
      <link href="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/"/>
      <url>/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>前提：搞懂<a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/</a></p><h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p><a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">https://15445.courses.cs.cmu.edu/fall2022/project1/</a></p><p>待补充，可看原论文<br>设计要点：</p><ol><li>Page Fault</li><li>Access Memory/Disk</li><li>Dynamic File Organization</li><li>Balance Radix Search Tree</li><li>Static &amp; Dynamic Hash</li></ol><h1 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h1><ol><li>$h$: fixed hash function</li><li>$K$: is a key</li><li>$K’$: $h(K)$, also $pseudokey$. <ul><li>We choose pseudokeys to be of fixed length, such as 32 bits. </li><li>The pseudokeys are of fixed length, the keys need not be.</li></ul></li><li>$I(K)$: is associated information: either the record associated with $K$, or a pointer to the record. </li></ol><h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><p>基本结构如下：</p><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/1.png" alt></p><ol><li><strong>Two levels</strong>: $directory$ and $leaves$<ul><li>The leaves contain pairs$(K, I(K))$</li><li>The directory contains pointers to leaf pages</li></ul></li><li><strong>Depth d</strong>: the depth $d$ of the directory. </li><li><p><strong>Directory pointers</strong>:</p><ul><li>First, There is a pointer to a leaf that stores all keys $K$ for which the pseudokey $K’ = h(K)$ starts with $d$ consecutive zeros.<br>directory第一个指针指向的leaf中所有的$K$有下面的特征：$K’$前$d$位都是0</li><li>第二个指针指向的leaf中所有的$k’$前$d$位是<code>0...01</code>，第三个是<code>0...010</code>，后面以此类推。</li><li>所以directory总共$2^d$个pointer</li></ul></li><li><p><strong>Find $K$</strong>: </p><ul><li>计算出$K’$,  找出其前$d$位.</li><li>找到这$d$位对应的是directory哪个pointer</li><li>然后可以找到leaf，在leaf中遍历pairs</li></ul></li><li><p><strong>Leaf header</strong>:</p><ul><li>Each leaf page has a header that contains a local depth $d’$ for the leaf page. </li><li>举例directory中 <code>000</code> pointer指向的leaf: Local depth 2 means that not only does this leaf page contain all keys whose pseudokey begins with 000, but even more, it containsall keys whose pseudokey begins with the 2 bits 00. Thus the 001 pointer also points to this leaf page.</li><li>$d’ &lt;= d$</li></ul></li></ol><h1 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h1><p>这里以lab的要求为准：</p><ul><li>在编程中计算后$d$位比较方便，和上面看前$d$位有所区别，但是原理相同</li><li>leaf在lab中称为Bucket</li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><p>lab中extendible hash table结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global_depth_;    <span class="comment">// The global depth of the directory</span></span><br><span class="line"><span class="type">size_t</span> bucket_size_;  <span class="comment">// The size of a bucket</span></span><br><span class="line"><span class="type">int</span> num_buckets_;     <span class="comment">// The number of buckets in the hash table</span></span><br><span class="line">std::vector&lt;std::shared_ptr&lt;Bucket&gt;&gt; dir_;  <span class="comment">// The directory of the hash table</span></span><br></pre></td></tr></table></figure><p>Bucket结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="type">size_t</span> size_;</span><br><span class="line"><span class="type">int</span> depth_;</span><br><span class="line">std::list&lt;std::pair&lt;K, V&gt;&gt; list_;</span><br></pre></td></tr></table></figure><p>所以<code>dir_</code>里面保存了directory pointer，<code>bucket_size_</code>代表每个bucket最大容量是多少，<code>Bucket</code>中的<code>list_</code>保存了上述讲的pairs</p><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><p>初始情况下global_depth为0，总共有$2^0=1$个bucket，所以num_buckets=1，bucket_size每个用例都是不一样的，每个bucket里面都还是空的。</p><h2 id="Indexof"><a href="#Indexof" class="headerlink" title="Indexof"></a>Indexof</h2><p>For the given key, return the entry index in the directory where the key hashes to.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="keyword">auto</span> ExtendibleHashTable&lt;K, V&gt;::<span class="built_in">IndexOf</span>(<span class="type">const</span> K &amp;key) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">  <span class="type">int</span> mask = (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">hash</span>&lt;K&gt;()(key) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mask<ul><li>对1左移global_depth位，即在1的二进制后面加global_depth个0，然后-1</li><li>比如<code>(1&lt;&lt;4)-1</code>: 1&lt;&lt;4 可以写成二进制形式 10000，然后再减去 1，为 1111。</li><li>所以这mask为global_depth个1</li></ul></li><li><code>std::hash&lt;K&gt;()(key) &amp; mask</code><ul><li>这里取&amp;为的是将index控制在一定数量的位数上，该位数由global<em>depth</em>变量确定，也就是index不能超过$2^d$，比如global_depth=2，有4个bucket，index最大为3，3的二进制是11，正好是global_depth个1</li><li>这里意思也就是看后global depth位</li></ul></li></ul><h2 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, std::string&gt;&gt;(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里bucket_size为2</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230426112938666.png" alt="image-20230426112938666"></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure><p>这时候bucket已经满了，正常情况下处理bucket满的策略有两个，double directory和split bucket only。</p><p>采用哪个策略需要看global depth和已满的bucket的local depth：</p><h3 id="Bucket-Full"><a href="#Bucket-Full" class="headerlink" title="Bucket Full"></a>Bucket Full</h3><ul><li>如果global depth == local depth，需要double directory。为什么呢，这是由两个depth代表的意思决定，两个相等，代表该bucket只有一个directory pointer指向，没有多余的pointer来指向了，只能是增加pointer。至于为什么是double呢，我想这里可能和二进制方便运算有关系吧，也许这样处理起来比较规整？</li><li>因为local depth不会大于global depth（两个相等时double directory，global depth都会+1），所以还有一种情况是global depth &gt; local depth，global depth代表了找到key需要看后几位bit，local depth代表了该bucket里面的key后local depth位都是相同的，当global depth &gt; local depth时，因为看的位数的差异，自然会有多个directory pointer指向这个bucket，那么这时候只需要split bucket就好了，有多余的pointer能指向新的bucket。</li></ul><h3 id="Double-Directory"><a href="#Double-Directory" class="headerlink" title="Double Directory"></a>Double Directory</h3><p>这里global depth和local depth相等，所以执行double directory逻辑，假设原先满的bucket是bucket j：</p><ol><li><p>global depth = global depth+1</p></li><li><p>directory翻倍，多出来的pointer按顺序指向原pointer</p><ul><li>比如原先directory size为4，double后变成8，那么多出来的<code>dir_[4]</code>指向<code>dir_[0]</code>，<code>dir_[5]</code>指向<code>dir_[1]</code>，6指向2，7指向3。</li><li>假设这里每个directory pointer只有一个对应的bucket，那么这里的操作就是每个bucket多了个pointer指向。</li><li>这里其实也好理解，比如原先pointer是<code>010</code>，double directory后，无非就是多了一位二进制，对应到directory要么是<code>0010</code>，要么是<code>1010</code>，因为local depth目前还没有到+1的地步，所以这两个先指向同一个bucket也可以。</li></ul></li><li><p>创建一个新的bucket z，设置bucket j、bucket z的local depth=global depth</p></li><li><p>对bucket j的里面所有的key执行rehash操作，判断该key是留在bucket j还是移动到bucket z。</p></li><li><p>重试插入操作，一般情况下会插入成功，某些情况下会插入失败，比如rehash时候所有的key还是在bucket j，这时候就需要重新执行插入逻辑，重新判断是需要 double directory还是split bucket。</p></li><li><p>一般情况下如果选择的hash函数合适的话，那么一次split即可。极端情况下会退化生成静态hash那样解决冲突，同时应该设定最大的directory depth）。</p></li></ol><h3 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h3><p>rehash过程其实就是看bucket j里面所有的key是放在bucket j还是bucket z。在double directory的情况下，多看了一位，所以是新增二进制位（也可以说是从低到高第global depth/local depth位，此时global depth=local depth）为1的话就放在bucket z。</p><p>这里实现的方式有两种，一种是直接调用erase将key从bucket中移除，另外一种是使用先将key放到<code>hashmap&lt;directory index, value list&gt;</code>，然后根据hashmap的key重新将value分配到bucket，因为每次只涉及到两个bucket，所以hashmap的length不大于2，理想情况是2，极端情况是1，也就是上面讲的所有的key都还在bucket j。</p><p>因为directory中可能有多个index指向bucket j，所以这里还得更新下别的index指向。这里处理的逻辑是，遍历所有的index，如果这个index之前指向的是bucket j，但是对应的新增的二进制位是1的话，就需要将这个index指向bucket z。</p><h3 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h3><p>回到<code>table-&gt;Insert(3, &quot;c&quot;);</code>，此时执行double directory和Rehash逻辑</p><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506153403500.png" alt="image-20230506153403500"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">4</span>, <span class="string">&quot;d&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506153552617.png" alt="image-20230506153552617"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">5</span>, <span class="string">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure><p>需要插入index为01的位置，执行double directory逻辑</p><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506154531571.png" alt="image-20230506154531571"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">6</span>, <span class="string">&quot;f&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时需要插入index=10对应的bucket，该bucket已经满了，因为global depth &gt; local depth，所以执行split bucket逻辑即可。</p><h3 id="Split-Bucket"><a href="#Split-Bucket" class="headerlink" title="Split Bucket"></a>Split Bucket</h3><ol><li>创建一个新的bucket z，设置bucket j、bucket z的local depth= local depth + 1</li><li>对bucket j的里面所有的key执行rehash操作，判断该key是留在bucket j还是移动到bucket z。<ul><li>这里和double directory的逻辑有点区别，但是大体相似。这里看的是从低到高第local depth位是否为1，因为只变了local depth。同样也得处理多个index指向同一个bucket的情况。</li></ul></li><li>重试插入的操作和double directory操作一样</li></ol><h3 id="Insert-2"><a href="#Insert-2" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">6</span>, <span class="string">&quot;f&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506160229598.png" alt="image-20230506160229598"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">7</span>, <span class="string">&quot;g&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506160405852.png" alt="image-20230506160405852"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">8</span>, <span class="string">&quot;h&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2023/04/24/CMU445-Project1-ExtendibleHashTable%E6%80%BB%E7%BB%93/image-20230506160507560.png" alt="image-20230506160507560"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">9</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="function">local <span class="title">depth</span><span class="params">(<span class="number">2</span>)</span>: [<span class="number">4</span>,<span class="number">8</span>,]</span></span><br><span class="line"><span class="function"><span class="number">1</span> local depth(<span class="number">3</span>): [<span class="number">1</span>,<span class="number">9</span>,]</span></span><br><span class="line"><span class="function"><span class="number">2</span> local depth(<span class="number">2</span>): [<span class="number">2</span>,<span class="number">6</span>,]</span></span><br><span class="line"><span class="function"><span class="number">3</span> local depth(<span class="number">2</span>): [<span class="number">3</span>,<span class="number">7</span>,]</span></span><br><span class="line"><span class="function"><span class="number">4</span> local depth(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">8</span>,]</span></span><br><span class="line"><span class="function"><span class="number">5</span> local depth(<span class="number">3</span>): [<span class="number">5</span>,]</span></span><br><span class="line"><span class="function"><span class="number">6</span> local depth(<span class="number">2</span>): [<span class="number">2</span>,<span class="number">6</span>,]</span></span><br><span class="line"><span class="function"><span class="number">7</span> local depth(<span class="number">2</span>): [<span class="number">3</span>,<span class="number">7</span>,]</span></span><br></pre></td></tr></table></figure><h2 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(<span class="number">2</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">16</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">64</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">31</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">51</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">18</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">7</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">23</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">11</span>, <span class="number">0</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">19</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line">[Init] bucket_size:<span class="number">2</span></span><br><span class="line">===========[Insert]key: <span class="number">4</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">4</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">12</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">12</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">16</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">0</span> local depth: <span class="number">0</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">1</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">2</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): []</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">===========[Insert]key: <span class="number">64</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">64</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">===========[Insert]key: <span class="number">31</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">31</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">10</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">10</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">51</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">51</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">15</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">15</span>, dir_index:<span class="number">7</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">15</span>, dir_index:<span class="number">7</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">15</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">18</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">18</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">20</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">4</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">3</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">4</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">7</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">7</span>, dir_index:<span class="number">7</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">4</span> local depth: <span class="number">3</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): []</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">7</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">23</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">23</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,<span class="number">23</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">11</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">11</span>, dir_index:<span class="number">11</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,<span class="number">23</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">19</span> ,value:<span class="number">0</span></span><br><span class="line">[FindBucket] key:<span class="number">19</span>, dir_index:<span class="number">3</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">4</span> local depth: <span class="number">3</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,<span class="number">23</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,<span class="number">23</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">11</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">19</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">4</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">51</span>,<span class="number">19</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">4</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">7</span>,<span class="number">23</span>,]</span><br><span class="line"><span class="number">8</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">9</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">10</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">11</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">11</span>,]</span><br><span class="line"><span class="number">12</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">12</span>,]</span><br><span class="line"><span class="number">13</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">14</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">15</span> local <span class="built_in">depth</span>(<span class="number">4</span>): [<span class="number">31</span>,<span class="number">15</span>,]</span><br></pre></td></tr></table></figure><h2 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(ExtendibleHashTableTest, GetNumBuckets2) &#123;</span><br><span class="line"><span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, std::string&gt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">4</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">12</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">16</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">64</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">31</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">10</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">51</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">15</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">18</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">20</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">7</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">23</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line">[Init] bucket_size:<span class="number">4</span></span><br><span class="line">===========[Insert]key: <span class="number">4</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">4</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">12</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">12</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">16</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">64</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">64</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">31</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">31</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">0</span> local depth: <span class="number">0</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">[FindBucket] key:<span class="number">31</span>, dir_index:<span class="number">1</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">10</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">10</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">1</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">10</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">51</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">51</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">15</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">15</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">18</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">18</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">20</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">2</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">4</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">7</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">7</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">23</span> ,value:a</span><br><span class="line">[FindBucket] key:<span class="number">23</span>, dir_index:<span class="number">7</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">23</span>, dir_index:<span class="number">7</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">31</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">23</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">31</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">23</span>,]</span><br></pre></td></tr></table></figure><h2 id="Case4"><a href="#Case4" class="headerlink" title="Case4"></a>Case4</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> table = std::make_unique&lt;ExtendibleHashTable&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;(<span class="number">4</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">64</span>, <span class="number">64</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">51</span>, <span class="number">51</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">15</span>, <span class="number">15</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">18</span>, <span class="number">18</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">21</span>, <span class="number">21</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">table-&gt;<span class="built_in">Insert</span>(<span class="number">19</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">[Init] bucket_size:<span class="number">4</span></span><br><span class="line">===========[Insert]key: <span class="number">4</span> ,value:<span class="number">4</span></span><br><span class="line">[FindBucket] key:<span class="number">4</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">12</span> ,value:<span class="number">12</span></span><br><span class="line">[FindBucket] key:<span class="number">12</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">16</span> ,value:<span class="number">16</span></span><br><span class="line">[FindBucket] key:<span class="number">16</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">64</span> ,value:<span class="number">64</span></span><br><span class="line">[FindBucket] key:<span class="number">64</span>, dir_index:<span class="number">0</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">5</span> ,value:<span class="number">5</span></span><br><span class="line">[FindBucket] key:<span class="number">5</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">0</span> local depth: <span class="number">0</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">0</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">0</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): []</span><br><span class="line">[FindBucket] key:<span class="number">5</span>, dir_index:<span class="number">1</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">10</span> ,value:<span class="number">10</span></span><br><span class="line">[FindBucket] key:<span class="number">10</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">1</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">1</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): []</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">10</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">51</span> ,value:<span class="number">51</span></span><br><span class="line">[FindBucket] key:<span class="number">51</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">15</span> ,value:<span class="number">15</span></span><br><span class="line">[FindBucket] key:<span class="number">15</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">18</span> ,value:<span class="number">18</span></span><br><span class="line">[FindBucket] key:<span class="number">18</span>, dir_index:<span class="number">2</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">20</span> ,value:<span class="number">20</span></span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">0</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">2</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">2</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">20</span>, dir_index:<span class="number">4</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">7</span> ,value:<span class="number">7</span></span><br><span class="line">[FindBucket] key:<span class="number">7</span>, dir_index:<span class="number">7</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">21</span> ,value:<span class="number">21</span></span><br><span class="line">[FindBucket] key:<span class="number">21</span>, dir_index:<span class="number">5</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">1</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">1</span>): [<span class="number">5</span>,<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">21</span>, dir_index:<span class="number">5</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">11</span> ,value:<span class="number">11</span></span><br><span class="line">[FindBucket] key:<span class="number">11</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">11</span>,]</span><br><span class="line">===========[Insert]key: <span class="number">19</span> ,value:<span class="number">19</span></span><br><span class="line">[FindBucket] key:<span class="number">19</span>, dir_index:<span class="number">3</span></span><br><span class="line">key_bucket is full</span><br><span class="line">global_depth: <span class="number">3</span> local depth: <span class="number">2</span></span><br><span class="line">before RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">51</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">11</span>,]</span><br><span class="line">after RedistributeBucket</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">15</span>,<span class="number">7</span>,]</span><br><span class="line">[FindBucket] key:<span class="number">19</span>, dir_index:<span class="number">3</span></span><br><span class="line">insert success</span><br><span class="line">PrintDir:</span><br><span class="line">dir_ global depth: <span class="number">3</span></span><br><span class="line"><span class="number">0</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">16</span>,<span class="number">64</span>,]</span><br><span class="line"><span class="number">1</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">2</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">3</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">51</span>,<span class="number">11</span>,<span class="number">19</span>,]</span><br><span class="line"><span class="number">4</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">4</span>,<span class="number">12</span>,<span class="number">20</span>,]</span><br><span class="line"><span class="number">5</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">5</span>,<span class="number">21</span>,]</span><br><span class="line"><span class="number">6</span> local <span class="built_in">depth</span>(<span class="number">2</span>): [<span class="number">10</span>,<span class="number">18</span>,]</span><br><span class="line"><span class="number">7</span> local <span class="built_in">depth</span>(<span class="number">3</span>): [<span class="number">15</span>,<span class="number">7</span>,]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> extendiblehash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU445-Project0-primer</title>
      <link href="/2023/02/15/CMU445-Project0-primer/"/>
      <url>/2023/02/15/CMU445-Project0-primer/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul><li>链接：<a href="https://15445.courses.cs.cmu.edu/fall2022/project0/">https://15445.courses.cs.cmu.edu/fall2022/project0/</a></li><li>目的：因为后续的项目都是使用c++编写，所以提供一个入门c++项目给新手熟悉下。</li><li>要求：给出基本的代码框架，填充核心代码实现trie树的插入、查找、删除。最终要求为并发版本，但是不要求性能，所以可以一把大锁直接梭哈。</li><li>环境：使用clang-12，c++17标准</li><li>使用到的常见cpp知识点：<ul><li>unique_ptr管理内存资源</li><li>类的常见知识，比如构造函数，类方法等</li><li>rvalue与move</li><li>shared_mutex</li></ul></li></ul><h1 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h1><p>简单记录下trie树</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>又称<strong>前缀树</strong>或<strong>字典树</strong>，存储公共前缀字符串比较高效，一般用于字符串查找。</p><p>在项目中的应用是将(key, value)插入到trie树，类似hashmap的作用，但是使用trie树实现。</p><p>普通的trie树如下：</p><p><img src="/2023/02/15/CMU445-Project0-primer/trie.jpg" alt></p><p>项目中要求实现的trie树：</p><p><img src="/2023/02/15/CMU445-Project0-primer/graph.png" alt></p><p>上面是将(ab, 1)和(ac, “val”)插入到trie。注意项目中的value都是同类型的，这里是不同类型</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>给出的代码框架中总共有三个类</p><ul><li><code>TrieNode</code>：除了带有value的节点外，树的每个节点都是这种类型。这种类型的节点的EndNode值自然为false，children_是一个unordered_map，里面记录了其子节点的信息。</li><li><code>TrieNodeWithValue</code>：带有value的节点，继承自TrieNode，多了个T value_属性，EndNode值为true</li><li><code>Trie</code>：trie树的实现，需要实现查找插入删除方法</li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找比较简单，顺着根节点一直找到末尾，这里比较简单的一种方法直接遍历给定的key，不断更新currentNode到末尾。</p><p>最后再使用dynamic_cast在运行时将TrieNode类型转为TrieNodeWithValue类型提取出value。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入的时候需要知道有哪些字符已经在树中了，所以开始需要遍历一下key，看currentNode能到哪里。</p><p>接着如果遍历完了整个key，就代表已经树中已经有了完全字符，此时最后一个节点可能有两者情况，可能需要转换节点类型。</p><p>否则就将剩余的字符插到树里面。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>参考：<a href="https://cloud.tencent.com/developer/article/1530883、https://www.geeksforgeeks.org/trie-delete/">https://cloud.tencent.com/developer/article/1530883、https://www.geeksforgeeks.org/trie-delete/</a></p><p><img src="/2023/02/15/CMU445-Project0-primer/o7hh4nqujx.png" alt></p><p>删除有两个情况：</p><ul><li>删除door单词，需要把第二个o和r也删除掉</li><li>删除pan，直接把n那个节点的EndNode属性设置为False就可。</li></ul><p>这里的难点就在于怎么从子节点回溯删除父节点，其中一个方法是使用递归，先递归到最后一个节点，如果需要删除父节点，可以返回一个nullptr代表子节点删除了，父节点可能也需要删除，这样就实现了父子节点的逆向联系，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;TrieNode&gt; *<span class="title">RecursivelyRemoveNode</span><span class="params">(<span class="type">const</span> std::string &amp;key, std::unique_ptr&lt;TrieNode&gt; *root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                 <span class="type">size_t</span> depth)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回值代表上一个节点有没有被删除</span></span><br><span class="line">  <span class="comment">// 作用是使其父节点将其删除，从达到从底向上遍历的效果</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// root倒数第一个节点</span></span><br><span class="line">  <span class="comment">// 第一次递归时候root获取到第一个字符，但是depth已经为1，指向第二个字符</span></span><br><span class="line">  <span class="comment">// 所有这里要遍历到最后一个字符对应的节点，得是以下条件</span></span><br><span class="line">  <span class="keyword">if</span> (depth == key.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// 该字符串已经删除了，所以如果最后一个字符对应的节点是end节点，先取消掉</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">IsEndNode</span>()) &#123;</span><br><span class="line">      root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">SetEndNode</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该节点没有子节点，删除掉</span></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">HasChildren</span>()) &#123;</span><br><span class="line">      root-&gt;<span class="built_in">reset</span>();</span><br><span class="line">      root = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最后一次递归完，root为倒数第二个节点</span></span><br><span class="line">  <span class="keyword">auto</span> last_node = <span class="built_in">RecursivelyRemoveNode</span>(key, root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">GetChildNode</span>(key[depth]), depth + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 上一个节点被删除掉，对应的其父子节点也得删除掉</span></span><br><span class="line">  <span class="keyword">if</span> (last_node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">RemoveChildNode</span>(key[depth]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向上回溯删除</span></span><br><span class="line">  <span class="keyword">if</span> (root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">GetKeyChar</span>() != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; !root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">HasChildren</span>() &amp;&amp; !root-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">IsEndNode</span>()) &#123;</span><br><span class="line">    root-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    root = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取测试用例"><a href="#获取测试用例" class="headerlink" title="获取测试用例"></a>获取测试用例</h1><p>参考：<a href="https://blog.csdn.net/freedom1523646952/article/details/123056958">https://blog.csdn.net/freedom1523646952/article/details/123056958</a></p><p>原本项目里面带的测试用例都是比较简单的，gradescope里面的测试会稍微复杂一点。</p><p>gradescope能够多次提交测试，但是因为可能要排队，所以有时候测试挺久，有一个方法能够拉取测试代码下来，在本地测试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetTestFileContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">bool</span> first_enter = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (first_enter) &#123;</span><br><span class="line">    std::vector&lt;std::string&gt; filenames = &#123;</span><br><span class="line">        <span class="string">&quot;/autograder/bustub/test/primer/grading_starter_trie_test.cpp&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    std::ifstream fin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> std::string &amp;filename : filenames) &#123;</span><br><span class="line">      fin.<span class="built_in">open</span>(filename, std::ios::in);</span><br><span class="line">      <span class="keyword">if</span> (!fin.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;cannot open the file:&quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">char</span> buf[<span class="number">200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">      std::cout &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">while</span> (fin.<span class="built_in">getline</span>(buf, <span class="built_in">sizeof</span>(buf))) &#123;</span><br><span class="line">        std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">      fin.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    first_enter = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述的方法放入到要提交的代码文件中，然后在任意一个构造函数中调用，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TrieNode</span><span class="params">(<span class="type">char</span> key_char)</span> : key_char_&#123;</span>key_char&#125; &#123;<span class="built_in">GetTestFileContent</span>();&#125;</span><br></pre></td></tr></table></figure><p>然后压缩并提交代码，在平台的执行日志中就可以看到打印了测试代码，将测试代码复制下来即可。</p><p>ps：添加了代码后记得重新format代码，并执行格式测试命令，避免还没有执行到代码就因为格式问题被打回。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="TrieNode如何转换为TrieNodeWithValue"><a href="#TrieNode如何转换为TrieNodeWithValue" class="headerlink" title="TrieNode如何转换为TrieNodeWithValue"></a>TrieNode如何转换为TrieNodeWithValue</h2><p>假设插入如下数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&quot;abc&quot;, 1)</span><br><span class="line">(&quot;ab&quot;, 2)</span><br></pre></td></tr></table></figure><p>在插入ab的时候，因为之前插入abc的时候，已经有了a节点和b节点，并且b节点的类型为TrieNode，所以我们的任务其实是将b节点类型转为TrieNodeWithValue，而我们遍历一般以如下的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;TrieNode&gt; *current_node = &amp;root_;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> c : key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!current_node-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">HasChild</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current_node = current_node-&gt;<span class="built_in">get</span>()-&gt;<span class="built_in">GetChildNode</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个循环退出的时候，current_node指向的是b节点，问题就是怎么将current_node指向的节点的类型变为TrieNodeWithValue。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConvertToTrieNodeWithValue</span><span class="params">(std::unique_ptr&lt;TrieNode&gt; *currentNode, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> <span class="built_in">TrieNodeWithValue</span>&lt;T&gt;(std::<span class="built_in">move</span>(**currentNode), value);</span><br><span class="line">    currentNode-&gt;<span class="built_in">reset</span>(new_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>currentNode为a节点的一个子节点（unordered_map里面key为a的value），所以这里可以直接将currentNode的值变为TrieNodeWithValue就行，相当于子节点的类型也变了，也就是说之前指的是TrieNode，现在指向TrieNodeWithValue就行，这样就完成了节点转换。</li><li><p><code>*currentNode</code>表示取到<code>std::unique_ptr&lt;TrieNode&gt;</code>，<code>**currentNode</code>表示取到<code>TrieNode</code></p></li><li><p>因为TrieNodeWithValue有个构造函数<code>TrieNodeWithValue(TrieNode &amp;&amp;trieNode, T value)</code>，所以取<code>std::move(**currentNode)</code>使用move constructor避免了不必要的复制操作。</p></li><li><p>在完成转换后，原始的 <code>TrieNode</code> 对象已经不再被引用，由于没有显式释放内存，它将自动被销毁。</p></li></ul><h2 id="defer-unlock"><a href="#defer-unlock" class="headerlink" title="defer unlock"></a>defer unlock</h2><p>go中有一个很好的功能defer，用于在函数退出时执行一些操作，这样可以避免忘记unlock，但是c++中没有，可以使用以下代替。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::shared_timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//独占锁,只能被一个线程访问</span></span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>;     </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//共享锁,在一次时刻，多个线程可以同时访问共享锁所保护的资源</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::shared_mutex&gt; <span class="title">lock</span><span class="params">(mtx_)</span></span>; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(bar)</span></span>;</span><br><span class="line"></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmu445 </tag>
            
            <tag> trie </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU213-CSAPP-Virtual-Memory-Concepts</title>
      <link href="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/"/>
      <url>/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/</url>
      
        <content type="html"><![CDATA[<h1 id="17-Virtual-Memory-Concepts"><a href="#17-Virtual-Memory-Concepts" class="headerlink" title="17-Virtual-Memory-Concepts"></a>17-Virtual-Memory-Concepts</h1><h2 id="Physical-and-Virtual-Addressing"><a href="#Physical-and-Virtual-Addressing" class="headerlink" title="Physical and Virtual Addressing"></a>Physical and Virtual Addressing</h2><ul><li><p><strong>Main memory</strong>: an array of M contiguous(<em>连续的</em>) byte-size cells(<em>单元</em>). Each byte has a unique physical address (PA) <code>&#123;0, 1, 2, 3 … &#125;</code></p></li><li><p>The most natural way for a <strong>CPU to access memory</strong> would be to use physical addresses. We call this approach <strong>physical addressing</strong>.</p></li><li><p>When the CPU executes the load instruction, it <strong>generates an effective physical address</strong> and <strong>passes it to main memory</strong> over the memory bus. The <strong>main memory fetches the 4-byte word</strong> starting at physical address 4 and <strong>returns it to the CPU</strong>, which <strong>stores it in a register</strong>.<br><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_3.JPG" alt="png"></p></li><li><p>Modern processors use a form of addressing known as virtual addressing</p></li><li><p>The CPU accesses main memory by generating a <strong>virtual address</strong> (VA), which is <strong>converted to the appropriate physical address before being sent to main memory</strong>.<br><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_4.JPG" alt="png"></p></li></ul><h2 id="Address-Spaces"><a href="#Address-Spaces" class="headerlink" title="Address Spaces"></a>Address Spaces</h2><ul><li>An <strong>address space</strong> is an ordered set of nonnegative integer addresses.(<em>一个非负整数的有序集合</em>)</li><li><strong>Linear address space</strong>: Ordered set of contiguous non-negative integer<br>addresses <code>&#123;0, 1, 2, 3 … &#125;</code>。为了简化讨论，后面均采用线性地址空间。</li><li><strong>Virtual address space</strong>: Set of N = 2^n virtual addresses <code>&#123;0, 1, 2, 3, …, N-1&#125;</code></li><li><strong>Physical address space</strong>: Set of M = 2^m physical addresses <code>&#123;0, 1, 2, 3, …, M-1&#125;</code><br>（N通常大于M）</li><li>地址空间明确区分了数据对象data objects (bytes)和它们的attributes (addresses)。</li><li>Basic idea of virtual memory: allow <strong>each data object</strong> to have <strong>multiple independent addresses</strong>, each chosen from a <strong>different address space</strong>.</li><li>Each byte of main memory has a virtual address chosen from the virtual address space, and a physical address chosen from the physical address space.</li></ul><h2 id="Why-Virtual-Memory"><a href="#Why-Virtual-Memory" class="headerlink" title="Why Virtual Memory"></a>Why Virtual Memory</h2><ul><li>It <strong>uses main memory efficiently</strong> by<ul><li>treating it as <strong>a cache</strong> for an address space stored on disk</li><li>keeping only the active areas in main memory</li><li>transferring data back and forth between disk and memory as needed.</li></ul></li><li>It <strong>simplifies memory management</strong> by providing each process with a uniform address space.</li><li>Isolates address spaces<ul><li>One process can’t interfere(<em>干涉</em>) with another’s memory</li><li>User program cannot access privileged kernel information and code</li></ul></li></ul><p>虚拟地址为应用程序提供的功能：</p><ul><li>create and destroy chunks of memory</li><li>map chunks of memory to portions of disk files<ul><li>read or modify the contents of a disk file by reading and writing memory locations</li><li>load the contents of a file into memory without doing any explicit copying</li></ul></li><li>share memory with other processes</li></ul><h2 id="VM-as-a-Tool-for-Caching"><a href="#VM-as-a-Tool-for-Caching" class="headerlink" title="VM as a Tool for Caching"></a>VM as a Tool for Caching</h2><ul><li><strong>Virtual memory</strong> is an array of N contiguous(<em>连续的</em>) bytes stored on <strong>disk</strong>. Each byte has a unique virtual address that serves as an index into the array. The contents of the array on disk are cached in <strong>physical memory (DRAM cache)</strong></li><li>The data on disk is partitioned into <strong>blocks</strong> that serve as the transfer units between the disk and the main memory.</li><li>VM systems handle this by partitioning the virtual memory into <strong>fixed-size blocks</strong> called <strong>virtual pages</strong>. Similarly, physical memory is partitioned into <strong>physical pages</strong>.</li><li>virtual page有三种<ul><li><strong>Unallocated</strong>: have not yet been allocated (or created) by the VM system, do not occupy(<em>占用</em>) any space on disk.</li><li><strong>Cached</strong>. Allocated pages that are currently cached in physical memory.</li><li><strong>Uncached</strong>. Allocated pages that are not cached in physical memory.</li></ul></li></ul><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_8.JPG" alt="png"></p><p>在DRAM的某处缓存了三个virtual page，一些page没有被缓存依旧存储在磁盘上(比如vp2)，有些page甚至没有分配，所以在磁盘上不存在。</p><h3 id="DRAM-Cache-Organization"><a href="#DRAM-Cache-Organization" class="headerlink" title="DRAM Cache Organization"></a>DRAM Cache Organization</h3><ul><li><p>若未命中DRAM cache，从磁盘中获取数据的代价是非常大的。</p><ul><li>DRAM is about <strong>10x</strong> slower than SRAM.</li><li>Disk is about <strong>10,000x</strong> slower than DRAM.</li></ul></li></ul><p>造成的影响：</p><ul><li>Large page (block) size: typically 4 KB, sometimes 4 MB</li><li>Fully associative<ul><li>Any VP can be placed in any PP.</li><li>Requires a “large” mapping function – different from cache memories.</li></ul></li><li>更复杂的替换算法（替换page），无法在硬件中实现，而替换算法相对简单的cache memory则利用了硬件并行查找。替换失误造成未命中的成本远远大于复杂算法执行的成本。</li><li>Write-back rather than write-through</li></ul><h3 id="Page-table"><a href="#Page-table" class="headerlink" title="Page table"></a>Page table</h3><p>A page table(<em>页表</em>) is an array of page table entries (PTEs) that maps virtual pages to physical pages.</p><p>内核会将它作为每一个进程上下文的一部分进行维护，所以每个进程都有自己的页表。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_10.JPG" alt="png"></p><p>valid: 1代表当前vp在DRAM中，0且地址不为空代表在磁盘上，0且地址为null代表unallocated page。</p><h3 id="Page-hit"><a href="#Page-hit" class="headerlink" title="Page hit"></a>Page hit</h3><p>CPU执行move指令、call指令、ret指令、或者任何类型的控制转移指令，会生成一个虚拟地址。MMU(Memory Management Unit)会在页表中查找。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_11.JPG" alt="png"></p><h3 id="Handling-Page-Fault"><a href="#Handling-Page-Fault" class="headerlink" title="Handling Page Fault"></a>Handling Page Fault</h3><ul><li><strong>Page fault</strong>: reference to VM word that is not in physical memory (DRAM cache miss)</li></ul><ol><li>Page miss causes page fault (an exception)。硬件触发异常。</li><li>导致控制权转移到内核中的page fault handler的代码块</li><li>从Physical memory选择出一个page需要被替换，比如pp4。如果vp4被修改过，内核还需要将数据写回到磁盘。</li><li>内核从磁盘上获取vp3加载到内存中，并更新Physical memory和页表</li><li>当内核中的Page fault handler返回时，它返回到导致错误的指令位置，然后重新执行该指令，page hit。</li></ol><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_14.JPG" alt="png"></p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_16.JPG" alt="png"></p><ul><li>The activity of transferring a page between disk and memory is- known as <strong>swapping</strong> or <strong>paging</strong>.</li><li>All modern systems use <strong>demand paging</strong>.</li></ul><h3 id="Allocating-Pages"><a href="#Allocating-Pages" class="headerlink" title="Allocating Pages"></a>Allocating Pages</h3><p>page table中的PTE5还没有分配，如果需要分配则要调用malloc函数：先在磁盘上分配这个page(vp5)，PT5指向vp5。并不会一开始就存放在DRMA缓存中，直到被使用到为止。所谓的分配只是修改PTE而已。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_17.JPG" alt="png"></p><p>分配新page的时候大多是都会有一个选项，可以分配全为0的page，这样的page不需要存储在磁盘上，它会在内存中，就好像它是在磁盘上创建然后加载到内存中一样，磁盘上不存在这些全为零的pages。page可以映射到文件，code对应的page实际上映射到二进制文件中包含code的部分，当未命中page时候，会将这些code pages加载进来。</p><h3 id="Locality-to-the-Rescue-Again"><a href="#Locality-to-the-Rescue-Again" class="headerlink" title="Locality to the Rescue Again"></a>Locality to the Rescue Again</h3><p>虚拟内存因为要复制数据、分配内存、修改页表，甚至可能会出现大量的cache miss而导致swapping，看起来很低效，但是因为局部性原理并不会上面讲的那样低效。</p><p>在任何时间点，程序因为局部性倾向于在working set(set of active virtual pages)上工作，具有更好的时间局部性程序的working set会更小。一般来讲，开销比较大的情况只有初始化working set时候将在磁盘的page加载到内存的时候，后续使用working set将会是page hit。</p><p>只要程序具有良好的局部性，虚拟内存系统就可以很好地工作，但并不是所有的程序都这样，可能会出现thrashing(<em>抖动</em>)的情况：</p><ul><li>If (working set size &lt; main memory size): 当前所有的page都在主存</li><li>If (SUM(working set sizes) &gt; main memory size)。当所有进程的working set之和大于主存大小，就会导致Thrashing：页面不断的在内存和磁盘之间来回复制。</li></ul><h2 id="VM-as-a-Tool-for-Memory-Management"><a href="#VM-as-a-Tool-for-Memory-Management" class="headerlink" title="VM as a Tool for Memory Management"></a>VM as a Tool for Memory Management</h2><ul><li>Key idea: each process has its own virtual address space。<ul><li>It can view memory as a simple linear array.</li><li>内核通过为每个进程的上下文中提供属于自己的单独页表来实现。</li></ul></li><li>Simplifying memory allocation<ul><li>Each virtual page can be mapped to any physical page</li><li>每个进程的页表映射了该进程的虚拟地址空间，虚拟地址空间中的page可以映射到物理地址空间(DRAM)中的任何位置。不同的虚拟页(vp)和不同的进程可以映射到不同的物理页(pp)。</li><li>相同的虚拟页也可以在不同的时间存储在不同的物理页中。</li><li>每个进程都有一个非常相似的虚拟地址空间，相同大小的地址空间、code和data都从相同的位置开始，但是随后进程使用的page可以分散在内存中，以最有效的方式使用内存。</li><li>没有虚拟内存以前，是按物理内存分区的形式为进程分配内存，增加进程及其麻烦，无法知道物理空间位于内存中的哪个地方，需要重新定位等。</li></ul></li><li>Sharing code and data among processes<ul><li>Map virtual pages to the same physical page (here: PP 6)</li><li>这就是共享库的实现方式，比如共享lib.c，只需要在物理内存中加载一次即可。<br><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_21.JPG" alt="png"></li></ul></li></ul><h3 id="Simplifying-Linking-and-Loading"><a href="#Simplifying-Linking-and-Loading" class="headerlink" title="Simplifying Linking and Loading"></a>Simplifying Linking and Loading</h3><p>程序代码和数据一开始没有被加载到内存，只有出现未命中才会进行真正的加载，demand paging。</p><p>loading其实是一个非常有效率的机制，可能有一个包含大型数组的程序，但是只访问数组的一部分，延迟加载可以提高性能。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_22.JPG" alt="png"></p><h2 id="VM-as-a-Tool-for-Memory-Protection"><a href="#VM-as-a-Tool-for-Memory-Protection" class="headerlink" title="VM as a Tool for Memory Protection"></a>VM as a Tool for Memory Protection</h2><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_24.JPG" alt="png"></p><ul><li>sup: supervisor. Processes running in <strong>kernel mode</strong> can access <strong>any page</strong>, but processes running in <strong>user mode</strong> are only allowed to access <strong>pages for which SUP is 0</strong>.</li><li>READ and WRITE: control read and write access to the page (i.e., process i is running in user mode: <code>r: vp0/1, rw: vp1, not allowed: vp2</code>)</li><li>如果一条指令违背了这些权限，CPU将触发一个exception(通常是segmentation fault)，将控制权转向exception handler，该handler将发送SIGSEGV信号给该进程</li></ul><p>在x86-64系统上，指针和地址都是64位的，但是虚拟地址空间则是48位的，超过48位的bit要么全是0要么全是1，这是intel制定的规则，高位全为1的地址为内核保留（地址指向内核中的代码或者数据），高位全为0的地址为用户代码保留。</p><h2 id="VM-Address-Translation"><a href="#VM-Address-Translation" class="headerlink" title="VM Address Translation"></a>VM Address Translation</h2><h3 id="Address-Translation-With-a-Page-Table"><a href="#Address-Translation-With-a-Page-Table" class="headerlink" title="Address Translation With a Page Table"></a>Address Translation With a Page Table</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_28.JPG" alt="png"></p><p>在intel系统中，页表的起始地址(物理地址)保存在一个特殊的CPU寄存器页表基址寄存器(Page Table Base Register，PTBR)中，它被称为CR3(control register 3：控制寄存器3)</p><p>虚拟块中的offset与物理块中的offset相同</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_29.JPG" alt="png"></p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_30.JPG" alt="png"></p><h3 id="Speeding-up-Translation-with-a-TLB"><a href="#Speeding-up-Translation-with-a-TLB" class="headerlink" title="Speeding up Translation with a TLB"></a>Speeding up Translation with a TLB</h3><ul><li><p>Page table entries (PTEs) are cached in SRAM(L1/L2/L3) like any other memory word</p><ul><li>PTEs may be evicted(<em>驱逐</em>) by other data references</li><li>PTE hit still requires a small L1 delay</li></ul><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_31.JPG" alt="png"><br>(In any system that uses both virtual memory and SRAM caches, there is the issue of whether to use virtual or physical addresses to access the SRAM cache. Most systems opt for <strong>physical addressing</strong>.)</p></li><li><p>Solution: <strong>Translation Lookaside Buffer</strong> (TLB)</p><ul><li>Small set-associative hardware cache in MMU</li><li>Maps virtual page numbers to  physical page numbers</li><li>Contains <strong>complete page table entries</strong> for small number of pages</li></ul></li></ul><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_33.JPG" alt="png"></p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_34.JPG" alt="png"></p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_35.JPG" alt="png"></p><h3 id="Multi-Level-Page-Tables"><a href="#Multi-Level-Page-Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_36.JPG" alt="png"></p><p>一个页表需要的空间很大，见图，需要512GB，因为如果想用一个页表映射虚拟地址空间，需要为每个page的地址提供一个PTE，不管page有没有被使用过，因为不确定这些地址空间哪些需要被覆盖，比如48位地址空间，则需要512GB，但是很多都没有使用到，为此使用多级页表可以避免创建不必要的页表。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_37.JPG" alt="png"></p><p>上图已经为这个程序的代码和数据分配了2k个page，还有6个没有分配的page，底下有一个为栈分配的1024个page，但是大部分没有使用，只为栈顶分配了一个page。</p><p>2个level 2的页表覆盖了这分配的2k个page，1个level 2页表覆盖栈page(1023个null PTEs，因为大部分没有使用到)，1个level 1页表，共需要4个页表。</p><p>足够的level 2的页表就能覆盖实际使用的虚拟地址空间部分。没有用到的page就放到Gap区域，无需为它搞一个页表。</p><p>reduces memory requirements in two ways</p><ol><li>if a PTE in the level 1 table is null, then the corresponding level 2 page table does not even have to exist.</li><li>The level 2 page tables can be <strong>created and paged in and out</strong> by the VM system as they are needed, which reduces pressure on main memory. <strong>Only the most heavily used level 2 page tables need to be cached in main memory.</strong></li></ol><h3 id="Translating-with-a-k-level-Page-Table"><a href="#Translating-with-a-k-level-Page-Table" class="headerlink" title="Translating with a k-level Page Table"></a>Translating with a k-level Page Table</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/17-vm-concepts_38.JPG" alt="png"></p><p>MMU做的这些都是硬件逻辑，包括有多少级页表，由硬件架构定义。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU213 </tag>
            
            <tag> CSAPP </tag>
            
            <tag> virtual-memory </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMU213-CSAPP-Virtual-Memory-Systems</title>
      <link href="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/"/>
      <url>/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/</url>
      
        <content type="html"><![CDATA[<h1 id="18-Virtual-Memory-Systems"><a href="#18-Virtual-Memory-Systems" class="headerlink" title="18-Virtual-Memory-Systems"></a>18-Virtual-Memory-Systems</h1><h2 id="Simple-memory-system-example"><a href="#Simple-memory-system-example" class="headerlink" title="Simple memory system example"></a>Simple memory system example</h2><h3 id="Address-Translation-Example-1"><a href="#Address-Translation-Example-1" class="headerlink" title="Address Translation Example #1"></a>Address Translation Example #1</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/20220508122617.png" alt="png"></p><p>PPN实际不存在页表中</p><ol><li>MMU做的第一件事是检查TLB，将VA中的VPN的TLBI(0x3)和TLBT(0x03)提取出来。所以会去查set3找到tag为3的line，找到对应的line并且valid为1，TLB将PPN(0D)返回给MMU</li><li>MMU使用0D构建物理地址。将VA的VPO复制到PA的PPO，0D作为PA的PPN，由此构成了一个物理地址</li><li>将地址发送给cache，提取出CI(0x5)、CT(0x0D)，所以会去查set5找到tag为0xD的line，找到并且valid为1，因为CO为0，所以找到B0(36)</li><li>cache将该字节通过MMU返回给CPU，并将其存到一个寄存器中。</li></ol><h3 id="Address-Translation-Example-2"><a href="#Address-Translation-Example-2" class="headerlink" title="Address Translation Example #2"></a>Address Translation Example #2</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/20220508131850.png" alt="png"></p><ol><li>VA中的VPN的TLBI=TLBT=0，TLB的set=0&amp;tag=0的line的valid=0，TLB miss</li><li>通过VPN=0查找页表，valid=1有效，内存将PTE返回给MMU构造物理地址。</li><li>MMU用物理地址请求cache，CI=0x8,CT=0x28，set 8中不存在tag为28的line，cache miss</li><li>将物理地址传递给内存获取数据</li></ol><h2 id="Case-study-Core-i7-Linux-memory-system"><a href="#Case-study-Core-i7-Linux-memory-system" class="headerlink" title="Case study: Core i7/Linux memory system"></a>Case study: Core i7/Linux memory system</h2><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_12.JPG" alt="png"></p><p>单个芯片封装了4个核心，每个核都可以看作一个单独的cpu，可以各自独立的执行指令。</p><p>每个核心都有：</p><ul><li>寄存器、获取指令的硬件(instruction fetch)</li><li>两个L1 cache：d-cache保存从内存中获取的数据，i-cache保存从code region获取的指令，d-cache只有数据，i-cache只有指令。访问L1大概需要4个CPU周期。</li><li>L2 unified cache：既可以保存指令，又可以保存数据。访问L1大概需要10个CPU周期。</li></ul><h3 id="End-to-end-Core-i7-Address-Translation"><a href="#End-to-end-Core-i7-Address-Translation" class="headerlink" title="End-to-end Core i7 Address Translation"></a>End-to-end Core i7 Address Translation</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_14.JPG" alt="png"></p><h3 id="Core-i7-Level-1-4-Page-Table-Entries"><a href="#Core-i7-Level-1-4-Page-Table-Entries" class="headerlink" title="Core i7 Level 1-4 Page Table Entries"></a>Core i7 Level 1-4 Page Table Entries</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_15.JPG" alt="png"></p><p>这三级的PTE指向的是下一级的页表的地址</p><p>CD表示能不能缓存</p><p>XD为disable意味着无法从这个page上加载到任何指令</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_16.JPG" alt="png"></p><h3 id="Cute-Trick-for-Speeding-Up-L1-Access"><a href="#Cute-Trick-for-Speeding-Up-L1-Access" class="headerlink" title="Cute Trick for Speeding Up L1 Access"></a>Cute Trick for Speeding Up L1 Access</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_18.JPG" alt="png"></p><p>因为VPO和PPO都是一样的，所以CI也是一样的。当CPU需要转换虚拟地址时，它会将VPN发送到MMU，将VPO发送到L1 cache，MMU查询TLB的时候cache可以并行做set的查找，找到所有的line后并且MMU完成地址转换，此时就可以根据tag找到特定的line了。</p><h3 id="Virtual-Address-Space-of-a-Linux-Process"><a href="#Virtual-Address-Space-of-a-Linux-Process" class="headerlink" title="Virtual Address Space of a Linux Process"></a>Virtual Address Space of a Linux Process</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_19.JPG" alt="png"></p><ul><li>程序的代码(<code>program .text</code>)总是在相同的地址：0x400000上加载的。</li><li><code>.data</code>可执行二进制文件的的初始化数据，<code>.bss</code>二进制文件中定义的未初始化数据</li><li>Runtime heap逐渐向上增长，内核通过进程上下文中brk全局变量来跟踪该进程中堆顶(heap top)的位置</li><li>User stack：用户程序可访问内存，向下增长，底部由%rsp指向。</li><li>User stack与kernel code and data还有一段空间隔开，原因是intel架构虚拟地址只有48位，其他12位被内核利用。</li><li>每个进程都有相同的内核部分，内核代码也是一样的，内核为每个进程维护特定的数据结构，所有这些数据结构称为上下文。</li></ul><h3 id="Linux-Organizes-VM-as-Collection-of-“Areas”"><a href="#Linux-Organizes-VM-as-Collection-of-“Areas”" class="headerlink" title="Linux Organizes VM as Collection of “Areas”"></a>Linux Organizes VM as Collection of “Areas”</h3><ul><li><p>Linux organizes the virtual memory as a <strong>collection of areas</strong> (also called segments). An area is a <strong>contiguous chunk</strong> of existing (allocated) virtual memory whose pages are related in some way.</p></li><li><p>The code segment, data segment, heap, shared library segment, and user stack are all distinct areas.</p></li><li><p>It allows the virtual address space to have <strong>gaps</strong>. The kernel <strong>does not keep track of virtual pages that do not exist</strong>, and such pages do not consume any additional resources in memory, on disk, or in the kernel itself.</p></li></ul><p>the kernel data structures that keep track of the virtual memory areas in a process:</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_20.JPG" alt="png"></p><ul><li><p>内核为每个进程维护了一个数据结构task_struct，包含或者指向了内核运行该进程需要的所有信息(e.g., the PID, pointer to the user stack, name of the executable object file, and program counter)</p></li><li><p>task_struct包含了一个指向代表VM当前状态的mm struct的指针，mm_struct包含了指向L1 page table的地址，这是上下文的一部分，当这个进程被调度时，内核把pgd复制到CR3中（通过修改CR3进而修改虚拟地址空间地址）。一旦CR3的值发生了改变，该进程不再有权访问之前进程的页表。</p></li><li><p>area_struct通过vm_start标识该area的开始位置，通过vm_end标识该area结束的位置。</p></li><li><p>vm_prot: Describes the read/write permissions for all of the pages contained in the area.</p></li><li><p>vm_flags: whether the pages in the area are shared with other processes or private to this process.</p></li><li><p>vm_next: Points to the next area struct in the list(图这里描述是链表，实际上在操作系统中的实现可能是树).</p></li></ul><h3 id="Linux-Page-Fault-Handling"><a href="#Linux-Page-Fault-Handling" class="headerlink" title="Linux Page Fault Handling"></a>Linux Page Fault Handling</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_21.JPG" alt="png"></p><p>MMU尝试转换虚拟地址A的时候触发了一个page fault，随后将控制权转向kernel’s page fault handler，该handler会执行以下步骤：</p><ol><li>判断A是否位于某个area_struct定义的area区间内。handler会搜索所有的area struct，将A与vm_start和vm_end比较。如果不合法，则handler触发segmentation fault，进而终止进程。</li><li>判断A是否有权读取或者写入该area中的page。比如写入一个只读的page，或者是运行在用户态的进程访问只能由内核访问的page。如果不合法，则handler触发protection exception，进而终止进程。</li><li>否则是normal page fault，即page不在DRAM，执行paging流程。</li></ol><h2 id="Memory-Mapping"><a href="#Memory-Mapping" class="headerlink" title="Memory Mapping"></a>Memory Mapping</h2><p>Linux <strong>initializes the contents of a virtual memory area</strong> by associating it with <strong>an object on disk</strong>, a process known as <strong>memory mapping</strong>.</p><p> Areas can be mapped to one of two types of objects:</p><ul><li><strong>Regular file on disk</strong> (e.g., an executable object file)<ul><li>An area can be mapped to a <strong>contiguous section</strong> of a regular disk file.</li><li>The file section is divided into <strong>page-size pieces</strong>, with each piece containing the initial contents of a virtual page.</li><li>Demand paging</li><li>If the area is larger than the file section, then the area is <strong>padded with zeros</strong>.</li></ul></li><li><strong>Anonymous file</strong> (e.g., nothing, there isn’t a file specified)<ul><li>The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, <strong>overwrites the victim page with binary zeros</strong>, and updates the page table to mark the page as resident.</li><li>Once the page is written to (dirtied), it is like any other page</li><li>No data are actually transferred between disk and memory.</li><li>Pages in areas that are mapped to anonymous files are sometimes called <strong>demand-zero pages</strong>.</li></ul></li></ul><p>In either case, once a virtual page is initialized, it is swapped back and forth(<em>来回</em>) between a special <strong>swap file</strong> maintained by the kernel.</p><h3 id="Shared-Objects"><a href="#Shared-Objects" class="headerlink" title="Shared Objects"></a>Shared Objects</h3><ul><li><p>Many programs need to access identical copies of readonly run-time library code. For example, every C program requires functions from the standard C library such as printf.</p></li><li><p>Memory mapping provides us with a clean mechanism for controlling how objects are shared by multiple processes.</p></li><li><p>An object can be mapped into an area of virtual memory as either a <strong>shared object</strong> or a <strong>private object</strong>.</p></li><li><p>Since each object has a unique filename, the kernel can quickly determine that process has already mapped the object.</p></li></ul><p>如果一个进程对共享对象(shared object)对应的虚拟地址空间进行了写操作，那么这个写操作也会同步到磁盘上的文件，并且所有映射了该对象的进程都可见该修改。</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/1.png" alt="png"></p><p>The key point is that only a single copy of the shared object needs to be stored in physical memory, even though the object is mapped into multiple shared areas.</p><h3 id="Private-Copy-on-write-COW-Objects"><a href="#Private-Copy-on-write-COW-Objects" class="headerlink" title="Private Copy-on-write (COW) Objects"></a>Private Copy-on-write (COW) Objects</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/2.png" alt="png"></p><ul><li><p>Two processes have mapped a private object into different areas of their virtual memories but share the same physical copy of the object.</p></li><li><p>Area flagged as private copy-on-<br>write.PTEs in private areas are flagged as read-only.</p></li><li><p>So long as neither(<em>只要两者都不</em>) process attempts to write to its respective(<em>各自的</em>) private area, they continue to share a single copy of the object in physical memory. </p></li><li><p>As soon as a process attempts to write to some page in the private area, the write triggers a <strong>protection fault</strong>.</p></li><li><p>Handler creates a new copy of the page in physical memory, updates the page table entry to point to the new copy, and then restores write permissions to the page. 返回时CPU重新执行写操作，将会在新的page上写。</p></li><li><p>Copying deferred as long a possible. 更有效利用内存。</p></li></ul><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork时候会提供一个几乎一样但是独立的虚拟地址空间，如果将所有页表都复制一遍效率很低，COW就提供了一个高效的方法。</p><ul><li><p>VM and memory mapping explain how fork provides private<br>address space for each process.</p></li><li><p>To create virtual address for new new process：</p><ul><li>Create exact copies of current mm_struct, vm_area_struct, and page tables.内核只拷贝所有的内核数据结构，无法避免，但是不大。</li><li>Flag each page in both processes as read-only.</li><li>Flag each vm_area_struct in both processes as private COW.</li></ul></li><li><p>On return, each process has exact copy of virtual memory</p></li><li><p>Subsequent(<em>后续</em>) writes create new pages using COW mechanism.</p></li></ul><p>本质是让copy延迟了，只有在写时候才复制。</p><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>Suppose that the program running in the current process makes the following call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;a.out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>The execve function <strong>loads and runs</strong> the program contained in the executable object file a.out within the current process, effectively replacing the current program with the a.out program.</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_29.JPG" alt="png"></p><ul><li><strong>Delete the existing area</strong> structs in the <strong>user portion</strong> of the current process’s virtual address: vm_area_struct’s and page tables</li><li><strong>Create vm_area_struct’s and page tables for new areas</strong><ul><li><strong>Map private areas</strong>: Create new area(private copy-on-write) structs<ul><li>code, data area: mapped to the .text and .data sections of the a.out file.</li><li>bss area: demand-zero, mapped to an anonymous file whose size is contained in a.out.</li><li>stack, heap area: demand-zero, initially of zero length.</li></ul></li><li><strong>Map shared areas</strong>: If the a.out program was linked with shared objects, such as the standard C library libc.so , then these objects are dynamically linked into the program, and then mapped into the shared region of the user’s virtual address space.</li></ul></li><li><strong>set the program counter</strong> in the current process’s context to point to the entry point in the code area.</li></ul><p>The next time this process is scheduled, it will begin execution from the entry point. Linux will <strong>swap in code and data pages as needed</strong>.</p><p>只是在内核中创建了数据结构和内存映射，还没有任何内容拷贝到内存。</p><h3 id="User-Level-Memory-Mapping"><a href="#User-Level-Memory-Mapping" class="headerlink" title="User-Level Memory Mapping"></a>User-Level Memory Mapping</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">int</span> offset)</span></span><br></pre></td></tr></table></figure><ul><li><p>Linux processes can use the mmap function to <strong>create new areas of virtual memory and to map objects into these areas</strong>.只是内存映射，没有copy，只是将虚拟地址空间中空闲的部分映射到文件</p></li><li><p>start：mmap函数尝试将从start处开始，创建长度为length 字节的区域，并映射到由fd确定的某个文件的offset位置。The start address is merely(<em>仅仅</em>) a hint, and is usually specified as NULL.</p></li><li><p>prot: 对应area_struct中的vm_prot, the access permissions of the newly mapped virtual memory area: PROT_READ, PROT_WRITE…</p></li><li><p>flags: the type of the mapped object: MAP_ANON(anonymous object, corresponding virtual pages are demand-zero), MAP_PRIVATE(private copy-on-write object), MAP_SHARED(shared object)</p></li><li><p>Return a pointer to start of mapped area (may not be start)</p></li></ul><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_31.JPG" alt="png"></p><p>Asks the kernel to create a new read-only, private, demand-zero area of virtual memory containing size bytes. If the call is successful, then bufp contains the address of the new area:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bufp = mmap(<span class="literal">NULL</span>, size, PROT_READ, </span><br><span class="line">            MAP_PRIVATEIMAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>The <strong>munmap</strong> function deletes the area starting at virtual address start and consisting of the next length bytes. Subsequent references to the deleted region result in segmentation faults.</p><h4 id="Example-Using-mmap-to-Copy-Files"><a href="#Example-Using-mmap-to-Copy-Files" class="headerlink" title="Example: Using mmap to Copy Files"></a>Example: Using mmap to Copy Files</h4><p>拷贝文件到标准输出，没有把数据拷贝到用户地址空间。标准做法是读取文件，然后写到标准输出中去，需要用两个系统调用，read和write。但只使用一个系统调用mmap就可以做到这点。</p><p>从命令行得到一个文件名，然后打开这个文件，获取到文件的大小。调用mmap，传递fd、大小、长度，设置flag为私有。然后调用write，把buffer指向的内容拷贝到标准输出，设置拷贝的大小。write 函数会从bufp中一个字节一个字节地读取，执行的时候会出现异常，异常处理完成后，write把bufp写入到fd对应的文件，也就是stdout</p><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_32.JPG" alt="png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMU213 </tag>
            
            <tag> CSAPP </tag>
            
            <tag> virtual-memory </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>玩客云部署beancount-telegram-bot</title>
      <link href="/2022/05/07/%E7%8E%A9%E5%AE%A2%E4%BA%91%E9%83%A8%E7%BD%B2beancount-telegram-bot/"/>
      <url>/2022/05/07/%E7%8E%A9%E5%AE%A2%E4%BA%91%E9%83%A8%E7%BD%B2beancount-telegram-bot/</url>
      
        <content type="html"><![CDATA[<h1 id="玩客云"><a href="#玩客云" class="headerlink" title="玩客云"></a>玩客云</h1><p>捡垃圾，40块钱还行，民间大佬弄出了刷Linux的方法，可惜是32位，不过也凑合用，比斐讯N1折腾了那么一点。</p><p><img src="/2022/05/07/%E7%8E%A9%E5%AE%A2%E4%BA%91%E9%83%A8%E7%BD%B2beancount-telegram-bot/2022-05-07_211739.png" alt="png"></p><h2 id="beancount"><a href="#beancount" class="headerlink" title="beancount"></a>beancount</h2><p>beancount介绍可以看下面几个文章，整挺好。之前是用ios端的Moze3，感觉还是差了点意思。</p><p><a href="https://byvoid.com/zhs/blog/beancount-bookkeeping-1/">Beancount复式记账（一）：为什么</a></p><p><a href="https://blog.kaaass.net/archives/1700">复式记账指北（三）：如何打造不半途而废的记账方案</a></p><p><a href="https://www.bmpi.dev/self/beancount-my-accounting-tool-v2/">使用 Beancount 管理家庭财务 · 构建我的被动收入</a></p><p><a href="https://medium.com/leplay/%E4%BD%BF%E7%94%A8-costflow-%E6%8F%90%E9%AB%98-beancount-%E8%AE%B0%E8%B4%A6%E6%95%88%E7%8E%87-bdae22d1f6c4">使用 Costflow 提高 Beancount 记账效率</a></p><h2 id="bot-docker"><a href="#bot-docker" class="headerlink" title="bot-docker"></a>bot-docker</h2><p>这里推荐使用kaaass/beancount_bot_costflow_docker，参考上面第二篇文章，里面有详细说明。不过上面的镜像只支持64位，只能自己弄32位的docker镜像。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>从beancount_bot_costflow_docker的Dockerfile修改而来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.6</span><br><span class="line"></span><br><span class="line">WORKDIR /app</span><br><span class="line">ADD requirements.txt /app</span><br><span class="line"></span><br><span class="line">ENV PYTHONUNBUFFERED=1</span><br><span class="line">RUN apk add --update --no-cache python3 python3-dev &amp;&amp; ln -sf python3 /usr/bin/python</span><br><span class="line">RUN python3 -m ensurepip</span><br><span class="line">RUN pip3 install --no-cache --upgrade pip setuptools</span><br><span class="line"></span><br><span class="line">RUN apk add --update --no-cache --virtual .build-deps gcc libc-dev libxml2-dev libxml2 libxslt-dev py3-lxml &amp;&amp; \</span><br><span class="line">    pip install --no-cache-dir -r requirements.txt &amp;&amp; \</span><br><span class="line">        apk del .build-deps</span><br><span class="line"></span><br><span class="line">RUN apk add --no-cache libgcc libstdc++ curl</span><br><span class="line">RUN curl -fLO https://github.com/oznu/alpine-node/releases/download/14.18.1/node-v14.18.1-linux-arm-alpine.tar.gz</span><br><span class="line">RUN tar -xzf node-v14.18.1-linux-arm-alpine.tar.gz -C /usr --strip-components=1 --no-same-owner</span><br><span class="line">RUN rm -rf node-v14.18.1-linux-arm-alpine.tar.gz</span><br><span class="line"></span><br><span class="line">RUN node --version</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;/config&quot;, &quot;/bean&quot;]</span><br><span class="line"></span><br><span class="line">ENV BEANCOUNT_BOT_CONFIG /config/beancount_bot.yml</span><br><span class="line">ENV PYTHONPATH /config</span><br><span class="line"></span><br><span class="line">ADD docker-entrypoint.sh /app</span><br><span class="line">CMD [&quot;/app/docker-entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure><p>这里用alpine:3.6的原因是3.6以上版本有联网问题，不知道是不是32位系统的问题。不过用了3.6版本需要自己安装Python3和nodejs，也算是小麻烦了点。</p><h3 id="build"><a href="#build" class="headerlink" title="build"></a>build</h3><p>因为玩客云的CPU架构是armv7，所以docker build的时候需要指定一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --platform=linux/arm/v7 -t bctg .</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --restart=always --network=host -v $PWD/bean:/bean -v $PWD/config:/config --name bctg -v /etc/localtime:/etc/localtime:ro bctg</span><br></pre></td></tr></table></figure><p>这里映射了localtime文件，主要是让docker的时间和host的时间一样，因为脚本记录的时候需要获取当前时间。</p><p>使用host network模式主要是为了设置proxy</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="beancount-bot-yml"><a href="#beancount-bot-yml" class="headerlink" title="beancount_bot.yml"></a>beancount_bot.yml</h3><p>这里配置主要是删除掉了一些自己目前用不上的功能。因为主要用costflow语法，所以把template的功能也关闭了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="comment"># 日志等级</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">&#x27;INFO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bot:</span></span><br><span class="line">  <span class="comment"># 代理</span></span><br><span class="line">  <span class="attr">proxy:</span> <span class="string">&#x27;127.0.0.1:8118&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Telegram 机器人 Token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 鉴权用令牌。第一次进入机器人时用于校验身份</span></span><br><span class="line">  <span class="attr">auth_token:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 机器人会话文件路径</span></span><br><span class="line">  <span class="attr">session_file:</span> <span class="string">&#x27;/config/bot.session&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">transaction:</span></span><br><span class="line">  <span class="comment"># 账本文件。可以使用：&#123;year&#125;、&#123;month&#125;、&#123;date&#125;</span></span><br><span class="line">  <span class="attr">beancount_file:</span> <span class="string">&#x27;/bean/&#123;year&#125;/&#123;month&#125;.bean&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 消息处理器</span></span><br><span class="line">  <span class="attr">message_dispatcher:</span></span><br><span class="line">    <span class="comment"># 模板</span></span><br><span class="line">    <span class="comment"># - class: &#x27;beancount_bot.builtin.TemplateDispatcher&#x27;</span></span><br><span class="line">    <span class="comment">#   args:</span></span><br><span class="line">    <span class="comment">#     template_config: &#x27;/config/template.yml&#x27;</span></span><br><span class="line">    <span class="comment"># Costflow</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">class:</span> <span class="string">&#x27;beancount_bot_costflow.CostflowDispatcher&#x27;</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">costflow_config:</span> <span class="string">&#x27;/config/costflow.json&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># schedule:</span></span><br><span class="line">  <span class="comment"># 定时任务定义</span></span><br><span class="line">  <span class="comment"># name：定时任务名，可以用 /task name 主动触发</span></span><br><span class="line">  <span class="comment"># class：定时任务类</span></span><br><span class="line">  <span class="comment"># args：创建任务需要的参数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 定时任务示例：定时更新价格</span></span><br><span class="line">  <span class="comment"># 使用内建任务类：beancount_bot.builtin.DailyCommandTask</span></span><br><span class="line">  <span class="comment"># 该类在每日 time 时执行指令，之后广播 message 消息</span></span><br><span class="line">  <span class="comment"># - name: price</span></span><br><span class="line">  <span class="comment">#   class: &#x27;beancount_bot.builtin.DailyCommandTask&#x27;</span></span><br><span class="line">  <span class="comment">#   args:</span></span><br><span class="line">  <span class="comment">#     time: &#x27;21:30&#x27;</span></span><br><span class="line">  <span class="comment">#     message: &#x27;当日价格更新完成&#x27;</span></span><br><span class="line">  <span class="comment">#     commands:</span></span><br><span class="line">  <span class="comment">#       - &#x27;bean-price /bean/main.bean &gt;&gt; /bean/automatic/prices.bean&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="costflow-json"><a href="#costflow-json" class="headerlink" title="costflow.json"></a>costflow.json</h3><p>这个就相对简单一点，因为我觉得设置account的缩写比较难看，所以这里就没用到account的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mode&quot;: &quot;beancount&quot;,</span><br><span class="line">    &quot;currency&quot;: &quot;CNY&quot;,</span><br><span class="line">    &quot;tag&quot;: &quot;#costflow&quot;,</span><br><span class="line">    &quot;defaultAccount&quot;:  &quot;Liabilities:CreditCard:招行信用卡&quot;,</span><br><span class="line">    &quot;alphavantage&quot;: null,</span><br><span class="line">    &quot;indent&quot;: 2,</span><br><span class="line">    &quot;lineLength&quot;: 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2022/05/07/%E7%8E%A9%E5%AE%A2%E4%BA%91%E9%83%A8%E7%BD%B2beancount-telegram-bot/2022-05-07_215121.png" alt="png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-05-07 * &quot;地铁&quot; #costflow</span><br><span class="line">  tgbot_time: &quot;2022-05-07 19:53:17.985351&quot;</span><br><span class="line">  tgbot_uuid: &quot;230a4246-b864-495d-8510-ed6f8da75cf1&quot;</span><br><span class="line">  Liabilities:CreditCard:招行信用卡                       -0.02 CNY</span><br><span class="line">  Expenses:Transport:公交地铁</span><br></pre></td></tr></table></figure><p>这里的tgbot_time暂时没有除修改代码外的方法去除，不过也不碍事，留个记录怕到时候tg的消息找不到。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 玩客云 </tag>
            
            <tag> Docker </tag>
            
            <tag> beancount </tag>
            
            <tag> tgbot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-GC笔记-GC-Traces</title>
      <link href="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/"/>
      <url>/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html">https://www.ardanlabs.com/blog/2019/05/garbage-collection-in-go-part2-gctraces.html</a></p><h1 id="开关GC的对比"><a href="#开关GC的对比" class="headerlink" title="开关GC的对比"></a>开关GC的对比</h1><p>有一个从不同的新闻提供商下载RSS并搜索的应用程序</p><p>在关闭GC的情况下测试并发请求应用程序耗时情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build</span><br><span class="line">$ GOGC=off ./project &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 10k requests using 100 connections</span></span><br><span class="line">hey -m POST -c 100 -n 10000 <span class="string">&quot;http://localhost:5000/search?term=topic&amp;cnn=on&amp;bbc=on&amp;nyt=on&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/Untitled.png" alt="Untitled"></p><p>处理10k个请求需要4188ms，每秒处理约2387个请求</p><p>在开启GC的情况下呢，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG=gctrace=<span class="number">1</span> ./project &gt; /dev/null</span><br><span class="line">gc <span class="number">3</span> @<span class="number">3.182</span>s <span class="number">0</span>%: <span class="number">0.015</span>+<span class="number">0.59</span>+<span class="number">0.096</span> ms clock, <span class="number">0.19</span>+<span class="number">0.10</span>/<span class="number">1.3</span>/<span class="number">3.0</span>+<span class="number">1.1</span> ms cpu, <span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span> MB, <span class="number">5</span> MB goal, <span class="number">12</span> P</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">gc <span class="number">2553</span> @<span class="number">8.452</span>s <span class="number">14</span>%: <span class="number">0.004</span>+<span class="number">0.33</span>+<span class="number">0.051</span> ms clock, <span class="number">0.056</span>+<span class="number">0.12</span>/<span class="number">0.56</span>/<span class="number">0.94</span>+<span class="number">0.61</span> ms cpu, <span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span> MB, <span class="number">5</span> MB goal, <span class="number">12</span> P</span><br></pre></td></tr></table></figure><p>共需要2551次gc（省略前两次还没有开始正式测试的gc数据）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gc <span class="number">2553</span> @<span class="number">8.452</span>s <span class="number">14</span>%: <span class="number">0.004</span>+<span class="number">0.33</span>+<span class="number">0.051</span> ms clock, <span class="number">0.056</span>+<span class="number">0.12</span>/<span class="number">0.56</span>/<span class="number">0.94</span>+<span class="number">0.61</span> ms cpu, <span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span> MB, <span class="number">5</span> MB goal, <span class="number">12</span> P</span><br><span class="line"></span><br><span class="line">gc <span class="number">2553</span>     : The <span class="number">2553</span> GC runs since the program started</span><br><span class="line">@<span class="number">8.452</span>s     : Eight seconds since the program started</span><br><span class="line"><span class="number">14</span>%         : Fourteen percent of the available CPU so far has been spent in GC</span><br><span class="line"></span><br><span class="line"><span class="comment">// wall-clock</span></span><br><span class="line"><span class="number">0.004</span>ms     : STW        : Write-Barrier - Wait <span class="keyword">for</span> all Ps to reach a GC safe-point.</span><br><span class="line"><span class="number">0.33</span>ms      : Concurrent : Marking</span><br><span class="line"><span class="number">0.051</span>ms     : STW        : Mark Term     - Write Barrier off and clean up.</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU time</span></span><br><span class="line"><span class="number">0.056</span>ms     : STW        : Write-Barrier</span><br><span class="line"><span class="number">0.12</span>ms      : Concurrent : Mark - Assist Time (GC performed in line with allocation)</span><br><span class="line"><span class="number">0.56</span>ms      : Concurrent : Mark - Background GC time</span><br><span class="line"><span class="number">0.94</span>ms      : Concurrent : Mark - Idle GC time</span><br><span class="line"><span class="number">0.61</span>ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>MB         : Heap memory in-use before the Marking started</span><br><span class="line"><span class="number">4</span>MB         : Heap memory in-use after the Marking finished</span><br><span class="line"><span class="number">2</span>MB         : Heap memory marked as live after the Marking finished</span><br><span class="line"><span class="number">5</span>MB         : Collection goal <span class="keyword">for</span> heap memory in-use after Marking finished</span><br><span class="line"></span><br><span class="line"><span class="comment">// Threads</span></span><br><span class="line"><span class="number">12</span>P         : Number of logical processors or threads used to run Goroutines.</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Requests            : <span class="number">10</span>,<span class="number">000</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">Requests/sec        : <span class="number">1</span>,<span class="number">882</span> r/s   - Hey</span><br><span class="line">Total Duration      : <span class="number">5</span>,<span class="number">311</span>ms     - Hey</span><br><span class="line">Percent Time in GC  : <span class="number">14</span>%         - GC Trace</span><br><span class="line">Total Collections   : <span class="number">2</span>,<span class="number">551</span>       - GC Trace</span><br><span class="line">------------------------------------------------------</span><br><span class="line">Total GC Duration   : <span class="number">744.54</span>ms    - (<span class="number">5</span>,<span class="number">311</span>ms * <span class="number">.14</span>)</span><br><span class="line">Average Pace of GC  : ~<span class="number">2.08</span>ms     - (<span class="number">5</span>,<span class="number">311</span>ms / <span class="number">2</span>,<span class="number">551</span>)</span><br><span class="line">Requests/Collection : ~<span class="number">3.98</span> r/gc  - (<span class="number">10</span>,<span class="number">000</span> / <span class="number">2</span>,<span class="number">511</span>)</span><br></pre></td></tr></table></figure><p><img src="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/Untitled%201.png" alt="Untitled"></p><p><img src="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/Untitled%202.png" alt="Untitled"></p><p>开启GC后耗费的时间增加了1.1s的延迟</p><h1 id="减少分配"><a href="#减少分配" class="headerlink" title="减少分配"></a>减少分配</h1><p>首先使用go的pprof工具查看内存使用情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;localhost:5000&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">$ <span class="keyword">go</span> tool pprof http:<span class="comment">//localhost:5000/debug/pprof/allocs</span></span><br></pre></td></tr></table></figure><p>使用top命令查看前6个分配内存最多的函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top <span class="number">6</span> -cum</span><br><span class="line">Showing nodes accounting <span class="keyword">for</span> <span class="number">0.56</span>GB, <span class="number">5.84</span>% of <span class="number">9.56</span>GB total</span><br><span class="line">Dropped <span class="number">80</span> nodes (cum &lt;= <span class="number">0.05</span>GB)</span><br><span class="line">Showing top <span class="number">6</span> nodes out of <span class="number">51</span></span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%     <span class="number">0</span>%     <span class="number">4.96</span>GB <span class="number">51.90</span>%  net/http.(*conn).serve</span><br><span class="line">    <span class="number">0.49</span>GB  <span class="number">5.11</span>%  <span class="number">5.11</span>%     <span class="number">4.93</span>GB <span class="number">51.55</span>%  project/service.handler</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%  <span class="number">5.11</span>%     <span class="number">4.93</span>GB <span class="number">51.55</span>%  net/http.(*ServeMux).ServeHTTP</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%  <span class="number">5.11</span>%     <span class="number">4.93</span>GB <span class="number">51.55</span>%  net/http.HandlerFunc.ServeHTTP</span><br><span class="line">         <span class="number">0</span>     <span class="number">0</span>%  <span class="number">5.11</span>%     <span class="number">4.93</span>GB <span class="number">51.55</span>%  net/http.serverHandler.ServeHTTP</span><br><span class="line">    <span class="number">0.07</span>GB  <span class="number">0.73</span>%  <span class="number">5.84</span>%     <span class="number">4.55</span>GB <span class="number">47.63</span>%  project/search.rssSearch</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(pprof) list rssSearch</span><br><span class="line">Total: <span class="number">9.56</span>GB</span><br><span class="line">ROUTINE ======================== project/search.rssSearch in project/search/rss.<span class="keyword">go</span></span><br><span class="line">   <span class="number">71.53</span>MB     <span class="number">4.55</span>GB (flat, cum) <span class="number">47.63</span>% of Total</span><br><span class="line"></span><br><span class="line">         .          .    <span class="number">117</span>:<span class="comment">// Capture the data we need for our results if we find ...</span></span><br><span class="line">         .          .    <span class="number">118</span>:<span class="keyword">for</span> _, item := <span class="keyword">range</span> d.Channel.Items &#123;</span><br><span class="line">         .     <span class="number">4.48</span>GB    <span class="number">119</span>:<span class="keyword">if</span> strings.Contains(strings.ToLower(item.Description), strings.ToLower(term)) &#123;</span><br><span class="line">   <span class="number">48.53</span>MB    <span class="number">48.53</span>MB    <span class="number">120</span>:results = <span class="built_in">append</span>(results, Result&#123;</span><br><span class="line">         .          .    <span class="number">121</span>:Engine:  engine,</span><br><span class="line">         .          .    <span class="number">122</span>:Title:   item.Title,</span><br><span class="line">         .          .    <span class="number">123</span>:Link:    item.Link,</span><br><span class="line">         .          .    <span class="number">124</span>:Content: item.Description,</span><br><span class="line">         .          .    <span class="number">125</span>:&#125;)</span><br></pre></td></tr></table></figure><p>strings.ToLower会在堆上面创建新的字符串，循环调用是不需要的，可以放在循环外</p><p>改正之后重新测试一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build</span><br><span class="line">$ GODEBUG=gctrace=<span class="number">1</span> ./project &gt; /dev/null</span><br><span class="line">gc <span class="number">3</span> @<span class="number">6.156</span>s <span class="number">0</span>%: <span class="number">0.011</span>+<span class="number">0.72</span>+<span class="number">0.068</span> ms clock, <span class="number">0.13</span>+<span class="number">0.21</span>/<span class="number">1.5</span>/<span class="number">3.2</span>+<span class="number">0.82</span> ms cpu, <span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">2</span> MB, <span class="number">5</span> MB goal, <span class="number">12</span> P</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">gc <span class="number">1404</span> @<span class="number">8.808</span>s <span class="number">7</span>%: <span class="number">0.005</span>+<span class="number">0.54</span>+<span class="number">0.059</span> ms clock, <span class="number">0.060</span>+<span class="number">0.47</span>/<span class="number">0.79</span>/<span class="number">0.25</span>+<span class="number">0.71</span> ms cpu, <span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span> MB, <span class="number">5</span> MB goal, <span class="number">12</span> P</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">With Extra Allocations              Without Extra Allocations</span><br><span class="line">======================================================================</span><br><span class="line">Requests            : <span class="number">10</span>,<span class="number">000</span>        Requests            : <span class="number">10</span>,<span class="number">000</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Requests/sec        : <span class="number">1</span>,<span class="number">882</span> r/s     Requests/sec        : <span class="number">3</span>,<span class="number">631</span> r/s</span><br><span class="line">Total Duration      : <span class="number">5</span>,<span class="number">311</span>ms       Total Duration      : <span class="number">2</span>,<span class="number">753</span> ms</span><br><span class="line">Percent Time in GC  : <span class="number">14</span>%           Percent Time in GC  : <span class="number">7</span>%</span><br><span class="line">Total Collections   : <span class="number">2</span>,<span class="number">551</span>         Total Collections   : <span class="number">1</span>,<span class="number">402</span></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Total GC Duration   : <span class="number">744.54</span>ms      Total GC Duration   : <span class="number">192.71</span> ms</span><br><span class="line">Average Pace of GC  : ~<span class="number">2.08</span>ms       Average Pace of GC  : ~<span class="number">1.96</span>ms</span><br><span class="line">Requests/Collection : ~<span class="number">3.98</span> r/gc    Requests/Collection : <span class="number">7.13</span> r/gc</span><br></pre></td></tr></table></figure><p><img src="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/Untitled%203.png" alt="Untitled"></p><p>相比上一次减少了1149次GC，GC时间占比从14%下降到7%，程序运行速度提高了48%，collection时间减少74%</p><p><img src="/2022/04/23/Golang-GC%E7%AC%94%E8%AE%B0-GC-Traces/Untitled%204.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang笔记-Fan-in</title>
      <link href="/2022/04/23/Golang%E7%AC%94%E8%AE%B0-Fan-in/"/>
      <url>/2022/04/23/Golang%E7%AC%94%E8%AE%B0-Fan-in/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://go.dev/talks/2012/concurrency.slide">https://go.dev/talks/2012/concurrency.slide</a></p><ul><li><p>The boring function runs, like a boring party guest.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">fmt.Println(msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> boring(<span class="string">&quot;boring!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;I&#x27;m listening.&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A channel connects the main and boring goroutines so they can communicate.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>, c <span class="keyword">chan</span>&lt;- <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line"><span class="comment">// Expression to be sent can be any suitable value.</span></span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="keyword">go</span> boring(<span class="string">&quot;boring!&quot;</span>, c)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Generator Pattern: function that returns a channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns receive-only channel of strings.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"><span class="comment">// We launch the goroutine from inside the function.</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">&quot;%s %d&quot;</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c <span class="comment">// Return the channel to the caller.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := boring(<span class="string">&quot;boring!&quot;</span>) <span class="comment">// Function returning a channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;You say: %q\n&quot;</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Multiplexing: Fan-in<br><img src="/2022/04/23/Golang%E7%AC%94%E8%AE%B0-Fan-in/image_1641177362810_0.png" alt="image.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input1 &#125; &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="keyword">for</span> &#123; c &lt;- &lt;-input2 &#125; &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Fan-in using select</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(input1, input2 &lt;-<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>keep sequencing</strong>: Each speaker must wait for a go-ahead.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">msg  <span class="type">string</span></span><br><span class="line">wait <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span><span class="params">(msg <span class="type">string</span>)</span></span> &lt;-<span class="keyword">chan</span> Message &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">waitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>) <span class="comment">// Shared between all messages.</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Message)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- Message&#123; fmt.Sprintf(<span class="string">&quot;%s: %d&quot;</span>, msg, i), waitForIt &#125;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&lt;-waitForIt</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++&#123;</span><br><span class="line">msg1 := &lt;-c</span><br><span class="line">fmt.Println(msg1.msg)</span><br><span class="line">msg2 := &lt;-c</span><br><span class="line">fmt.Println(msg2.msg)</span><br><span class="line">msg1.wait &lt;- <span class="literal">true</span></span><br><span class="line">msg2.wait &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re both boring; I&#x27;m leaving.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Timeout:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">&quot;Joe&quot;</span>), boring(<span class="string">&quot;Ann&quot;</span>))</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s := &lt;-c: fmt.Println(s.msg)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span>*time.Second):</span><br><span class="line">fmt.Println(<span class="string">&quot;You&#x27;re too slow.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Example -Google Search:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">Web = fakeSearch(<span class="string">&quot;web&quot;</span>)</span><br><span class="line">Image = fakeSearch(<span class="string">&quot;image&quot;</span>)</span><br><span class="line">Video = fakeSearch(<span class="string">&quot;video&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> Search <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fakeSearch</span><span class="params">(kind <span class="type">string</span>)</span></span> Search &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(query <span class="type">string</span>)</span></span> Result &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> Result(fmt.Sprintf(<span class="string">&quot;%s result for %q\n&quot;</span>, kind, query))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> (results []Result) &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- Web(query) &#125; ()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- Image(query) &#125; ()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- Video(query) &#125; ()</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> result := &lt;-c:</span><br><span class="line">results = <span class="built_in">append</span>(results, result)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout: <span class="comment">//Don&#x27;t wait for slow servers.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;timed out&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">start := time.Now()</span><br><span class="line">results := Google(<span class="string">&quot;golang&quot;</span>)</span><br><span class="line">elapsed := time.Since(start)</span><br><span class="line">fmt.Println(results)</span><br><span class="line">fmt.Println(elapsed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Avoid discarding results from slow servers: Replicate the servers. Send requests to multiple replicas, and use the first response. More<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">First</span><span class="params">(query <span class="type">string</span>, replicas ...Search)</span></span> Result &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line">searchReplica := <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123; c &lt;- replicas[i](query) &#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> replicas &#123;</span><br><span class="line"><span class="keyword">go</span> searchReplica(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Google</span><span class="params">(query <span class="type">string</span>)</span></span> (results []Result) &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Result)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- First(query, fakeSearch(<span class="string">&quot;web&quot;</span>), fakeSearch(<span class="string">&quot;web&quot;</span>)) &#125; ()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- First(query, fakeSearch(<span class="string">&quot;image&quot;</span>), fakeSearch(<span class="string">&quot;image&quot;</span>)) &#125; ()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c &lt;- First(query, fakeSearch(<span class="string">&quot;video&quot;</span>), fakeSearch(<span class="string">&quot;video&quot;</span>)) &#125; ()</span><br><span class="line"></span><br><span class="line">timeout := time.After(<span class="number">80</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> result := &lt;-c:</span><br><span class="line">results = <span class="built_in">append</span>(results, result)</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout: <span class="comment">//Don&#x27;t wait for slow servers.</span></span><br><span class="line">fmt.Println(<span class="string">&quot;timed out&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang笔记-Pipelines-and-cancellation</title>
      <link href="/2022/04/19/Golang%E7%AC%94%E8%AE%B0-Pipelines-and-cancellation/"/>
      <url>/2022/04/19/Golang%E7%AC%94%E8%AE%B0-Pipelines-and-cancellation/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://go.dev/blog/pipelines">Go Concurrency Patterns: Pipelines and cancellation - The Go Programming Language</a></p><h1 id="What-is-pipeline"><a href="#What-is-pipeline" class="headerlink" title="What is pipeline"></a>What is pipeline</h1><ul><li>receive values from upstream via inbound channels</li><li>perform some function on that data, usually producing new values</li><li>send values downstream via outbound channels</li></ul><h1 id="Squaring-numbers"><a href="#Squaring-numbers" class="headerlink" title="Squaring numbers"></a>Squaring numbers</h1><ul><li>Generator Pattern converts a list of integers to a channel that emits the integers in the list</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nums&#123;</span><br><span class="line">out &lt;- n</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>receives integers from a channel and returns a channel that emits the square of each received integer</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> in&#123;</span><br><span class="line">out &lt;- n*n</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>receives integers from a channel and returns a channel that emits the square of each received integer</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">out := gen(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> sq(out)&#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>we can compose it any number of times</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">out := gen(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> sq(sq(sq(out)))&#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Fan-out-Fan-in"><a href="#Fan-out-Fan-in" class="headerlink" title="Fan-out, Fan-in"></a>Fan-out, Fan-in</h1><ul><li>Multiple functions can read from the same channel until that channel is closed; this is called <em>fan-out</em>. This provides a way to distribute work amongst a group of workers to parallelize CPU use and I/O.</li><li>A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that’s closed when all the inputs are closed. This is called fan-in.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> c&#123;</span><br><span class="line">out &lt;- n</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cs&#123;</span><br><span class="line"><span class="keyword">go</span> output(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">out := gen(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">c1 := sq(out)</span><br><span class="line">c2 := sq(out)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> merge(c1, c2)&#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Resource-leak"><a href="#Resource-leak" class="headerlink" title="Resource leak"></a>Resource leak</h1><ul><li><p>Stages don’t always receive all the inbound values</p><ul><li>The receiver may only need a subset of values to make progress</li><li>More often, a stage exits early because an inbound value represents an error in an earlier stage</li></ul></li><li>If a stage fails to consume all the inbound values, the goroutines attempting to send those values will block indefinitely</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Consume the first value from the output.</span></span><br><span class="line">    out := merge(c1, c2)</span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// Since we didn&#x27;t receive the second value from out,</span></span><br><span class="line">    <span class="comment">// one of the output goroutines is hung attempting to send it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>This is a resource leak: goroutines consume memory and runtime resources, and heap references in goroutine stacks keep data from being garbage collected. Goroutines are not garbage collected; they must exit on their own.</li><li>One way to do this is to change the outbound channels to have a buffer. But it depends on knowing the number of values merge will receive and the number of values downstream stages will consume.</li><li>Instead, we need to provide a way for downstream stages to <strong>indicate to the senders that they will stop accepting input.</strong></li></ul><h1 id="Explicit-cancellation"><a href="#Explicit-cancellation" class="headerlink" title="Explicit cancellation"></a>Explicit cancellation</h1><p>We need a way to tell an unknown and unbounded number of goroutines to <strong>stop sending their values downstream</strong>. In Go, we can do this by <strong>closing a channel</strong>, <strong>because a receive operation on a closed channel can always proceed immediately, yielding the element type’s zero value.</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, nums ...<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> nums&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- n:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> in&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- n * n:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cs ...&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line">out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> c&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> out &lt;- n:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> cs&#123;</span><br><span class="line"><span class="keyword">go</span> output(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Set up a done channel that&#x27;s shared by the whole pipeline,</span></span><br><span class="line"><span class="comment">// and close that channel when this pipeline exits, as a signal</span></span><br><span class="line"><span class="comment">// for all the goroutines we started to exit.</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">in := gen(done, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">c1 := sq(done, in)</span><br><span class="line">c2 := sq(done, in)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> merge(done, c1, c2)&#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Digesting-a-tree"><a href="#Digesting-a-tree" class="headerlink" title="Digesting a tree"></a>Digesting a tree</h1><p>Taking a single directory as an argument and prints the digest values for each regular file under that directory, sorted by path name.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Calculate the MD5 sum of all files under the specified directory,</span></span><br><span class="line">    <span class="comment">// then print the results sorted by path name.</span></span><br><span class="line">    m, err := MD5All(os.Args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> paths []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> m &#123;</span><br><span class="line">        paths = <span class="built_in">append</span>(paths, path)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(paths)</span><br><span class="line">    <span class="keyword">for</span> _, path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%x  %s\n&quot;</span>, m[path], path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>No concurrency and simply reads and sums each file as it walks the tree.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MD5All reads all the files in the file tree rooted at root and returns a map</span></span><br><span class="line"><span class="comment">// from file path to the MD5 sum of the file&#x27;s contents.  If the directory walk</span></span><br><span class="line"><span class="comment">// fails or any read operation fails, MD5All returns an error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5All</span><span class="params">(root <span class="type">string</span>)</span></span> (<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>)</span><br><span class="line">    err := filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !info.Mode().IsRegular() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        data, err := ioutil.ReadFile(path)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        m[path] = md5.Sum(data)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Parallel-digestion"><a href="#Parallel-digestion" class="headerlink" title="Parallel digestion"></a>Parallel digestion</h1><ul><li>We split <code>MD5All</code> into a two-stage pipeline.</li><li>The first stage, <code>sumFiles</code>, walks the tree, <strong>digests each file in a new goroutine</strong>, and sends the results on a channel with value type <code>result</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumFiles</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, root <span class="type">string</span>)</span></span> (&lt;-<span class="keyword">chan</span> result, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// For each regular file, start a goroutine that sums the file and sends</span></span><br><span class="line">    <span class="comment">// the result on c.  Send the result of the walk on errc.</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line">    errc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">        err := filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !info.Mode().IsRegular() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            wg.Add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                data, err := ioutil.ReadFile(path)</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> c &lt;- result&#123;path, md5.Sum(data), err&#125;:</span><br><span class="line">                <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                &#125;</span><br><span class="line">                wg.Done()</span><br><span class="line">            &#125;()</span><br><span class="line">            <span class="comment">// Abort the walk if done is closed.</span></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span> errors.New(<span class="string">&quot;walk canceled&quot;</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// Walk has returned, so all calls to wg.Add are done.  Start a</span></span><br><span class="line">        <span class="comment">// goroutine to close c once all the sends are done.</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            wg.Wait()</span><br><span class="line">            <span class="built_in">close</span>(c)</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="comment">// No select needed here, since errc is buffered.</span></span><br><span class="line">        errc &lt;- err</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c, errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>MD5All receives the digest values from c. MD5All returns early on error, closing done via a defer<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5All</span><span class="params">(root <span class="type">string</span>)</span></span> (<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// MD5All closes the done channel when it returns; it may do so before</span></span><br><span class="line">    <span class="comment">// receiving all the values from c and errc.</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)          </span><br><span class="line"></span><br><span class="line">    c, errc := sumFiles(done, root)</span><br><span class="line"></span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>)</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> c &#123;</span><br><span class="line">        <span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, r.err</span><br><span class="line">        &#125;</span><br><span class="line">        m[r.path] = r.sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := &lt;-errc; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Bounded-parallelism"><a href="#Bounded-parallelism" class="headerlink" title="Bounded parallelism"></a>Bounded parallelism</h1><p>Our pipeline now has three stages: walk the tree, read and digest the files, and collect the digests.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">path <span class="type">string</span></span><br><span class="line">sum [md5.Size]<span class="type">byte</span></span><br><span class="line">err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkFiles</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, root <span class="type">string</span>)</span></span> (<span class="keyword">chan</span> <span class="type">string</span>, &lt;-<span class="keyword">chan</span> <span class="type">error</span>) &#123;</span><br><span class="line">paths := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">errc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(paths)</span><br><span class="line"><span class="comment">// No select needed for this send, since errc is buffered.</span></span><br><span class="line">errc &lt;- filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info fs.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !info.Mode().IsRegular() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> paths &lt;-path:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;walk canceled&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> paths, errc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digester</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, paths &lt;-<span class="keyword">chan</span> <span class="type">string</span>, c <span class="keyword">chan</span>&lt;- result)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">data, err := ioutil.ReadFile(path)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- result&#123;path, md5.Sum(data), err&#125;:</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MD5All</span><span class="params">(root <span class="type">string</span>)</span></span>(<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>, <span class="type">error</span>)&#123;</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">paths, errc := walkFiles(done, root)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a fixed number of goroutines to read and digest files.</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">const</span> numDigesters = <span class="number">20</span></span><br><span class="line">wg.Add(numDigesters)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numDigesters; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">digester(done, paths, c)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][md5.Size]<span class="type">byte</span>)</span><br><span class="line"><span class="keyword">for</span> r := <span class="keyword">range</span> c &#123;</span><br><span class="line"><span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, r.err</span><br><span class="line">&#125;</span><br><span class="line">m[r.path] = r.sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check whether the Walk failed.</span></span><br><span class="line"><span class="keyword">if</span> err := &lt;-errc; err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Calculate the MD5 sum of all files under the specified directory,</span></span><br><span class="line"><span class="comment">// then print the results sorted by path name.</span></span><br><span class="line">m, err := MD5All(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> paths []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> path := <span class="keyword">range</span> m &#123;</span><br><span class="line">paths = <span class="built_in">append</span>(paths, path)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(paths)</span><br><span class="line"><span class="keyword">for</span> _, path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%x  %s\n&quot;</span>, m[path], path)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-GC笔记-Semantics</title>
      <link href="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/"/>
      <url>/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html">https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html</a></p><h1 id="Garbage-collectors-responsibility"><a href="#Garbage-collectors-responsibility" class="headerlink" title="Garbage collectors responsibility"></a>Garbage collectors responsibility</h1><ul><li>tracking heap memory allocations</li><li>freeing up allocations that are no longer needed</li><li>keeping allocations that are still in-use</li></ul><p>As of version 1.12, the Go programming language uses a non-generational concurrent tri-color mark and sweep collector.</p><p>非分代并发三色标记和扫描收集器</p><h1 id="Collector-Behavior"><a href="#Collector-Behavior" class="headerlink" title="Collector Behavior"></a>Collector Behavior</h1><p>collection工作会经历三个阶段</p><ul><li>Mark Setup - STW(Stop The World)</li><li>Marking - Concurrent</li><li>Mark Termination - STW</li></ul><h2 id="Mark-Setup-STW"><a href="#Mark-Setup-STW" class="headerlink" title="Mark Setup - STW"></a><strong>Mark Setup - STW</strong></h2><p>collection开始时候第一个活动就是打开Write Barrier，目的是允许collector在收集期间保持堆上的数据完整性，因为collection和application goroutines会同时运行。</p><p>为了打开Write Barrier，必须停止运行的application goroutine，该动作通常会很快，10~30 microseconds。</p><p>示例：</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled.png" alt="Untitled"></p><p>在collection之前必须停止正在运行的4个application goroutines，唯一停止的方法是让collector监视并等待每个goroutine进行一次function call，function call保证goroutine在safe point处停止。</p><p>假如其中一个goroutine没有进行function call，而其他的都进行了，会发生什么呢</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%201.png" alt="Untitled"></p><p>在P4上的goroutine停止之前，collection无法启动，因为处于数学计算中。<br><a href="https://github.com/golang/go/issues/10958">https://github.com/golang/go/issues/10958</a></p><h2 id="Marking-Concurrent"><a href="#Marking-Concurrent" class="headerlink" title="Marking - Concurrent"></a><strong>Marking - Concurrent</strong></h2><h3 id="25-CPU-capacity"><a href="#25-CPU-capacity" class="headerlink" title="25% CPU capacity"></a>25% CPU capacity</h3><p>一旦打开了Write Barrier，collector就进入了Marking阶段，第一件事就是为自己申请25%可用CPU容量（CPU capacity）的占用。</p><p>collector使用goroutine完成collection工作，并且需要使用与application goroutine一样的P和M。</p><p>对于4线程的go程序（4 threaded Go program），一个完整的P将专门用于collection工作。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%202.png" alt="Untitled"></p><h3 id="Marking"><a href="#Marking" class="headerlink" title="Marking"></a>Marking</h3><p>接着进入Marking阶段，标记堆内存（heap memory）中仍在使用的值。</p><p>首先会检查所有现有goroutine的stacks以找到指向heap memory的root pointers，然后collector必须从root pointers遍历heap memory graph。Marking进行时候，应用依旧可以在P2、P3、P4上继续进行。</p><p>如果P1上专门用于GC的goroutine在达到堆内存上限之前无法完成Markding工作，在这种情况下，新分配（new allocation）的速度必须放慢。collector确定需要放慢分配速度后，会招募application Goroutine来协助Marking工作，这称为MA（Mark Assist）。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%203.png" alt="Untitled"></p><p>collector的一个目标是减少MA的需求。为了减少下一次collection工作需要的MA，某一次collection工作可能需要大量的MA，以便collector可以更早的开始下一轮GC（理解：时间间隔短应用分配的内存也少，需要的MA也少）。</p><p>标记的速度：<em>4 CPU-milliseconds per MB of live heap</em></p><p>估计标记阶段要运行多久：<em>take the live heap size in MB and divide by 0.25 </em> the number of CPUs*</p><h2 id="Mark-Termination-STW"><a href="#Mark-Termination-STW" class="headerlink" title="Mark Termination - STW"></a><strong>Mark Termination - STW</strong></h2><p>Marking完成后，下一个阶段是Mark Termination，将会关闭Write Barrier、执行各种清理任务、计算下一个收集目标。执行得同样迅速，60～90 microseconds。可以不通过STW实现以增加性能，但增加了复杂性，相比之下使用更好。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%204.png" alt="Untitled"></p><p>一旦collection工作完成，每个P都又可以被application goroutine使用。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%205.png" alt="Untitled"></p><h1 id="Sweeping-Concurrent"><a href="#Sweeping-Concurrent" class="headerlink" title="Sweeping - Concurrent"></a><strong>Sweeping - Concurrent</strong></h1><p>collection完成之后会发生另外一个动作：Sweeping，该动作会回收未标记的值的相关内存，当application goroutine尝试在堆内存中分配新值（allocate new values）的时候会触发该动作，产生的时间开销附加在堆内存分配产生的开销中。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%206.png" alt="Untitled"></p><p>12个hardware threads可用于执行goroutine</p><p>在collection期间（左上角蓝色GC部分），十二个P中的三个专用于 GC。goroutine2450、1978、2696在这段时间内执行Mark Assit工作。collection工作完成后，只有一个P专门用于GC并执行Mark Termination工作。收集完成后，所有的P又可以被application goroutine使用（除了玫瑰色的细细线条外）。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%207.png" alt="Untitled"></p><p>玫瑰色表示gouroutine执行sweeping工作而不是application工作，发生于goroutine尝试在堆内存中分配新值的时刻。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%208.png" alt="Untitled"></p><p>上图是执行了sweep工作goroutine的stack trace</p><p>runtime.mallocgc代表堆内存中分配新值，runtime.(*mcache).nextFree代表sweep动作。</p><h1 id="GC-Percentage"><a href="#GC-Percentage" class="headerlink" title="GC Percentage"></a>GC Percentage</h1><p>runtime中有个配置项目是GC Percentage，决定下一个collection动作何时发生。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%209.png" alt="Untitled"></p><p>上一次collection动作完成后显示正在使用（收集阶段的任务就是标记正在使用的内存）的堆内存为2MB（上图中的内存不一定是连续分配的，仅为了好理解），由于GC Percentage设置为了100（默认值），那么下一次collection动作会发生于堆内存新分配达到2MB时或者在这之前。</p><h1 id="GC-Trace"><a href="#GC-Trace" class="headerlink" title="GC Trace"></a>GC Trace</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GODEBUG=gctrace=1 ./app</span><br><span class="line"></span><br><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1406 @6.070s 11%: 0.051+1.8+0.076 ms clock, 0.61+2.0/2.5/0+0.91 ms cpu, 8-&gt;11-&gt;6 MB, 13 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">gc 1407 @6.073s 11%: 0.052+1.8+0.20 ms clock, 0.62+1.5/2.2/0+2.4 ms cpu, 8-&gt;14-&gt;8 MB, 13 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>每次发生collection动作时候，runtime都会将GC trace information写入到stderr</p><h2 id="GC1405"><a href="#GC1405" class="headerlink" title="GC1405"></a>GC1405</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gc 1405 @6.068s 11%: 0.058+1.2+0.083 ms clock, 0.70+2.5/1.5/0+0.99 ms cpu, 7-&gt;11-&gt;6 MB, 10 MB goal, 12 P</span><br><span class="line"></span><br><span class="line">// General</span><br><span class="line">gc 1404     : The 1404 GC run since the program started</span><br><span class="line">@6.068s     : Six seconds since the program started</span><br><span class="line">11%         : Eleven percent of the available CPU so far has been spent <span class="keyword">in</span> GC</span><br><span class="line"></span><br><span class="line">// Wall-Clock</span><br><span class="line">0.058ms     : STW        : Mark Start       - Write Barrier on</span><br><span class="line">1.2ms       : Concurrent : Marking</span><br><span class="line">0.083ms     : STW        : Mark Termination - Write Barrier off and clean up</span><br><span class="line"></span><br><span class="line">// CPU Time</span><br><span class="line">0.70ms      : STW        : Mark Start</span><br><span class="line">2.5ms       : Concurrent : Mark - Assist Time (GC performed <span class="keyword">in</span> line with allocation)</span><br><span class="line">1.5ms       : Concurrent : Mark - Background GC <span class="keyword">time</span></span><br><span class="line">0ms         : Concurrent : Mark - Idle GC <span class="keyword">time</span></span><br><span class="line">0.99ms      : STW        : Mark Term</span><br><span class="line"></span><br><span class="line">// Memory</span><br><span class="line">7MB         : Heap memory in-use before the Marking started</span><br><span class="line">11MB        : Heap memory in-use after the Marking finished</span><br><span class="line">6MB         : Heap memory marked as live after the Marking finished</span><br><span class="line">10MB        : Collection goal <span class="keyword">for</span> heap memory in-use after Marking finished</span><br><span class="line"></span><br><span class="line">// Threads</span><br><span class="line">12P         : Number of logical processors or threads used to run Goroutines</span><br></pre></td></tr></table></figure><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%2010.png" alt="Untitled"></p><p>在Marking动作之前，正在使用的堆内存量为7MB，Marking完成后，使用中的堆内存达到11MB，意味着在collection期间发生了额外的4MB分配。Marking完成后，标记为活动中的堆内存量为6MB，这意味着应用程序在下一次collection开始之前可以将使用中的堆内存量增加到12MB（理想情况）。</p><p>global是根据使用中的堆内存量（before marking）、标记为活动中的堆内存量（after marking）、以及collection运行时发生的额外分配计算而来的。</p><h2 id="GC1406"><a href="#GC1406" class="headerlink" title="GC1406"></a>GC1406</h2><p>gc1406发生在gc1405 2ms之后</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%2011.png" alt="Untitled"></p><p>gc1405完成之后根据GC Percentage推测下一次触发时间为堆内存使用量达到12MB，但是这个是理想情况，如果collector决定最好早点开始collection动作那么则会早点开始，因为应用程序分配了大量内存，而collector希望减少收集期间Mark Assist使用量，所以当使用量达到8M的时候就开始了下一轮。</p><h1 id="Pacing"><a href="#Pacing" class="headerlink" title="Pacing"></a><strong>Pacing</strong></h1><p>collector有一个pacing算法用于确定何时开始collection工作。该算法依赖于feedback loop，collector用它来收集有关正在运行的应用程序和应用程序给堆施加的压力的信息，压力可以理解为给定时间内分配堆内存的速度，正是这种压力决定了collector的工作频率。</p><p>在collector开始collection工作之前，它会计算完成collection工作所需的时间。一旦collection工作运行，就会对在正在运行的应用程序上产生延迟，从而减慢应用程序的速度。</p><p>一个误解是认为降低collector的工作频率是提高性能的一种方式，比如将GC Percentage的值调大，这样可能就会导致collection频率降低？实际上这对于提高性能没有直接关系。</p><p>实际上与提高性能有关系的是每次collection完成之间（两个collectopn的间隔）应用程序执行的任务数量，可以通过减少堆内存的使用来影响到它以提高吞吐量。</p><p><img src="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/Untitled%2012.png" alt="Untitled"></p><p>蓝色版本没有任何优化，绿色版本则是发现并去掉了4.48GB无关的内存分配（non-productive memory allocations）后的结果。</p><p>两个版本的collection平均频率相差不大（2.08ms vs 1.96ms），根本变化是每个collection之间完成的工作量，从每个间隔平均处理3.98个请求到7.13个请求。collection的频率并没有随着内存分配减少而减少，而是保存不变。</p><p>总的来说，尝试减少collection工作频率的措施并不是提高性能的方式，而减少collector运行需要的时间才是重要的，因为这个会减少因为延迟带来的成本。</p><p>当压力降低时候，collector造成的延迟将会减少，而这种GC延迟又是减慢应用程序的主要原因，所以减少堆内存的压力是正确的方法。</p><p>collector造成的影响有：</p><ul><li>Marking - Concurrent阶段会占用25%CPU性能</li><li>Mark Assist</li><li>STW（一般情况下花费时间少于100 microsecond）</li></ul><p>可以减少延迟的措施有：</p><ul><li>保持最少的使用堆内存</li><li>最大限度缩短每次collection、STW、Mark Assist持续的时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-LEC11-Cache-Consistency-Frangipani</title>
      <link href="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/"/>
      <url>/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要阅读这篇论文"><a href="#为什么要阅读这篇论文" class="headerlink" title="为什么要阅读这篇论文"></a>为什么要阅读这篇论文</h1><ul><li>cache coherence</li><li>distributed transactions</li><li>distributed crash recovery</li><li>三者的相互作用</li></ul><h1 id="整体的设计"><a href="#整体的设计" class="headerlink" title="整体的设计"></a>整体的设计</h1><ul><li>a network file system，与现有的应用程序共同工作，类似普通的unix程序。<br><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220326232624.png" alt><br>可以将petal想象成一个磁盘，通过网络将数据共享给Frangipani，看起来就像从普通磁盘上读取数据</li></ul><h1 id="预期用途"><a href="#预期用途" class="headerlink" title="预期用途"></a>预期用途</h1><ul><li>一个文件系统，能保存自己的home目录以及共享的项目文件，在任何的workstation（可以理解是个人PC）能拿到自己的home目录以及所需要的所有文件。</li><li>没有涉及到安全问题，彼此电脑之间互相信任，适用于小群体</li></ul><h1 id="Frangipani的设计"><a href="#Frangipani的设计" class="headerlink" title="Frangipani的设计"></a>Frangipani的设计</h1><ul><li>强一致性</li><li>caching in each workstation — write-back<ul><li>所有对文件的更新最初只是在workstation cache中完成—速度快</li><li>包括创建文件、目录、重命名等</li><li>比如ws1(workstation user 1)想要创建并读写<code>/grades</code>：Frangipani会从Petal读取<code>/infomation</code>的信息并保存到cache，然后添加<code>/grades</code>到cache，但是并不会立马将修改同步到Petal，因为ws1也许会继续修改<code>/grades</code></li></ul></li><li>所以Frangipani程序应该安装在workstation，而且petal不会知道workstation上面的文件以及目录信息，所有的逻辑处理复杂性都放在了Frangipani中<ul><li>这是一种中心化方案（decentralized scheme）</li><li>添加更多workstation能添加更多CPU算力，有一定的扩展性，但是存储系统则会增加存储的负载，可能需要更多存储服务器。</li></ul></li></ul><h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><ul><li>主要来自caching、decentralized</li><li>cache coherence：ws1创建<code>/A</code>，ws2希望能看到<code>/A</code>（本地cache不会立即同步到Petal）</li><li>atomic multi-step operations：两个不同的workstation对同一个目录修改，比如ws1创建<code>/A</code>，ws2创建<code>/B</code>，最终<code>/</code>应该有两个目录，不应该出现覆盖的情况（因为中间会有很多更新的步骤），或者是同时创建两个相同的文件。</li><li>crash recovery：当一个workstation crash，不应该影响到其他用户，即使浏览crashed workstation目录下的文件，也应该看到正确的内容（没有损坏的，不一定要最新）</li><li>Petal里面内置了一套完全独立的容错系统（很像之前讨论的Chain Replication），不在讨论的范围内。</li></ul><h1 id="cache-coherence"><a href="#cache-coherence" class="headerlink" title="cache coherence"></a>cache coherence</h1><ul><li>目标是linearizability和caching，即同时兼备性能和一致性</li><li>许多系统使用了cache coherence protocols：多核处理器、file servers、distributed shared memory，但是Frangipani使用的不是这种，而是使用锁实现。</li></ul><h2 id="Frangipani’s-coherence-protocol"><a href="#Frangipani’s-coherence-protocol" class="headerlink" title="Frangipani’s coherence protocol"></a>Frangipani’s coherence protocol</h2><ul><li>lock server (LS), with one lock per file/directory，简化版，实际上Frangipani的锁更复杂，允许一个writer或者多个reader对文件操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file  owner</span><br><span class="line">-----------</span><br><span class="line">x     WS1</span><br><span class="line">y     WS1</span><br></pre></td></tr></table></figure></li><li>workstation (WS) Frangipani <strong>cache</strong>：每个workstation会去跟踪它持有的锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file/dir  lock  content(文件或者目录的实际内容)</span><br><span class="line">-----------------------</span><br><span class="line">x         busy  ...</span><br><span class="line">y         idle  ...</span><br></pre></td></tr></table></figure>锁的种类：</li></ul><ol><li>busy：正在使用数据</li><li>idle：持有锁，但是现在不使用cached data（结束系统调用后由busy变成idle，比如创建文件、重命名、写入读取）</li></ol><ul><li>workstation使用锁的规则，保证缓存一致性<ul><li>只有持有该文件锁的时候，才能对这个文件的数据缓存</li><li>先获得锁，然后从Petal中读取数据，并保存到缓存</li><li>先将修改后的数据写回到Petal，再释放锁（会有定时将缓存写入到磁盘的机制，避免一直没有释放锁后又crash丢失数据）</li></ul></li><li>coherence protocol messages<ul><li>request  (WS -&gt; LS)</li><li>grant (LS -&gt; WS)</li><li>revoke (LS -&gt; WS)：请求ws释放idle锁，一般情况下workstation创建了文件立即释放掉，而是由busy变成idle，因为绝大部分情况下，创建了文件还会对其操作。当ws收到revoke且能释放的时候（也就是ws此时没有对文件进行操作），如果缓存数据修改过，则需要按照第3条规则写回到Petal。</li><li>release (WS -&gt; LS)</li></ul></li></ul><h2 id="示例-WS1更改文件z，然后WS2读取z"><a href="#示例-WS1更改文件z，然后WS2读取z" class="headerlink" title="示例:WS1更改文件z，然后WS2读取z"></a>示例:WS1更改文件z，然后WS2读取z</h2><p><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220328083733.png" alt></p><ol><li>WS1向LS请求文件z的锁</li><li>WS1拿到锁</li><li>从Petal读取文件z的内容，保存到cache</li><li>WS2向LS请求文件z的锁</li><li>WS1持有这把锁，向WS1发送revoke请求</li><li>如果z被修改过，需要将更新后的z的内容写回到Petal</li><li>WS1发送release给Petal，释放锁</li><li>WS2拿到锁</li></ol><ul><li>锁和使用锁的规则保证最后一次的修改能被别人看到</li><li>优化点：<ul><li>增加idle锁，避免频繁向LS请求</li><li>增加shared read lock、exclusive-write lock，共享读锁，当要写入时候回收读锁，写锁独占。</li></ul></li></ul><h1 id="atomic-multi-step-operations"><a href="#atomic-multi-step-operations" class="headerlink" title="atomic multi-step operations"></a>atomic multi-step operations</h1><p>Frangipani实现了transactional file-system operations（创建文件、删除文件、重命名等），以保证原子性</p><ol><li>获取该操作所需的所有锁</li><li>在持有所有锁的情况下执行操作，并将修改后的数据写到Petal</li><li>完成后释放锁<br>Frangipani的锁有两种作用：</li></ol><ul><li>cache coherence：同步最新的写入</li><li>transactional file-system：避免没有完成的操作让别的ws看到</li></ul><h1 id="crash-recovery"><a href="#crash-recovery" class="headerlink" title="crash recovery"></a>crash recovery</h1><ul><li>ws持有锁的时候崩溃（可能已经写入部分修改的数据到Petal）</li><li>此时不能直接释放对应的锁，因为操作还没有完成，释放后别的ws可能看到损坏的或者杂乱的数据，但是不释放锁别的ws就得一直等待锁。</li></ul><h2 id="write-ahead-logging"><a href="#write-ahead-logging" class="headerlink" title="write-ahead logging"></a>write-ahead logging</h2><p>Frangipani使用write-ahead logging实现crash recovery</p><ol><li>将cache中的信息写入到Petal的之前，先在Petal写入这组完整操作的log（日志是ws一段段根据offset发送给Petal）</li><li>只有这组操作的log已经安全落地到Petal，ws才发送写操作给Petal<ul><li>当已经写入部分到Petal的ws crash后，剩余的写入操作可以根据Petal的log完成<br>有两处与传统的logging方法不一样</li></ul></li></ol><ul><li>在大部分事务系统中，只有一个地方存放log，并且所有的事务日志都存放于此，所以一次crash或者多个操作都可以影响到这段数据。而Frangipani则是每个ws都有单独的log，避免了记录log的瓶颈，但是某个文件的更新日志可能分散存到不同的位置。</li><li>在大部分事务系统中，事务log存放位置和执行事务的那台机器是在一起的，基本是存在本地磁盘，但是Frangipani的log存放在共享的Petal中，而不是ws本地磁盘，这样ws2可以读取crash ws1的log并恢复。</li></ul><h2 id="log中的内容"><a href="#log中的内容" class="headerlink" title="log中的内容"></a>log中的内容</h2><ul><li>使用带有编号的block存储每个ws的日志</li><li>每个ws以环形队列的方式使用Petal上为它分配的空间，当空间用完的时候，ws可以从头写入，以此复用空间，但是在复用之前需要确保日志已经不需要（该日志的操作被Petal执行过了）<br><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220331073356.png" alt></li><li>log entry中的内容：<ul><li>LSN(log sequence number)：递增的log entry number，如果ws崩溃了，Frangipani会去扫描它的日志，直到LSN不在递增为止。</li><li>描述数据更新的数组，每个元素都有：Petal上的block号、version number和需要写入的内容</li></ul></li><li>log中只有文件系统中的目录、inode、allocation bitmap的元数据修改信息，没有文件中实际的内容的信息，只是包含了crash后恢复文件系统结构的足够信息。比如在目录d下创建了文件f，增加一个log entry，里面有两条关于修改的描述：如何初始化f的inode、该文件在目录d下的新名字。</li><li>最初log entry只在ws的内存中，避免频繁写入Petal。</li></ul><h2 id="revoke"><a href="#revoke" class="headerlink" title="revoke"></a>revoke</h2><p>收到ls的revoke消息的时候，需要释放锁</p><ol><li>将某些部分日志写到Petal的内存中，得确保日志是完整的</li><li>将已经修改的cache数据发送给Petal写入（这组数据修改操作的日志第一步已经发送了）</li><li>发送release消息释放锁</li></ol><h2 id="ws1在持有锁的时候崩溃"><a href="#ws1在持有锁的时候崩溃" class="headerlink" title="ws1在持有锁的时候崩溃"></a>ws1在持有锁的时候崩溃</h2><ul><li>ws2请求ws1持有的锁<ul><li>ls向ws发送revoke请求，没有得到响应，Frangipani的lock使用了lease的设定，当超过了lease time，就会判定ws肯定崩溃了。</li><li>ls告诉ws2根据Petal的日志恢复ws1（根据ws1的log写入到Petal，有一些checksum机制确保每个log entry都是完整的，避免执行没有写完整的log entry）</li><li>完成后告诉ls才能释放锁</li></ul></li><li>ws1可能没有将log写回到Petal就崩溃了，或者是在写的过程中崩溃了，那么可能会丢掉ws1做的一些操作，但是其他的ws不会收到影响。</li><li>另外一种情况是ws1将日志发送给Petal完成后或者只发送了一点缓存数据后就崩溃了，但是进行恢复工作的ws2并不知道ws1什么时候崩溃了，ws2需要重新执行log（可能会在相同的地方写入相同的内容）</li></ul><h1 id="版本号机制保证不会执行旧的日志"><a href="#版本号机制保证不会执行旧的日志" class="headerlink" title="版本号机制保证不会执行旧的日志"></a>版本号机制保证不会执行旧的日志</h1><p><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220401090622.png" alt></p><ul><li>ws1删除完d/f，ws2接着创建d/f，然后ws1崩溃了，接着ws3要恢复ws1</li><li>对于Petal中所保存的数据（元数据、目录、数据块等）来说都有一个版本号，当修改元数据并保存更新后的数据的时候会对版本+1。所以如果一个ws没有故障，并且成功的将数据写回到了Petal，这样元数据的版本号会大于等于Log条目中的版本号。如果有其他的工作站之后修改了同一份元数据，版本号会更高。</li><li>如果Petal中的版本号大于等于log entry中的版本号，ws3就忽略该日志，所以上述场景ws3不会执行ws1删除的日志，其他的日志同理，选择性的恢复。</li><li>当ws3进行恢复工作的时候，ws2可能持有着该目录所对应的锁，此时ws3查看ws1的log时候需要锁，这个应该怎么解决？<ul><li>一种不可行的方法是让ws3先获取所有的锁，再执行恢复动作。当发生系统级的供电故障后，所有持有锁的信息都丢失了，就没有了之前锁提供的两种保障，此时就不能随便恢复。</li><li>实际上，ws3可以在不关心锁的情况下对Petal进行数据读写。ws1要么释放了锁，要么没有。如果没有，那么没有其他人可以读写该目录，ws3可以放心地写。如果释放了锁，根据版本号比对就知道不用恢复该数据了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> Frangipani </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-LEC10-Cloud Replicated-DB-Aurora</title>
      <link href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/"/>
      <url>/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要学习Aurora"><a href="#为什么要学习Aurora" class="headerlink" title="为什么要学习Aurora"></a>为什么要学习Aurora</h2><ul><li>作为近几年成功的云服务，解决了严重的问题</li><li>设计良好，有性能的优势</li><li>使用general-purpose storage架构情况下的局限性</li><li>许多关于云基础架构中重要的内容</li></ul><h2 id="Amazon-EC2，cloud-computing，针对于web"><a href="#Amazon-EC2，cloud-computing，针对于web" class="headerlink" title="Amazon EC2，cloud computing，针对于web"></a>Amazon EC2，cloud computing，针对于web</h2><p><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220312154755.png" alt></p><ul><li>租用直接运行在Amazon数据中心物理机器上的virtual machines instances</li><li>使用的存储是连接在物理磁盘上的virtual local disk</li><li>客户在EC2上面运行着stateless www server或者DB</li><li>但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）</li></ul><h2 id="Amazon-EBS-Elastic-Block-Store"><a href="#Amazon-EBS-Elastic-Block-Store" class="headerlink" title="Amazon EBS (Elastic Block Store)"></a>Amazon EBS (Elastic Block Store)</h2><p><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220312160129.png" alt></p><ul><li>使用的是Chain Replication，基于paxos的configuration manager</li><li>如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume</li><li>EBS不是shared storage，只能由一个EC2挂载</li></ul><h2 id="DB-on-EBS缺点"><a href="#DB-on-EBS缺点" class="headerlink" title="DB-on-EBS缺点"></a>DB-on-EBS缺点</h2><ul><li>需要通过网络发送大量数据—log和dirty data pages，即使只是几bytes的更改，data pages也很大，可能一个page是8k</li><li>为了性能，两个replica放在同一个”availability zone” (AZ)—machine room or datacenter，AZ挂了则数据库都挂了</li></ul><h2 id="generic-transactional-DB"><a href="#generic-transactional-DB" class="headerlink" title="generic transactional DB"></a>generic transactional DB</h2><p>示例：单机，x账户转账10元到y账户，在事务执行期间，x和y将被锁住，直到commit完成后释放，事务完成后数据就被持久化。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin</span><br><span class="line">x = x + 10</span><br><span class="line">y = y - 10</span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220313112022.png" alt></p><p><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220320110439.png" alt></p><ul><li>WAL(Write-Ahead Log)：让系统实现容错能力的关键部分</li></ul><ol><li>DB server在事务运行时只会修改cached data page，并将更新信息（log entry）添加到WAL<br><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220313112559.png" alt></li><li>安全提交WAL到磁盘后，释放x和y的锁，并回复给client</li><li>随后将修改后的data page从缓存写入到磁盘，但是数据库一般会积累很多未写入磁盘的值在cache上面。当db crash后重启，会扫描commit记录，执行redo和undo操作。</li></ol><ul><li>需要在WAL保存旧值，当崩溃恢复的时候，需要undo回滚到旧值。</li></ul><h2 id="Multi-AZ-RDS"><a href="#Multi-AZ-RDS" class="headerlink" title="Multi-AZ RDS"></a>Multi-AZ RDS</h2><p>database-as-a-service，而不是客户自己运行db在EC2<br><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220313120857.png" alt></p><ul><li>目标：通过cross-AZ replication实现更好的容错能力</li><li>每个写数据必须发送到本地EBS和另外一个EC2上运行的DB，包括log entry和所有的dirty data pages</li><li>数据库写入必须等待四个EBS完成后才能回复给client，所以数据量大的话这里会有很大的延迟，但是容错性更好。</li></ul><h2 id="Aurora的做法"><a href="#Aurora的做法" class="headerlink" title="Aurora的做法"></a>Aurora的做法</h2><p><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220313122926.png" alt></p><ul><li>一个DB server（使用EC2实例），底层对应着6个replica（storage server，其实就是挂载着一个或两个硬盘的server instance）</li><li>但是6个replica并不比RDS慢，因为只需要发送log entry（small），而不用发送dirty data pages（big）。但是这里并不是通用的，只能处理MySQL的log entry，EBS则具有通用，因为只是一个磁盘。</li><li>不需要让6个replica都确认写请求，只要有Quorum（达到法定确认人数，事实证明只需要任意4个，简单的来说，在写操作时候，可以忽略最慢或者基本死掉的replica），数据库服务器就能够继续运行。</li><li>35x throughput increase，可能主要是因为发送的数据少得多，但是增加了cpu和存储的使用量。</li></ul><h2 id="Aurora’s-storage-fault-tolerance-goal"><a href="#Aurora’s-storage-fault-tolerance-goal" class="headerlink" title="Aurora’s storage fault tolerance goal"></a>Aurora’s storage fault tolerance goal</h2><ul><li>即使一个AZ完全死了也能处理写请求</li><li>即使一个AZ完全死了+另外一台server发生故障，也能够处理读请求</li><li>即使在某些存储服务器变慢或者暂时不可用情况下，服务也能够继续进行</li><li>fast re-replication（快速复制出另外一个replica或者修复dead replica）</li></ul><h2 id="Quorum-read-write-technique"><a href="#Quorum-read-write-technique" class="headerlink" title="Quorum read/write technique"></a>Quorum read/write technique</h2><ul><li>目标：fault-tolerant storage，即使出现一些failures也能够读取最新的数据</li><li>通常应用于简单的read/write (put/get) storage</li><li>需要配置N、W、R（<strong>N</strong> replicas, writes to any <strong>W</strong> replicas,  reads from any <strong>R</strong> replicas），W和R的replica需要有一台重叠（overlap，也就是R+W=N+1），即负责写也负责读</li><li>示例：N=3, W=2, R=2<br><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220313212518.png" alt></li></ul><ol><li>发出一个写请求，将值更新为23</li><li>得写入W个replica</li><li>接着处理读请求，为了处理读请求，至少得包含一个处理过写请求的server<br>所以overlap确保了至少有1个来自write quorum</li></ol><ul><li>read quorum对应的server有多个，如何确定从哪个server中读取到的是最新数据？<br>采用版本号机制，最大版本号的就是最新的数据，不能采用投票机制，可能read quorum中只有一个数据是最新的。</li><li>read/write quorum不能达到指定人数怎么办？继续重试</li></ul><h2 id="quorum-read-write-storage-systems有什么好处"><a href="#quorum-read-write-storage-systems有什么好处" class="headerlink" title="quorum read/write storage systems有什么好处"></a>quorum read/write storage systems有什么好处</h2><ul><li>可以轻易处理dead or slow or partitioned storage servers，不需要等待、检测、超时机制等并且也不存在split brain风险。</li><li>可以调整R和W以使读/写更快，比如可以使R=1，W=3，这样读起来更快，只需要等待一台机器响应即可，反过来写则会慢很多。但是Aurora容错能力是min(N-W, N-R)，这里的值是0，所以就没有容错能力。</li></ul><h2 id="Aurora的N、W、R是怎么样的"><a href="#Aurora的N、W、R是怎么样的" class="headerlink" title="Aurora的N、W、R是怎么样的"></a>Aurora的N、W、R是怎么样的</h2><p>N=6，W=4，R=3<br>一个AZ完全死掉之后剩余4个replica，W=4，可以继续写入<br>一个AZ完全死掉+一个server死掉后，剩余3个replica，R=3，可以继续读取</p><h2 id="Aurora是怎么样写入的"><a href="#Aurora是怎么样写入的" class="headerlink" title="Aurora是怎么样写入的"></a>Aurora是怎么样写入的</h2><ul><li>DB server写入storage servers时候不会修改现有的数据项，而是写入新的log entry，即写操作或者事务完成之前，这条日志记录至少已经落地到4台server上面。达到Write Quorum后才会对client进行响应。</li><li>确定一个事务之前，需要等待Write Quorum的storage server对之前所有提交的事务响应之后，才会响应现在这个事务。崩溃恢复也是如此，需要先恢复前面的事务。</li></ul><h2 id="storage-server如何处理传入的log-entry"><a href="#storage-server如何处理传入的log-entry" class="headerlink" title="storage server如何处理传入的log entry"></a>storage server如何处理传入的log entry</h2><ul><li>拿到的只是对data page修改的日志，并没有data page</li><li>storage server内部保持了数据库中data page在某一时刻的数据（旧版本），所以实际上存储的是旧版本的data page和更新page所需要的日志列表</li><li>storage server异步或者在需要读取日志的时候apply这些日志到page，然后将data page返回</li></ul><h2 id="Aurora的读是怎么样的"><a href="#Aurora的读是怎么样的" class="headerlink" title="Aurora的读是怎么样的"></a>Aurora的读是怎么样的</h2><ul><li>写入的是log entry，读取的是data page（cached data page is missed）。实际上，DB server会跟踪每个storage server收到了多少个log entry，读取的时候只需要从有最新的server里面读即可，不需要Read Quorum（写入需要Write Quorum）。</li><li>当DB server（不是storage server）崩溃恢复的时候，会自动在不同的EC2示例上重新启动一个DB server。</li><li>崩溃的DB server可能处于处理某组事务的状态上，一些事务已经执行完成数据保存在Quorum上面，还有一些执行到一半的事务（一些数据可能已经保存到了某一个server上，而有的server可能还没有），所以重新启动的DB server需要读取Read Quorum，会在这些storage server上找到缺失日志编号最高的那个log entry，并告诉storage server丢失后续所有的日志。</li><li>所以可能存在一些半路崩溃保存下来的没有提交的日志（只有更新记录，没有commit记录标志），DB server需要检测出这些日志，并执行undo操作</li></ul><h2 id="如何处理解决太大而无法存储在storage-server的问题"><a href="#如何处理解决太大而无法存储在storage-server的问题" class="headerlink" title="如何处理解决太大而无法存储在storage server的问题"></a>如何处理解决太大而无法存储在storage server的问题</h2><p><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220324073828.png" alt></p><ul><li>data page被分片（每片大概10GB）存储在Protection Groups (PGs)上，比如将B-Tree中编号为奇数的data page放到PG1，偶数的放到PG2</li><li>每个PG由6个replica组成，不同的PG可能位于不同集群（sets of six storage servers），这些server由Aurora客户共同使用。</li><li>如何拆分log：当DB server发送log entry时候，会根据log中所修改的数据查到保存该数据的PG，然后将日志发送给PG。所以每个PG存储了部分data page+这部分data page进行提交的日志记录。</li></ul><h2 id="当storage-server-crash时候如何快速替换"><a href="#当storage-server-crash时候如何快速替换" class="headerlink" title="当storage server crash时候如何快速替换"></a>当storage server crash时候如何快速替换</h2><ul><li>需要快速替换，避免接着有更多的server崩溃，导致无法恢复</li><li>可能crash掉的storage server里面保存了1000个PG（假设每个硬盘10T）replica，这可能会导致其他客户的10G PG数据也不可用，所以需要复制的是整个硬盘上的数据。假设内网的网速是10Gb/s，那么传输需要10000秒。<br><img src="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/Pasted image 20220326092303.png" alt></li><li>当发生特定storage server crash时候，假设这里面存储了PGABC的数据，处理程序会将PGABC其他replica里面的数据发送到另外几台server，并行的恢复需要的时间很少。不过当发生很多server都crash时候，这种方法也不奏效，只能通过单台机器恢复。</li></ul><h2 id="只读实例"><a href="#只读实例" class="headerlink" title="只读实例"></a>只读实例</h2><ul><li>master只负责写，同时存在很多只读replica（R/O），以减少master的负载</li><li>R/0从storage server读取data page，并缓存data page，master将log发送给R/O保持缓存的data page是最新的。</li><li>master需要在log中标注uncommitted log，R/O则需要直到这些transaction commit后才应用到缓存中。</li><li>replica在storage server直接读数据的时候可能会看到B-Tree正在执行平衡或者一些其他操作，所以storage server得展示已完成事务后对应的data page，不能是未完成的，需要对B-Tree加锁之类的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-LEC9-More-Replication-CRAQ</title>
      <link href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/"/>
      <url>/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么学习CRAQ"><a href="#为什么学习CRAQ" class="headerlink" title="为什么学习CRAQ"></a>为什么学习CRAQ</h2><ul><li>Chain Replication(CR)，一种与Raft非常不一样的方法。</li><li>CRAQ能够从replica读取数据并且保持强一致性</li></ul><h2 id="什么是CR"><a href="#什么是CR" class="headerlink" title="什么是CR"></a>什么是CR</h2><ul><li>write：<br>  <img src="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/Pasted image 20220310073110.png" alt><ol><li>client发送写请求给head server</li><li>请求按顺序沿着链下发</li><li>每个server用新数据覆盖旧数据</li><li>当tail server处理完成后回复给client</li></ol></li><li>read：<br>  <img src="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/Pasted image 20220310073341.png" alt><ol><li>client发送读请求给tail server</li><li>tail server回复给client（不涉及其他server）</li></ol></li><li>为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。</li><li>如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。</li><li>如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。</li><li>不能处理network partition或者spilt brain的情况，需要配合第三方组件configuration manager (cm)来判断哪些服务器或者还是挂掉了，当有问题的时候，cm会重新发出配置决定谁是head，谁是tail，怎么安排链等。cm一般会使用Raft或者Zookeeper。</li><li>可能不止一条链，也许是replication group，以此来请求分流，这个都由cm去决定。</li><li>每个节点不需要更新其他服务器是否处于在线情况，当下一个节点挂掉后，上一个节点会一直尝试和下一个节点通信，除非收到了新的配置。</li></ul><h2 id="为什么CR比Raft更有吸引力"><a href="#为什么CR比Raft更有吸引力" class="headerlink" title="为什么CR比Raft更有吸引力"></a>为什么CR比Raft更有吸引力</h2><ul><li>client请求的接收和回复在CR中是在两个不同的server中处理，Raft需要leader都处理。</li><li>在CR中head server只需要发送一次请求，Raft需要leader将请求发送给所有的follower。</li><li>读取数据在CR中是由tail server完成，而在Raft中则是leader，会增加leader的负载。</li><li>失败的情况比Raft更简单</li></ul><h2 id="可以让client读取CR中任一replica？"><a href="#可以让client读取CR中任一replica？" class="headerlink" title="可以让client读取CR中任一replica？"></a>可以让client读取CR中任一replica？</h2><ul><li>当大量读取操作导致tail server负载很高的情况，此时中间的server可能还有很多闲置的性能。因此，如果中间节点也参与进处理读请求的话性能可能会更好。</li><li>paper中提出一种解决方案：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain1: S1 S2 S3</span><br><span class="line">Chain2: S2 S3 S1</span><br><span class="line">Chain3: S3 S1 S2</span><br></pre></td></tr></table></figure>这不一定有效，如果请求没有均匀分配的话</li><li>这也会导致强一致性失效，可能会读到未提交的值，或者是从一个replica读到旧值，从另外一个replica读到新值。</li></ul><h2 id="如何让CRAQ支持强一致性读取任一replica"><a href="#如何让CRAQ支持强一致性读取任一replica" class="headerlink" title="如何让CRAQ支持强一致性读取任一replica"></a>如何让CRAQ支持强一致性读取任一replica</h2><p><img src="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/Pasted image 20220311090029.png" alt></p><ul><li>每个replica存储每一个object的version list：clean version和最近写入的dirty version</li><li>write：<ul><li>client向head server发送写请求</li><li>写请求在链传递的时候中间每个replica创建新的dirty version</li><li>tail server则创建clean version，沿着链返回ack，将dirty version转变为clean version</li></ul></li><li>read from replica：<ul><li>如果最新版本是clean version，则返回给client</li><li>如果最新是dirty version，不能返回recent clean version，因为client可能从别的replica获得了部分新的数据；也不能直接返回dirty version，因为这个可能是未committed的</li><li>只需要向tail server查询最新的版本即可（version query）</li></ul></li></ul><h2 id="为什么CRAQ支持强一致性读取replica，而Raft-Zookpeer不能"><a href="#为什么CRAQ支持强一致性读取replica，而Raft-Zookpeer不能" class="headerlink" title="为什么CRAQ支持强一致性读取replica，而Raft/Zookpeer不能"></a>为什么CRAQ支持强一致性读取replica，而Raft/Zookpeer不能</h2><ul><li>CRAQ的结构是一条链，所以对于所有的节点：<ul><li>在写入commit之前，所有节点都知道了这个写入</li><li>能够知道何时查询tail server以得到最新的数据</li></ul></li><li>Raft/Zookpeer的leader机制是以majority进行的，所以follower不能何时错过了一个committed write</li></ul><h2 id="这是否意味CR比Raft-amp-c更强大"><a href="#这是否意味CR比Raft-amp-c更强大" class="headerlink" title="这是否意味CR比Raft &amp;c更强大"></a>这是否意味CR比Raft &amp;c更强大</h2><p>不是</p><ul><li>所有的CRAQ replica都处理了请求后才能提交数据，Raft只需要majority</li><li>如果一个节点变得很慢的话，会影响这个链的性能，Raft则没有这些影响。</li><li>不能像Raft或者Zookeeper那样立即可以fault-tolerant</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> CRAQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-LEC8-Zookeeper</title>
      <link href="/2022/03/30/MIT6.824-LEC8-Zookeeper/"/>
      <url>/2022/03/30/MIT6.824-LEC8-Zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Zookeeper提出了什么问题"><a href="#Zookeeper提出了什么问题" class="headerlink" title="Zookeeper提出了什么问题"></a>Zookeeper提出了什么问题</h2><ol><li>能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？</li><li>我们有N个replica server，能从这个N个server中获得N倍性能吗？</li></ol><h2 id="将Zookeer视为基于Raft的service"><a href="#将Zookeer视为基于Raft的service" class="headerlink" title="将Zookeer视为基于Raft的service"></a>将Zookeer视为基于Raft的service</h2><p><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220305160645.png" alt><br>只不过ZooKeeper使用的是zab协议，为ZooKeeper专门设计的一种支持崩溃恢复的一致性协议</p><h2 id="当我们添加更多的server时候，replication-arrangement是否变得更快"><a href="#当我们添加更多的server时候，replication-arrangement是否变得更快" class="headerlink" title="当我们添加更多的server时候，replication arrangement是否变得更快"></a>当我们添加更多的server时候，replication arrangement是否变得更快</h2><p>replica越多，写入的速度就越慢<br>leader必须将每次写入发送给越来越多的server</p><h2 id="可以让follower提供只读服务，这样leader压力就小很多"><a href="#可以让follower提供只读服务，这样leader压力就小很多" class="headerlink" title="可以让follower提供只读服务，这样leader压力就小很多"></a>可以让follower提供只读服务，这样leader压力就小很多</h2><p>可能会产生log与leader不一致的情况，导致client读取的数据不对，甚至是产生“倒退现象”，client先从up-to-date replica读，再从logging replica读。这个就不可能是Linearizability<br>Raft和Lab3不会出现这种情况，因为follower不提供只读服务</p><h2 id="Zookeeper怎么处理这个"><a href="#Zookeeper怎么处理这个" class="headerlink" title="Zookeeper怎么处理这个"></a>Zookeeper怎么处理这个</h2><p>在性能和强一致性之间保持平衡，不提供强一致性，允许从replica读取数据（写只能是写leader），但是在其他方面则是保证了顺序。</p><h2 id="Ordering-guarantees-Section-2-3"><a href="#Ordering-guarantees-Section-2-3" class="headerlink" title="Ordering guarantees (Section 2.3)"></a>Ordering guarantees (Section 2.3)</h2><h3 id="Linearizable-writes"><a href="#Linearizable-writes" class="headerlink" title="Linearizable writes"></a>Linearizable writes</h3><ol><li>client发送写入命令到leader</li><li>leader选择一个顺序，编号为<code>zxid</code></li><li>将该命令发送给replica，所以replica按照zxid顺序去执行。</li><li>即使是并发写操作，也会保证按照某个顺序去一一执行。</li></ol><h3 id="FIFO-client-order"><a href="#FIFO-client-order" class="headerlink" title="FIFO client order"></a>FIFO client order</h3><p>client指定write和read操作的执行顺序</p><ul><li>write：按照client指定的write order，section2.3 ready file</li><li>read：<ul><li>每次读都在写入顺序中的某一个点开始执行</li><li>client连续读操作，每次读的顺序保证是非递减，这一次读不会读到前面的内容</li><li>如果执行读操作的时候，replica挂掉了，client需要将它的读请求发送给另外一个replica，这时候依旧会保证FIFO client order（非递减）。</li><li>工作原理是每个log entry都有一个zxid，当一个replica响应client的读请求时会携带上一个log entry的zxid（这里的上一个相对于是下一个读请求），client会记住最新数据的zxid，每次请求会携带上zxid。</li><li>如果另外一个replica也没有最新zxid对应的下一个log，replica可能会延迟对读请求回复直到leader同步了log或者是拒绝这个请求，或者是其他。</li></ul></li><li>将write发送给leader，但是leader还没有同步给replica，这时候read replica会被delay（因为指定了命令的执行顺序）或者sync()</li><li>只是保证了一个client的FIFO order（同一个clien的Linearizability），即同一个client的命令可以保证下一次读到的是上一次的写。但是对于不同的client来讲，client2不一定能准确读到刚刚client1写的数据</li></ul><h2 id="尽管Zookeeper不是Linearizability，但是在别的方面还是有用的"><a href="#尽管Zookeeper不是Linearizability，但是在别的方面还是有用的" class="headerlink" title="尽管Zookeeper不是Linearizability，但是在别的方面还是有用的"></a>尽管Zookeeper不是Linearizability，但是在别的方面还是有用的</h2><ul><li>sync()能够让后续不同的client看到之前client写入的值。只有该数据在整个系统中处于写状态，不允许其他client读到。想要读取最新数据，需要sync再读。缺点是增加了leader的处理时间，不这样做的话就不是linearizable</li><li>场景1 ready file：master在Zookeeper中维护了一个配置文件（描述了分布系统的东西，比如worker ip，master信息等），里面有一堆文件（可以实现原子更新效果），master会去更新配置文件，在更新的过程中worker不能查看配置，只能看到完全更新后的配置。<ul><li>正常的操作序列，虽然不是完全linearizable（只有写），但是读只能往前读，所以达了类似linearizable的效果，提高了性能：<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306190528.png" alt></li></ul></li><li>可能会出现的问题：<br>  <img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306190548.png" alt><br>  读f1的时候，执行了写操作，导致读到的f2不是原来应该读的<br>  Zookeeper使用watch事件去解决，当调用exists的时候，除了判断file是否存在，还在这个文件上面设置了watch事件（replicate会创建watch table，文件修改之前查看watch table)，当这个文件被修改时候replica会在一个相对正确的时间点通知client，即会在读操作执行之前。<br>  <img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306191450.png" alt><br>  当replicate crash时候，对应的watch table也会没有，client切换到新的replicate读的时候就不会有对应的watch table。但是client会在合适的时间收到replica崩溃的通知。</li></ul><h2 id="几个影响"><a href="#几个影响" class="headerlink" title="几个影响"></a>几个影响</h2><ul><li>当leader failed时候leader必须保存client的write order（？</li><li>replicate需要保障client的读取顺序按照zxid顺序</li><li>client必须跟踪它已读取的最高 zxid</li></ul><h2 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h2><ul><li>client可以让leader发送异步写入，不必等待</li><li>leader可以批处理请求以减少磁盘和网络开销</li></ul><h2 id="Coordination-as-a-service是怎么样的（Zookeeper有什么用）"><a href="#Coordination-as-a-service是怎么样的（Zookeeper有什么用）" class="headerlink" title="Coordination as a service是怎么样的（Zookeeper有什么用）"></a>Coordination as a service是怎么样的（Zookeeper有什么用）</h2><h3 id="VMware-FT’s-test-and-set-server"><a href="#VMware-FT’s-test-and-set-server" class="headerlink" title="VMware-FT’s test-and-set server"></a>VMware-FT’s test-and-set server</h3><ul><li>要求：一个replica无法和其他replica通信，则获取t-a-s lock（test-and-set lock），成为sole server。必须是唯一的以避免存在两个primary（如果出现network partition），必须是fault-tolerant。</li><li>Zookeeper提供了工具，可以写出fault-tolerant test-and-set服务</li></ul><h3 id="Config-info"><a href="#Config-info" class="headerlink" title="Config info"></a>Config info</h3><p>通过Zookeeper发布信息给其他服务使用，比如可以将一组worker中作为当前master的那个ip存放在Zookeeper</p><h3 id="Mater-elect"><a href="#Mater-elect" class="headerlink" title="Mater elect"></a>Mater elect</h3><p>在test-and-set server中有体现，master可以把state存放在Zookeeper，如果master crash，选出一个新的maser代替它，新的master可以从Zookeeper中读取旧master的状态。</p><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>worker可以注册到Zookeeper中，master会在里面记录着worker的任务，worker会从Zookeeper中将任务一件件拿出来，完成后就会移除掉。</p><h3 id="Zookeeper-API"><a href="#Zookeeper-API" class="headerlink" title="Zookeeper API"></a>Zookeeper API</h3><ul><li>a file-system-like tree of znodes<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220308074546.png" alt><br>each znode has a version number<br>示例：将一组机器和哪个机器是primary的信息存放在znodes</li><li>znode的分类：regular、ephemeral、sequential（file name + seqno）</li></ul><h2 id="Operations-on-znodes"><a href="#Operations-on-znodes" class="headerlink" title="Operations on znodes"></a>Operations on znodes</h2><p>flags：znode type</p><ul><li>create(path, data, flags)：互斥的（exclusive），只有第一次创建才能成功</li><li>delete(path, version)：if znode.version = version, then delete</li><li>exists(path, watch)：设置watch后，当path创建或者删除后会发送一个通知。原子操作，两个write之间的watch不会有任何操作，znode完成改变之前不会收到通知</li><li>getData(path, watch)</li><li>setData(path, data, version)：if znode.version = version, then update</li><li>getChildren(path, watch)</li><li>sync()</li></ul><h2 id="Zookeeper-api可以很好地实现同步"><a href="#Zookeeper-api可以很好地实现同步" class="headerlink" title="Zookeeper api可以很好地实现同步"></a>Zookeeper api可以很好地实现同步</h2><ul><li>exclusive file creation：并发创建只有一个能返回成功</li><li>getData()/setData(x, version)支持mini-transactions</li><li>当client fail的时候，session会自动执行操作，例如失败时release lock</li><li>sequential znode file可用于并发创建的同时又能指定顺序</li><li>watch</li></ul><h2 id="znode中的数字递增"><a href="#znode中的数字递增" class="headerlink" title="znode中的数字递增"></a>znode中的数字递增</h2><p>mini-transaction保障atomic read-modify-write<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true:</span><br><span class="line">    x, v := getData(&quot;f&quot;)</span><br><span class="line">    if setData(x + 1, version=v):</span><br><span class="line">      break</span><br></pre></td></tr></table></figure><br>当replica不能与leader通信时候，不能退出while循环。只适合少量请求的场景，当有大量的client同时递增时候，性能就会很差，因为同时操作只有一个能完成，复杂度是N^2。使用随机sleep能够减少循环的次数，避免大量的重试。</p><h2 id="Simple-Locks-Section-2-4"><a href="#Simple-Locks-Section-2-4" class="headerlink" title="Simple Locks (Section 2.4)"></a>Simple Locks (Section 2.4)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire():</span><br><span class="line">    while true:</span><br><span class="line">      if create(&quot;f&quot;, ephemeral=true), success</span><br><span class="line">      if exists(&quot;f&quot;, watch=true)</span><br><span class="line">        wait for notification</span><br><span class="line">release():</span><br><span class="line">delete(&quot;f&quot;)</span><br></pre></td></tr></table></figure><p>在replica exists执行过程中，lock文件被释放掉，会发生什么情况。exists是个只读请求，可能会发生在replica，与此同时，可能会有别的client在执行delete操作。exists会在两个write请求之间执行。<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220309081922.png" alt><br>在完成执行成功的时间点，replica会看到lock文件依旧存在，replica会插入watch信息到watch table，然后才执行delete操作。所以当delete操作执行时，确保watch请求会在replica的watch table中，并且replica会给client发送通知。<br>每次释放锁，所有剩下的client都会收到watch通知，都会返回第一步发送create请求，所以时间复杂度基本上还是N^2。这个就是大量等待client引起的<code>Herd Effect</code>。</p><h2 id="Locks-without-Herd-Effect-scalable-lock"><a href="#Locks-without-Herd-Effect-scalable-lock" class="headerlink" title="Locks without Herd Effect(scalable lock)"></a>Locks without Herd Effect(scalable lock)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. create a &quot;sequential&quot; file</span><br><span class="line">2. list files</span><br><span class="line">3. if no lower-numbered, lock is acquired!</span><br><span class="line">4. if exists(next-lower-numbered, watch=true)</span><br><span class="line">5.   wait for event...</span><br><span class="line">6. goto 2</span><br></pre></td></tr></table></figure><ul><li>大量client请求的话会按顺序产生很多个文件</li><li>这些文件代表着获得了锁，如果释放了锁则需要删除文件</li><li>为什么需要list files，因为前一个client可能会failed，导致文件被自动删除，这时候就需要关注上一个的上一个的文件是否存在，而不能只是关注上一个文件（相对于client创建的文件序号，比如client创建了f500，不能只是关注f499）是否存在。</li><li>如何解决Herd Effect：创建了第501个文件的client在等待第500个文件被释放，创建了第500个文件的client等待第499个文件被释放，每个client都在等待文件被释放。当释放锁的时候，一个client就会收到通知，第三步就会成立，那么这个client就获得了锁。所以一个client的开销只有几次RPC请求的开销，等待锁也可以是异步等待，在另外一个线程通过某种方式查看Zookeeper的状态。其实就相等于锁队列，后一个client都在等待着前面的client释放。<ul><li>如果client持有锁的时候，但是它中途操作失败，那么锁会立即释放，导致下一个client获得锁的时候看到的数据不是正确的数据。所以这些锁和语言带的线程锁相比，它们无法提供相同的原子性保证。<ul><li>基本上使用这种锁有两种考虑：每个获取到锁的client都应该准备好遇到上一个失败这种情况时的操作（比如推断出是在哪个地方出现错误）；要么就是保护的数据不是很重要，比如MapReduce中的worker失败后，释放锁后下一个worker执行时看到任务没有完成，重新执行即可。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-Raft-index含义</title>
      <link href="/2022/03/30/MIT6.824-Raft-index%E5%90%AB%E4%B9%89/"/>
      <url>/2022/03/30/MIT6.824-Raft-index%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="nextIndex"><a href="#nextIndex" class="headerlink" title="nextIndex"></a>nextIndex</h1><ol><li>官方描述：for each server, index of the next log entry  to send to that server (initialized to leader last log index + 1)</li><li>leader保存该数组变量，由leader更新。</li><li><code>nextIndex[i]</code>代表着对第i个follower发起Append Entries RPC时<strong>尝试</strong>replicated log的位置，仅仅是猜测并不是真实的，并且出现<code>log inconsistency</code>会将该值回退。所以<code>nextIndex[i]</code>需要比<code>matchIndex[i]</code>要大。</li><li>leader收到Append Entries RPC回复后只有是因为<code>log inconsistency</code>才能更新nextIndex。</li><li>更新nextIndex的三个时机<ul><li>leader election成功时候，需要更新nextIndex为<code>leader last log index + 1</code></li><li>AppendEntries RPC返回success，代表已经成功replicated log</li><li><code>log inconsistency</code>时候回退nextIndex</li></ul></li></ol><h1 id="matchIndex"><a href="#matchIndex" class="headerlink" title="matchIndex"></a>matchIndex</h1><ol><li>官方描述：for each server, index of highest log entry known to be replicated on server  (initialized to 0, increases monotonically)</li><li>leader保存该数组变量，由leader更新。</li><li>更新matchIndex时候，应该取自args的值，因为nextIndex和raft中的logEntries的值可能已经发生了变化。<code>matchIndex = prevLogIndex + len(args.entries)</code></li><li>更新matchIndex的三个时机<ul><li>leader election成功，更新matchIndex为lastLogIndex</li><li>AppendEntries RPC返回success，代表已经成功replicated log</li><li>leader接收到新的command时候，主要用于配合该规则更新commitIndex，然后触发apply操作：<code>If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N</code></li></ul></li></ol><h1 id="commitIndex"><a href="#commitIndex" class="headerlink" title="commitIndex"></a>commitIndex</h1><ol><li>官方描述：index of highest log entry known to be  committed (initialized to 0, increases  monotonically)</li><li>commitIndex并不是只有leader才有的，所有server的commitIndex应该是一致的。</li><li>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)<ul><li>leader发送带有log的Append Entries RPC给follower，append log的follower达到majority后，leader commit该log，并更新commitIndex</li><li>第二次发送RPC时候，因为leaderCommit大于follower的commitIndex，代表着leader已经commit了新的log，所以follower根据上述规则更新自己的commitIndex</li><li>根据commitIndex &gt; lastApplied，leader(如果已经达到majority的话)/follower就会apply <code>[lastApplied+1, commitIndex]</code>的log到state machine。这里apply的是上一次的log。因为leader commit后，follower才能commit，本次log leader还没有commit</li></ul></li><li>apply时候需要注意Figure8的条件，leader只能apply currentTerm的log时候顺便apply了之前的term的log，而不能直接apply之前term的log</li></ol><h1 id="lastApplied"><a href="#lastApplied" class="headerlink" title="lastApplied"></a>lastApplied</h1><ul><li>highest applied log index，和commitIndex配合使用，标明要apply log的区间</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Patterns and Hints for Concurrency in Go -- Replicated service client</title>
      <link href="/2021/12/30/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Replicated%20service%20client/"/>
      <url>/2021/12/30/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Replicated%20service%20client/</url>
      
        <content type="html"><![CDATA[<h1 id="ReplicatedClient"><a href="#ReplicatedClient" class="headerlink" title="ReplicatedClient"></a>ReplicatedClient</h1><ul><li><p>ReplicatedClient interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplicatedClient <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Init initializes the client to use the given servers.</span></span><br><span class="line">    <span class="comment">// To make a particular request later,</span></span><br><span class="line">    <span class="comment">// the client can use callOne(srv, args),</span></span><br><span class="line">    <span class="comment">// where srv is one of the servers from the list.</span></span><br><span class="line">    Init(servers []<span class="type">string</span>, callOne <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, Args)</span></span> Reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call makes a request an available server.</span></span><br><span class="line">    <span class="comment">// Multiple goroutines may call Call concurrently.</span></span><br><span class="line">    <span class="comment">// Find an available server and keep using the same server </span></span><br><span class="line">    <span class="comment">// until it becomes unavailable.</span></span><br><span class="line">    Call(args Args) Reply</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Init and Call function implementation</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">    servers []<span class="type">string</span></span><br><span class="line">    callOne <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, Args)</span></span> Reply</span><br><span class="line">    mu sync.Mutex</span><br><span class="line">    <span class="comment">//server id of the last successful request</span></span><br><span class="line">    prefer <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Init(servers []<span class="type">string</span>, callOne <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, Args)</span></span> Reply)&#123;</span><br><span class="line">    c.servers = servers</span><br><span class="line">    c.callOne = callOne</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Call(args Args) Reply&#123;</span><br><span class="line">    <span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">        serverID <span class="type">int</span></span><br><span class="line">        reply Reply</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> result, <span class="number">1</span>)</span><br><span class="line">    id := ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        done &lt;- result&#123;id, c.callOne(c.servers[id], args)&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hint: Use a mutex if that is the clearest way to write the code.</p></li></ul><h1 id="Call-function-failed"><a href="#Call-function-failed" class="headerlink" title="Call function failed"></a>Call function failed</h1><ul><li><p>If Call function takes too long that means it failed. In the case of the timeout we’re going to <strong>need to try a different server</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Call(args Args) Reply&#123;</span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">serverID <span class="type">int</span></span><br><span class="line">reply Reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Second</span><br><span class="line">t := time.NewTimer(timeout)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可能会同时发出去多个请求，但是只要一个请求成功ok就行</span></span><br><span class="line"><span class="comment">// 这里使用buffer channel的原因接收其他的返回请求</span></span><br><span class="line"><span class="comment">// 避免一直阻塞在goroutine</span></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> result, <span class="built_in">len</span>(c.servers))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id := <span class="number">0</span>; id &lt; <span class="built_in">len</span>(c.servers); id++&#123;</span><br><span class="line">id := id</span><br><span class="line">log.Println(<span class="string">&quot;try to call&quot;</span>, id)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">          res := &lt;- result&#123;id, c.callOne(c.servers[id], args)&#125;</span><br><span class="line">          done &lt;- res</span><br><span class="line">          <span class="keyword">defer</span> log.Println(<span class="string">&quot;goroutine call return&quot;</span>, res)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-done:</span><br><span class="line"><span class="keyword">return</span> r.reply</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line"><span class="comment">//timeout</span></span><br><span class="line">t.Reset(timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果全部超时的话则会阻塞住</span></span><br><span class="line">r := &lt;-done</span><br><span class="line"><span class="keyword">return</span> r.reply</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Hint: Stop timers you don’t need. Otherwise you might end up with a lot of timers in a timer queue.</li></ul></li></ul><h1 id="prefer-last-available-server"><a href="#prefer-last-available-server" class="headerlink" title="prefer last available server"></a>prefer last available server</h1><ul><li>Find an available server and <strong>keep using the same server until it becomes unavailable</strong>.<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Call(args Args) Reply&#123;</span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">serverID <span class="type">int</span></span><br><span class="line">reply Reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Second</span><br><span class="line">t := time.NewTimer(timeout)</span><br><span class="line"><span class="keyword">defer</span> t.Stop()</span><br><span class="line"></span><br><span class="line">c.mu.Lock()</span><br><span class="line">prefer := c.prefer</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> result, <span class="built_in">len</span>(c.servers))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r result</span><br><span class="line"><span class="keyword">for</span> id := <span class="number">0</span>; id &lt; <span class="built_in">len</span>(c.servers); id++&#123;</span><br><span class="line">id := (prefer + id) % <span class="built_in">len</span>(c.servers)</span><br><span class="line">log.Println(<span class="string">&quot;try to call&quot;</span>, id)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">res := result&#123;id, c.callOne(c.servers[id], args)&#125;</span><br><span class="line">done &lt;- res</span><br><span class="line"><span class="keyword">defer</span> log.Println(<span class="string">&quot;goroutine call finish, return&quot;</span>, res)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>&#123;</span><br><span class="line"><span class="keyword">case</span> r = &lt;-done:</span><br><span class="line"><span class="keyword">goto</span> Done</span><br><span class="line"><span class="keyword">case</span> &lt;-t.C:</span><br><span class="line"><span class="comment">//timeout</span></span><br><span class="line">t.Reset(timeout)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">r = &lt;-done</span><br><span class="line">Done:</span><br><span class="line">c.mu.Lock()</span><br><span class="line">c.prefer = r.serverID</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> r.reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><ul><li>使用示例<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">servers := []<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>&#125;</span><br><span class="line">callOne := <span class="function"><span class="keyword">func</span><span class="params">(server <span class="type">string</span>, args Args)</span></span> Reply&#123;</span><br><span class="line"><span class="keyword">if</span> server != <span class="string">&quot;5&quot;</span>&#123;</span><br><span class="line">time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;yes&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c Client</span><br><span class="line">c.Init(servers, callOne)</span><br><span class="line">log.Println(<span class="string">&quot;call return:&quot;</span>, c.Call(<span class="string">&quot;args&quot;</span>))</span><br><span class="line">log.Println(<span class="string">&quot;finish&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> concurrency </tag>
            
            <tag> replicated_service_client </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Patterns and Hints for Concurrency in Go -- Work scheduler</title>
      <link href="/2021/12/27/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Work%20scheduler/"/>
      <url>/2021/12/27/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Work%20scheduler/</url>
      
        <content type="html"><![CDATA[<h1 id="use-channel-as-synchronized-queue"><a href="#use-channel-as-synchronized-queue" class="headerlink" title="use channel as synchronized queue"></a>use channel as synchronized queue</h1><ul><li><p>Scheduling n machines to execute m tasks, and each task may be different</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers []<span class="type">string</span>, numTask <span class="type">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span>)</span><br></pre></td></tr></table></figure></li><li><p>We can use a channel install of stack or queue, because it’s a <strong>good synchronized queue</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers []<span class="type">string</span>, numTask <span class="type">int</span>, call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span>)&#123;</span><br><span class="line">    idle := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="built_in">len</span>(servers))</span><br><span class="line">    <span class="keyword">for</span> _, srv := <span class="keyword">range</span> servers&#123;</span><br><span class="line">        idle &lt;- srv</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++&#123;</span><br><span class="line">        task := task</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            srv := &lt;-idle</span><br><span class="line">            call(srv, task)</span><br><span class="line">            idle &lt;- srv</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for循环会一下启动numTask个goroutine，然后等待获取空闲的server，如果只有几个server，那么性能会很浪费，所以我们可以把获取空闲的server代码放在goroutine外面，只有有空闲的server时候才创建gouroutine。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++&#123;</span><br><span class="line">    task := task</span><br><span class="line">    srv := &lt;-idle</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        call(srv, task)</span><br><span class="line">        idle &lt;- srv</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Waiting for the task to finish</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++&#123;</span><br><span class="line">    &lt;-idle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="one-goroutine-per-server"><a href="#one-goroutine-per-server" class="headerlink" title="one goroutine per server"></a>one goroutine per server</h1><ul><li><p>There’s only one goroutine that makes requests of a server at a particular time. So instead of having one goroutine per task maybe <strong>we should have one goroutine per server</strong>, because there are probably going to be fewer servers than tasks.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers []<span class="type">string</span>, numTask <span class="type">int</span>, call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span>)&#123;</span><br><span class="line">    work := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    runTasks := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> task := <span class="keyword">range</span> work&#123;</span><br><span class="line">            call(srv, task)</span><br><span class="line">        &#125;</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, srv := <span class="keyword">range</span> servers&#123;</span><br><span class="line">        <span class="keyword">go</span> runTasks(srv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++&#123;</span><br><span class="line">        work &lt;- task</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(servers); i++&#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(work)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="get-new-servers-at-any-given-time"><a href="#get-new-servers-at-any-given-time" class="headerlink" title="get new servers at any given time"></a>get new servers at any given time</h1><ul><li><p>In some cases,  you might <strong>get new servers at any given time</strong>. So we can pass server channel instead of slice and put that loop into its own goroutine so that while we’re sending tasks to servers we can still accept new servers.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers <span class="keyword">chan</span> <span class="type">string</span>, numTask <span class="type">int</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">              call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> srv := <span class="keyword">range</span> servers &#123;</span><br><span class="line">            <span class="keyword">go</span> runTasks(srv)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Now we don’t know <strong>when all the servers are done</strong> because we don’t know how many servers there.  We can count the number of tasks that have finished instead of counting number of servers come in because it’s a little tricky.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">runTasks := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> task := <span class="keyword">range</span> work&#123;</span><br><span class="line">        call(srv, task)</span><br><span class="line">        done &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numTask; i++&#123;</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>But we will <strong>run into deadlock</strong>. 当server完成一个task时候，执行<code>done &lt;- True</code>，但是没有对应的channel接收，因为此时还处于<code>work &lt;- task</code>循环中，所以修改也很简单，放到goroutine里面即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++&#123;</span><br><span class="line">        work &lt;- task</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(work)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numTask; i++&#123;</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>But the simplest possible fix for this is to just make the work channel big enough that you’re never gonna run out of space.  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numTask)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="failed-task-and-shut-down"><a href="#failed-task-and-shut-down" class="headerlink" title="failed task and shut down"></a>failed task and shut down</h1><ul><li><p>If the <strong>call returning a false</strong> just put the task back on the work list.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers <span class="keyword">chan</span> <span class="type">string</span>, numTask <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">              call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span> <span class="type">bool</span>)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    runTasks := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> task := <span class="keyword">range</span> work&#123;</span><br><span class="line">            <span class="keyword">if</span> call(srv, task)&#123;</span><br><span class="line">                done &lt;- <span class="literal">true</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                work &lt;- task</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>We have to do which is to <strong>shut down the loop that’s watching for new servers</strong> or you can run close(servers) when schedule function done.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> srv := &lt;-servers:</span><br><span class="line"><span class="keyword">go</span> runTasks(srv)</span><br><span class="line"><span class="keyword">case</span> &lt;- exit:</span><br><span class="line">log.Println(<span class="string">&quot;loop runTask finish&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(work)</span><br><span class="line">exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h1><ul><li><p><strong>运行示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Schedule</span><span class="params">(servers <span class="keyword">chan</span> <span class="type">string</span>, numTask <span class="type">int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">call <span class="keyword">func</span>(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span> <span class="type">bool</span>)&#123;</span><br><span class="line">work := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numTask)</span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">runTasks := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> task := <span class="keyword">range</span> work&#123;</span><br><span class="line"><span class="keyword">if</span> call(srv, task)&#123;</span><br><span class="line">done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">work &lt;- task</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> srv := &lt;-servers:</span><br><span class="line"><span class="keyword">go</span> runTasks(srv)</span><br><span class="line"><span class="keyword">case</span> &lt;- exit:</span><br><span class="line">log.Println(<span class="string">&quot;loop runTask finish&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> task := <span class="number">0</span>; task &lt; numTask; task++ &#123;</span><br><span class="line">work &lt;- task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numTask; i++&#123;</span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(work)</span><br><span class="line">exit &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.LstdFlags | log.Lmicroseconds)</span><br><span class="line">numTask := <span class="number">1000</span></span><br><span class="line">numServer := <span class="number">10</span></span><br><span class="line">servers := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">call := <span class="function"><span class="keyword">func</span><span class="params">(srv <span class="type">string</span>, task <span class="type">int</span>)</span></span> <span class="type">bool</span>&#123;</span><br><span class="line">log.Println(srv, task)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numServer; i++&#123;</span><br><span class="line">srv := fmt.Sprintf(<span class="string">&quot;srv-%d&quot;</span>, i)</span><br><span class="line">servers &lt;- srv</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">Schedule(servers, numTask, call)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> concurrency </tag>
            
            <tag> work_scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Patterns and Hints for Concurrency in Go -- Publishsubscribe server</title>
      <link href="/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/"/>
      <url>/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/</url>
      
        <content type="html"><![CDATA[<h1 id="PubSub-interface"><a href="#PubSub-interface" class="headerlink" title="PubSub interface"></a>PubSub interface</h1><ul><li><p>A classic publish subscribe server operates in three ways: subscribe、publish、cancel.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubSub <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// publishes the event e to all current subscriptions.</span></span><br><span class="line">Publish (e Event)</span><br><span class="line"></span><br><span class="line"><span class="comment">// registers c to receive future events.</span></span><br><span class="line"><span class="comment">// if Publish(e1) happens before Publish(e2),</span></span><br><span class="line"><span class="comment">// subscribers receive e1 before e2.</span></span><br><span class="line">Subscribe (c <span class="keyword">chan</span>&lt;- Event)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancels the prior subscription of channel c.</span></span><br><span class="line">Cancel(c <span class="keyword">chan</span>&lt;- Event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>A simple implementation is as follows：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex</span><br><span class="line">  <span class="comment">// key of map represents the channel </span></span><br><span class="line">  <span class="comment">// used to receive the event.</span></span><br><span class="line">sub <span class="keyword">map</span>[<span class="keyword">chan</span> &lt;- Event]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Init()&#123;</span><br><span class="line">s.sub = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;-Event]<span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Publish(e Event)&#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> s.sub&#123;</span><br><span class="line">c &lt;- e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Subscribe(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.sub[c]&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;pubsub: already subscribed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s.sub[c] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Cancel(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">s.mu.Lock()</span><br><span class="line">s.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !s.sub[c]&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;pubsub: not subscribed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line"><span class="built_in">delete</span>(s.sub, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Hint: Prefer defer for unlocking mutexes</p></li></ul><h1 id="One-slow-subscriber-can-slow-down-everyone"><a href="#One-slow-subscriber-can-slow-down-everyone" class="headerlink" title="One slow subscriber can slow down everyone"></a>One slow subscriber can slow down everyone</h1><ul><li>If one subscriber falls behind, the next subscriber doesn’t get the event until that slow subscriber wakes up. So <strong>one slow subscriber can slow down everyone.</strong><ul><li><strong>One way is to use  channel buffer.</strong><br>As long as they’re not too far behind When you’re publishing. The new event always go into the channel buffer and then the actual publish won’t block for too long.</li><li>There’s a better way to deal with arbitrarily slow subscribers in a really big program.</li></ul></li></ul><h1 id="Options-for-slow-goroutines"><a href="#Options-for-slow-goroutines" class="headerlink" title="Options for slow goroutines"></a>Options for slow goroutines</h1><ul><li><p><strong>Slow down event generation</strong><br>Publish stops until the subscribers catch up.</p></li><li><p><strong>Coalesce or drop events</strong></p><ul><li>The subscriber might find out that it missed some events. No one knows what they were because didn’t save them but at least subscriber can see how many events are missing and maybe can do something try to catch up.</li><li>Profiler:<ul><li>There’s a separate goroutine that fills the profile on a signal handler. Whose job is to read the data back out and write it to disk or send it to a http request or whatever it is you’re doing with profile data.</li><li>There’s a buffer in the middle and if the receiver from the profile data falls behind when the buffer fills up we start adding entries to a final profile by call runtime.lost function.</li><li>if you go look at the profile you see the program spent five percent of its time in lost profile data. we’re clear about exactly the error rate is in the profile.</li></ul></li><li>OS signal package:<ul><li>You have to pass in a channel that will be ready to receive the signal like SIGHUP or SIGQUIT.</li><li>When the signal comes in the run time tries to send to each of the channels and if it can’t send to it, it’s just gone.</li><li>The callers have to do is they have to pass in a buffered channel which length at least one and they only register that channel to a single signal.</li><li>If a signal comes in you’re definitely going to get told about it if it comes in twice you might only get told about it once. That’s actually the same semantics that unix gives to processes for signals.</li></ul></li></ul></li><li><p><strong>Save all the events that slow subscriber hasn’t seen</strong></p><ul><li>There’s always slow computers that have fallen offline or whatever and they might be gone for a while.</li><li>In general you want to think very carefully before you do that and think well you know how unbounded is it really and can I tolerate.</li></ul></li></ul><h1 id="Implement-the-third-option"><a href="#Implement-the-third-option" class="headerlink" title="Implement the third option"></a>Implement the third option</h1><ul><li><p>start a new goroutine handles requests three channels:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">publish   <span class="keyword">chan</span> Event</span><br><span class="line">subscribe <span class="keyword">chan</span> subReq</span><br><span class="line">cancel    <span class="keyword">chan</span> subReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> subReq <span class="keyword">struct</span> &#123;</span><br><span class="line">c <span class="keyword">chan</span>&lt;- Event</span><br><span class="line">ok <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Init()&#123;</span><br><span class="line">s.publish = <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line">s.subscribe = <span class="built_in">make</span>(<span class="keyword">chan</span> subReq)</span><br><span class="line">s.cancel = <span class="built_in">make</span>(<span class="keyword">chan</span> subReq)</span><br><span class="line"><span class="keyword">go</span> s.loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Can’t ever have a publish and subscribe  happening at the same time because it’s just single threaded code.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> loop()&#123;</span><br><span class="line">sub := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;- Event]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-s.publish:</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> sub &#123;</span><br><span class="line">c &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> req := &lt;-s.subscribe:</span><br><span class="line"><span class="keyword">if</span> sub[req.c] &#123;</span><br><span class="line">req.ok &lt;- <span class="literal">false</span></span><br><span class="line"><span class="comment">// only break select</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sub[req.c] = <span class="literal">true</span></span><br><span class="line">req.ok &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> req := &lt;-s.cancel:</span><br><span class="line"><span class="keyword">if</span> !sub[req.c] &#123;</span><br><span class="line">req.ok &lt;- <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(req.c)</span><br><span class="line"><span class="built_in">delete</span>(sub, req.c)</span><br><span class="line">req.ok &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Publish(e Event)&#123;</span><br><span class="line">s.publish &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Subscribe(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">req := subReq&#123;</span><br><span class="line">c:  c,</span><br><span class="line">ok: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line">s.subscribe &lt;- req</span><br><span class="line"><span class="keyword">if</span> ! &lt;- req.ok&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;pubsub: already subscribed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Cancel(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">req := subReq&#123;</span><br><span class="line">c:  c,</span><br><span class="line">ok: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line">s.cancel &lt;- req</span><br><span class="line"><span class="keyword">if</span> ! &lt;- req.ok&#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;pubsub: not subscribed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Convert mutexes into goroutines when it makes programs clearer. But implement raft probably prefer the state with the mutex is because raft is so different from most concurrent programs and that like each replica is just kind of profoundly uncertain of its state.</p></li><li><p>Deal with the slow subscribers, keep the overall program from blocking. Main loop goroutine will send the events to the helper.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> q []Event</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-in:</span><br><span class="line">q = <span class="built_in">append</span>(q, e)</span><br><span class="line"><span class="keyword">case</span> out &lt;- q[<span class="number">0</span>]:</span><br><span class="line">q = q[:<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Improvement: if queue is empty send to empty channel<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> q []Event</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="comment">// Decide whether and what to send.</span></span><br><span class="line"><span class="keyword">var</span> sendOut <span class="keyword">chan</span>&lt;- Event</span><br><span class="line"><span class="keyword">var</span> next Event</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line">sendOut = out</span><br><span class="line">next = q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-in:</span><br><span class="line">q = <span class="built_in">append</span>(q, e)</span><br><span class="line"><span class="keyword">case</span> sendOut &lt;- next:</span><br><span class="line">q = q[:<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Improvement: the input channel closes and queue is finally empty we can exit<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> q []Event</span><br><span class="line"><span class="keyword">for</span> in != <span class="literal">nil</span> || <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line"><span class="comment">// Decide whether and what to send.</span></span><br><span class="line"><span class="keyword">var</span> sendOut <span class="keyword">chan</span>&lt;- Event</span><br><span class="line"><span class="keyword">var</span> next Event</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line">sendOut = out</span><br><span class="line">next = q[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e, ok := &lt;-in:</span><br><span class="line"><span class="keyword">if</span> !ok&#123;</span><br><span class="line">in = <span class="literal">nil</span> <span class="comment">// stop receiving from in</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">q = <span class="built_in">append</span>(q, e)</span><br><span class="line">fmt.Println(<span class="string">&quot;in&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> sendOut &lt;- next:</span><br><span class="line">q = q[:<span class="number">1</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Every time we get a new subscription we make a helper channel. If you wanted to have a different strategy for clients that fall too far behind that can modify the code in the helper.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> loop()&#123;</span><br><span class="line"><span class="comment">//map from subscribe channel to helper in channel</span></span><br><span class="line">sub := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;- Event]<span class="keyword">chan</span>&lt;- Event)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-s.publish:</span><br><span class="line"><span class="keyword">for</span> _, helperIn := <span class="keyword">range</span> sub &#123;</span><br><span class="line">helperIn &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> req := &lt;-s.subscribe:</span><br><span class="line"><span class="keyword">if</span> sub[req.c] != <span class="literal">nil</span> &#123;</span><br><span class="line">req.ok &lt;- <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">helperIn := <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line"><span class="keyword">go</span> helper(helperIn, req.c)</span><br><span class="line">sub[req.c] = helperIn</span><br><span class="line">req.ok &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> req := &lt;-s.cancel:</span><br><span class="line"><span class="keyword">if</span> sub[req.c] != <span class="literal">nil</span>&#123;</span><br><span class="line">req.ok &lt;- <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(sub[req.c])</span><br><span class="line"><span class="built_in">delete</span>(sub, req.c)</span><br><span class="line">req.ok &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Hint: you can use goroutines a lot of the time to separate independent concerns.</p></li></ul><h1 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h1><ul><li><p>在上文Russ Cox的代码中，Subscribe的参数使用的是单向channel，但是在实际中subscribe后还应该把值拿出来处理，所以参数改为双向channel就好了。<br>（对于<code>chan&lt;-</code> 和<code>&lt;-chan</code>的提示：因为上面对于订阅者（subscription）来讲，并不需要拿出值消费，所以传一个<code>chan&lt;- Event</code>去让server发送消息给它，因为这个channel只能用来发送，以达到发送的目的）</p><blockquote><p>The optional <code>&lt;-</code> operator specifies the channel <em>direction</em>, <em>send</em> or <em>receive</em>. If no direction is given, the channel is <em>bidirectional</em>.</p><p><code>chan&lt;- float64 // can only be used to send float64s</code><br><code>&lt;-chan int // can only be used to receive ints</code></p></blockquote></li><li><p>下面的代码创建了10个subscription后接着publish 100个event，每个subscription拿到event后会sleep一下再打印出来，模拟不同的消费速度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetFlags(log.LstdFlags | log.Lmicroseconds)</span><br><span class="line">pubsub := Server&#123;&#125;</span><br><span class="line">pubsub.Init()</span><br><span class="line"></span><br><span class="line">subscriptionCount := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;create a lot of subscription channel&quot;</span>)</span><br><span class="line">subscriptionChannels := <span class="built_in">make</span>([]<span class="keyword">chan</span> Event, subscriptionCount, subscriptionCount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> subscriptionChannels &#123;</span><br><span class="line">subscriptionChannels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line">pubsub.Subscribe(subscriptionChannels[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer := <span class="function"><span class="keyword">func</span><span class="params">(subscriptionIndex <span class="type">int</span>, c <span class="keyword">chan</span> Event)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> event := <span class="keyword">range</span> c&#123;</span><br><span class="line">generator := rand.New(rand.NewSource(time.Now().UnixNano() + <span class="type">int64</span>(subscriptionIndex*<span class="number">1000</span>)))</span><br><span class="line">max, min := <span class="number">15.0</span>, <span class="number">2.0</span> <span class="comment">// random 2~15</span></span><br><span class="line">n := min + generator.Float64() * (max - min)</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Duration(n)*time.Second)</span><br><span class="line">log.Println(<span class="string">&quot;consumer&quot;</span>, subscriptionIndex, <span class="string">&quot;time.sleep&quot;</span>, n, <span class="string">&quot;receive&quot;</span>, event)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;start receive from subscription channel handler&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> subscriptionChannels&#123;</span><br><span class="line"><span class="keyword">go</span> consumer(i, subscriptionChannels[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;publish Event to all subscription&quot;</span>)</span><br><span class="line">publish := <span class="function"><span class="keyword">func</span><span class="params">(publishCount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; publishCount; i++&#123;</span><br><span class="line">event := Event(fmt.Sprintf(<span class="string">&quot;test-%d&quot;</span>, i))</span><br><span class="line">log.Println(<span class="string">&quot;publish&quot;</span>, event)</span><br><span class="line">pubsub.Publish(event)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> publish(subscriptionCount*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>程序的一个简单流程如下：</p><ul><li>subscribe 10个 subscription channel并启动10个接收Event的goroutine</li><li>启动publish goroutine，设置同时publish 100个event</li><li>s.loop()处理publish，将event传递给每个subscription的helper</li><li>此时消费速度慢于生产速度，但是不会拖延publish进度，因为publish进来的会存到event slice里面再消费</li><li>接收event的channel接收到打印数值</li></ul></li><li>所以Russ Cox其实是用channel进行解耦，并使用slice当作缓存解决消费慢的问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> publish-subscribe </tag>
            
            <tag> concurrency </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>logseq搭配简悦建立自己的知识库</title>
      <link href="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
      <url>/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/oHUJ3Q.gif" alt></p><p>网页标注，自动离线到本地（网页内容+标注），logseq 里面建立双链，同时还可以自动跳转到本地文件具体内容处</p><p>这样的话可以实现一个工作流：</p><ul><li>第一阶段：网页内容标注</li><li>第二阶段：logseq整理建立联系</li><li>第三阶段：Notion知识整合输出（或者是在logseq里面输出也行，可以用很多相关联的双链直接输出一篇文章，而不用反复复制粘贴）</li><li>本地知识库：在第一阶段标注的时候，会自动保存网页内容+标注到本地，个人认为会带来几个好处：<ul><li>避免内容失效404</li><li>搜索相关知识点时候可以先在本地笔记或者缓存目录搜索先，这样相当于是先查找自己的笔记，对知识利用率更高，Windows下可以用FileLocator、Mac可以用DEVONthink</li><li>对于一些英文文章的学习，可以先双语翻译，然后做笔记保存，下次查看时候有双语翻译和笔记，效率提高很多</li><li>网络上文章都是抄来抄去，复制粘贴，对于某些知识点其实完全可以通过双链引用形成一篇文章，内容可以来自官网、著名书籍pdf等，这样就不会学到很多假知识</li></ul></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>参考文章：</p><p><a href="https://github.com/Kenshin/simpread/discussions/2221">当简悦变成你的知识库（离线且具有永久链接） · Discussion #2221 · Kenshin/simpread</a></p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><ol><li>双链笔记软件，比如logseq、思源、obsidian等</li><li>简悦2.0版本以上</li><li>简悦同步助手</li><li>简悦高级账号（需要用到付费功能，12块钱永久<a href="https://afdian.net/@kenshin/plan">https://afdian.net/@kenshin/plan</a>，2021.12.12有效）</li></ol><p>简悦和简悦助手下载最新版就可以了</p><p><a href="http://ksria.com/simpread/wiki/#/Download">简悦百科 | 简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展</a></p><h2 id="产生标注同步到本地"><a href="#产生标注同步到本地" class="headerlink" title="产生标注同步到本地"></a>产生标注同步到本地</h2><p><a href="https://github.com/Kenshin/simpread/discussions/2220">当产生标注时，如何自动同步到本地 · Discussion #2220 · Kenshin/simpread</a></p><h3 id="配置自定义标题"><a href="#配置自定义标题" class="headerlink" title="配置自定义标题"></a>配置自定义标题</h3><p><strong>一定要配置这个，产生的本地文件命名和稍后读助手读取本地缓存什么的都会用到</strong></p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled.png" alt="Untitled"></p><h3 id="开启增强导出功能"><a href="#开启增强导出功能" class="headerlink" title="开启增强导出功能"></a>开启增强导出功能</h3><p>该功能主要利用简悦同步助手将在线网页的内容和标注导出到本地</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%201.png" alt="Untitled"></p><h3 id="配置自动化"><a href="#配置自动化" class="headerlink" title="配置自动化"></a>配置自动化</h3><p><strong>当生成标注时，执行导出 HTML 的功能。因为logseq设置了使用md模式，所以同时还需要导出一个符合logseq语法的md文件。</strong></p><p>这样HTML用于保存完整网页，以及使用链接跳转时候用；md文件则用于在logseq，建立双链、增加笔记、跳转到本地离线文件处等。</p><p>简悦本身导出的md文件格式并不符合logseq要求，所以这里得定制化，定制化教程可看</p><p><a href="https://github.com/Kenshin/simpread/discussions/2513">使用简悦导出含有永久链接与双向链接的 Markdown 并自动保存在 Obsidian 库 · Discussion #2513 · Kenshin/simpread</a></p><p><a href="http://ksria.com/simpread/docs/#/%E5%AE%9A%E5%88%B6%E5%8C%96%E5%AF%BC%E5%87%BA?id=markdown">入门指引 | 简悦 SimpRead - 如杂志般沉浸式阅读体验的扩展</a></p><p>说白了也就是定制简悦输出md的格式是怎么样的，简悦提前定义了一些规则能够让我们重新组织内容，所以这里可以直接抄一下logseq的作业</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#[[excerpt]] [&#123;&#123;title&#125;&#125;](&#123;&#123;url&#125;&#125;) </span></span><br><span class="line">- tags: <span class="comment">#[[SimpRead]] &#123;&#123;tags&#125;&#125;</span></span><br><span class="line">- <span class="built_in">read</span> <span class="built_in">date</span>: [[&#123;&#123;date_format|now|yyyy_MM_dd&#125;&#125; ]]</span><br><span class="line">- desc: &#123;&#123;desc&#125;&#125;</span><br><span class="line">&#123;&#123;#each&#125;&#125;</span><br><span class="line">- [📌](&lt;&#123;&#123;an_int_uri&#125;&#125;&gt;)  &#123;&#123;an_html&#125;&#125;</span><br><span class="line">&#123;&#123;&gt;|an_note&#125;&#125;&#123;&#123;an_tags&#125;&#125;</span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><p>（这里的定制化折腾了很久，主要是各种不生效，各种尝试，折腾了很久，还好群里面的人热心）</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%202.png" alt="Untitled"></p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%203.png" alt="Untitled"></p><p>怎么使用上面的模板呢</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%204.png" alt="Untitled"></p><p><strong>注意第4点，必须要改成这样，不然生成的标注永久链接缺少序号，链接不对。同时需要注意一点，在使用简悦网页标注的时候，不能使用简悦的设置，这样会造成设置冲突。</strong></p><p><strong>所以想要测试模板的时候，先填好模板，等几秒简悦保存（没有保存按钮emmm），然后刷新下设置页面看看有没有设置成功，接着可以去标注测试生成的内容了。</strong></p><hr><p>设置了模板之后，可以配置自动化，当标注的时候会自动保存网页全文内容+标注到本地</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%205.png" alt="Untitled"></p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%206.png" alt="Untitled"></p><p>导出的内容可以定制化</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%207.png" alt="Untitled"></p><h2 id="让稍后读支持读取本地缓存"><a href="#让稍后读支持读取本地缓存" class="headerlink" title="让稍后读支持读取本地缓存"></a>让稍后读支持读取本地缓存</h2><p>简悦还有一大功能是稍后读，看字面意思就是将想要看的内容统一保存到一个地方，然后有时间时候深度阅读。</p><p>这个教程其实不会用到稍后读，不过因为涉及到导出本地文件时的路径和配置的完整性，所以在这里面也配置一下。</p><p><a href="https://github.com/Kenshin/simpread/discussions/2146">如何让稍后读支持读取本地缓存 · Discussion #2146 · Kenshin/simpread</a></p><h3 id="配置同步助手的导出文件夹"><a href="#配置同步助手的导出文件夹" class="headerlink" title="配置同步助手的导出文件夹"></a>配置同步助手的导出文件夹</h3><p>第一次配置同步助手教程可看</p><p><a href="https://github.com/Kenshin/simpread/discussions/2754">[新手教程]如何安装和配置同步助手 · Discussion #2754 · Kenshin/simpread</a></p><p>教程写的很详细，不一定要用坚果云，坚果云用来同步文件，换OneDrive，Dropbox都可以。</p><hr><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%208.png" alt="Untitled"></p><p>上面那个路径是简悦生成本地文件后保存的路径，根据上面的配置，会生成四个文件</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%209.png" alt="Untitled"></p><p>第一个是网页原内容，第二个是网页原内容md，第三是带有标注的网页原内容，第四个标注内容md</p><h3 id="配置稍后读"><a href="#配置稍后读" class="headerlink" title="配置稍后读"></a>配置稍后读</h3><p>直接复制官方教程了</p><p>选项页 → 高级设定 → 稍后读（<strong>必须要开启下面的选项</strong>）</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%2010.png" alt="Untitled"></p><p>打开稍后读 → 左下角 → 打开选项页，并勾选下面的选项</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%2011.png" alt="Untitled"></p><p>达成的效果是这样</p><p><img src="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/Untitled%2012.png" alt="Untitled"></p><p>会优先读取本地已缓存的文件，不过这个教程并没有用过这个。感觉这个在上面的工作流（网页标注→logseq→Notion）更多是标注一次完了之后，想要第二次第三次继续标注的时候使用的，这样就不用重新进入网页，同时这个本地缓存文件可以带上双语翻译，实在是很nice，具体教程看</p><p><a href="https://github.com/Kenshin/simpread/discussions/3182">使用彩云小译实现双语翻译并同时保存在本地 · Discussion #3182 · Kenshin/simpread</a></p><p>稍后读作用还不止现在谈到的这些，具体了解可以看简悦官网介绍。</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>上面配置完之后就可以看到文章开头的结果啦。</p>]]></content>
      
      
      <categories>
          
          <category> 知识管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识管理 </tag>
            
            <tag> logseq </tag>
            
            <tag> 简悦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JetBrains Gateway远程开发初体验</title>
      <link href="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://www.jetbrains.com/remote-development/gateway/">Remote Development with JetBrains Gateway</a></p><blockquote><p>JetBrains Gateway is a compact desktop app that allows you to work remotely with a JetBrains IDE without even downloading one<br>JetBrains Gateway是一个轻量的桌面应用程序，允许在不下载JetBrains IDE的情况下远程使用JetBrains IDE</p></blockquote><p>白话介绍一下：通过使用该软件ssh连接到Linux环境，自动下载IDE到Linux并配置，稍等一会本地会弹出个IDE窗口进行工作。</p><p>具体效果看下图：</p><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/nelj4-egcsq.gif" alt></p><h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><h2 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h2><p>Gateway目前只支持在Linux上配置（后续会支持macOS 和 Windows），所以需要一个Linux，由于用的是Windows，所以最简单方式就是安装一个VMware，然后到<a href="https://www.linuxvmimages.com/images/centos-8/#centos-842105">https://www.linuxvmimages.com/images/</a>下载一个为VMware处理好的镜像，下载完成后直接打开即可。</p><p>第一个尝试的发行版是VMware官方制作的一个专门为云原生打造的发行版Photon，主要特点是轻量，占用空间和启动时间少，针对云计算和云应用程序进行了优化。</p><p><a href="https://vmware.github.io/photon/assets/files/html/3.0/Introduction.html">Introduction to Photon OS</a></p><p>不过Gateway对该镜像兼容性较差，会一直卡进度条，等了好久之后提示<code>Failed to get IDE status in 60 seconds. Probably IDE backend is stuck</code>。同样试过<code>debian11</code>也是如此。</p><ul><li>官方例举了几个支持的发行版：<code>Ubuntu 16.04+、RHEL/Centos 7+</code> ，目前用的是centos8，比较稳定，不会出现重启后重连不上的情况。当然也可以在<code>glibc-based docker</code>中运行（例如Alpine就不属于）。</li><li>推荐配置：<code>2+ cores, 4GB+ of RAM, and 5GB+ of disk space</code></li></ul><h2 id="JetBrains"><a href="#JetBrains" class="headerlink" title="JetBrains"></a>JetBrains</h2><p>接着就是要下载软件连接了。可以直接下载JetBrains Gateway或者使用最新版IDE里面内置的Gateway软件</p><ul><li>在Gateway里面能下载的应用有：</li></ul><blockquote><p>IntelliJ IDEA Ultimate, PyCharm Professional, GoLand, WebStorm, CLion, PhpStorm, and RubyMine starting from version 2021.3 of these IDEs.</p></blockquote><ul><li>最新版IDE里面内置Gateway的软件有：</li></ul><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled.png" alt="Untitled"></p><p>经验证（截至2021.12.04），使用IDE里面的Gateway功能比独立的JetBrains Gateway好用，不会出现连接过程中卡死的情况。</p><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled%201.png" alt="Untitled"></p><p>当然使用本地IDE内地Gateway功能还有另外一个好处是Linux上面的IDE可以使用本地IDE的许可证（狗脸）。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled%202.png" alt="Untitled"></p><p>点击新建一个SSH连接</p><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled%203.png" alt="Untitled"></p><p>填好后点击继续</p><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled%204.png" alt="Untitled"></p><p>选择IDE版本、工作目录后点击确认按钮就可以自动下载IDE并配置了，稍等片刻就会弹出一个IDE窗口，期间不用配置任何东西，够傻瓜式。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><a href="https://www.jetbrains.com/help/idea/remote-development-overview.html#defs">Remote development overview | IntelliJ IDEA</a></p><p><img src="/2021/12/06/JetBrains%20Gateway%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E5%88%9D%E4%BD%93%E9%AA%8C/Untitled%205.png" alt="Untitled"></p><p>远程开发总共有两种模式：</p><ul><li>server to client：在server上启动 IDE Backend获取链接，client连接</li><li>client to server：server上没有安装IDE，client使用Gateway为server自动配置好环境并连接</li></ul><p>一般用户使用client to server模式多一点，流程如下：</p><ol><li>client下载并安装 JetBrains Gateway</li><li>启动Gateway，选择Connect via SSH以连接到server</li><li>如果server上没有 IDE，JetBrains Gateway 会下载它。IDE 可以从 JetBrains 服务器下载、从client计算机上传或从自定义位置下载。</li><li>client通过RD协议与IDE Backend互联，下载特定版本的JetBrans Client。</li><li>JetBrains Gateway 在server上启动 IntelliJ IDEA进程，建立 TCP 隧道，并使用适当的参数启动 JetBrains Client 以使其可以连接。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>telegram聊天记录入库elk</title>
      <link href="/2021/11/15/telegram%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%85%A5%E5%BA%93elk/"/>
      <url>/2021/11/15/telegram%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%85%A5%E5%BA%93elk/</url>
      
        <content type="html"><![CDATA[<p>telegram中文搜索功能一直很差，但是telegram上面的内容搜索引擎却又无法索引，虽然已经有大佬做了一个专门的telegram引擎，但是只覆盖到部分群组，没有我想要的群组，为此抽空搞了下elk的方案去索引聊天记录</p><p><strong>（仅用来学习交流，勿用于不符合法律法规操作）</strong></p><p><a href="https://www.sssoou.com/">telegram中文搜索</a></p><h1 id="docker-elk"><a href="#docker-elk" class="headerlink" title="docker-elk"></a>docker-elk</h1><h2 id="docker-compose启动"><a href="#docker-compose启动" class="headerlink" title="docker-compose启动"></a>docker-compose启动</h2><p>安装elk最快的方式自然是docker的方式，es官方提供了dockerfile，只需要使用docker-compose启动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deviantony/docker-elk</span><br><span class="line">cd docker-elk</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>第一次下载镜像可能会慢点，安装完成后可以测试一下有没有安装成功了，浏览器访问kibana控制台即可<a href="http://127.0.0.1:5601。">http://127.0.0.1:5601。</a></p><h2 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h2><p>安装好后修改一下默认密码，免得出什么问题。对服务默认的账户进行默认密码重置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec -T elasticsearch bin/elasticsearch-setup-passwords auto --batch</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Changed password for user apm_system</span><br><span class="line">PASSWORD apm_system = rcTzsAV</span><br><span class="line"></span><br><span class="line">Changed password for user kibana_system</span><br><span class="line">PASSWORD kibana_system = awWKyX2H</span><br><span class="line"></span><br><span class="line">Changed password for user kibana</span><br><span class="line">PASSWORD kibana = awWKyX2Hx</span><br><span class="line"></span><br><span class="line">Changed password for user logstash_system</span><br><span class="line">PASSWORD logstash_system = zXhnmei</span><br><span class="line"></span><br><span class="line">Changed password for user beats_system</span><br><span class="line">PASSWORD beats_system = UQtnmc2Fi</span><br><span class="line"></span><br><span class="line">Changed password for user remote_monitoring_user</span><br><span class="line">PASSWORD remote_monitoring_user = Z6E9AJR</span><br><span class="line"></span><br><span class="line">Changed password for user elastic</span><br><span class="line">PASSWORD elastic = gkKDmNLRl</span><br></pre></td></tr></table></figure><p>（以上密码只是示例）</p><p>重置之后，接着修改下之前从git拉取下来的配置文件即可，主要涉及到三个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-elk/logstash/config/logstash.yml</span><br><span class="line">docker-elk/logstash/pipeline/logstash.conf</span><br><span class="line">docker-elk/kibana/config/kibana.yml</span><br></pre></td></tr></table></figure><p>对应上图输出的命令输出修改账号和密码即可</p><ul><li><p>docker-elk/kibana/config/kibana.yml</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: 0.0.0.0</span><br><span class="line">elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]</span><br><span class="line">monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># X-Pack security credentials</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">elasticsearch.username: kibana_system</span></span><br><span class="line">elasticsearch.password: awWKyX2H</span><br><span class="line"></span><br><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br></pre></td></tr></table></figure></li><li><p>docker-elk/logstash/config/logstash.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">http.host: &quot;0.0.0.0&quot;</span><br><span class="line">xpack.monitoring.elasticsearch.hosts: [ &quot;http://elasticsearch:9200&quot; ]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># X-Pack security credentials</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">xpack.monitoring.enabled: <span class="literal">true</span></span></span><br><span class="line">xpack.monitoring.elasticsearch.username: logstash_system</span><br><span class="line">xpack.monitoring.elasticsearch.password: zXhnmei</span><br></pre></td></tr></table></figure></li><li><p>docker-elk/logstash/pipeline/logstash.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">beats &#123;</span><br><span class="line">port =&gt; 5044</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tcp &#123;</span><br><span class="line">port =&gt; 5000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Add your filters / logstash plugins configuration here</span></span></span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line">hosts =&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">user =&gt; &quot;elastic&quot;</span><br><span class="line">password =&gt; &quot;gkKDmNLRl&quot;</span><br><span class="line">ecs_compatibility =&gt; disabled</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>接着输入<code>docker-compose restart</code>重启即可</p><h2 id="登录kibana"><a href="#登录kibana" class="headerlink" title="登录kibana"></a>登录kibana</h2><p>地址：<a href="http://127.0.0.1:5601">http://127.0.0.1:5601</a></p><p>账号：<code>elastic</code></p><p>密码：<code>gkKDmNLRl</code></p><h1 id="telegram聊天记录入库"><a href="#telegram聊天记录入库" class="headerlink" title="telegram聊天记录入库"></a>telegram聊天记录入库</h1><h2 id="获取聊天记录"><a href="#获取聊天记录" class="headerlink" title="获取聊天记录"></a>获取聊天记录</h2><h3 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h3><p>在手机浏览器（电脑注册可能会出现error情况，尚未明确原因，可能和去广告插件或者代理有关）上面访问<a href="https://my.telegram.org/apps">https://my.telegram.org/apps</a>，注册一个应用，url不用填</p><p>获取到<strong>api_id</strong>和<strong>api_hash</strong>即可</p><h3 id="api封装"><a href="#api封装" class="headerlink" title="api封装"></a>api封装</h3><p>telegtam提供了众多api并有自己的私有协议，自己实现起来略复杂，不然直接用封装好的即可，看了一圈，发现telethon比较完善：<a href="https://github.com/LonamiWebs/Telethon">LonamiWebs/Telethon: Pure Python 3 MTProto API Telegram client library, for bots too!</a></p><p>说明文档里面提到的这几个包可以安装一下，主要用来提升代码运行效率</p><p><img src="/2021/11/15/telegram%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%85%A5%E5%BA%93elk/1.png"></p><p><a href="https://docs.telethon.dev/en/latest/basic/installation.html">Installation — Telethon 1.23.0 documentation</a></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> telethon <span class="keyword">import</span> TelegramClient</span><br><span class="line"><span class="variable language_">self</span>.client = TelegramClient(<span class="string">&#x27;anon&#x27;</span>, api_id, api_hash, proxy=(<span class="string">&quot;http&quot;</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8118</span>))</span><br></pre></td></tr></table></figure><p>这里如果要使用代理访问api的话，需要安装下面教程安装下相关依赖</p><p><a href="https://docs.telethon.dev/en/latest/basic/signing-in.html?highlight=proxy#signing-in-behind-a-proxy">https://docs.telethon.dev/en/latest/basic/signing-in.html?highlight=proxy#signing-in-behind-a-proxy</a><br>第一个参数会在运行脚本的当前目录下生成<code>anon.session</code>文件，第一次登录后后面不需要登录了。</p><h3 id="获取到频道的聊天记录"><a href="#获取到频道的聊天记录" class="headerlink" title="获取到频道的聊天记录"></a>获取到频道的聊天记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">load_history_to_save</span>(<span class="params">self</span>):</span><br><span class="line">    entity = <span class="keyword">await</span> <span class="variable language_">self</span>.client.get_entity(channel_id)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> <span class="variable language_">self</span>.client.iter_messages(entity, reverse=<span class="literal">True</span>, offset_id=latest_id, limit=<span class="literal">None</span>):</span><br><span class="line">        <span class="built_in">print</span>(message.text)</span><br></pre></td></tr></table></figure><p>上面可以获取到某一个频道的所有聊天记录</p><ul><li>channel_id：频道id，在telegram客户端可查看，比如<code>archlinux-cn-offtopic</code>群的id是<code>-1001094615131</code></li><li>reverse：按照时间从最旧到最新的顺序输出日志</li><li>message：信息封装对象，具体属性可看<a href="https://docs.telethon.dev/en/latest/quick-references/objects-reference.html?highlight=message#message">https://docs.telethon.dev/en/latest/quick-references/objects-reference.html?highlight=message#message</a></li><li>offset_id：因为导出记录较大，所以可能一次性导入不太可能，需要记录已经导出的位置。</li></ul><h2 id="入库es"><a href="#入库es" class="headerlink" title="入库es"></a>入库es</h2><h3 id="Python操作es"><a href="#Python操作es" class="headerlink" title="Python操作es"></a>Python操作es</h3><p>使用官方的es操作封装库</p><p><a href="https://github.com/elastic/elasticsearch-py">elastic/elasticsearch-py: Official Elasticsearch client library for Python</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="variable language_">self</span>.es = Elasticsearch(<span class="string">&#x27;localhost&#x27;</span>, http_auth=(<span class="string">&#x27;elastic&#x27;</span>, <span class="string">&#x27;gkKDmNLRl&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="保存到es"><a href="#保存到es" class="headerlink" title="保存到es"></a>保存到es</h3><p>首先需要对上面获取到的message进行格式化，提取出想要的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> telethon.utils <span class="keyword">import</span> get_display_name</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">format_message</span>(<span class="params">self, message, chat_id</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> message.text <span class="keyword">or</span> message.media:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    chat = <span class="keyword">await</span> message.get_chat()</span><br><span class="line"></span><br><span class="line">    chat_display_name = get_display_name(chat)</span><br><span class="line">    sender_user = <span class="keyword">await</span> message.get_sender()</span><br><span class="line">    doc_data = &#123;</span><br><span class="line">        <span class="string">&quot;timestamp&quot;</span>: message.date,</span><br><span class="line">        <span class="string">&quot;sender&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;username&quot;</span>: <span class="built_in">getattr</span>(sender_user, <span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&quot;firstName&quot;</span>: <span class="built_in">getattr</span>(sender_user, <span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">            <span class="string">&quot;lastName&quot;</span>: <span class="built_in">getattr</span>(sender_user, <span class="string">&#x27;last_name&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;channel&quot;</span>: chat_display_name,</span><br><span class="line">        <span class="string">&quot;channel_id&quot;</span>: chat_id,</span><br><span class="line">        <span class="string">&quot;text&quot;</span>: <span class="variable language_">self</span>.converter.convert(message.text),</span><br><span class="line">        <span class="string">&quot;message_id&quot;</span>: message.<span class="built_in">id</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doc_data</span><br></pre></td></tr></table></figure><p>然后保存到es即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> elasticsearch <span class="keyword">import</span> Elasticsearch</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># key：channel_id, value：已保持到es的最新的id</span></span><br><span class="line"><span class="variable language_">self</span>.channel_dict = &#123;</span><br><span class="line">    -<span class="number">1001094615131</span>: <span class="number">0</span>,  <span class="comment"># archlinux-cn-offtopic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">save_to_es</span>(<span class="params">self, doc_data, message_id, channel_id</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> doc_data:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.es.index(index=<span class="string">&#x27;telegram&#x27;</span>, document=doc_data)</span><br><span class="line">    <span class="comment"># 保存最新id到文本中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.channel_dict[channel_id] &lt; message_id:</span><br><span class="line">        <span class="variable language_">self</span>.channel_dict[channel_id] = message_id</span><br><span class="line">        FileDict.save_obj(<span class="variable language_">self</span>.channel_dict, <span class="string">&#x27;latest_id&#x27;</span>)</span><br><span class="line">        logger.info(<span class="string">&#x27;成功存储:&#123;&#125;-&#123;&#125;-&#123;&#125;&#x27;</span>, doc_data[<span class="string">&quot;channel&quot;</span>], message_id, doc_data[<span class="string">&quot;timestamp&quot;</span>])</span><br></pre></td></tr></table></figure><p>这里将已保存到es的消息的最新id保存到文本中，每次保存一条记录就更新id，用于保存已经处理的位置</p><p>使用自带的<code>pickle</code>将<code>dict</code>保存到文本中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDict</span>:</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_file_path</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="keyword">return</span> os.path.join(<span class="string">&#x27;obj&#x27;</span>, name + <span class="string">&#x27;.pkl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_obj</span>(<span class="params">obj, name</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&#x27;obj&#x27;</span>):</span><br><span class="line">            os.makedirs(<span class="string">&#x27;obj&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(FileDict.get_file_path(name), <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            pickle.dump(obj, f, pickle.HIGHEST_PROTOCOL)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">load_obj</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(FileDict.get_file_path(name), <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> pickle.load(f)</span><br></pre></td></tr></table></figure><p>所以，在脚本刚启动的时候还需要初始化一下最新的id</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_latest_channel_message_id</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从文本中读取到最新保存到es的id并更新到变量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        latest_dict = FileDict.load_obj(<span class="string">&#x27;latest_id&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> channel_id, _ <span class="keyword">in</span> <span class="variable language_">self</span>.channel_dict.items():</span><br><span class="line">            <span class="keyword">if</span> channel_id <span class="keyword">in</span> latest_dict:</span><br><span class="line">                <span class="variable language_">self</span>.channel_dict[channel_id] = latest_dict[channel_id]</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>完善代码拉取数据和保存到es代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">load_history_to_save</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从api拉取数据并保存到es&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> channel_id, latest_id <span class="keyword">in</span> <span class="variable language_">self</span>.channel_dict.items():</span><br><span class="line">        entity = <span class="keyword">await</span> <span class="variable language_">self</span>.client.get_entity(channel_id)</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> message <span class="keyword">in</span> <span class="variable language_">self</span>.client.iter_messages(entity, </span><br><span class="line">                                                       reverse=<span class="literal">True</span>, offset_id=latest_id, limit=<span class="literal">None</span>):</span><br><span class="line">            doc_data = <span class="keyword">await</span> <span class="variable language_">self</span>.format_message(message, channel_id)</span><br><span class="line">            <span class="keyword">await</span> <span class="variable language_">self</span>.save_to_es(doc_data, message.<span class="built_in">id</span>, channel_id)</span><br></pre></td></tr></table></figure><p>启动脚本运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="variable language_">self</span>.client:</span><br><span class="line"><span class="variable language_">self</span>.client.loop.run_until_complete(<span class="variable language_">self</span>.load_history_to_save())</span><br></pre></td></tr></table></figure><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="/2021/11/15/telegram%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%85%A5%E5%BA%93elk/2.png"></p><p><img src="/2021/11/15/telegram%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%E5%85%A5%E5%BA%93elk/3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> telegram </tag>
            
            <tag> elk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>退休计划p1-为何讲起财产自由</title>
      <link href="/2021/11/09/%E9%80%80%E4%BC%91%E8%AE%A1%E5%88%92p1-%E4%B8%BA%E4%BD%95%E8%AE%B2%E8%B5%B7%E8%B4%A2%E4%BA%A7%E8%87%AA%E7%94%B1/"/>
      <url>/2021/11/09/%E9%80%80%E4%BC%91%E8%AE%A1%E5%88%92p1-%E4%B8%BA%E4%BD%95%E8%AE%B2%E8%B5%B7%E8%B4%A2%E4%BA%A7%E8%87%AA%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="财产自由的目标"><a href="#财产自由的目标" class="headerlink" title="财产自由的目标"></a>财产自由的目标</h1><p>最近正在学习费曼学习法，其核心思想是以教代学，用输出倒逼输入，正好近期也看了也谈钱公众号的财产自由的一些文章，有所感悟，整理成了思维导图，用费曼学习法的方式输出，并不断回顾知识。</p><p>财产自由计划我觉得也可以作为退休计划去看待，其实生活中大部分的烦恼来自于工作，如果我们某一天不用为了生计去工作，就不用再被这些烦心事去约束，去把有限的时间投入到无限的热爱的事情中去。</p><p><img src="/2021/11/09/%E9%80%80%E4%BC%91%E8%AE%A1%E5%88%92p1-%E4%B8%BA%E4%BD%95%E8%AE%B2%E8%B5%B7%E8%B4%A2%E4%BA%A7%E8%87%AA%E7%94%B1/Untitled.png" alt="Untitled"></p><p>当然，财产自由是不想干什么就可以不想干什么，而不是想干什么就干什么</p><h1 id="财产自由对比财产富裕"><a href="#财产自由对比财产富裕" class="headerlink" title="财产自由对比财产富裕"></a>财产自由对比财产富裕</h1><p>这里就直接引用也大的话来讲：</p><blockquote><p>财务自由和财务富裕实际是两个概念。自由是个相对值，起点越低、欲望越少，自由也越容易，每个人都可以通过自我管理来实现；而富裕是个绝对值，严格来讲并非人人可及。这里我们只谈财务自由，不谈富裕。</p></blockquote><p><img src="/2021/11/09/%E9%80%80%E4%BC%91%E8%AE%A1%E5%88%92p1-%E4%B8%BA%E4%BD%95%E8%AE%B2%E8%B5%B7%E8%B4%A2%E4%BA%A7%E8%87%AA%E7%94%B1/Untitled%201.png" alt="Untitled"></p><p>关键点是自由是每个人都可及，并且通过自我管理就可以实现，每个人都有无限的可能。</p><h1 id="我自己的财产自由计划"><a href="#我自己的财产自由计划" class="headerlink" title="我自己的财产自由计划"></a>我自己的财产自由计划</h1><p>看也大的文章过程中也等于学习知识的一种过程，学习不只是为了记住什么，而是我们通过学习建立自己行之有效的思维框架，并将知识运用到实践中，解决生活和工作中的实际问题。</p><p>所以将实践与知识结合尤为重要，我自己也思考过这方面，但碍于开始计划不久，并没有很多经验，等后续经验充足时候可以分享一下。</p><p>其实开始的时候会碰到很多的问题，这些问题会在更详细的讨论退休计划的时候提出。</p>]]></content>
      
      
      <categories>
          
          <category> 投资 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 退休计划 </tag>
            
            <tag> 财产自由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-Raft中使用锁的建议</title>
      <link href="/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
      <url>/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Raft-Locking-Advice"><a href="#Raft-Locking-Advice" class="headerlink" title="Raft Locking Advice"></a>Raft Locking Advice</h1><p><a href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt</a></p><p>If you are wondering how to use locks in the 6.824 Raft labs, here are some rules and ways of thinking that might be helpful.</p><p>如果您想知道如何在6.824 Raft labs中使用锁，以下是一些可能会有所帮助的规则和思考方法。</p><h1 id="规则1：go-race"><a href="#规则1：go-race" class="headerlink" title="规则1：go race"></a>规则1：go race</h1><p>Rule 1: Whenever you have data that more than one goroutine uses, and at least one goroutine might modify the data, the goroutines should use locks to prevent simultaneous use of the data. The Go race detector is pretty good at detecting violations of this rule (though it won’t help with any of the rules below).</p><p>规则1：当您有多个goroutine使用的数据，并且至少有一个goroutine可能会修改数据时，goroutine应该使用锁来防止同时使用数据。<code>Go race</code>检测器非常擅长检测违反此规则的情况（尽管它对下面的任何规则都没有帮助）。</p><h1 id="规则2：锁住整个代码sequence"><a href="#规则2：锁住整个代码sequence" class="headerlink" title="规则2：锁住整个代码sequence"></a>规则2：锁住整个代码sequence</h1><p>Rule 2: Whenever code makes a sequence of modifications to shared data, and other goroutines might malfunction if they looked at the data midway through the sequence, you should use a lock around the whole sequence.</p><p>规则2：每当代码对共享数据进行一系列修改时，如果其他goroutine查看sequence中间的某个数据，则可能会出现故障，您应该对整个sequence使用锁。</p><p>An example:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line">rf.currentTerm += <span class="number">1</span></span><br><span class="line">rf.state = Candidate</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure><p>It would be a mistake for another goroutine to see either of these updates alone (i.e. the old state with the new term, or the new term with the old state). So we need to hold the lock continuously over the whole sequence of updates. All other code that uses rf.currentTerm or rf.state must also hold the lock, in order to ensure exclusive access for all uses.</p><p>如果另一个goroutine单独看到这些更新中的任何一个（即旧的state和新的term，或者新的term和旧的state），这将是一个错误。所有其他使用rf.currentTerm或rf.state的代码也必须持有该锁，以确保所有使用的独占性。</p><p>The code between Lock() and Unlock() is often called a “critical section.”The locking rules a programmer chooses (e.g.“a goroutine must hold rf.mu when using rf.currentTerm or rf.state”) are often called a “locking protocol”.</p><p><code>Lock()</code>和<code>unlock()</code>之间的代码通常被称为“临界区”。程序员选择的锁定规则（例如，当使用rf.currentTerm或rf.state时，goroutine必须持有<code>rf.mu</code>）通常被称为”锁定协议”。</p><h1 id="规则3：同规则2"><a href="#规则3：同规则2" class="headerlink" title="规则3：同规则2"></a>规则3：同规则2</h1><p>Rule 3: Whenever code does a sequence of reads of shared data (or reads and writes), and would malfunction if another goroutine modified the data midway through the sequence, you should use a lock around the whole sequence.</p><p>规则3：每当代码执行一系列共享数据读取（或读写）时，如果另一个goroutine在该sequence中途修改数据了，则会出现故障，您应该在整个sequence使用锁。</p><p>An example that could occur in a Raft RPC handler:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line"> rf.currentTerm = args.Term</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure><p>This code needs to hold the lock continuously for the whole sequence. Raft requires that currentTerm only increases, and never decreases. Another RPC handler could be executing in a separate goroutine; if it were allowed to modify rf.currentTerm between the if statement and the update to rf.currentTerm, this code might end up decreasing rf.currentTerm. Hence the lock must be held continuously over the whole sequence. In addition, every other use of currentTerm must hold the lock, to ensure that no other goroutine modifies currentTerm during our critical section.</p><p>此代码需要在整个sequence中连续持有锁。Raft要求currentTerm只增不减。另一个RPC处理程序可以在单独的goroutine中执行；如果允许它在if语句和rf.currentTerm更新之间修改rf.currentTerm，则此代码最终可能会减少rf.currentTerm。因此，必须在整个sequence中连续持有锁。此外，currentTerm的每一次其他使用都必须持有锁，以确保在我们的临界区期间没有其他goroutine修改currentTerm。</p><p>Real Raft code would need to use longer critical sections than these examples; for example, a Raft RPC handler should probably hold the lock for the entire handler.</p><p>真正的Raft代码需要使用比这些示例更长的临界区；例如，Raft RPC处理程序可能应该持有整个处理程序的锁。</p><h1 id="规则4：并发情况下锁释放前后值可能会发生变化"><a href="#规则4：并发情况下锁释放前后值可能会发生变化" class="headerlink" title="规则4：并发情况下锁释放前后值可能会发生变化"></a>规则4：并发情况下锁释放前后值可能会发生变化</h1><p>Rule 4: It’s usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the reply). One reason is that you probably want other goroutines to make progress during the wait. Another reason is deadlock avoidance. Imagine two peers sending each other RPCs while holding locks; both RPC handlers need the receiving peer’s lock; neither RPC handler can ever complete because it needs the lock held by the waiting RPC call.</p><p>规则4：在执行任何可能等待的操作时保持锁定通常不是一个好主意：读取channel、发送channel、等待timer、调用time.sleep()或发送RPC(并等待回复)。其中一个原因是，可能希望其他goroutine在等待期间能够继续执行代码。另一个原因是避免死锁。设想两个peer在持有锁的同时相互发送RPC；两个RPC处理程序都需要接收peer的锁；两个RPC处理程序都无法完成，因为它需要等待的RPC调用持有的锁。</p><p>Code that waits should first release locks. If that’s not convenient, sometimes it’s useful to create a separate goroutine to do the wait.</p><p>等待的代码应该首先释放锁。如果这不方便，有时创建一个单独的goroutine来执行等待是很有用的。</p><p>Rule 5: Be careful about assumptions across a drop and re-acquire of a lock. One place this can arise is when avoiding waiting with locks held. For example, this code to send vote RPCs is incorrect:</p><p>对于锁的释放和重新获取的假设（if语句）要小心，可能出现这种情况的一个地方是避免持有锁的等待。例如，发送投票RPC的代码是错误的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line">rf.currentTerm += <span class="number">1</span></span><br><span class="line">rf.state = Candidate</span><br><span class="line"><span class="keyword">for</span> &lt;each peer&gt; &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args.Term = rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)</span><br><span class="line">    <span class="comment">// handle the reply...</span></span><br><span class="line">  &#125; ()</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure><p>The code sends each RPC in a separate goroutine. It’s incorrect because args.Term may not be the same as the rf.currentTerm at which the surrounding code decided to become a Candidate. Lots of time may pass between when the surrounding code creates the goroutine and when the goroutine reads rf.currentTerm; for example, multiple terms may come and go, and the peer may no longer be a candidate. One way to fix this is for the created goroutine to use a copy of rf.currentTerm made while the outer code holds the lock. Similarly, reply-handling code after the Call() must re-check all relevant assumptions after re-acquiring the lock; for example, it should check that rf.currentTerm hasn’t changed since the decision to become a candidate.</p><p>该代码在一个单独的goroutine中发送每个RPC。这是不正确的，因为args.Term可能与周围代码决定成为候选者的rf.currentTerm不一样。从周围的代码创建goroutine到goroutine读取rf.currentTerm之间可能会经过很多时间；例如，多个term可能来来去去去，该peer可能不再是候选人。解决这个问题的一个方法是，创建的goroutine使用在外层代码持有锁的时候创建的rf.currentTerm的副本。类似地，Call()后的应答处理代码必须在重新获取锁后重新检查所有相关假设；例如，它应该检查rf.currentTerm在决定成为候选人之后没有改变。</p><h1 id="如何正确加锁"><a href="#如何正确加锁" class="headerlink" title="如何正确加锁"></a>如何正确加锁</h1><p>It can be difficult to interpret and apply these rules. Perhaps most puzzling is the notion in Rules 2 and 3 of code sequences that shouldn’t be interleaved with other goroutines’ reads or writes. How can one recognize such sequences? How should one decide where a sequence ought to start and end?</p><p>解释和应用这些规则可能会很困难。也许最令人困惑的是规则2和规则3中的代码sequence的概念，这些代码序列不应该与其他 goroutine 的读或写交错。人们如何识别这样的sequence？我们应该如何决定一个sequence应该从哪里开始和结束？</p><p>One approach is to start with code that has no locks, and think carefully about where one needs to add locks to attain correctness. This approach can be difficult since it requires reasoning about the correctness of concurrent code.</p><p>一种方法是从没有锁的代码开始，仔细考虑需要在何处添加锁以实现正确性。 这种方法可能很困难，因为它需要对并发代码的正确性进行推理。</p><p>A more pragmatic approach starts with the observation that if there were no concurrency (no simultaneously executing goroutines), you would not need locks at all. But you have concurrency forced on you when the RPC system creates goroutines to execute RPC handlers, and because you need to send RPCs in separate goroutines to avoid waiting. You can effectively eliminate this concurrency by identifying all places where goroutines start (RPC handlers, background goroutines you create in Make(), &amp;c), acquiring the lock at the very start of each goroutine, and only releasing the lock when that goroutine has completely finished and returns. This locking protocol ensures that nothing significant ever executes in parallel; </p><p>一种更实用的方法首先观察到，如果没有并发(没有同时执行goroutines)，则根本不需要锁。但是，当RPC系统创建goroutine来执行RPC处理程序时，您就会遇到并发问题，因为您需要在单独的goroutine中发送RPC以避免等待。您可以通过确定goroutine开始的所有地方（RPC处理程序，在Make()或者其他地方中创建的后台goroutine），在每个goroutine的最开始获取锁，并仅在该goroutine完全完成并返回时释放锁，从而有效地消除这种并发性。此锁定协议确保不会并行执行任何重要任务；</p><p>the locks ensure that each goroutine executes to completion before any other goroutine is allowed to start. With no parallel execution, it’s hard to violate Rules 1, 2, 3, or 5. If each goroutine’s code is correct in isolation (when executed alone, with no concurrent goroutines), it’s likely to still be correct when you use locks to suppress concurrency. So you can avoid explicit reasoning about correctness, or explicitly identifying critical sections.</p><p>锁确保每个 goroutine 在允许启动任何其他 goroutine 之前执行完成。由于没有并行执行，很难违反规则1、2、3或5。如果每个goroutine的代码在单独执行时是正确的(单独执行时，没有并发的goroutine)，那么当您使用锁来抑制并发性时，它很可能仍然是正确的。因此，您可以避免对正确性进行显式推理，或显式识别关键部分。</p><p>However, Rule 4 is likely to be a problem. So the next step is to find places where the code waits, and to add lock releases and re-acquires (and/or goroutine creation) as needed, being careful to re-establish assumptions after each re-acquire. You may find this process easier to get right than directly identifying sequences that must be locked for correctness.</p><p>然而，规则4可能是个问题。因此，下一步是找到代码等待的位置，并根据需要添加锁释放和重新获取(和/或goroutine创建)，在每次重新获取之后小心地重新建立假设。您可能会发现，与直接识别必须锁定以确保正确性的sequence相比，此过程更容易正确。</p><p>(As an aside, what this approach sacrifices is any opportunity for better performance via parallel execution on multiple cores: your code is likely to hold locks when it doesn’t need to, and may thus unnecessarily prohibit parallel execution of goroutines. On the other hand, there is not much opportunity for CPU parallelism within a single Raft peer.) </p><p>（顺便说一句，这种方法所牺牲的是通过在多个内核上并行执行来获得更好性能的任何机会：你的代码可能会在不需要的时候持有锁，因此可能会不必要地禁止goroutine的并行执行。另一方面，在单个Raft peer中，也没有太多的机会实现CPU并行化。)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> raft </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>即使睡了7.5个小时，我仍然感觉不到精力充沛</title>
      <link href="/2021/10/16/%E5%8D%B3%E4%BD%BF%E7%9D%A1%E4%BA%867.5%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%8D%E7%84%B6%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%B2%BE%E5%8A%9B%E5%85%85%E6%B2%9B/"/>
      <url>/2021/10/16/%E5%8D%B3%E4%BD%BF%E7%9D%A1%E4%BA%867.5%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%8D%E7%84%B6%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%B2%BE%E5%8A%9B%E5%85%85%E6%B2%9B/</url>
      
        <content type="html"><![CDATA[<p>翻译自《I Wasn’t Feeling Refreshed Even After 7.5 Hours of Sleep. Here’s How I Fixed It | by Samir S. | In Fitness And In Health | Medium》</p><span id="more"></span><blockquote><p><a href="https://medium.com/in-fitness-and-in-health/i-wasnt-feeling-refreshed-even-after-7-5-hours-of-sleep-here-s-how-i-fixed-it-f785a51fec15">https://medium.com/in-fitness-and-in-health/i-wasnt-feeling-refreshed-even-after-7-5-hours-of-sleep-here-s-how-i-fixed-it-f785a51fec15</a></p></blockquote><p>Getting enough sleep is perhaps one of the most important things we can do for our health and body. Sleep is a chance for the body to repair itself and to reenergize.</p><p>充足的睡眠可能是我们能为我们的健康和身体做的最重要的事情之一。睡眠是身体自我修复和重新获得能量的机会。</p><p>Ever since I read the book “<em><a href="https://www.amazon.com/Why-We-Sleep-Unlocking-Dreams/dp/1501144324/ref=tmm_pap_swatch_0?_encoding=UTF8&amp;qid=1613271789&amp;sr=8-1">Why We Sleep</a>”</em> by Matthew Walker (not an affiliate link), I became more aware of how sleep virtually impacts every cell in our body and how not getting consistent and adequate high-quality sleep can severely impact our body.</p><p>自从我读了马修·沃克（Matthew Walker）的《为什么我们睡觉》（不是附属链接）一书后，我就更加意识到睡眠实际上是如何影响我们身体的每一个细胞的，以及没有持续和充足的高质量睡眠是如何严重影响我们的身体的。</p><p>I made a promise to myself that I would try to get at least 7 hours of sleep if not more every single night to increase my productivity, effectiveness, and to overall feel more refreshed.</p><p>我对自己承诺，如果每晚睡眠时间不增加的话，至少要保证7个小时的睡眠，以提高我的工作效率和效率，并且让我整体感觉更加精神焕发。</p><p>I would go to bed at around 11 PM and a 7-hour sleeping time equates to a 6 AM wakeup time. Even though 7 hours is a good amount of night rest, I wasn’t feeling refreshed and full of energy when I would wake up at 6 AM. This slump in energy and grogginess would last the whole day and I was feeling extremely sleepy at around 4 PM.</p><p>我会在晚上11点左右上床睡觉，7小时的睡眠时间相当于早上6点起床的时间。尽管7小时是一个很好的夜间休息时间，但是当我早上6点醒来时，我并没有感到精神振奋和充满活力。这种精力下降和昏昏沉沉的感觉会持续一整天，我在下午4点左右感到极度困倦。</p><p>I then considered increasing the 7 hours to 7.5 hours which I felt would be enough and it was. For the first week after I increased my sleeping time to 7.5 hours, I felt consistently refreshed and full of energy. I would feel a bit tired at around 4 PM but not by a lot and at night, I was getting good and restful sleep.</p><p>然后我考虑把7个小时增加到7.5个小时，我觉得这样就足够了。在我把睡眠时间增加到7.5小时后的第一个星期，我感到精神振奋，精力充沛。下午4点左右，我会感到有点累，但不是很累，到了晚上，我睡得很好，也很放松。</p><p>After about 2 weeks of sleeping for around 7.5 hours, it was as if a lightbulb in my head just turned off. 7.5 hours of sleep stopped being enough for me and in the mornings, I stopped waking up feeling full of energy.</p><p>在大约两个星期的7.5小时的睡眠之后，我脑袋里的一个电灯泡就好像刚刚熄灭了一样。7.5小时的睡眠对我来说已经不够用了，到了早上，我醒来时也不再感到精力充沛。</p><p>Instead throughout the night when I was sleeping, I would constantly wake up 7 or 8 times. Not everyone sleeps through the night and instead many people get up at random points at night and then go back to sleep. However in my case, when I would wake up at night, it would take me a solid 10 minutes to go back to sleep again. As soon as I would fall asleep, half an hour later I would wake up again.</p><p>取而代之的是，当我整晚都在睡觉的时候，我会不断地醒来七八次。并不是每个人都会整夜睡觉，相反，许多人会在晚上随机起床，然后再继续睡觉。然而，就我的情况而言，当我晚上醒来时，我需要整整10分钟才能再次入睡。我一睡着，半个小时后又会醒过来。</p><p>This periodic wakening for 7 or 8 times is perhaps what was causing me to feel tired and not enough refreshed even after 7.5 hours of sleep each night.</p><p>这种周期性的7到8次醒来可能是导致我感到疲劳的原因，即使每晚睡7.5个小时也没有足够的精力。</p><p>This had never happened to me before and I was genuinely concerned what was causing this. This cycle continued for another 4 days until I decided that I should again increase my sleeping time to 8 hours. In that case even if I wake up through the night, an extra 30 minutes of sleep could probably help me regain that little bit of lost sleep.</p><p>这在我身上从来没有发生过，我真的很关心是什么导致了这一切。这个循环又持续了4天，直到我决定再次将睡眠时间增加到8小时。在这种情况下，即使我整晚醒来，多睡30分钟也可能帮助我恢复失去的一点点睡眠。</p><p><strong>This actually had the opposite effect.</strong></p><p>这实际上产生了相反的效果。</p><p>After sleeping for 8 hours the first night, I still wasn’t feeling refreshed because I was still periodically waking up all throughout the night. I gave it a 2nd go the other night and I still got the same result.</p><p>在第一个晚上睡了8个小时之后，我仍然感觉不到精神振奋，因为我整晚都还在周期性地醒来。前几天晚上我试了第二次，结果还是一样的。</p><p>That’s when I made the decision to tackle the problem of waking up so many times at night head-on.</p><p>就在那时，我决定解决晚上醒来这么多次的问题。</p><p><em>This was easier said than done.</em></p><p>I first consciously reviewed my daily activities and my daily plans to see if any of those were having an impact on my sleeping routine.</p><p>我首先有意识地回顾了我的日常活动和日常计划，看看这些是否对我的睡眠习惯有影响。</p><p><strong>Here is the list I went through:</strong></p><p>以下是我列出的清单:</p><ul><li><p><strong>Eating:</strong> I get a decent amount of fiber throughout the day. Some of the things that I regularly eat throughout the day are: egg, apple, orange, yogurt, milk, almonds, etc. As you can see, everything is healthy and nothing is really considered junk food. This might not be affecting my sleep.</p><p>  饮食: 我一天中摄入了相当多的纤维。我每天经常吃的东西有: 鸡蛋、苹果、橙子、酸奶、牛奶、杏仁等等。正如你所看到的，一切都是健康的，没有什么是真正被认为是垃圾食品。这可能不会影响我的睡眠。</p></li><li><p><strong>Bed quality:</strong> I sleep in a comfortable mattress with a comfortable blanket and pillow. Lights are kept to a minimum that don’t affect my eyes. This might not be affecting my sleep.</p></li><li>床的质量：我睡在舒适的床垫上，有舒适的毯子和枕头。光线要保持在最低限度，不会影响我的眼睛。这可能不会影响我的睡眠。</li><li><strong>Daily activities:</strong> My daily activities are working on my assignments, exercising, writing articles, using my laptop and phone, etc.</li><li>日常活动：我的日常活动包括作业、锻炼、写文章、使用笔记本电脑和手机等。</li></ul><p><strong>That is when I found the culprit!</strong></p><p>就在那时我找到了罪魁祸首！</p><p>When I was reviewing my daily activities list, I found that I had written: using laptop and phone.Since a majority of my work and assignments are done online, I use my laptop literally the whole day.</p><p>当我回顾我的日常活动清单时，我发现我写了: 使用笔记本电脑和手机。由于我的大部分工作和作业都是在网上完成的，我一整天都在使用我的笔记本电脑。</p><blockquote><p>As soon as I am done eating, I use my laptop.As soon as I am done exercising, I use my laptop.As soon as I am done talking, I use my laptop.<br>我一吃完饭就用我的笔记本电脑。我一做完运动就用我的笔记本电脑。我一说完话就用我的笔记本电脑。</p></blockquote><p>This is not just me. Due to <a href="https://www.reviewofophthalmology.com/article/electronic-device-use-in-the-time-of-covid19">COVID-19</a>, people’s assignments and work have shifted online and with more time being spent at homes due to lockdown, people have no option but to resort to using their digital devices.</p><p>这不仅仅是我。由于新冠病毒的出现，人们的任务和工作都转移到了网络上，而且由于封锁，人们在家里花的时间更多，人们别无选择，只能使用他们的数字设备。</p><p>Even though lockdown is being eased in many countries, some countries such as the UK are still under lockdown. People now have a habit of using their digital devices at every moment and this is the same for me.</p><p>尽管许多国家已经放松了戒严，但是像英国这样的一些国家仍然处于戒严状态。人们现在已经习惯于每时每刻都使用他们的数字设备，这对我来说也是一样。</p><p>In my case, I use my laptop to get my assignments and other stuff done.</p><p>就我而言，我用笔记本电脑完成作业和其他事情。</p><p><strong>Now back to the story.</strong></p><p>Before going to bed at 11 PM, I saw that I would still use my phone for a good 20 minutes before going to bed. Even before then, I would still be using my laptop to squeeze in that bit of extra time to get other assignments done.</p><p>晚上11点睡觉前，我发现我仍然会在睡觉前20分钟使用手机。甚至在那之前，我仍然挤出一点额外的时间会用我的笔记本电脑来完成其他任务。</p><p>I had <a href="https://www.webmd.com/sleep-disorders/sleep-blue-light">recently read</a> that using your digital devices such as phone or laptop before bed can affect sleep quality since the blue light that is emitted by these devices suppresses the secretion of melatonin that is responsible for making us sleepy.</p><p>我最近读到，睡前使用手机或笔记本电脑等数字设备会影响睡眠质量，因为这些设备发出的蓝光会抑制褪黑激素的分泌，而褪黑激素正是导致我们困倦的原因。</p><p>After realizing how much blue light I was being exposed to before bed which was perhaps disrupting my sleep quality, I made a decision to stop using any electronic devices at least 30 minutes before bed.</p><p>在意识到睡前我暴露在多么强烈的蓝光下可能会影响我的睡眠质量之后，我决定至少在睡前30分钟停止使用任何电子设备。</p><p>That 30 minutes comes from the National Sleep Foundation’s <a href="https://www.sclhealth.org/blog/2019/09/why-it-is-time-to-ditch-the-phone-before-bed/">recommendation</a> that people stop using electronic devices at least 30 minutes before bedtime.</p><p>这30分钟来自于美国国家睡眠基金会的建议，建议人们在睡觉前至少30分钟停止使用电子设备。</p><p>After making this change, the results have been nothing short of <strong>MAGICAL!</strong></p><p>在做了这个改变之后，结果简直就是神奇！</p><p>Last night was the 3rd night going without electronic devices at least 30 minutes before bedtime and each of those nights has been peaceful. For the past 3 days, I have been waking up feeling more refreshed and energized than before. I am still sleeping 7.5 hours at night which is the perfect amount for me.</p><p>昨晚是就寝前至少30分钟没有电子设备的第三个晚上，每个晚上都很平静。在过去的3天里，我醒来后感觉比以前更精神焕发、精力充沛。我晚上仍然睡7.5小时，这对我来说是完美的睡眠时间。</p><p>I can’t always stop using my electronic devices at least 30 minutes before bedtime because life gets in the way so I plan on using a built-in blue light filter on my Macbook and iPhone.</p><p>我不能总是在睡觉前至少30分钟停止使用我的电子设备，因为生活会阻碍我，所以我计划在我的Macbook和iphone上使用内置蓝光过滤。</p><p>Apple calls it “Night Shift” and when it is turned on, it changes the color of the screen to pale orange. It kind of gets getting used to but essentially this feature decreases the amount of blue light emitted by the screen which in theory should help you sleep better.</p><p>苹果称其为“Night Shift”，当它被打开时，它会将屏幕的颜色更改为淡橙色。它有点习惯了，但从本质上说，这个功能减少了屏幕发出的蓝光，从理论上讲，这应该会帮助你睡得更好。</p><p>I will try this feature in the upcoming few days by turning it on after sunset so my eyes are not that exposed to the blue light.</p><p>在接下来的几天里，我会尝试在日落后打开这个功能，这样我的眼睛就不会暴露在蓝光下。</p><p><strong>Key Takeaways</strong></p><p>关键要点</p><p>In our modern society, we are too obsessed with our digital devices and because of this, we are constantly being exposed to blue light. This may be affecting our sleep quality without us knowing.</p><p>在我们的现代社会，我们过于沉迷于数字设备，因此，我们经常暴露在蓝光下。这可能会在不知不觉中影响我们的睡眠质量。</p><p>For the next few days, try this:</p><ul><li><p>Stop using your digital devices at least 30 minutes before bedtime</p><p>  睡前至少30分钟停止使用数字设备</p></li><li><p>Use a blue light filter that turns the screen to a pale orange to reduce blue light exposure (Night Shift on Apple devices)</p></li><li>使用蓝光过滤器，将屏幕变成浅橙色，以减少蓝光(苹果设备上的Night Shift)</li></ul><p>Evaluate your sleep quality after making these changes.</p><p>做出这些改变后，评估你的睡眠质量。</p><p>If you see no change in your sleep quality, still stick to these changes because over the long run this can help reduce damage to your eyes and help you sleep better.</p><p>如果你的睡眠质量没有变化，那么还是坚持这些变化，因为从长远来看，这有助于减少对眼睛的伤害，帮助你睡得更好。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 睡眠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火车头使用教程</title>
      <link href="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>声明：本教程无任何盈利目的，仅供学习使用，也不会对网站运行造成负担，请勿用于任何商业用途。</p><h1 id="火车头简介"><a href="#火车头简介" class="headerlink" title="火车头简介"></a>火车头简介</h1><p><a href="http://www.locoy.com/">火车采集器官网-网页抓取工具<em>火车头采集器</em>免费网站采集软件</a></p><blockquote><p>火车采集器，一款专业的互联网数据抓取、处理、分析，挖掘软件，可以灵活迅速地抓取网页上散乱分布的数据信息，并通过一系列的分析处理，准确挖掘出所需数据。火车采集器历经十二年的升级更新，积累了大量用户和良好口碑，是目前最受欢迎的网页数据采集软件。</p></blockquote><p>简单来讲，就是使用软件来简化我们的爬虫过程，在整一个过程中，不需要编写代码就能够实现爬虫逻辑。</p><h1 id="举例爬取任务"><a href="#举例爬取任务" class="headerlink" title="举例爬取任务"></a>举例爬取任务</h1><p>需要分页爬取所有页面，并对页面上所有感兴趣的条目进一步爬取二级URL</p><h1 id="新建任务"><a href="#新建任务" class="headerlink" title="新建任务"></a>新建任务</h1><h2 id="添加一个任务"><a href="#添加一个任务" class="headerlink" title="添加一个任务"></a>添加一个任务</h2><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled.png" alt></p><h2 id="网址采集规则-网址获取"><a href="#网址采集规则-网址获取" class="headerlink" title="网址采集规则-网址获取"></a>网址采集规则-网址获取</h2><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%201.png" alt></p><ul><li>起始网址填上【第一页的URL】</li><li><p>网址获取选项的意思：提取当前页面上想要爬取的条目的URL，比如xx网第一页上的符合条件的所有商品链接。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Z_list-box&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic-box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;//test.com/4343434333555.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pic-wrap&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">alt</span>=<span class="string">&quot;立白洗衣液&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;display: inline&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;ico ico-video&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pic-box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;//test.com/434322425.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pic-wrap&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;lazy&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">alt</span>=<span class="string">&quot;外星人鼠标&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;display: inline&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;ico ico-video&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Z_pages&quot;</span> <span class="attr">id</span>=<span class="string">&quot;page&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  比如当前网页的源码是这样的，想要获取这两件商品的链接，分析网页源码可知商品的链接为<code>//test.com/xx.html</code> ，我们要提取的链接就是这个</p><ul><li>在提取规则里面填入<code>&lt;div class=&quot;pic-box&quot;&gt;(*)href=&quot;[参数]&quot;</code> 这里的<code>&lt;div class=&quot;pic-box&quot;&gt;</code> 代表内容开头的地方；<code>(*)</code> 代表匹配所有内容，<code>href=&quot;[参数]&quot;</code> 代表内容结束，<code>[参数]</code> 则表示想要提取的内容，也就是这里的链接。简而言之，就是指定搜查的区域，然后使用<code>[参数]</code> 提取出内容。</li><li>设置区域可以减少噪音，避免爬取区域外的内容</li></ul></li></ul><h2 id="网址采集规则-分页设置"><a href="#网址采集规则-分页设置" class="headerlink" title="网址采集规则-分页设置"></a>网址采集规则-分页设置</h2><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%202.png" alt></p><p>这里主要设置分页规则，表示不仅要爬当前页，还要爬取所有的页面</p><ul><li>打开无限极分页：任务可以重复运行，如果URL已经爬取过了，那么就不会对该URL执行任务，该选项一般是关闭的，因为我们想要想要不断爬取从而不断获取到新的信息</li><li><p>区域开始结束位置：无限极分页模式下面的两个输入框就是指定获取下一页位置的开始结束区域</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Z_pages&quot;</span> <span class="attr">id</span>=<span class="string">&quot;page&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;//test.com?p=2&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span>2&lt;/a</span><br><span class="line">  &gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;//test.com?p=3&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>3&lt;/a</span><br><span class="line">&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;next&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;//test.com/next&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span>下一页&lt;/a</span><br><span class="line">  &gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;Z_bar&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  这里可以看到分页信息区域的开始结束位置为<code>&lt;div class=&quot;Z_pages&quot; id=&quot;page&quot;&gt;</code> <code>&lt;div class=&quot;Z_bar&quot;&gt;</code></p></li><li><p>地址样式：这里用来提取第几页，比如<code>&lt;a (*)&gt;[参数]&lt;/a&gt;</code> ，参数会提取出数字2、3</p></li><li>分页地址：地址的拼接规则</li></ul><h2 id="内容采集规则"><a href="#内容采集规则" class="headerlink" title="内容采集规则"></a>内容采集规则</h2><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%203.png" alt></p><p>这里设定对前面采集到的URL里面的内容提取的规则，也就是一个个商品详情页的内容</p><ul><li>这里一般设置为从源码获取数据，使用XPath提取，因为这个规则可以直接从Chrome中复制粘贴，比较方便</li><li>对采集到的内容可以进一步，比如去除HTML标签，数据为空跳过等等</li><li>设置好规则后可以填入某一个页面测试提取的规则是否正确</li></ul><h2 id="内容发布规则"><a href="#内容发布规则" class="headerlink" title="内容发布规则"></a>内容发布规则</h2><p>用来指定采集到的内容怎么处理，这里是设置为发送到某个api</p><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%204.png" alt></p><p>点击+号添加规则</p><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%205.png" alt></p><p>新建发布模块</p><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%206.png" alt></p><p>这里指定想要发送给api的参数，其中name就是在【内容采集规则】部分获取到的信息，参数为规则名。</p><p>其他设置不用动即可，直接保存。</p><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%207.png" alt></p><p>接着填入请求的host即可</p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%208.png" alt></p><p>这里有一些常用设置，可选。</p><h1 id="查看爬取到数据"><a href="#查看爬取到数据" class="headerlink" title="查看爬取到数据"></a>查看爬取到数据</h1><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%209.png" alt></p><h1 id="定时任务设置"><a href="#定时任务设置" class="headerlink" title="定时任务设置"></a>定时任务设置</h1><p><img src="/2021/10/08/%E7%81%AB%E8%BD%A6%E5%A4%B4%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Untitled%2010.png" alt></p><p>这里可以指定任务重复运行的规则</p><h1 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h1><p>可使用ios软件bark接受通知，其内容为爬取到的规则，这里使用Golang简单新建了一个api，当软件爬取完成后会将信息发送到该api【内容发布规则里面设置】，然后将消息推送到ios</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/gogf/gf/frame/g&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gogf/gf/net/ghttp&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gogf/gf/os/glog&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gogf/gf/util/gconv&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gogf/gf/util/grand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">Url <span class="type">string</span> <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">TaskType <span class="type">string</span> <span class="string">`json:&quot;task_type&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := g.Server()</span><br><span class="line">s.SetPort(<span class="number">8080</span>)</span><br><span class="line">_ = glog.SetConfigWithMap(g.Map&#123;</span><br><span class="line"><span class="string">&quot;path&quot;</span>:  <span class="string">&quot;log&quot;</span>,</span><br><span class="line"><span class="string">&quot;level&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line"><span class="string">&quot;file&quot;</span>:  <span class="string">&quot;&#123;Y-m-d&#125;.log&quot;</span>,</span><br><span class="line"><span class="string">&quot;flags&quot;</span>: glog.F_TIME_DATE | glog.F_TIME_MILLI | glog.F_FILE_LONG,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">s.BindHandler(<span class="string">&quot;/send_info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(r *ghttp.Request)</span></span>&#123;</span><br><span class="line">requestId := grand.Letters(<span class="number">16</span>)</span><br><span class="line"><span class="keyword">var</span> info Info</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.ParseForm(&amp;info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">glog.Error(requestId, err)</span><br><span class="line">_ = r.Response.WriteJsonExit(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">glog.Info(requestId, info)</span><br><span class="line"></span><br><span class="line">bark := <span class="string">&quot;https://api.day.app/&#123;xxxxxxxxxxxx&#125;&quot;</span></span><br><span class="line">body := gconv.String(g.Map&#123;</span><br><span class="line"><span class="string">&quot;device_key&quot;</span>: <span class="string">&quot;xxxxxxxxxxxxx&quot;</span>,</span><br><span class="line"><span class="string">&quot;body&quot;</span>: gconv.String(info),</span><br><span class="line"><span class="string">&quot;title&quot;</span>: <span class="string">&quot;商品信息&quot;</span>,</span><br><span class="line"><span class="string">&quot;ext_params&quot;</span>: g.Map&#123;<span class="string">&quot;url&quot;</span>: info.Url&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">glog.Info(requestId, body)</span><br><span class="line"><span class="keyword">if</span> _, err := g.Client().Post(bark, body); err != <span class="literal">nil</span>&#123;</span><br><span class="line">glog.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">s.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客重启</title>
      <link href="/2021/10/06/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/"/>
      <url>/2021/10/06/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo博客重建"><a href="#Hexo博客重建" class="headerlink" title="Hexo博客重建"></a>Hexo博客重建</h1><h2 id="为啥还是Hexo"><a href="#为啥还是Hexo" class="headerlink" title="为啥还是Hexo"></a>为啥还是Hexo</h2><p>博客之前是使用Hexo+Github Page搭建的</p><ul><li>使用Github Page肯定是没有问题，因为只有<del>白嫖</del>的东西才能持久运行，国内访问速度不关键，常年你懂的</li><li>至于静态内容生成框架，有考虑过Hugo，因为生成速度比Hexo快很多，调试方便，同时安装起来比较方便（npm那堆东西恶心一批）。但是Hexo众多主题还是留住我了哈哈哈（真香警告）</li></ul><h2 id="新的主题"><a href="#新的主题" class="headerlink" title="新的主题"></a>新的主题</h2><p>之前的配置博客已经很久了，很多东西已经忘记了，所以这次打算重新配置下，使用新的主题，新年新气象。</p><h3 id="hexo-theme-butterfly"><a href="#hexo-theme-butterfly" class="headerlink" title="hexo-theme-butterfly"></a>hexo-theme-butterfly</h3><p>功能丰富的Hexo博客主题<br>Features：</p><ul><li>卡片式两栏 UI 设计</li><li>响应式布局</li><li>支持搜索和 TOC 展示</li><li>可自定义博客主题色</li><li>支持 Disqus、Gitalk、Valine、Waline 等评论系统</li><li>丰富的动画效果</li><li>内置 Mathjax 和 Katex</li></ul><p>Butterfly 主题的开发基于 Melody 主题，在此基础上做了两栏设计，并带来了很多一眼看不出的实用功能。同时，作者也提供了一些文档便于大家安装和使用，涵盖入门至进阶需求。但我认为这些文档不够连贯，有些功能也没有进行详细介绍，如果可以的话用类似 Gitbook 的平台工具来写会更好。<br>Butterfly 的着陆页和内页设计深得我心，heading、TOC 和代码块样式也恰到好处。它不经可以满足正常的图文需求，也可以根据自己的需求插入音视频素。作者还提供了 PWA 实现、插件注入等进阶玩法，感兴趣的朋友可进行尝试<br>频道：@NewlearnerChannel</p><h3 id="Valine迁移到Twikoo"><a href="#Valine迁移到Twikoo" class="headerlink" title="Valine迁移到Twikoo"></a>Valine迁移到Twikoo</h3><p><a href="https://github.com/imaegoo/twikoo">GitHub - imaegoo/twikoo: 💬 一个简洁、安全、免费的静态网站评论系统 | A simple, safe, free comment system.</a></p><p>之前采用的Valine也不错，不需要登陆就可以回复，简洁，轻便，最近出了一个和其差不多的，腾讯开发，功能比较丰富，特点可在Github上面查看。</p><p>个人觉得好的地方：</p><ul><li>自带评论管理工具</li><li>设置邮件提醒比较方便</li><li>可以点赞</li></ul><p>其部署在Vercel，使用AWS免费的MongoDB保存数据，适用于想要免费部署的用户，在中国大陆访问速度较慢。</p><p>目前的一个不便之处在于：</p><ul><li>支持的图床不够丰富（内置的两个都不怎么好用，不过可以手动上传到sm.ms解决）</li><li>管理页面不能全屏（虽然有方法改主题文件去解决，但是希望还是官方解决好）</li></ul><h2 id="使用Notion搭配"><a href="#使用Notion搭配" class="headerlink" title="使用Notion搭配"></a>使用Notion搭配</h2><p>写作工具迁移历史：本地MarkDown+Github Pages→Notion→三者结合</p><p>为什么要重新搭建激活博客</p><p>因为使用Notion之后不想写作了，写作概率有点低，而且Notion的内容从搜索引擎上面很少搜索得到，希望激活博客后能够找回重新的激情，毕竟有一个自己的博客，看到有成篇的文章，也许会有一种成就感激励自己写作吧。</p><p>Notion确实比较方便，直接使用一个表格就能搭建一个简单的博客，使用表格中自带的功能就能满足需求，而且粘贴图片起来也方便，不像本地MarkDown图片要么图床要么放本地</p><p>所以，综合以上，先在Notion里面写好，然后导出到Hexo博客，结合两者的特点，Notion实时保存，写作方便，适合素材的收集，甚至可以在平时中使用手机写作；而Github Pages则是成篇文章的收集地，方便外对交流，更重要的是数据保存在本地，两份数据互存，毕竟在线文档的数据不是在本地，可能会数据丢失的风险。</p><h1 id="笔记系统"><a href="#笔记系统" class="headerlink" title="笔记系统"></a>笔记系统</h1><p>目前笔记系统还在研究中，暂时找不到完全复合自己需求的，大部分够用</p><h2 id="Inbox和Note"><a href="#Inbox和Note" class="headerlink" title="Inbox和Note"></a>Inbox和Note</h2><p>先下结论，目前的笔记系统：大概分为两个模块：Inbox和Note</p><ul><li>Inbox：用来收集任何时刻、任何方式得到的零碎资讯</li><li>Note：用来存放 Inbox 中经过整理的完整笔记</li></ul><p>很多时候我们零零散散的东西都可以放在Inbox里面，等到时间成熟，或者加以应用后，就可以加工成Note，发布到Hexo博客里面。</p><h2 id="Inbox"><a href="#Inbox" class="headerlink" title="Inbox"></a>Inbox</h2><p>作为程序猿一枚，其实很多东西网上都有，我们很多文章只是缝合怪罢了，故很多知识其实可以放到Inbox里面，直接书签或者使用文章收集工具即可，到时候可以直接在Note里面引用。</p><p>其实这里面没有一个好的工具可以管理这一块，Inbox的来源有很多，比如pdf、网页、手机摘录、app等。更多时候我的需求是在这些来源里面建立索引，而不是复制粘贴全部内容，这样反而会丢失了上下文和其他内容。一旦建立索引，这些索引和索引之间的联系反而才是最重要的吧，这样可以建立起来一个知识网络，通过这个网络我们可以直接定位到知识源，这个知识源可以是pdf里面的某一段话，也可以是某篇文章里面的一句话，或者是自己写的文章等等。这样收集起来比较方便，而且知识也方便管理。</p><h3 id="简悦"><a href="#简悦" class="headerlink" title="简悦"></a>简悦</h3><p>简悦经常用来将网页的内容保存到Notion，然后在Notion上面划重点，记笔记。</p><p><img src="/2021/10/06/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/Untitled.png" alt></p><h3 id="flomo"><a href="#flomo" class="headerlink" title="flomo"></a>flomo</h3><p>flomo更多是手机端看到文章好句，然后在里面打标签收集</p><p><img src="/2021/10/06/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/Untitled%201.png" alt></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其实还有很多我不知道怎么管理，比如某一本书籍pdf里面的感兴趣部分，某篇论文里面的内容等等，很多时候我是期望能够直接建立索引的方式，而不是复制粘贴的形式（自写的除外）。</p><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>Note的形式有很多，比如博文、思维导图、PPT等，这些都尝试过，但是没有一个好的能够与各个Inbox建立关联。</p><p>在Note部分，我也只是写写文章，然后使用Notion画画思维导图，比如使用目录当思维导图，点击目录可以跳转到对应的源，这个是Notion的一个功能。</p><p><img src="/2021/10/06/%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF/Untitled%202.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实怎么说，笔记这东西还是得靠用，不然也只是吃灰，最近在读《费曼学习法》，感觉会有不少的感悟，想找个时间总结一下，不然看了等于白看，其实这个过程就好像Inbox和Note，Inbox的是在看的时候画重点，Note的则是自己想要总结出来的。</p><p>对于很多笔记软件，我尝试过了很多，比如OneNote、Anki、MarginNote、Obsidian等等，感觉还是没有一个适合我，能够将pdf、网页、摘录等的信息形成一个可视化的知识网络，也有可能是方法不对吧。</p><p>不过，这种不断探索的精神其实是让自己保持好奇，保持初心，保持动力吧，而不至于屈服于干枯的搬运工作中。</p>]]></content>
      
      
      <categories>
          
          <category> 悠闲谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uniapp微信小程序callMethod调研记录</title>
      <link href="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/"/>
      <url>/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="官方模板项目搭建"><a href="#官方模板项目搭建" class="headerlink" title="官方模板项目搭建"></a>官方模板项目搭建</h1><p><a href="https://uniapp.dcloud.io/collocation/auto/quick-start">uni-app官网</a></p><p>这里搭建起来的是官方项目，便于研究自带的测试api</p><h2 id="准备模板"><a href="#准备模板" class="headerlink" title="准备模板"></a>准备模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装vue-cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建项目，选择Hello uni-app模板</span></span><br><span class="line">vue create -p dcloudio/uni-preset-vue#alpha my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装测试依赖包</span></span><br><span class="line">npm install @dcloudio/uni-automator --save-dev</span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改<code>jest.config.js</code> 中的<code>testEnvironmentOptions</code> ，添加以下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testEnvironmentOptions: &#123;</span><br><span class="line">    <span class="string">&quot;mp-weixin&quot;</span>: &#123;</span><br><span class="line">      port: 9420, // 默认 9420</span><br><span class="line">      account: <span class="string">&quot;&quot;</span>, // 测试账号</span><br><span class="line">      args: <span class="string">&quot;&quot;</span>, // 指定开发者工具参数</span><br><span class="line">      cwd: <span class="string">&quot;D:/software/微信web开发者工具&quot;</span>, // 指定开发者工具工作目录</span><br><span class="line">      launch: <span class="literal">true</span>, // 是否主动拉起开发者工具</span><br><span class="line">      teardown: <span class="string">&quot;disconnect&quot;</span>, // 可选值 <span class="string">&quot;disconnect&quot;</span>|<span class="string">&quot;close&quot;</span> 运行测试结束后，断开开发者工具或关闭开发者工具</span><br><span class="line">      remote: <span class="literal">false</span>, // 是否真机自动化测试</span><br><span class="line">      executablePath: <span class="string">&quot;D:/software/微信web开发者工具/cli.bat&quot;</span>, // 开发者工具cli路径，默认会自动查找,  windows: C:/Program Files (x86)/Tencent/微信web开发者工具/cli.bat<span class="string">&quot;, mac: /Applications/wechatwebdevtools.app/Contents/MacOS/cli</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run <span class="built_in">test</span>:mp-weixin</span><br></pre></td></tr></table></figure><p><em>如果一直卡在编译后的第一条RUNS，可以手动启动一下微信开发者工具</em></p><h1 id="关于callMethod"><a href="#关于callMethod" class="headerlink" title="关于callMethod"></a>关于callMethod</h1><p>这里研究是page的callMethod方法</p><p><a href="https://uniapp.dcloud.io/collocation/auto/api">uni-app官网</a></p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled.png" alt></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这里支持<code>.nvue</code>和<code>.vue</code>文件中的<code>methods: &#123;&#125;</code>里面定义的方法</p><p>关于两者区别可看<a href="https://ask.dcloud.net.cn/question/69854">https://ask.dcloud.net.cn/question/69854</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;pages/tabBar/component/component.nvue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> page</span><br><span class="line">    <span class="title function_">beforeAll</span>(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 重新reLaunch至首页，并获取首页page对象（其中 program 是uni-automator自动注入的全局对象）</span></span><br><span class="line">        page = <span class="keyword">await</span> program.<span class="title function_">reLaunch</span>(<span class="string">&#x27;/pages/tabBar/component/component&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> page.<span class="title function_">waitFor</span>(<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;test-callmethod&#x27;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> program.<span class="title function_">currentPage</span>()</span><br><span class="line">        <span class="keyword">await</span> page.<span class="title function_">callMethod</span>(<span class="string">&#x27;testCallMethod&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"><span class="title function_">testCallMethod</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>本质是uni-automator自动注入了program对象，向微信开发者工具发送ws(Websocket)请求，调用其<code>Page.callMethod</code> 方法</p><h3 id="使用webstorm调试"><a href="#使用webstorm调试" class="headerlink" title="使用webstorm调试"></a>使用webstorm调试</h3><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%201.png" alt></p><p>添加上述启动配置后就可以打断点调试代码</p><p>发送ws请求的地方在于</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%202.png" alt></p><p>这里pageId是发送<code>getcurrentPage</code> ws请求得到的</p><p>大概请求过来的路径是，这里除了ws包外，其余的方法都在<code>dist/index.js</code> ，也就是编译构建后的文件</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%203.png" alt></p><h3 id="Page-3-not-exists"><a href="#Page-3-not-exists" class="headerlink" title="Page[3] not exists"></a>Page[3] not exists</h3><p>刚开始的时候使用官方的示例中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="title function_">callMethod</span>(<span class="string">&#x27;onShareAppMessage&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%204.png" alt></p><p>遇到了报错，根据上面原理分析，id是由微信开发者工具提供的，应该不会找不到page</p><p>通过搜索<code>not exists</code> 关键字，将目标定位到了dist文件夹里面的一个文件</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%205.png" alt></p><p>这里的变量t其实ws传输过来的内容</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%206.png" alt></p><p>在<code>return new Promise</code>里面<code>T()</code>会对要call的方法进行验证</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%207.png" alt></p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%208.png" alt></p><p>上面分别是t，n，t参数的值</p><p>这里t其实就是可以call的方法列表，n是想要调用的方法，找不到的话会抛出异常</p><p><img src="/2021/02/25/uniapp%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FcallMethod%E8%B0%83%E7%A0%94%E8%AE%B0%E5%BD%95/Untitled%209.png" alt></p><p>从这里看出，是因为没有找到对应的方法，而不是<code>page not exists</code></p><p>后面根据上图方法列表，确定了可以调用的方法有哪些</p><h1 id="期间遇到的问题"><a href="#期间遇到的问题" class="headerlink" title="期间遇到的问题"></a>期间遇到的问题</h1><ul><li>使用<code>npm run test:weixin</code> 有时候不能启动微信开发者工具，一直卡住，重新执行命令即可解决</li><li>出现了几次修改用例不生效的情况，需要把dist文件夹删除后才生效，或者在<code>jest.config.js</code> 的<code>testEnvironmentOptions</code> 添加<code>compile: true</code> 参数</li><li>如果<code>npm run test:mp-weixin</code> 时提示<code>Wechat web devTools not found, please specify executablePath option</code> ，可能是路径填错了，而不是没有填路径</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>uniapp对自动化方面支持度比较高，和微信官方的automator相似度很高，对应的可操作空间也很高。在本文中提高的callMethod，可以让我们进一步深入测试前端程序提高测试覆盖率和速度，比如js逻辑层，而不是只停留在UI测试阶段，进一步接近分层测试。</li><li>这个和mpvue的测试页方案有点类似，只不过这个更为简便，直接提供了支持，但是最终结果都是调到某个函数</li><li>这里对比UI层面来讲，UI层面更多只是验证一个功能可不可用，比如按一下按钮，观察反应是否正常，但是里面提供的其他功能可能没有进一步去测试。但是对于这个来讲，可以根据不同的参数去验证所有的功能的正常性（前提是支持验证）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL慢查询优化</title>
      <link href="/2021/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="优化出发点"><a href="#优化出发点" class="headerlink" title="优化出发点"></a>优化出发点</h1><p>大部分情况下一般是考虑索引，但是其他方面也值得考虑。</p><h2 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h2><ul><li>表的结构：列是否具有正确的数据类型？表的结构是否设计正确，例如，频繁更新的应用的表结构应该是少列多表，分析大量数据的应用应该是少表多列</li><li>是否创建索引？索引是否有用？</li><li>是否选择了合适的存储引擎，这个现在一般是<code>InnoDB</code></li><li>表是否使用正确的行格式(<code>ROW_FORMAT</code>)？特别是ROW_FORMAT为<code>COMPRESSED</code> 的表使用较少的磁盘空间，因此需要较少的磁盘I/O来读写数据</li><li>应用程序是否使用了适当的锁策略？例如在某种情况下允许共享读(<code>shared access</code>)，以便数据库操作能够同时进行</li><li>缓存大小是否设置正确？足够大的缓存能够容纳经常访问的数据，但是又不能过大，过大导致使用虚拟内存I/O性能下降</li></ul><h2 id="硬件级别"><a href="#硬件级别" class="headerlink" title="硬件级别"></a>硬件级别</h2><p>磁盘种类、速度、CPU、内存等因素</p><h1 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h1><p>几个简单原则：</p><ol><li><p><strong>更小的通常更好</strong></p><p> 应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型占用更少磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少。（确保没有低估，如果无法确定哪个数据类型最好，就选择不会超过范围的最小类型）</p></li><li><p><strong>简单就好</strong></p><p>  简单类型操作通常需要更少的CPU周期。例如整型比字符操作代价更低，因为字符集和排序规则时字符比较比整型比较更复杂。比如使用MySQL的内置类型（date,time,datatime）而不是字符串来存储时间和日期</p></li><li><p><strong>尽量避免NULL</strong></p><p> 可为NULL的列被索引时使用更多的存储空间，在MySQL里需要被特殊处理。当可为NULL的列被索引时，每个索引记录需要额外的字节记录。（注意，通常把可NULL的列改为NOT NULL带来的性能提升比较小，但是如果计划在列上建索引，就应该尽量避免设计成可为NULL的列）</p></li></ol><h1 id="索引建立策略"><a href="#索引建立策略" class="headerlink" title="索引建立策略"></a>索引建立策略</h1><p>一般加索引就能解决了很多慢查询问题</p><p>下面默认讲的索引都是btree索引</p><h3 id="独立列"><a href="#独立列" class="headerlink" title="独立列"></a>独立列</h3><p>索引列不能是表达式一部分，也不能是函数参数，否则MySQL不会使用索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> id<span class="operator">+</span><span class="number">1</span><span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">where</span> TO_DAYS(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> TO_DAYS(date_col)<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="前缀索引和后缀索引"><a href="#前缀索引和后缀索引" class="headerlink" title="前缀索引和后缀索引"></a>前缀索引和后缀索引</h3><ul><li><p>索引很长的字符串，会让索引变得大且慢，通常可以索引开始的部分字符（前缀），可以大大节约索引空间，提高索引效率</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index table_index <span class="keyword">on</span> atdata_casedataon(<span class="keyword">user</span>(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>  选择的前缀尽量让建立的索引区分度更高。可以用下面的方法选择合适的前缀，如果选择性能够接近0.031，基本上就可用。如果全是0，就没有必要用这个了。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(<span class="keyword">user</span>, <span class="number">1</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> user1,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(<span class="keyword">user</span>, <span class="number">2</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> user2,</span><br><span class="line">    <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(<span class="keyword">user</span>, <span class="number">3</span>))<span class="operator">/</span><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> user3</span><br><span class="line"><span class="keyword">from</span> atdata_casedata</span><br></pre></td></tr></table></figure><p>  缺点是<strong>无法使用前缀索引做Group by和Order by，也无法使用前缀索引做覆盖索引</strong></p></li><li><p>后缀索引在某些情况下会有用途，比如找到某个域名所有电子邮箱地址，但是MySQL原生不支持反向索引，但是可用把字符串反转后存储</p></li></ul><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在多个列上建立独立的单列索引大部分情况下不能提高查询性能，旧版本MySQL中只会使用其中一个索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT...WHERE name <span class="operator">=</span> x <span class="keyword">AND</span> age <span class="operator">=</span> t</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX name_index <span class="keyword">ON</span> <span class="keyword">table</span> (name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX age_index <span class="keyword">ON</span> <span class="keyword">table</span> (age);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX name_age_index <span class="keyword">ON</span> <span class="keyword">table</span> (name, age);</span><br></pre></td></tr></table></figure><p>虽然新版本有优化，但是在有多个查询条件情况下最好使用多列索引，使其索引到所有条件列。</p><h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>索引列的顺序意味着首先按照最左列进行排序，其次是第二列，那么如何选择列的顺序，有一个经验法则是将选择性（值不同的个数）最高的列放到索引最前列（更多适用于不考虑order和groupby）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> payment <span class="keyword">WHERE</span> staff_id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> customer_id <span class="operator">=</span> <span class="number">58</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">   <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id) <span class="keyword">AS</span> count_staff_id, </span><br><span class="line">   <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id) <span class="keyword">AS</span> count_customer_id</span><br><span class="line"><span class="keyword">FROM</span> payment</span><br><span class="line"></span><br><span class="line">count_staff_id: <span class="number">1001</span></span><br><span class="line">count_customer_id: <span class="number">1241334</span></span><br></pre></td></tr></table></figure><p>那么此时选择customer_id会更好。</p><p>或者有个更通用的做法是按照最左前缀匹配原则。MySQL会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式</p><h3 id="使用索引优化order-by"><a href="#使用索引优化order-by" class="headerlink" title="使用索引优化order by"></a>使用索引优化order by</h3><p>条件：</p><ul><li>当索引列的顺序和order by子句的顺序完全一致，并且所有列排序方向一致（有一特殊情况，前面列为常量）</li><li>关联多张表，order by子句引用的字段全部在第一个表</li></ul><p>比如有一索引<code>KEY a_b_c_index(a,b,c)</code> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b  #前面列为常量,<span class="literal">true</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c #前面列为常量,<span class="literal">true</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b,c #前面列为范围查询,<span class="literal">false</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a,b,c #索引列顺序一样,<span class="literal">true</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> b <span class="keyword">DESC</span>,c <span class="keyword">ASC</span> #所有列排序方式不一样,<span class="literal">false</span></span><br><span class="line"><span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> c #没有符合最左前缀,<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="优化group-by"><a href="#优化group-by" class="headerlink" title="优化group by"></a>优化group by</h3><p>group by操作在没有合适的索引可用时，通常先扫描整个表提取数据并创建一个临时表，然后按照group by指定的列进行排序，需要通过建立索引避免创建临时表，一般会选择多列索引</p><h3 id="优化聚合函数"><a href="#优化聚合函数" class="headerlink" title="优化聚合函数"></a>优化聚合函数</h3><p>将所有使用的列包括在索引中（“覆盖索引”），MySQL不需要访问表本身，并且可以仅读取索引来继续进行操作。</p><p>覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。</p><h3 id="重复索引"><a href="#重复索引" class="headerlink" title="重复索引"></a>重复索引</h3><p>避免创建重复索引（相同的列上按照相同的顺序创建相同类型的索引），MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑</p><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><h1 id="查询性能优化"><a href="#查询性能优化" class="headerlink" title="查询性能优化"></a>查询性能优化</h1><h3 id="避免访问所有列"><a href="#避免访问所有列" class="headerlink" title="避免访问所有列"></a>避免访问所有列</h3><ol><li>只返回需要的列</li><li>使用覆盖索引来减少查询扫描的行数</li></ol><h3 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h3><p>在很多场景下通过重构查询将关联放到应用程序中将会更加高效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post_id<span class="operator">=</span>tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> post.post_id<span class="operator">=</span>post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以分解成下面这些查询来代替：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id<span class="operator">=</span><span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post_id <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><ol><li>让缓存效率更高，许多应用程序可以方便地缓存单表查询对应的结果集</li><li>将查询分解后，执行单个查询可以减少锁的竞争</li><li>查询本身效率也可能会有所提升：比如使用<code>IN()</code> 代替关联查询，可以让MySQL按照ID顺序进行查询，这可能比随机的关联要更高效</li><li>减少冗余记录查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。</li></ol><h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>原理推荐看这篇</p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-Primary-Backup-Replication</title>
      <link href="/2020/12/14/MIT6.824-Primary-Backup-Replication/"/>
      <url>/2020/12/14/MIT6.824-Primary-Backup-Replication/</url>
      
        <content type="html"><![CDATA[<h1 id="What-kinds-of-failures-can-replication-deal-with"><a href="#What-kinds-of-failures-can-replication-deal-with" class="headerlink" title="What kinds of failures can replication deal with?"></a>What kinds of failures can replication deal with?</h1><ul><li>“fail-stop” failure of a single replica<ul><li>fan stops working, CPU overheats and shuts itself down</li><li>someone trips over replica’s power cord or network cable（电源线或网络电缆）</li><li>software notices it is out of disk space and stops</li></ul></li><li>Maybe not defects in h/w(Hardware/Software) or bugs in s/w or human configuration errors</li></ul><h1 id="Two-main-replication-approaches"><a href="#Two-main-replication-approaches" class="headerlink" title="Two main replication approaches"></a>Two main replication approaches</h1><h2 id="State-transfer"><a href="#State-transfer" class="headerlink" title="State transfer"></a>State transfer</h2><ul><li>Primary replica executes the service</li><li><strong>Primary sends [new] state to backups</strong></li></ul><h2 id="Replicated-state-machine"><a href="#Replicated-state-machine" class="headerlink" title="Replicated state machine"></a>Replicated state machine</h2><ul><li><strong>Clients send operations to primary, primary sequences and sends to backups</strong></li><li>All replicas execute all operations</li><li>If same start state, same operations, same order, deterministic, then same end state.</li><li>support only uni-processor (In fact, vmware has a solution for multi-core processor, but it seems to be based on state transfer)</li></ul><hr><h2 id="Compared"><a href="#Compared" class="headerlink" title="Compared"></a>Compared</h2><ul><li>State transfer is simpler, but state may be large, slow to transfer over network</li><li>Replicated state machine often generates less network traffice<ul><li>Operations are often small compared to state But complex to get right</li></ul></li></ul><h1 id="At-what-level-do-we-want-replicas-to-be-identical"><a href="#At-what-level-do-we-want-replicas-to-be-identical" class="headerlink" title="At what level do we want replicas to be identical"></a>At what level do we want replicas to be identical</h1><p>identical: similar in every detail</p><ul><li><code>VMware vSphere Fault Tolerance (VMware FT)</code>   replicates the low-level memory and machine registers ( <code>Machine level</code> )<ul><li>might allow us to replicate any existing server without modification</li><li>requires forwarding of machine events (interrupts, DMA（指内存和外设直接存取数据这种内存访问的计算机技术）)</li><li>can run any existing O/S and server software. Appears like a single server to clients</li></ul></li><li>Most like GFS where it was replicating much more application level table of chunks<ul><li>Can be efficient; primary only sends high-level operations to backup</li><li>Application code (server) must understand fault tolerance, to e.g. forward op stream</li></ul></li></ul><h1 id="VMware-FT"><a href="#VMware-FT" class="headerlink" title="VMware FT"></a>VMware FT</h1><p><img src="/2020/12/14/MIT6.824-Primary-Backup-Replication/test_1.png" alt></p><p>有两台机器，分别是primary和backup，它们都是通过VMM虚拟化运行同一个OS，按照FT来讲，它们运行的内容也是一样的，它们的存储数据的磁盘可能不是在机器上面，而是有个Disk Server，并且有个Client访问数据，这些都通过网路连接在一起。</p><p><img src="/2020/12/14/MIT6.824-Primary-Backup-Replication/test_2.png" alt></p><ul><li>现在Client发送一个网络数据包给Primary，Primary的VMM接收到数据包，并产生一个中断，它会模拟一个网络数据包到达的中断给primary上的os，以将这个数据包发送给应用程序。</li><li>同时VMM还将数据包的副本发送给Backup的VMM，Backup的VMM也会做同样的事情。</li><li>应用程序会产生Response，并通过VMM所模拟的<code>NIC (Network Interface Card)</code> 将它发送出去。因为Backup也在执行同样的操作，所以Backup也会产生同样的Response，但是FT会将其丢弃，最终只有Primary应答。</li></ul><p>Primary将所有<code>external events</code>（网络数据包等）都通过称为<code>Logging channel</code>的网络连接发送到Backup，发送的内容称为<code>log entries</code></p><p>如果Backup超过一定时间没有从Logging channel中拿到数据，那么VMM会让Backup代替Primary。</p><h1 id="What-sources-of-divergence-must-FT-handle"><a href="#What-sources-of-divergence-must-FT-handle" class="headerlink" title="What sources of divergence must FT handle?"></a>What sources of divergence must FT handle?</h1><p>divergence: the process or state of (of opinions or methods) differing</p><ul><li>Most instructions execute identically on primary and backup<ul><li>As long as memory+registers are identical, which we’re assuming by induction</li></ul></li><li>Inputs from external world — just network packets<ul><li>These appear as DMA’d data plus an interrupt.</li><li>This interrupt will occur somewhere in the instruction stream. So we must know which instruction occurred when primary and backup behave the same.Otherwise they will be different in execution and the state.</li></ul></li><li>Instructions that aren’t functions of state, such as reading current time.</li><li>Not multi-core races, since uniprocessor only<ul><li>the instructions of the service are interleaved（交错的） in some way which is not predictable（预测的）  ( such as get lock)</li></ul></li></ul><h1 id="FT’s-handling-of-timer-interrupts"><a href="#FT’s-handling-of-timer-interrupts" class="headerlink" title="FT’s handling of timer interrupts"></a>FT’s handling of timer interrupts</h1><ul><li><strong>Goal</strong>: primary and backup should see interrupt at the same point in the instruction stream</li><li><strong>Primary</strong><ol><li>FT fields（处理） the timer interrupt</li><li>FT reads instruction number from CPU</li><li>FT sends “timer interrupt at instruction X” on logging channel</li><li>FT delivers interrupt to primary, and resumes（恢复） it（this relies on CPU support to interrupt after the X’th instruction）</li></ol></li><li><strong>Backup</strong><ol><li>ignores its own timer hardware</li><li>FT sees log entry <em>before</em> backup gets to instruction X</li><li>FT tells CPU to interrupt (to FT) at instruction X</li><li>FT mimics（模仿） a timer interrupt to backup</li></ol></li></ul><h1 id="FT’s-handling-of-network-packet-arrival-input"><a href="#FT’s-handling-of-network-packet-arrival-input" class="headerlink" title="FT’s handling of network packet arrival (input)"></a>FT’s handling of network packet arrival (input)</h1><ul><li>Primary<ol><li>FT tells NIC to copy packet data into FT’s private “bounce buffer”（When data travels between a device and high memory, it is first copied through the bounce buffer）</li><li>FT gets the interrupt from NIC</li><li>FT pauses the primary</li><li>FT copies the bounce buffer into the primary’s memory</li><li>FT simulates（模拟） a NIC interrupt in primary</li><li>FT sends the packet data and the instruction id to the backup</li></ol></li><li>Backup<ol><li>FT gets data and instruction id from log stream</li><li>FT tells CPU to interrupt (to FT) at instruction X</li><li>FT copies the data to backup memory, simulates NIC interrupt in backup</li></ol></li></ul><h1 id="output-rule"><a href="#output-rule" class="headerlink" title="output rule"></a>output rule</h1><p>Avoid data inconsistency caused by backup not receiving log after primary crash</p><ul><li>Primary：<ol><li>receives client “increment” request</li><li>sends client request on logging channel</li><li>about to（即将） send  reply to client</li><li>first waits for backup to acknowledge（承认） previous log entry</li><li>then sends reply to client</li></ol></li></ul><p><strong>what if the primary crashed <em>after</em> emitting the output? Will the backup emit the output a second time?</strong></p><p>Yes.<br>   OK for TCP, since receivers ignore duplicate sequence numbers.<br>   OK for writes to disk, since backup will write same data to same block id.</p><h1 id="could-it-suffer-from-split-brain"><a href="#could-it-suffer-from-split-brain" class="headerlink" title="could it suffer from split brain"></a>could it suffer from split brain</h1><p>The disk server breaks the tie.（打破了僵局）<br>Disk server supports <strong>atomic test-and-set</strong>.<br>If primary or backup thinks other is dead, <strong>attempts test-and-set</strong>.<br>If only one is alive, it will win test-and-set and go live.<br>If both try, one will lose, and halt.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> 主从备份 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-GFS</title>
      <link href="/2020/11/17/MIT6.824-GFS/"/>
      <url>/2020/11/17/MIT6.824-GFS/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么我们要阅读这篇论文"><a href="#为什么我们要阅读这篇论文" class="headerlink" title="为什么我们要阅读这篇论文?"></a>为什么我们要阅读这篇论文?</h1><p>在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的<code>interface/semantics</code> 应该怎么定义，它是怎么并行工作的等。</p><p>GFS paper涉及到了很多分布式系统主题：<code>parallel performance</code>, <code>fault tolerance</code>, <code>replication</code>, <code>consistency</code> 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。</p><h1 id="为什么分布式存储这么难"><a href="#为什么分布式存储这么难" class="headerlink" title="为什么分布式存储这么难?"></a>为什么分布式存储这么难?</h1><ul><li><code>high performance</code>→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据</li><li><code>many servers</code>→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复</li><li><code>fault tolerance</code> →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用</li><li><code>replication</code> →有数据不一致的风险</li><li><code>better consistency</code> →如果需要更强的一致性的话，在网络中所有不同的服务器和客户端之间需要进行很多额外的工作和交流，那么这样性能就会降低，所以这个不是我们最初想要的</li></ul><h1 id="我们想要什么样的一致性？"><a href="#我们想要什么样的一致性？" class="headerlink" title="我们想要什么样的一致性？"></a>我们想要什么样的一致性？</h1><ul><li>Ideal model: same behavior as a single server</li><li>server uses disk storage (persistence)</li><li>server executes client operations one at a time (even if concurrent)</li></ul><p>假设现在有两个客户端C1, C2，C1发送一个写请求，想将X的值设置为1，同时，C2也发送一个写请求，想把X的值设置为2。C1, C2都完成后，有两个客户端C3, C4想要读取X的值，会发生什么</p><p>显然这里两个客户端读到的值是不确定的，1或者2，因为没有定义服务器处理写请求的顺序。但是C3和C4得到的值必须是一样的，这就是强一致性模型。</p><hr><p>在多副本中强一致性变得麻烦起来，一个简单但是很糟糕的复制方案：</p><p>现有两个副本服务器S1和S2，现在两个客户端同时向两者发送写请求。</p><p>C1将S1和S2中的X设置为1，C2将S1和S2中的X设置为2</p><p><img src="/2020/11/17/MIT6.824-GFS/Untitled.png" alt></p><p>在这里我们并没有做任何事情来保证两个服务器是以同样的顺序来处理这两个请求。</p><p>如果S1先接受C1的设置，那么X先被设置为1，接着处理C2，那么X就被覆盖为2；如果S2处理的顺序反过来的话，S2的X会为1，那么读取到的数据就会不一致。或者是S1已经写数据了，但是S2突然崩溃了，没有执行成功，这样数据也会不一致。</p><p>更好的一致性通常需要确保副本之间的同步，这可能会有性能问题，所以这个得看使用者对一致性的接受程度。</p><h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在2003年时候Google file system论文发表，是第一个用分布式学术思想落地的应用，虽然在此之前十年已经有分布式的研究了。</p><p>Google许多服务都需要用到大型且快速的存储系统去存储或者读取大量数据集，比如MapReduce、索引、日志存储/分析、Youtube视频等。</p><p>这个系统是通用或者全局可复用的，允许在应用程序之间共享数据：</p><ul><li>为了提高并行性能和增加可用空间，在多个服务器/磁盘上自动“切分”每个文件</li><li>自动从故障中恢复</li><li>单个GFS是运行在一个数据中心或者一个大型机房，虽然部署全球副本很有价值，但是这个很难</li><li>GFS仅面向Google内部使用，但是会向外出售使用了GFS的服务，并不会直接出售GFS</li><li>旨在用于大文件（GB或者TB级别）的顺序访问和写入，而不是随机访问小文件</li><li>没有把重点放在低延迟上面，而是放在大吞吐量上面，比如几MB大小的操作</li></ul><h2 id="论文在当时的优点"><a href="#论文在当时的优点" class="headerlink" title="论文在当时的优点"></a>论文在当时的优点</h2><ul><li>构建的系统是比之前的类似的论文中所描述的系统要庞大得多</li><li>有着实践的经验</li><li>证明了弱一致性是ok的，借此获得更好的性能</li><li>单master成功应用。单个master可以让一致性更强，多个的话难维护较强的一致性，但会带来别的提升。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/2020/11/17/MIT6.824-GFS/Untitled%201.png" alt></p><p>GFS由一个<code>master</code>和多个<code>chunkserver</code>组成。</p><ul><li>文件被分成固定大小的<code>chunks</code>，每个chunk都是64MB大小。每一块都由一个不可变的、全局唯一的64位<code>chunk handle</code> 标识，这个标识在块chunk创建的时候由master分配</li><li>master会维护文件名和数据保存位置之间的关系，用来命名文件和查询这些chunk的位置信息</li><li>chunkserver用来保存实际数据的</li></ul><h2 id="Master-Data"><a href="#Master-Data" class="headerlink" title="Master Data"></a>Master Data</h2><p>主要保存两个映射关系，<code>nv</code>：非易失性：</p><ul><li>file name→array of chunk handles (nv)：去哪里找这些数据或者这些chunk的标识符是什么</li><li>chunk handle→list of chunkservers (v)：每个chunk有多个副本，这里不需要持久性，当master重启后，master会和所有的chunkserver通信以确定这些信息<ul><li>version (nv)：每个chunk都有一个version</li><li>primary (v)：有许多个副本，primary是其中的一个，master需要记住primary chunk对应的chunkserver，但是这个信息不需要存储，master可以等待60s后lease过期，然后再指定一个primary</li><li>lease expiration：master会记住lease的过期时间</li></ul></li></ul><p>这些数据读是在内存中进行，但是写会写到磁盘中（实际上保存的是操作日志），当日志达到一定大小时，master会建立<code>checkpoint</code>，当master重启后，会恢复到最近的checkpoint。</p><p>这些日志使用文件存储，而不使用数据库存储，是因为在磁盘上面它们有些是用B树或者哈希表进行组织的，这样的对日志进行追加操作时候会非常高效（当磁盘磁臂旋转到一个位置时，可以写入大量的数据，而数据库存储并不考虑顺序，要符合真实的b树需要去寻找再追加）。</p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><ol><li>Client向Master发出读请求，通过一个文件名和一个文件中的偏移量(<code>offset</code>)找到它想要的数据的范围。</li><li>Matser根据这两个信息查之前保存的映射关系表得到chunk handle列表和chunkserver列表，并返回，Client会缓存该信息。</li><li>Client向最近的chunkserver发送请求，包括chunk handle和offset，chunkserver读取磁盘上的chunk数据并返回</li></ol><h2 id="追加操作"><a href="#追加操作" class="headerlink" title="追加操作"></a>追加操作</h2><ol><li>Client询问Master文件最后一个chunk</li><li>写操作Master都是和Primary通信，如果此时没有Primary（或者lease已经过期）：<ul><li>需要等待Master找出需要的一组有着最近chunk的chunkservers</li><li>从中选择一个作为Primary，其他作为Secondary</li><li>递增版本号，写入磁盘</li><li>告诉所有副本它们是P(Primary)还是S，以及最新的版本号</li><li>副本将最新版本号写入磁盘</li></ul></li><li>Master回复Client Primary和Secondaries的位置，然后</li><li>Client向Primary和Secondaries发送要追加的数据，拿到数据后只是将这些数据写到临时区域上。一旦所有副本都确认接收到了数据，Client就向Primary发送写请求。</li><li>Primary会检查lease是否还未过期，同时检查chunk是否还有空间。</li><li>Primary选择一个offset(at end of chunk)，将数据写入到chunk中(Linux文件)。同时Primary会向Secondaries传递offset，让它们追加数据到chunk中。</li><li>Primary会等待Secondaries的回复，可能是”Yes“，”error”或者timeout。如果全部写入成功，则返回成功给Client，否则回复”error”。</li><li>如果收到error，Client会重试追加操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gfs </tag>
            
            <tag> mit6.824 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.824-MapReduce</title>
      <link href="/2020/11/06/MIT6.824-MapReduce/"/>
      <url>/2020/11/06/MIT6.824-MapReduce/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有时候我们需要从一批数据中得到一些结果，比如从最频繁查询的结果集，每个单词出现的次数。随着输入的数据越来越多，为了在合理的时间内完成，单台机器可能会完成不了这个任务，所以我们必须将这个计算压力分担到多个机器上面，并行计算。</p><p>但是解决计算的标准化，数据的分配，故障处理，负载均衡等问题是个大工程，让原本简单的代码变得复杂起来。</p><p>为此，Google发明了<code>MapReduce</code>系统，隔离了复杂的底层，让程序员能够容易使用这个系统进行大数据量的分布式计算。</p><h1 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h1><p>将用户的计算分为两个函数处理：<code>Map</code>和<code>Reduce</code> 函数</p><ul><li><code>Map</code>函数：输入数据，处理后生成一组键值对（中间值）</li><li><code>Reduce</code>函数：处理前面得到的中间值，然后将这些值合并在一起，形成更小的值集。通常，每次 Reduce调用只生成零个或一个输出值。</li></ul><p>简约模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map (k1,v1) → list(k2,v2)</span><br><span class="line">//这里是指对应k2的结果有多个</span><br><span class="line">reduce (k2,list(v2)) → list(v2)</span><br></pre></td></tr></table></figure><p><img src="/2020/11/06/MIT6.824-MapReduce/mapreduce.png" alt></p><hr><p>举个例子：</p><p>现有大量的文本数据，想统计每个单词出现的次数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>(<span class="type">string</span> documentName, <span class="type">string</span> documentValue):</span><br><span class="line"><span class="keyword">for</span> word in documentValue:</span><br><span class="line">EmitIntermediate(word, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">reduce(<span class="type">string</span> word, <span class="type">int</span>[] counts):</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> count in counts:</span><br><span class="line">result += count</span><br><span class="line">Emit(result)</span><br></pre></td></tr></table></figure><p><code>Map</code>函数统计每个单词及其出现的次数（假设只有1）。<code>Reduce</code> 函数将计算每个特定单词出现的总次数。</p><p>实际上，我们会将要输入的数据分割成多份，<code>Map</code>和<code>Reduce</code>函数也会起多个进程，这样能够更快的处理任务，如下图</p><p><img src="/2020/11/06/MIT6.824-MapReduce/Untitled.png" alt></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="执行概述"><a href="#执行概述" class="headerlink" title="执行概述"></a>执行概述</h2><p><img src="/2020/11/06/MIT6.824-MapReduce/Untitled%201.png" alt></p><p>上面是论文中MapReduce运行程序的总体流程，当用户程序调用 MapReduce 函数时，会有以下操作（编号对应上图中的编号）</p><ol><li>用户程序中的MapReduce库首先将输入文件拆分为 <code>m</code> 片，每片通常为 16 到 64 MB(用户可以通过一个可选参数进行控制)。然后，它在三台机器上启动多个程序副本。</li><li>其中有一个是主程序(<code>Master</code>)，它会管理其余的程序(<code>Worker</code>)，Master主要作用是分配一个Map或一个Reduce任务给闲置的Worker程序（假设有<code>M</code>个Map任务和<code>R</code>个Reduce任务）</li><li>有Map任务的Worker 会输入相应的分割后的内容，接着解析输入数据中的键值对，并将每个键值对传递给用户定义的Map函数。Map 函数生成的中间键/值对在内存中进行缓冲</li><li>缓存会定期写入到本地磁盘（磁盘通过分区函数被划分为R个区域）。本地磁盘上有数据的区域的位置信息会被上传给Master，Master负责将这些位置信息传递给Reduce 任务的Worker</li><li><p>当有Reduce 任务的Worker 接收到Master 传递过来的位置信息时，它会使用<code>RPC</code>从Map Worker 的本地磁盘读取缓冲数据。读取了所有的中间数据后，它会按照中间键对其进行排序，以便将出现的所有同一个键组合在一起。如果中间数据量太大，内存无法容纳，则使用外排序。</p><blockquote><p>外排序（External sorting）是指能够处理极大量数据的排序算法。 通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。</p></blockquote></li><li>Reduce Worker遍历排序后的中间键值对数据，对每个特定的key，会将key和相对应的中间值集合传递给用户定义的Reduce函数。Reduce函数的输出会写到对应的分区文件中。</li><li>当所有的Map和Reduce任务完成后，Master会唤醒用户程序。此时，用户程序中的MapReduce调用会返回。 </li></ol><p>一般完成之后并不是将这些分文件合并，而是将这些文件作为输入传递给另一个MapReduce调用，或者从另一个分布式应用程序使用它们。</p><h2 id="Master结构"><a href="#Master结构" class="headerlink" title="Master结构"></a>Master结构</h2><p>对于每个Map和Reduce任务，Master存储了这些任务的状态（闲置，进行中，已完成）以及有非闲置状态任务的Worker的标识。</p><p>对于每个已完成的Map任务，Master存储了Map任务产生的R个中间键值对文件的位置和大小。当有Map任务完成时，将更新位置和大小信息，这些信息将会推送给正在Reduce操作的Worker。</p><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="Worker故障"><a href="#Worker故障" class="headerlink" title="Worker故障"></a>Worker故障</h3><p>Master会定时给Worker发送信号，如果在一定时间内没有收到回复，则将该Worker标记为故障状态。任何Map任务或Reduce任务在失败的Worker上运行时会被重置为空闲状态并有资格进行重新调度。</p><p>已经完成的Map任务在故障时会重新执行，因为它们的输出在故障的Worker本地磁盘中，不可访问。已经完成的Reduce任务不需要重新执行，因为它们的输出存储在全局文件系统中。</p><p>假设有一个Map任务首先由Worker A执行，A出现了故障，然后由Worker B执行，执行Reduce任务的Worker会得到重新执行的通知。任何还没有从Worker A读取数据的Reduce任务将从Worker B读取数据。</p><p>如果是大量的Worker同时出现故障，MapReduce只是简单得重新执行无法访问的Worker机器所做的工作，并接着往下执行任务，最终完MapReduce的任务。</p><h3 id="Master故障"><a href="#Master故障" class="headerlink" title="Master故障"></a>Master故障</h3><p>如果Master出现故障 ，则可以从上一个<code>checkpointed</code>状态启动新的副本。但是由于只有一个master，它出现故障的可能性很小。因此，如果Master失败，目前的实现是将中止MapReduce 计算。如有需要，可以执行重试操作。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>因为网络带宽是比较昂贵的，可以用分布式文件系统（这里用<code>GFS</code>）去管理数据。GFS 将每个文件按 64MB 分块，并在不同的计算机上存储每个块的几个副本(通常是 3 个副本)。</p><p>Master尝试在包含相应输入数据副本的机器上面安排Map任务，如果不行，则尝试将Map任务安排在任务输入数据的副本附近（例如，同一个网络交换机），所以相当一部分Worker输入的数据都是在本地读取的，不消耗网络带宽。</p><h3 id="备份任务"><a href="#备份任务" class="headerlink" title="备份任务"></a>备份任务</h3><p>一个比较常见的问题是部分机器计算任务所需的时间过长，导致整个MapReduce的执行时间过长，这可能是各种各样的问题导致，比较常见的是CPU、内存、本地磁盘等资源的竞争。</p><p>有一个通用的解决方法是：当一个MapReduce计算接近完成时，Master会调度一个备用（backup）任务来执行剩下的处于正在执行中（in-progress）的任务。无论是这个主任务还是这个备用任务完成了，我们都会将这个任务标记为完成。</p><h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><p>在本地的一台机器上实现一个简易版本的<code>MapReduce</code> ，它由两个程序（Master和Worker）组成，只有一个Master，一个或多个Worker进程并行执行。每个Worker进程都会向Master索要任务，从一个或多个文件中读取任务的输入，执行任务，并将任务的输出写入一个或多个文件。这里的故障点只是简单的判断Worker是否在10s内完成任务，如果没有按时间完成则将该任务分配给其他可用Worker继续执行。</p><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><p>一开始拿到代码有点无从下手的感觉，我们得弄清楚代码的框架。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先得知道是怎么跑起来的，Lab1提供了一个测试脚本<code>test-mr.sh</code> ，里面会有几个测试点，它会通过这几个测试点检测你的代码是否编写正确，值得一提的是最后一个测试点就是模拟了故障情况，它会在每个Worker中执行一个函数，这个函数有几率会让Worker进程退出<code>(os.Exit(1))</code>或者让执行时间大幅延长<code>(time.Sleep)</code> 。</p><p>测试脚本主要是作了一下工作：</p><ol><li>清除历史执行产生的数据文件</li><li>go build代码</li><li>run一个Master和多个Worker进程</li><li>产生正确的文件以及对比你的代码在该测试点下输出的文件是否一致</li><li>直到所有的测试点完成</li></ol><p><img src="/2020/11/06/MIT6.824-MapReduce/Untitled%202.png" alt></p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p><code>src/main/mrsequential.go</code> 里面提供了单进程版本，主要用于测试点生成正确的输出文件，我们写代码时可以随意从里面拿代码。</p><p>与我们写代码有关系的是<code>src/main/mrmaster.go</code> <code>src/main/mrworker.go</code> 以及<code>src/mr</code> 里面的所有文件</p><ul><li>测试脚本启动一个<code>src/main/mrmaster.go</code> 进程，该进程主要是用于传递「要处理的文件列表」以及「ReduceWorker的个数」给<code>src/mr/master.go</code> 里面的<code>MakeMaster</code> 函数</li><li>启动多个<code>src/main/mrworker.go</code> 进程，主要用于执行<code>src/mr/worker.go</code> 里面的<code>Worker</code> 函数。</li></ul><p>所以到这里我们大概直到了我们要编写的代码就是位于<code>src/mr/master.go</code> 和<code>src/mr/worker.go</code>，脚本只是把必要的信息传给我们和启动对应的进程，所以我们要编写的主要代码如下：</p><ol><li>Master分配任务给Worker（Map和Reduce任务）</li><li>Worker处理任务，一直到Map任务或者Reduce任务完成</li><li>Master对Worker容错处理，当出现Worker超时未完成时，及时将任务分配给其他的Worker</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>RPC请求和返回的结构体字段首字母必须大写，否则拿到的值为空</li><li>对必要的操作加锁，因为涉及到并发操作</li><li>该实验先执行完所有的Map任务再执行Reduce任务，但是Worker还是那一些，只不过不同任务而已</li><li>每次执行任务都需要带上不同的id，即使是同一个Worker，因为生成的中间文件命名需要用到该id，如果id相同则可能会把之前生成的文件给覆盖掉</li></ol><h2 id="Master实现"><a href="#Master实现" class="headerlink" title="Master实现"></a>Master实现</h2><p>刚开始是用两个slice作为队列分别保存输入文件列表(<code>InputFiles</code>)和中间文件列表(<code>IntermediateFiles</code>)，主要处理流程如下：</p><ol><li>从InputFiles取文件作为Map任务分配到各个Worker</li><li>Map任务完成则调用Master的方法将返回的中间文件名放到IntermediateFiles</li><li>直到InputFiles为空，接着对中间文件分类，按照文件名分配好Reduce任务</li><li>从IntermediateFiles取文件作为Reduce任务分配到各个Worker</li><li>任务处理完成</li></ol><p>Worker中提供了<code>ihash</code>函数，能够根据key(单词)分配Reduce Worker，所以按照<code>mr-X-Y</code>规则生成的中间文件列表如下，按照<code>Y</code> 我们可以分类文件给不同的Reduce Worker</p><p><img src="/2020/11/06/MIT6.824-MapReduce/Untitled%203.png" alt></p><p>上面方案有几个缺点：</p><ol><li>没有对Worker进行容错处理，所以还需要额外的队列保存Worker，出错时把重新放到队列，这里三个队列的同步关系不好处理，因为是并发，加锁并不是那么好加</li><li>用队列保存中间文件还得分类，如果出错了又得重新放回队列，重新取，代码上繁琐了点。</li></ol><hr><p>针对上面的并发和繁琐问题，做了下面更改</p><ul><li><code>IntermediateFiles</code> 用<code>sync.Map</code> 代替，key为<code>ReduceWorkerId</code>  ，Value为待处理文件列表</li><li>使用<code>channel</code> 作为中间缓冲层处理Map和Reduce的通信</li><li>同时使用一个 <code>sync.Map</code> 记录Task信息，key为<code>WorkerId</code>，主要有两个状态：空闲和进行中，每次启动一个任务，则开启个十秒的定时任务，如果检测到没有完成，则将该Worker变为空闲状态，并将任务文件列表放到对应的channel</li></ul><p>sync.Map和channel的优势是并发下保证数据的一致性，节省了很多加锁操作</p><h2 id="Worker实现"><a href="#Worker实现" class="headerlink" title="Worker实现"></a>Worker实现</h2><p>Worker实现则是根据Master的任务来选择执行Map或者是Reduce任务，具体的对文件处理逻辑可以直接参考单进程版本</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><h3 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h3><p><code>MakeMaster</code>后，将输入文件放到<code>MapTaskChannel</code> ，将要执行reduceWorkerId放到<code>ReduceTaskChannel</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> putTask() &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.NReduce; i++ &#123;</span><br><span class="line">m.ReduceTaskChannel &lt;- strconv.Itoa(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> m.InputFiles &#123;</span><br><span class="line">m.MapTaskChannel &lt;- file</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p>Worker这部分比较简单，请求任务，并根据任务类型分发任务，执行完后再不断请求，直到任务请求完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue, reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line">reply := &amp;TaskReply&#123;&#125;</span><br><span class="line">call(<span class="string">&quot;Master.AssignTask&quot;</span>, &amp;Args&#123;&#125;, reply)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.IsDone &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.WorkerType == Map &#123;</span><br><span class="line">StartMapTask(reply, mapf)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.WorkerType == Reduce &#123;</span><br><span class="line">StartReduceTask(reply, reducef)</span><br><span class="line">&#125;</span><br><span class="line">Worker(mapf, reducef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Master分配任务"><a href="#Master分配任务" class="headerlink" title="Master分配任务"></a>Master分配任务</h3><p>这里是最核心的了</p><p>这里首先执行的Map任务，channel中没有了Map任务而且所有的Map任务都执行完成，则执行Reduce任务。</p><p>执行Map任务也比较简单，就是从channel里面拿一个任务，Reduce也同理，只不过MapTaskChannel拿到的是文件，ReduceTaskChannel拿到是具体执行哪个ReduceWorker。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> AssignTask(args *Args, reply *TaskReply) <span class="type">error</span> &#123;</span><br><span class="line">workerType := Map</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m.MapTaskChannel) == <span class="number">0</span> &amp;&amp; m.checkTaskIdle(Map) &#123;</span><br><span class="line">workerType = Reduce</span><br><span class="line">&#125;</span><br><span class="line">m.MU.Lock()</span><br><span class="line">reply.IsDone = m.isDone()</span><br><span class="line">m.MU.Unlock()</span><br><span class="line"><span class="keyword">if</span> workerType == Map &#123;</span><br><span class="line">mapFile := &lt;-m.MapTaskChannel</span><br><span class="line">m.startMapTask(mapFile, reply)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> workerType == Reduce &#123;</span><br><span class="line">reduceWorkerId := &lt;-m.ReduceTaskChannel</span><br><span class="line"><span class="keyword">if</span> id, ok := m.IntermediateFiles.Load(reduceWorkerId); ok &#123;</span><br><span class="line">m.startReduceTask(id.([]<span class="type">string</span>), reply)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里执行检测Map或者Reduce是否都已经执行完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> checkTaskIdle(workerType WorkerType) <span class="type">bool</span> &#123;</span><br><span class="line">flag := <span class="literal">true</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">task := v.(Task)</span><br><span class="line"><span class="keyword">if</span> task.WorkerType == workerType &amp;&amp; task.State != Idle &#123;</span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">m.TaskList.Range(f)</span><br><span class="line"><span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是检测全部任务是否完成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> isDone() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m.checkTaskIdle(Map) &amp;&amp; m.checkTaskIdle(Reduce) &amp;&amp; <span class="built_in">len</span>(m.MapTaskChannel) == <span class="number">0</span> </span><br><span class="line">&amp;&amp; <span class="built_in">len</span>(m.ReduceTaskChannel) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MapTaskFinish"><a href="#MapTaskFinish" class="headerlink" title="MapTaskFinish"></a>MapTaskFinish</h3><p>Map任务执行完后告诉给Master，然后Master将中间文件记录，这里用了sync.Map，记录同时分类</p><p>记录完后调用<code>initTaskState</code> 初始化Worker为空闲状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> MapTaskFinish(args *MapFinish, reply *TaskReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> args.IntermediateFiles &#123;</span><br><span class="line">id := m.getReduceWorkerId(file)</span><br><span class="line"><span class="keyword">if</span> arr, ok := m.IntermediateFiles.Load(id); ok &#123;</span><br><span class="line">m.IntermediateFiles.Store(id, <span class="built_in">append</span>(arr.([]<span class="type">string</span>), file))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.IntermediateFiles.Store(id, []<span class="type">string</span>&#123;file&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.initTaskState(args.WorkerId)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mit6.824 </tag>
            
            <tag> mapreduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目Golang优化点</title>
      <link href="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/"/>
      <url>/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>最近接手的一个项目需要<del>预先生成大量缓存（并不是一个好方案，最终ban掉了）</del>，在生成缓存处理数据中发现了一些优化点，可以提高速度，在此记录一下，首先可以了解一下如何利用工具找出代码中一些代码块的执行速度。</p><h1 id="二、pprof"><a href="#二、pprof" class="headerlink" title="二、pprof"></a>二、pprof</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p><a href="https://github.com/google/pprof">google/pprof</a></p><p>pprof 是用于可视化和分析性能分析数据的工具，这里主要用来定位性能问题</p><p>主要有以下数据：</p><ul><li><code>CPU Profiling</code>：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li><li><code>Memory Profiling</code>：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li><li><code>Block Profiling</code>：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li><li><code>Mutex Profiling</code>：互斥锁分析，报告互斥锁的竞争情况</li></ul><p>这里我们主要用到第一点</p><h2 id="2-2-结果分析"><a href="#2-2-结果分析" class="headerlink" title="2.2 结果分析"></a>2.2 结果分析</h2><p>这里使用的是web应用，可以使用 <code>net/http/pprof</code>库，它能够在提供 HTTP 服务进行分析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof <span class="string">&quot;http://127.0.0.1:8090/debug/pprof/profile&quot;</span></span><br></pre></td></tr></table></figure><p>输入命令后并调用接口，30s后会暂停，然后输入<code>web</code>命令出现下面的页面</p><p>这个是pprof的<code>Graph</code>视图，记录了调用方法所花的时间和调用链，<strong>我们一般会关注红色颜色比较深的那一块，然后找到自己写的方法</strong></p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled.png" alt></p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/pprof-graph_(1" alt>.png)</p><h2 id="2-3-找到关键部分"><a href="#2-3-找到关键部分" class="headerlink" title="2.3 找到关键部分"></a>2.3 找到关键部分</h2><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%201.png" alt></p><p>从顶端开始找到第一个自己的业务方法，这里为<code>GetDetailsInfo</code> </p><p>然后我们可以输入命令<code>list GetDetailsInfo</code> 获得详细信息</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%202.png" alt></p><p>这里定位到60行花销的时间最多，但是这个还是个方法，我们可以回到终端输入<code>web GetDetailsInfo</code>  命令显示详细一点信息。</p><p>![]项目Golang优化点/Untitled%203.png)</p><p>定位128行，这里是使用的<code>GoFrame</code>框架带的orm查询语句，再往下的代码则是框架的源码，至此，利用pprof找问题可以告一段落</p><h1 id="三、优化点"><a href="#三、优化点" class="headerlink" title="三、优化点"></a>三、优化点</h1><h2 id="3-1-反序列化"><a href="#3-1-反序列化" class="headerlink" title="3.1 反序列化"></a>3.1 反序列化</h2><h3 id="3-1-1-找出关键点"><a href="#3-1-1-找出关键点" class="headerlink" title="3.1.1 找出关键点"></a>3.1.1 找出关键点</h3><p>对同一接口调用三次，然后利用pprof找出缺陷点</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%204.png" alt></p><p>这里面可以看到，绝大部分时间都花在了<code>FindAll</code> 方法上面了，查看这一部分源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tapd_bugs.FindAll(tapd_bugs.Columns.WorkspaceName, workspaceName)</span><br></pre></td></tr></table></figure><p>这一部分代码的作用是从数据库拿出数据并反序列化到结构体上面，SQL查询语句相当于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM tapd_bugs</span><br><span class="line">WHERE workspace_name = <span class="string">&quot;xxx&quot;</span>;</span><br></pre></td></tr></table></figure><p>首先我们得查看从数据库拿出数据大概需要多久</p><p>从程序打印出来的log日志中看到，从数据库拿数据花费的时间不到10ms（大概8w数据）</p><p>![]项目Golang优化点/Untitled%205.png)</p><p>那么问题可能出在了反序列化上面了，这里的反序列化意思大概是</p><p>拿到的数据格式大概是这样，是一个json数组（这里实际是[]byte数组，只不过ide显示友好化了）</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%206.png" alt></p><p>经过我们反序列化后，就可以将这些值放到结构体中，就相当于确定化了</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%207.png" alt></p><p>我们查看下这部分源码</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%208.png" alt></p><p>这里可以明显看出代码346行是将查询的数据<code>all</code>反序列化到<code>entities</code> ，那么问题就应该出现在红框那一块，点进去查看源码的话</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%209.png" alt></p><p>我们可以看到很多关于<code>reflect</code>包的函数，可以很明显看出这里使用了反射的方式反序列化</p><h3 id="3-1-2-反序列化处理过程"><a href="#3-1-2-反序列化处理过程" class="headerlink" title="3.1.2 反序列化处理过程"></a>3.1.2 反序列化处理过程</h3><p>假设我们有如下JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span> <span class="number">31</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>和如下结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用该方法反序列化一般的过程是怎么样的呢，怎么能够把JSON里面的数据映射到结构体里面呢？</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/unmarshal.png" alt></p><ul><li>首先会利用JSON扫描状态机对输入的JSON byte数组进行合法性检查，以保证后面操作JSON的正确性</li><li>接着会利用状态机对JSON进行解析，提取出key，value等信息</li><li>最后利用反射，将这些信息映射到结构体中</li></ul><p>利用反射我们可以在运行时对结构体动态赋值，对于一般结构体赋值我们可以这样显式赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">21</span>&#125;</span><br></pre></td></tr></table></figure><p>但是这样就太限制了。因为对于一般的情况，我们是不知道传入的结构体和JSON的结构是怎么样的，所以我们就需要一种技术能够让我们在运行时动态获取到结构体相关的信息（比如类型和值），并且有一些方法能够操纵这些数据，比如赋值，这样的话我们就能够动态去处理这些数据了，反射能够提供方法支持，所以就是我们要用反射的原因。</p><h3 id="3-1-3-反射"><a href="#3-1-3-反射" class="headerlink" title="3.1.3 反射"></a>3.1.3 反射</h3><ul><li>通过<code>reflect.TypeOf(i interface&#123;&#125;)</code> 我们能拿到变量的类型</li><li>通过<code>reflect.ValueOf(i interface&#123;&#125;)</code> 我们能拿到变量的值</li></ul><p>如果我们知道了一个变量的类型和值，那么就意味着知道了这个变量的全部信息。</p><p>有了变量的类型之后，我们可以通过 <code>Method</code> 方法获得类型实现的方法，通过 <code>Field</code> 获取类型包含的全部字段。对于不同的类型，我们也可以调用不同的方法获取相关信息：</p><ul><li>结构体：获取字段的数量并通过下标和字段名获取字段 <code>StructField</code>；</li><li>哈希表：获取哈希表的 <code>Key</code> 类型；</li><li>函数或方法：获取入参和返回值的类型；</li><li>…</li></ul><p>接着我们可以利用<code>reflect.Value.Set</code> 方法更新反射对象，所以我们可以看到下面的这个代码，传入一个空的<code>entities数组</code>，然后就可以得到有具体值的<code>entities数组</code></p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%208.png" alt></p><p>反射的原理可以大概理解为：</p><p>因为传入的数据都是<code>interface&#123;&#125;</code>类型，其在内部存储了<code>分配给该变量的具体值（the concrete value assigned to the variable）</code>以及<code>该值的类型描述符（value&#39;s type descriptor）</code></p><p>在<code>build</code>时，<code>Go linker</code>会将有关应用程序使用的所有类型的信息嵌入到可执行文件中</p><p>转换【编译时已知的类型】到【<code>interface&#123;&#125;</code>】的过程中，GO编译器会将类型描述符指向具体的类型描述符，这是编译时已知的，所以通过这两个就能拿到相关的信息。</p><h3 id="3-1-4-反射缺点"><a href="#3-1-4-反射缺点" class="headerlink" title="3.1.4 反射缺点"></a>3.1.4 反射缺点</h3><p>对于本项目来讲，缺点就是慢，特别是数据量多需要循环调用反射的时候，主要的原因在于：</p><ol><li>涉及到内存分配以及后续的GC</li><li>每次执行时都需要验证执行的每个步骤</li><li>查找类型信息时<code>I/O</code>速度慢</li><li>等等</li></ol><h3 id="3-1-5-解决方法"><a href="#3-1-5-解决方法" class="headerlink" title="3.1.5 解决方法"></a>3.1.5 解决方法</h3><p>既然反序列化过程比较慢，那么我们可以使用第三方JSON库去提高效率。仅需要修改下源码，将<code>structs</code>部分去掉，改为调用第三方JSON库的解析方式。</p><p>对于序列化库的实现来讲，如果在运行时通过反射的方式进行序列化和反序列化，性能不会太好，所以高性能的序列化库很多都是通过代码生成在编译的时候提供序列化和反序列化的方法。因为在编译的时候已经知道每个字段的类型，所以无需元数据，可以聪明的对字节按照流的方式顺序处理以及作更多的优化。</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%2010.png" alt></p><p>效率对比</p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%204.png" alt></p><p><img src="/2020/10/26/%E9%A1%B9%E7%9B%AEGolang%E4%BC%98%E5%8C%96%E7%82%B9/Untitled%2011.png" alt></p><h3 id="3-1-6-方案缺点"><a href="#3-1-6-方案缺点" class="headerlink" title="3.1.6 方案缺点"></a>3.1.6 方案缺点</h3><ul><li>因为代码是提前生成的，所以灵活性不强</li><li>适用于大量数据序列化场景，如果数据量不强，效果不明显，反而增加成本</li><li>需要明确反序列化后的结构</li></ul><h2 id="3-2-Redis-mset-key"><a href="#3-2-Redis-mset-key" class="headerlink" title="3.2 Redis mset key"></a>3.2 Redis mset key</h2><h3 id="3-2-1-找出关键点"><a href="#3-2-1-找出关键点" class="headerlink" title="3.2.1 找出关键点"></a>3.2.1 找出关键点</h3><p>项目需要一下设置很多缓存，这个也是个优化点，因为pprof不能捕获到for循环中Redis set key的所花费的时间，所以我们只能手动打点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> data&#123;</span><br><span class="line">g.Redis().Do(<span class="string">&quot;SETEX&quot;</span>, key, expiredTime, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(time.Now().Sub(start))</span><br></pre></td></tr></table></figure><p>这里数据大概有1k条，每条数据序列后长度不到20000</p><p>跑了一下上面的打点，需要花费<code>8.8595475s</code></p><p>这里瓶颈主要在于循环调用，多次调用会增加开销：</p><p>因为Redis本身是基于<code>request/response</code>模式，每一个命令都需要等待上一个命令响应后进行处理，中间需要经过RTT（Round Time Trip，往返延时，表示发送端从发送数据开始，到发送端收到来自接收端的确认，所需要的时间。），并且需要频繁调用系统I/O</p><hr><p>单次setx的操作所花费的时间为<code>22.9419ms</code> 压缩字符串后能减少到<code>17.9522ms</code> 但是整体调用起来差别不大</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g.Redis().Do(<span class="string">&quot;SETEX&quot;</span>, key, expiredTime, </span><br><span class="line">snappy.Encode(<span class="literal">nil</span>, gconv.Bytes(testPlanProcessData)))</span><br></pre></td></tr></table></figure><h3 id="3-2-2-mset"><a href="#3-2-2-mset" class="headerlink" title="3.2.2 mset"></a>3.2.2 mset</h3><p>对于这种需求，一个更好的方法使用<code>MSET</code>命令，可以一次性设置多个key value</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET k1 <span class="string">&quot;good&quot;</span> k2 <span class="string">&quot;bye&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令是原子的，要不全部完成要么完全不完成，不会看到一部分值被更新，而其他值未更新这种情况。该命令执行后会返回”ok”字符串。</p><p>从Redis官方文档来看，该命令每次都是会返回成功，不会失败</p><blockquote><p>Return value<br>Simple string reply: always OK since MSET can’t fail.</p></blockquote><p>这里的意思是不会在<code>MSET</code> 阶段返回错误，有错误的话Redis会提前返回：</p><p>在处理命令之前会检查内存容量，如果内存容量不够，无论命令的实际响应如何，都会返回错误响应</p><p>效率对比：</p><p><code>8.8595475s</code> → <code>1.3812954s</code></p><h3 id="3-2-3-方案缺点"><a href="#3-2-3-方案缺点" class="headerlink" title="3.2.3 方案缺点"></a>3.2.3 方案缺点</h3><p>使用 <code>MSET</code> 不能设置过期时间，我们可以使用<code>Lua</code>脚本处理，这里是一个批量设置<code>xx:xx:</code>前缀的key过期时间脚本的示例。可直接在<code>Redis-cli</code>中执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> </span><br><span class="line"><span class="string">&#x27;for i, name in ipairs(redis.call(&quot;KEYS&quot;, &quot;xx:xx:*&quot;)) </span></span><br><span class="line"><span class="string">do redis.call(&quot;EXPIRE&quot;, name, 10); end&#x27;</span> </span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以使用 <code>eval</code>命令执行<code>Lua</code>脚本</p><p><code>EVAL script numkeys key [key ...] arg [arg ...]</code></p><ul><li>上面最后0代表0个key</li><li><code>redis.call</code> 执行Redis 命令</li><li><code>ipairs</code>遍历集合</li></ul><h2 id="3-3-其他优化"><a href="#3-3-其他优化" class="headerlink" title="3.3 其他优化"></a>3.3 其他优化</h2><p>其他优化点都是很常见的，比如：</p><ul><li>加索引</li><li>多线程优化</li><li>避免多次调SQL，一次性查出来映射到map</li><li>等等</li></ul><p>这里就不赘述。</p><hr><ul><li><p>参考：</p><p>  <a href="https://stackoverflow.com/questions/34605415/how-does-golang-implement-reflection">How does golang implement reflection?</a></p><p>  <a href="https://blog.golang.org/laws-of-reflection">The Go Blog</a></p><p>  <a href="http://cnblogs.com/clannadxr/p/11314874.html">从unmarshal带json字符串字段的json说起</a></p><p>  <a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#43-%E5%8F%8D%E5%B0%84">Go 语言反射的实现原理</a></p><p>  <a href="http://miloyip.github.io/rapidjson/md_doc_internals.html#IterativeParser">RapidJSON: Internals</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/37165706">Go语言encoding/json库源码分析</a></p><p>  <a href="https://stackoverflow.com/questions/12911248/redis-set-command-cant-fail-but-can">https://stackoverflow.com/questions/12911248/redis-set-command-cant-fail-but-can</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> pprof </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> mset </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang反射应用-排序</title>
      <link href="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h1><p><strong>Go基础教程可看</strong></p><p><a href="https://studygolang.com/articles/13178">Go 系列教程 — 34. 反射</a></p><p><a href="https://yar999.gitbook.io/gopl-zh/ch12">反射</a></p><p><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/">Go 语言反射的实现原理</a></p><p>这里记下用的部分</p><h2 id="1-1-reflect-Value"><a href="#1-1-reflect-Value" class="headerlink" title="1.1 reflect.Value"></a>1.1 reflect.Value</h2><p><code>reflect.Value</code> 可以表示一个任意类型的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := User&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;</span><br><span class="line">v := reflect.ValueOf(u)</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">&#123;张三 56&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="1-2-reflect-Kind"><a href="#1-2-reflect-Kind" class="headerlink" title="1.2 reflect.Kind"></a>1.2 reflect.Kind</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := User&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line">k := t.Kind()</span><br><span class="line">fmt.Println(t)</span><br><span class="line">fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">main.User</span></span><br><span class="line"><span class="comment">struct</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="1-3-反射字段"><a href="#1-3-反射字段" class="headerlink" title="1.3 反射字段"></a>1.3 反射字段</h2><p>想要利用反射拿到结构体的字段，然后对其操作，需要这个字段是可访问的，也就是首字母大写</p><p><code>reflect.Indirect()</code>函数用于获取传入参数指向的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Indirect</span><span class="params">(v Value)</span></span> Value &#123;</span><br><span class="line"><span class="keyword">if</span> v.Kind() != Ptr &#123;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v.Elem()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">u := User&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;</span><br><span class="line">indirect := reflect.Indirect(reflect.ValueOf(&amp;u)).FieldByName(<span class="string">&quot;Age&quot;</span>)</span><br><span class="line">fmt.Println(indirect)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">56</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Indirect</span><span class="params">(v Value)</span></span> Value &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> Elem() Value &#123;&#125;</span><br></pre></td></tr></table></figure><p>这二个长的很像的兄弟有什么区别</p><blockquote><p><strong>*Elem</strong> returns the value that the interface v contains or that the pointer v points to. It panics if v’s Kind is not Interface or Ptr. It returns the zero Value if v is nil.*</p><p><strong>*Indirect</strong> returns the value that v points to. If v is a nil pointer, Indirect returns a zero Value. If v is not a pointer, Indirect returns v.*</p><ul><li>如果<code>reflect.Value</code>是一个指针， 那么<code>v.Elem()</code>等价于<code>reflect.Indirect(v)</code></li><li>如果不是指针<ul><li>如果是<code>interface</code> ，那么<code>reflect.Indirect(v)</code>返回原值，而<code>v.Elem()</code>返回<code>interface</code>中包含的值</li><li>如果是其它值， <code>v.Elem()</code>会<code>panic</code>，而<code>reflect.Indirect(v)</code>返回原值</li></ul></li></ul></blockquote><h1 id="二、排序"><a href="#二、排序" class="headerlink" title="二、排序"></a>二、排序</h1><h2 id="2-1-场景"><a href="#2-1-场景" class="headerlink" title="2.1 场景"></a>2.1 场景</h2><p>给定特定字段字符串对结构体切片进行排序，如下</p><p><code>sortutil.DescByField</code> 按照User结构体中的Age字段从大到小对切片排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userSlice := []User&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">24</span>&#125;&#125;</span><br><span class="line">sortutil.DescByField(userSlice, <span class="string">&quot;Age&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-sort-Slice"><a href="#2-2-sort-Slice" class="headerlink" title="2.2 sort.Slice"></a>2.2 sort.Slice</h2><p>Go中有个<code>sort.Slice</code> 方法可以对结构体切片排序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort.Slice(userSlice , <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userSlice [i].Age &gt; userSlice [j].Age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是这样得配合<code>switch</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">userSlice := []User&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">24</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">field := <span class="string">&quot;Name&quot;</span></span><br><span class="line"><span class="keyword">switch</span> field&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Age&quot;</span>:</span><br><span class="line">sort.Slice(userSlice , <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userSlice [i].Age &gt; userSlice [j].Age</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Name&quot;</span>:</span><br><span class="line">sort.Slice(userSlice , <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userSlice [i].Name &gt; userSlice [j].Name</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> userSlice&#123;</span><br><span class="line">fmt.Println(user)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">&#123;王五 24&#125;</span></span><br><span class="line"><span class="comment">&#123;李四 13&#125;</span></span><br><span class="line"><span class="comment">&#123;张三 56&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="2-2-SortWrapper"><a href="#2-2-SortWrapper" class="headerlink" title="2.2 SortWrapper"></a>2.2 SortWrapper</h2><p><a href="https://golang.org/pkg/sort/#example_Interface">sort - The Go Programming Language</a></p><p>使用<code>SortWrapper</code>优雅地实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以声明为[]*User传入指针</span></span><br><span class="line"><span class="keyword">type</span> Users []User</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Users)</span></span> Len() <span class="type">int</span>      &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Users)</span></span> Swap(i, j <span class="type">int</span>) &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByName <span class="keyword">struct</span>&#123; Users &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u ByName)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> u.Users[i].Name &lt; u.Users[j].Name &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByAge <span class="keyword">struct</span>&#123; Users &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u ByAge)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> u.Users[i].Age &lt; u.Users[j].Age&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">userSlice := []User&#123;&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">56</span>&#125;, &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">13</span>&#125;, &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">24</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">sort.Sort(ByAge&#123;userSlice&#125;)</span><br><span class="line"><span class="keyword">for</span> _, user := <span class="keyword">range</span> userSlice&#123;</span><br><span class="line">fmt.Println(user)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后配上<code>map</code>可以<del>曲线救国</del></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]sort.Interface)</span><br><span class="line">m[<span class="string">&quot;Age&quot;</span>] = ByAge&#123;userSlice&#125;</span><br><span class="line">m[<span class="string">&quot;Name&quot;</span>] = ByName&#123;userSlice&#125;</span><br><span class="line"></span><br><span class="line">field := <span class="string">&quot;Age&quot;</span></span><br><span class="line">sort.Sort(m[field])</span><br></pre></td></tr></table></figure><h2 id="2-3-反射"><a href="#2-3-反射" class="headerlink" title="2.3 反射"></a>2.3 反射</h2><p>使用反射排序n多年前就有大佬实现了，只不过是停止更新了，不过还是可以用的，使用起来挺简单的，按照给的示例模仿就ok<br>不过缺点就是慢，大概在数据量在几万以上时会看出区别。</p><p>主要是因为涉及到内存分配以及后续的<code>GC</code>以及<code>reflect</code>实现里面有大量的枚举，也就是for循环，比如类型之类的。</p><p><a href="https://github.com/patrickmn/sortutil">patrickmn/sortutil</a></p><p><a href="https://groups.google.com/g/golang-nuts/c/EZ9yGIw0IeI">How to sort an array of struct by field?</a></p><hr><p>拿<code>2.1</code>那个代码来讲</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sortutil.DescByField(userSlice, <span class="string">&quot;Age&quot;</span>)</span><br></pre></td></tr></table></figure><p>该方法主要是通过反射按照给定的字段名从给定的切片中拿到关于该字段的列表</p><p><img src="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/Untitled.png" alt></p><p>然后判断类型</p><p><img src="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/Untitled%201.png" alt></p><p><code>stringDescending</code> 是为了实现自定义的大于比较规则。不比已知的<code>int</code>，<code>string</code>等类型，对于未知类型Golang也不知道如何比较大小</p><p><img src="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/Untitled%202.png" alt></p><p>然后对所得到的反射列表排序</p><p><img src="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/Untitled%203.png" alt></p><p>这里会根据数组的特点选择是快排还是堆排</p><p><img src="/2020/10/19/Golang%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8-%E6%8E%92%E5%BA%8F/Untitled%204.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch配置i3wm</title>
      <link href="/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/"/>
      <url>/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/</url>
      
        <content type="html"><![CDATA[<p>下面的某些软件可能在<code>archlinuxcn</code>源，注意先配置</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h2><p><a href="https://greenhathg.github.io/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">Arch安装配置笔记</a></p><h2 id="i3"><a href="#i3" class="headerlink" title="i3"></a>i3</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S i3</span><br></pre></td></tr></table></figure><p>注意<code>i3-gaps</code>会和<code>i3-wm</code>冲突，默认选择前者</p><p>配置文件位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.config/i3/config</span><br></pre></td></tr></table></figure><h2 id="Display-manager"><a href="#Display-manager" class="headerlink" title="Display manager"></a>Display manager</h2><p>为了方便管理i3的启动，这里选择使用<code>lightdm</code> 作为启动管理器，安装完后重启即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S lightdm lightdm-gtk-greeter</span><br></pre></td></tr></table></figure><p>如果不需要的话也可以在<code>tty</code>输入<code>startx</code>启动</p><h1 id="常用键位"><a href="#常用键位" class="headerlink" title="常用键位"></a>常用键位</h1><p><code>mod</code>为<code>win</code>键或者<code>alt</code>键，在第一次进入桌面时会选择</p><ol><li>打开终端：mod+enter</li><li>启动软件：mod+d</li><li>横向排列窗口：mod+h</li><li>纵向排列窗口：mod+v</li><li>将某个窗口全屏：mod+f</li><li>退出窗口：mod+shift+q</li><li>重启i3：mod+shift+r</li><li>打开工作区：mod+num</li><li>将当前窗口移动到某工作区：mod+shift+num</li></ol><h1 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h1><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>配置文件末尾加入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_window pixel 0</span><br><span class="line">gaps inner 7</span><br></pre></td></tr></table></figure><h2 id="关闭picom-popup-menu透明化"><a href="#关闭picom-popup-menu透明化" class="headerlink" title="关闭picom popup_menu透明化"></a>关闭picom popup_menu透明化</h2><p>复制一份配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/xdg/picom.conf.example ~/.config/picom.conf</span><br></pre></td></tr></table></figure><p>配置中修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popup_menu = &#123; fade = <span class="literal">true</span>; shadow = <span class="literal">false</span>; opacity = 1; focus = <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S alacrootty</span><br></pre></td></tr></table></figure><p>拉取默认配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.config/alacritty</span><br><span class="line">wget https://raw.githubusercontent.com/alacritty/alacritty/master/alacritty.yml ~/.config/alacritty</span><br></pre></td></tr></table></figure><p>配置文件写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="variable">$terminal</span> alacritty</span><br><span class="line">bindsym <span class="variable">$mod</span>+Return <span class="built_in">exec</span> <span class="variable">$terminal</span></span><br></pre></td></tr></table></figure><ul><li><p>修改字体</p><p>  <img src="/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/Untitled.png" alt></p></li><li><p>设置透明度</p><p>  <img src="/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/Untitled%201.png" alt></p></li></ul><h2 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S variety feh picom</span><br></pre></td></tr></table></figure><p>开机自启，配置文件写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec_always --no-startup-id variety</span><br><span class="line">exec_always --no-startup-id picom</span><br></pre></td></tr></table></figure><h2 id="快捷启动"><a href="#快捷启动" class="headerlink" title="快捷启动"></a>快捷启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S rofi</span><br></pre></td></tr></table></figure><h2 id="命令行文件管理器"><a href="#命令行文件管理器" class="headerlink" title="命令行文件管理器"></a>命令行文件管理器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S ranger</span><br></pre></td></tr></table></figure><p>配置文件写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindsym ctrl+<span class="variable">$mod</span>+f <span class="built_in">exec</span> --no-startup-id <span class="variable">$terminal</span> -e ranger</span><br></pre></td></tr></table></figure><p>这里注意先走安装<code>alacritty</code>这一步</p><h1 id="polybar"><a href="#polybar" class="headerlink" title="polybar"></a>polybar</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S polybar</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>这里推荐使用大佬的配置</p><p><a href="https://github.com/jessun2017/dotfiles">jessun2017/dotfiles</a></p><ul><li><p>测试</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">polybar -c <span class="variable">$HOME</span>/.config/polybar/config.ini example</span><br></pre></td></tr></table></figure></li><li><p>开机自启</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec_always ~/.config/polybar/launch.sh</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置温度"><a href="#配置温度" class="headerlink" title="配置温度"></a>配置温度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /sys/class/hwmon/hwmon*/temp*_input; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(&lt;$(dirname $i)</span>/name): <span class="subst">$(cat $&#123;i%_*&#125;_label 2&gt;/dev/null || echo $(basename $&#123;i%_*&#125;)</span>) <span class="subst">$(readlink -f $i)</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>一般选择<code>Tdie</code>那条结果，写入到配置文件<code>config.ini</code></p><p><img src="/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/Untitled%202.png" alt></p><h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S ttf-font-awesome ttf-liberation adobe-source-han-sans-cn-fonts ttf-material-design-icons</span><br></pre></td></tr></table></figure><p>如果有报错<code>Dropping unmatched character</code> ，可以尝试安装以下字体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S siji-git ttf-unifont</span><br></pre></td></tr></table></figure><h2 id="网速显示"><a href="#网速显示" class="headerlink" title="网速显示"></a>网速显示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S bc</span><br></pre></td></tr></table></figure><p>编辑文件<code>~/.config/polybar/polybar-scripts/polybar-scripts/network-traffic/[network-traffic.sh](http://network-traffic.sh/)</code> 修改网卡名称</p><p><img src="/2020/10/18/Arch%E9%85%8D%E7%BD%AEi3wm/Untitled%203.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> i3wm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-range中的坑</title>
      <link href="/2020/09/30/Golang-range%E4%B8%AD%E7%9A%84%E5%9D%91/"/>
      <url>/2020/09/30/Golang-range%E4%B8%AD%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>range遍历指针类型时注意事项</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">odd := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr&#123;</span><br><span class="line"><span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">1</span>&#123;</span><br><span class="line">odd = <span class="built_in">append</span>(odd, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> odd&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line">**odd := <span class="built_in">make</span>([]*<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)**</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr&#123;</span><br><span class="line"><span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">1</span>&#123;</span><br><span class="line">**odd = <span class="built_in">append</span>(odd, &amp;v)**</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> odd&#123;</span><br><span class="line">**fmt.Println(*v)**</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的区别主要是slice里面装的是标准类型还是指针类型，标准类型可以得到正常结果，而指针类型则得到重复的结果</p><hr><p><a href="https://golang.org/ref/spec#RangeClause">The Go Programming Language Specification</a></p><p>根据Go range的文档中得到</p><blockquote><p>The iteration variables may be declared by the “range” clause using a form of short variable declaration (:=). In this case their types are set to the types of the respective iteration values and their scope is the block of the “for” statement; they are re-used in each iteration. If the iteration variables are declared outside the “for” statement, after execution their values will be those of the last iteration.</p></blockquote><p><strong>变量在迭代中会重复使用</strong>，如果变量声明在for外，那么迭代结束后变量值为最后一次赋值。</p><p>因为变量v被重复使用，而它的地址不会变更。</p><p>那么上面指针类型的得到错误的结果原因也是这个</p><hr><p><strong>解决方法主要有两个：</strong></p><ol><li><p>使用下标</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr&#123;</span><br><span class="line"><span class="keyword">if</span> arr[i] % <span class="number">2</span> == <span class="number">1</span>&#123;</span><br><span class="line">odd = <span class="built_in">append</span>(odd, &amp;arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用临时变量</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr&#123;</span><br><span class="line"><span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">1</span>&#123;</span><br><span class="line">tmp := v</span><br><span class="line">odd = <span class="built_in">append</span>(odd, &amp;tmp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> range </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang生成十亿手机号码的探究</title>
      <link href="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/"/>
      <url>/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>优化大量生成手机号码所使用的时间，取得较好的成果</p><span id="more"></span><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>既然是计算时间，那么肯定受电脑配置影响，这里贴下配置</p><p>win10</p><p><img src="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/4.png" alt></p><h1 id="随机字符串生成前景"><a href="#随机字符串生成前景" class="headerlink" title="随机字符串生成前景"></a>随机字符串生成前景</h1><p>以下省略计算时间的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">before := time.Now()</span><br><span class="line">fmt.Println(before.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">after := time.Now()</span><br><span class="line">fmt.Println(after.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(after.Sub(before))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单纯跑十亿次循环"><a href="#单纯跑十亿次循环" class="headerlink" title="单纯跑十亿次循环"></a>单纯跑十亿次循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idx := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++&#123;</span><br><span class="line">    idx++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2020-09-14 15:01:22</span></span><br><span class="line"><span class="comment">//2020-09-14 15:01:22</span></span><br><span class="line"><span class="comment">//232.3817ms</span></span><br></pre></td></tr></table></figure><h2 id="十亿次随机获取手机号码"><a href="#十亿次随机获取手机号码" class="headerlink" title="十亿次随机获取手机号码"></a>十亿次随机获取手机号码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> headerNums = [...]<span class="type">string</span>&#123;<span class="string">&quot;139&quot;</span>, <span class="string">&quot;138&quot;</span>, <span class="string">&quot;137&quot;</span>, <span class="string">&quot;136&quot;</span>, <span class="string">&quot;135&quot;</span>, <span class="string">&quot;134&quot;</span>, <span class="string">&quot;159&quot;</span>, <span class="string">&quot;158&quot;</span>, <span class="string">&quot;157&quot;</span>, <span class="string">&quot;150&quot;</span>, <span class="string">&quot;151&quot;</span>, <span class="string">&quot;152&quot;</span>, <span class="string">&quot;188&quot;</span>, <span class="string">&quot;187&quot;</span>, <span class="string">&quot;182&quot;</span>, <span class="string">&quot;183&quot;</span>, <span class="string">&quot;184&quot;</span>, <span class="string">&quot;178&quot;</span>, <span class="string">&quot;130&quot;</span>, <span class="string">&quot;131&quot;</span>, <span class="string">&quot;132&quot;</span>, <span class="string">&quot;156&quot;</span>, <span class="string">&quot;155&quot;</span>, <span class="string">&quot;186&quot;</span>, <span class="string">&quot;185&quot;</span>, <span class="string">&quot;176&quot;</span>, <span class="string">&quot;133&quot;</span>, <span class="string">&quot;153&quot;</span>, <span class="string">&quot;189&quot;</span>, <span class="string">&quot;180&quot;</span>, <span class="string">&quot;181&quot;</span>, <span class="string">&quot;177&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> headerNumsLen = <span class="built_in">len</span>(headerNums)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPhone</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">header := headerNums[rand.Intn(headerNumsLen)]</span><br><span class="line">body := fmt.Sprintf(<span class="string">&quot;%08d&quot;</span>, rand.Intn(<span class="number">99999999</span>))</span><br><span class="line">phone := header + body</span><br><span class="line"><span class="keyword">return</span> phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++&#123;</span><br><span class="line">randomPhone()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2020-09-14 15:08:08</span></span><br><span class="line"><span class="comment">//2020-09-14 15:11:05</span></span><br><span class="line"><span class="comment">//2m56.9453851s</span></span><br></pre></td></tr></table></figure><p>可以看到时间差不多花在了生成随机数那里</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++&#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++&#123;</span><br><span class="line">            randomPhone()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2020-09-14 17:21:15</span></span><br><span class="line"><span class="comment">//2020-09-14 17:25:40</span></span><br><span class="line"><span class="comment">//4m25.289406s</span></span><br></pre></td></tr></table></figure><p>可以明显看到时间花长了，这一部分应该是<code>rand</code>内部有互斥锁的原因，并发情况下竞争锁</p><p><img src="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/1.jpg" alt></p><p><code>sync.mutex</code>锁的过程大概如下：</p><p><img src="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/2.jpg" alt></p><p>有两种状态：</p><ul><li>正常状态：等待锁的goroutine按照FIFO的顺序获得锁，如有新请求的锁，则与被唤醒的竞争锁，失败则加入队首，如果一个等待的goroutine超过1ms没有获取锁，那么它将会把锁转变为饥饿模式。</li><li>饥饿状态：把锁交给等待队列中的第一个（已经unlock状态），新来的goroutine将不会尝试去获得锁，即使锁看起来是unlock状态, 也不会去尝试自旋操作，而是放在等待队列的尾部。</li></ul><h2 id="协程改进"><a href="#协程改进" class="headerlink" title="协程改进"></a>协程改进</h2><p>既然那么多个goroutine会竞争锁，所以我们可以给每个goroutine开一把锁，也就是多个rand实例，那么就不用竞争锁了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> headerNums = [...]<span class="type">string</span>&#123;<span class="string">&quot;139&quot;</span>, <span class="string">&quot;138&quot;</span>, <span class="string">&quot;137&quot;</span>, <span class="string">&quot;136&quot;</span>, <span class="string">&quot;135&quot;</span>, <span class="string">&quot;134&quot;</span>, <span class="string">&quot;159&quot;</span>, <span class="string">&quot;158&quot;</span>, <span class="string">&quot;157&quot;</span>, <span class="string">&quot;150&quot;</span>, <span class="string">&quot;151&quot;</span>, <span class="string">&quot;152&quot;</span>, <span class="string">&quot;188&quot;</span>, <span class="string">&quot;187&quot;</span>, <span class="string">&quot;182&quot;</span>, <span class="string">&quot;183&quot;</span>, <span class="string">&quot;184&quot;</span>, <span class="string">&quot;178&quot;</span>, <span class="string">&quot;130&quot;</span>, <span class="string">&quot;131&quot;</span>, <span class="string">&quot;132&quot;</span>, <span class="string">&quot;156&quot;</span>, <span class="string">&quot;155&quot;</span>, <span class="string">&quot;186&quot;</span>, <span class="string">&quot;185&quot;</span>, <span class="string">&quot;176&quot;</span>, <span class="string">&quot;133&quot;</span>, <span class="string">&quot;153&quot;</span>, <span class="string">&quot;189&quot;</span>, <span class="string">&quot;180&quot;</span>, <span class="string">&quot;181&quot;</span>, <span class="string">&quot;177&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> headerNumsLen = <span class="built_in">len</span>(headerNums)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPhone</span><span class="params">(generator *rand.Rand)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">header := headerNums[generator.Intn(headerNumsLen)]</span><br><span class="line">body := fmt.Sprintf(<span class="string">&quot;%08d&quot;</span>, generator.Intn(<span class="number">99999999</span>))</span><br><span class="line">phone := header + body</span><br><span class="line"><span class="keyword">return</span> phone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">before := time.Now()</span><br><span class="line">fmt.Println(before.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">nCPU := runtime.NumCPU()</span><br><span class="line">runtime.GOMAXPROCS(nCPU)</span><br><span class="line"></span><br><span class="line">loop := <span class="number">1000000000</span> / nCPU</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nCPU; i++&#123;</span><br><span class="line">        <span class="comment">//避免种子一样，生成的随机数也一样</span></span><br><span class="line">generator := rand.New(rand.NewSource(time.Now().UnixNano() + <span class="type">int64</span>(i*<span class="number">1000</span>)))</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(generator *rand.Rand)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; loop; j++&#123;</span><br><span class="line">randomPhone(generator)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">&#125;(generator)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">after := time.Now()</span><br><span class="line">fmt.Println(after.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(after.Sub(before))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2020-09-15 22:23:09</span></span><br><span class="line"><span class="comment">//2020-09-15 22:23:38</span></span><br><span class="line"><span class="comment">//28.8154403s</span></span><br></pre></td></tr></table></figure><h1 id="改善字符串生成的方法"><a href="#改善字符串生成的方法" class="headerlink" title="改善字符串生成的方法"></a>改善字符串生成的方法</h1><h2 id="rand-Intn"><a href="#rand-Intn" class="headerlink" title="rand.Intn"></a>rand.Intn</h2><p><img src="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/3.jpg" alt></p><p>可以看到，<code>rand.Intn</code>函数最终会调用<code>Rand.Int63</code>，所以我们可以直接调用该函数即可</p><h2 id="利用掩码提高效率"><a href="#利用掩码提高效率" class="headerlink" title="利用掩码提高效率"></a>利用掩码提高效率</h2><p>我们现在有10个数字，10用二进制表示就是<code>1010</code>，所以我们可以只使用<code>Rand.Int63()</code>返回最低的4位数就可以。为了保证平均，如果返回的只大于<code>len(letterBytes)-1</code>，则舍弃不用</p><p><code>Rand.Int63</code>可以生成63个随机位的数，所以剩下的位数我们依旧可以使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> letterBytes = <span class="string">&quot;0123456789&quot;</span></span><br><span class="line"><span class="keyword">var</span> src = rand.NewSource(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> headerNums = [...]<span class="type">string</span>&#123;<span class="string">&quot;139&quot;</span>, <span class="string">&quot;138&quot;</span>, <span class="string">&quot;137&quot;</span>, <span class="string">&quot;136&quot;</span>, <span class="string">&quot;135&quot;</span>, <span class="string">&quot;134&quot;</span>, <span class="string">&quot;159&quot;</span>, <span class="string">&quot;158&quot;</span>, <span class="string">&quot;157&quot;</span>, <span class="string">&quot;150&quot;</span>, <span class="string">&quot;151&quot;</span>, <span class="string">&quot;152&quot;</span>, <span class="string">&quot;188&quot;</span>, <span class="string">&quot;187&quot;</span>, <span class="string">&quot;182&quot;</span>, <span class="string">&quot;183&quot;</span>, <span class="string">&quot;184&quot;</span>, <span class="string">&quot;178&quot;</span>, <span class="string">&quot;130&quot;</span>, <span class="string">&quot;131&quot;</span>, <span class="string">&quot;132&quot;</span>, <span class="string">&quot;156&quot;</span>, <span class="string">&quot;155&quot;</span>, <span class="string">&quot;186&quot;</span>, <span class="string">&quot;185&quot;</span>, <span class="string">&quot;176&quot;</span>, <span class="string">&quot;133&quot;</span>, <span class="string">&quot;153&quot;</span>, <span class="string">&quot;189&quot;</span>, <span class="string">&quot;180&quot;</span>, <span class="string">&quot;181&quot;</span>, <span class="string">&quot;177&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> headerNumsLen = <span class="built_in">len</span>(headerNums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">//使用四位二进制即可随机选择letterBytes里面的一位</span></span><br><span class="line">letterIdxBits = <span class="number">4</span></span><br><span class="line">    <span class="comment">//掩码，即4个1</span></span><br><span class="line">letterIdxMask = <span class="number">1</span>&lt;&lt;letterIdxBits - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">//使用六位二进制即可随机选择headerNums里面的一位</span></span><br><span class="line">headerIdxBits = <span class="number">6</span></span><br><span class="line">headerIdxMask = <span class="number">1</span>&lt;&lt;headerIdxBits - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHeaderIdx</span><span class="params">(cache <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> cache &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="comment">//得到掩码对应的位数，比如1010110101 &amp; 111111 = 0000110101</span></span><br><span class="line">        <span class="comment">//这样就可以取出二进制去随机选择数字了</span></span><br><span class="line">idx := <span class="type">int</span>(cache &amp; headerIdxMask)</span><br><span class="line"><span class="keyword">if</span> idx &lt; headerNumsLen&#123;</span><br><span class="line"><span class="keyword">return</span> idx</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//取到的数字超过headerNums的长度，除去后6位，重新选择数字</span></span><br><span class="line">cache &gt;&gt;= headerIdxBits</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//否则使用库函数生成</span></span><br><span class="line"><span class="keyword">return</span> rand.Intn(headerNumsLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPhone</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//12位手机号码</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">12</span>)</span><br><span class="line">    <span class="comment">//获取一个63位的随机数</span></span><br><span class="line">cache := src.Int63()</span><br><span class="line">    <span class="comment">//获取选择手机号码前3位的随机数</span></span><br><span class="line">headerIdx := getHeaderIdx(cache)</span><br><span class="line">    <span class="comment">//使用得到的随机数去获取手机号码前3位</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">b[i] = headerNums[headerIdx][i]</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//继续选择剩下的12位</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">3</span>; i &lt; <span class="number">12</span> ; &#123;</span><br><span class="line">        <span class="comment">//生成的随机数用完了，重新生成</span></span><br><span class="line"><span class="keyword">if</span> cache == <span class="number">0</span>&#123;</span><br><span class="line">cache = src.Int63()</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//和getHeaderIdx一样</span></span><br><span class="line"><span class="keyword">if</span> idx := <span class="type">int</span>(cache &amp; letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) &#123;</span><br><span class="line">b[i] = letterBytes[idx]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">cache &gt;&gt;= letterIdxBits</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用strings-Builder提升字符串拼接速度（可选）"><a href="#使用strings-Builder提升字符串拼接速度（可选）" class="headerlink" title="使用strings.Builder提升字符串拼接速度（可选）"></a>使用strings.Builder提升字符串拼接速度（可选）</h2><p>这个是G0 1.10 新增的功能，提升字符串拼接的效率，<code>strings.Builder</code>的原理其实很简单，是内置了一个<code>[]byte</code>存储字符，最终转换为<code>string</code>的时候为了避免拷贝，使用了<code>unsafe</code>包，可以把<code>string(b)</code>变为<code>*(*string)(unsafe.Pointer(&amp;b))</code></p><p>这里字符串长度比较短，所以影响不大</p><h2 id="最后的代码"><a href="#最后的代码" class="headerlink" title="最后的代码"></a>最后的代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> letterBytes = <span class="string">&quot;0123456789&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">letterIdxBits = <span class="number">4</span></span><br><span class="line">letterIdxMask = <span class="number">1</span>&lt;&lt;letterIdxBits - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> src = rand.NewSource(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> headerNums = [...]<span class="type">string</span>&#123;<span class="string">&quot;139&quot;</span>, <span class="string">&quot;138&quot;</span>, <span class="string">&quot;137&quot;</span>, <span class="string">&quot;136&quot;</span>, <span class="string">&quot;135&quot;</span>, <span class="string">&quot;134&quot;</span>, <span class="string">&quot;159&quot;</span>, <span class="string">&quot;158&quot;</span>, <span class="string">&quot;157&quot;</span>, <span class="string">&quot;150&quot;</span>, <span class="string">&quot;151&quot;</span>, <span class="string">&quot;152&quot;</span>, <span class="string">&quot;188&quot;</span>, <span class="string">&quot;187&quot;</span>, <span class="string">&quot;182&quot;</span>, <span class="string">&quot;183&quot;</span>, <span class="string">&quot;184&quot;</span>, <span class="string">&quot;178&quot;</span>, <span class="string">&quot;130&quot;</span>, <span class="string">&quot;131&quot;</span>, <span class="string">&quot;132&quot;</span>, <span class="string">&quot;156&quot;</span>, <span class="string">&quot;155&quot;</span>, <span class="string">&quot;186&quot;</span>, <span class="string">&quot;185&quot;</span>, <span class="string">&quot;176&quot;</span>, <span class="string">&quot;133&quot;</span>, <span class="string">&quot;153&quot;</span>, <span class="string">&quot;189&quot;</span>, <span class="string">&quot;180&quot;</span>, <span class="string">&quot;181&quot;</span>, <span class="string">&quot;177&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> headerNumsLen = <span class="built_in">len</span>(headerNums)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">headerIdxBits = <span class="number">6</span></span><br><span class="line">headerIdxMask = <span class="number">1</span>&lt;&lt;headerIdxBits - <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHeaderIdx</span><span class="params">(cache <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">for</span> cache &gt; <span class="number">0</span>&#123;</span><br><span class="line">idx := <span class="type">int</span>(cache &amp; headerIdxMask)</span><br><span class="line"><span class="keyword">if</span> idx &lt; headerNumsLen&#123;</span><br><span class="line"><span class="keyword">return</span> idx</span><br><span class="line">&#125;</span><br><span class="line">cache &gt;&gt;= headerIdxBits</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rand.Intn(headerNumsLen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomPhone</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">12</span>)</span><br><span class="line">cache := src.Int63()</span><br><span class="line">headerIdx := getHeaderIdx(cache)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++&#123;</span><br><span class="line">b[i] = headerNums[headerIdx][i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">3</span>; i &lt; <span class="number">12</span> ; &#123;</span><br><span class="line"><span class="keyword">if</span> cache == <span class="number">0</span>&#123;</span><br><span class="line">cache = src.Int63()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> idx := <span class="type">int</span>(cache &amp; letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) &#123;</span><br><span class="line">b[i] = letterBytes[idx]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">cache &gt;&gt;= letterIdxBits</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">before := time.Now()</span><br><span class="line">fmt.Println(before.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++&#123;</span><br><span class="line">randomPhone()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">after := time.Now()</span><br><span class="line">fmt.Println(after.Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>))</span><br><span class="line">fmt.Println(after.Sub(before))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2020-09-15 20:44:13</span></span><br><span class="line"><span class="comment">//2020-09-15 20:45:34</span></span><br><span class="line"><span class="comment">//1m21.0054747s</span></span><br></pre></td></tr></table></figure><p>速度提升还是很明显的，在配置低的电脑上面差距会更大</p><p>如果我们加上协程呢，同时注意去掉<code>var src = rand.NewSource(time.Now().UnixNano())</code>避免竞争锁</p><p>调用代码和没有使用改善字符串生成的方法差不多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2020-09-15 22:19:33</span></span><br><span class="line"><span class="comment">//2020-09-15 22:19:45</span></span><br><span class="line"><span class="comment">//11.851417s</span></span><br></pre></td></tr></table></figure><p>效果强劲</p><h1 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h1><ul><li><p>不开多个协程：<code>2m56.9453851s &gt;&gt; 1m21.0054747s</code></p></li><li><p>开多个协程：<code>28.8154403s &gt;&gt; 11.851417s</code> </p></li></ul><hr><p>参考：</p><p><a href="https://colobu.com/2018/12/18/dive-into-sync-mutex/">sync.mutex 源代码分析 | 鸟窝</a></p><p><a href="https://juejin.im/post/6844904029277913102">图解Go里面的互斥锁mutex了解编程语言核心实现源码 - 掘金</a></p><p><a href="https://www.flysnow.org/2019/09/30/how-to-generate-a-random-string-of-a-fixed-length-in-go.html">一步步提升Go语言生成随机字符串的效率 | 飞雪无情的博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 随机数据 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-admin-template第三方接入配合动态路由</title>
      <link href="/2020/09/10/vue-admin-template%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5%E9%85%8D%E5%90%88%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2020/09/10/vue-admin-template%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5%E9%85%8D%E5%90%88%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>vue-admin-template接入公司内部认证系统总结</p><span id="more"></span><h1 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h1><ol><li>检测用户有没有登录</li><li>没有则跳转至<code>http://xxx.com?url=&lt;return_url&gt;</code></li><li>授权后跳回<code>return_url</code>从url中获取token</li><li>解析token，保存用户数据</li><li>登录后的逻辑</li></ol><h1 id="跳转部分"><a href="#跳转部分" class="headerlink" title="跳转部分"></a>跳转部分</h1><h2 id="修改login页面"><a href="#修改login页面" class="headerlink" title="修改login页面"></a>修改login页面</h2><p>里面我们只需要在框架中添加跳转页面以及跳转后处理页面即可，其他的框架已经使用路由帮我们处理</p><p>因为判断到没有登录会重定向到<code>/login</code>，所以我们可以修改<code>/login</code>对应的页面，让其直接跳转到认证页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/views/login/index.vue</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;http://passport.oa.com/modules/passport/signin.ashx?url=http://127.0.0.1:9527/#/ioa&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="添加跳转后处理页面"><a href="#添加跳转后处理页面" class="headerlink" title="添加跳转后处理页面"></a>添加跳转后处理页面</h2><p>这里跳转后的页面是<code>/oauth</code>，所以我们需要添加一个全新页面去获取<code>token</code></p><h3 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/oauth&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/login/oauth&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="添加处理页面"><a href="#添加处理页面" class="headerlink" title="添加处理页面"></a>添加处理页面</h3><p>跳转后的url大概长这个样子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xx.com/?token=xx#/oauth</span><br></pre></td></tr></table></figure><p>我们需要提取出token的内容，使用下面方法即可提取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getQueryVariable</span>(<span class="params">variable</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> query = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> vars = query.<span class="title function_">split</span>(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vars.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> pair = vars[i].<span class="title function_">split</span>(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pair[<span class="number">0</span>] === variable) &#123;</span><br><span class="line">      <span class="keyword">return</span> pair[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> token = <span class="variable language_">this</span>.<span class="title function_">getQueryVariable</span>(<span class="string">&#x27;token&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="处理部分"><a href="#处理部分" class="headerlink" title="处理部分"></a>处理部分</h1><h2 id="解析token"><a href="#解析token" class="headerlink" title="解析token"></a>解析token</h2><p>发送get请求到特定的url即可获得到用户信息，这里使用的方式是后端获取，因为前端存在跨域问题，配置了一下不能解决，所以改为后端获取</p><p>然后后端解析l完成后把信息发回前端，大概实现如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/login&#x27;</span>, ticket).<span class="title function_">then</span>(...)</span><br></pre></td></tr></table></figure><p>这里token是随机给的，因为用不上token，同时框架判断登录等逻辑需要用到token，为了避免大改动，所以添加了个随机token</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/store/modules/user.js</span></span><br><span class="line"><span class="title function_">login</span>(<span class="params">&#123; commit &#125;, ticket</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios.<span class="title function_">post</span>(<span class="string">&#x27;http://127.0.0.1:8090/api/login&#x27;</span>, &#123;</span><br><span class="line">        <span class="string">&quot;ticket&quot;</span>: ticket</span><br><span class="line">      &#125;, &#123;<span class="attr">timeout</span>: <span class="number">1000</span> * <span class="number">20</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> token = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">slice</span>(-<span class="number">8</span>)</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_TOKEN&#x27;</span>, token)</span><br><span class="line">        <span class="title function_">setToken</span>(token)</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="property">data</span>.<span class="property">code</span> === <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="title function_">setLocalStorage</span>(<span class="string">&#x27;userInfo&#x27;</span>, res.<span class="property">data</span>.<span class="property">data</span>)</span><br><span class="line">          <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>整个处理页面看起来就是这样<code>src/views/login/oauth.vue</code></p><p><img src="/2020/09/10/vue-admin-template%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%85%A5%E9%85%8D%E5%90%88%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/1.png" alt></p><p><strong>路由处理是最核心也是比较难处理的一点</strong>，处理不好的话可能会导致</p><ol><li>浏览器无限加载，白屏</li><li>死循环，性能占用大幅上升，可能会造成浏览器卡死</li></ol><p><a href="https://greenhathg.github.io/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/">vue-admin-template动态路由 - GreenHatHGのBlog</a></p><p>相比之前的方案进行了一些调整，主要更改点：</p><ol><li>将请求动态路由数据部分放到了beforeEach里面处理</li><li>添加<code>ioa</code>页面处理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Message</span>, <span class="title class_">MessageBox</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NProgress</span> <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span> <span class="comment">// progress bar</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span> <span class="comment">// progress bar style</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span> <span class="comment">// get token from cookie</span></span><br><span class="line"><span class="keyword">import</span> getPageTitle <span class="keyword">from</span> <span class="string">&#x27;@/utils/get-page-title&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&#x27;@/layout/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getLocalStorage, setLocalStorage&#125; <span class="keyword">from</span> <span class="string">&quot;@/utils/my-utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">NProgress</span>.<span class="title function_">configure</span>(&#123; <span class="attr">showSpinner</span>: <span class="literal">false</span> &#125;) <span class="comment">// NProgress Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/ioa&#x27;</span>] <span class="comment">// no redirect whitelist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRouterKey = <span class="string">&#x27;myRouter&#x27;</span></span><br><span class="line"><span class="keyword">let</span> getRouter = []; <span class="comment">//后台拿到的路由</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addRouter</span>(<span class="params">to, next</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;addRouter&#x27;</span>, getRouter)</span><br><span class="line">  <span class="keyword">const</span> myRouters = <span class="title function_">filterAsyncRouter</span>(getRouter)</span><br><span class="line">  router.<span class="title function_">addRoutes</span>(myRouters)</span><br><span class="line">  router.<span class="title function_">addRoutes</span>(  [&#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;])</span><br><span class="line">  <span class="variable language_">global</span>.<span class="property">antRouter</span> = myRouters</span><br><span class="line">  <span class="title function_">next</span>(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setRouter</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data&#x27;</span>, data)</span><br><span class="line">  getRouter = []</span><br><span class="line">  <span class="keyword">let</span> children = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> data) &#123;</span><br><span class="line">    children.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">path</span>: name,</span><br><span class="line">      <span class="attr">name</span>: name,</span><br><span class="line">      <span class="attr">component</span>: <span class="string">&#x27;@/views/table/sss&#x27;</span>,</span><br><span class="line">      <span class="attr">meta</span>: &#123;<span class="attr">title</span>: name, <span class="attr">icon</span>: <span class="string">&#x27;table&#x27;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  getRouter.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/ss&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="string">&#x27;Layout&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/ss/table&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ApiData&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&#x27;sss&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-s-help&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">children</span>: children</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title function_">setLocalStorage</span>(myRouterKey, getRouter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="title function_">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// start progress bar</span></span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">start</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set page title</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title function_">getPageTitle</span>(to.<span class="property">meta</span>.<span class="property">title</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// determine whether the user has logged in</span></span><br><span class="line">  <span class="keyword">const</span> hasToken = <span class="title function_">getToken</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// if is logged in, redirect to the home page</span></span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasGetUserInfo = store.<span class="property">getters</span>.<span class="property">name</span></span><br><span class="line">      <span class="keyword">if</span> (hasGetUserInfo) &#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// get user info</span></span><br><span class="line">          <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getInfo&#x27;</span>)</span><br><span class="line">          <span class="comment">//不加这个判断，路由会陷入死循环</span></span><br><span class="line">          <span class="keyword">if</span> (getRouter.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="title function_">getLocalStorage</span>(myRouterKey))&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;read from axios&#x27;</span>)</span><br><span class="line">              axios.<span class="title function_">get</span>(<span class="string">&#x27;http://xx.com/getProjectList&#x27;</span>, &#123;<span class="attr">timeout</span>: <span class="number">5000</span>&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">setRouter</span>(res.<span class="property">data</span>)</span><br><span class="line">                <span class="title function_">addRouter</span>(to, next)</span><br><span class="line">              &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;addRouter&#x27;</span>, err)</span><br><span class="line">                <span class="title function_">setRouter</span>([<span class="string">&#x27;xxx&#x27;</span>])</span><br><span class="line">                <span class="title function_">addRouter</span>(to, next)</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;read from local&#x27;</span>)</span><br><span class="line">              getRouter = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title function_">getLocalStorage</span>(myRouterKey))</span><br><span class="line">              <span class="title function_">addRouter</span>(to, next)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// remove token and go to login page to re-login</span></span><br><span class="line">          <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/resetToken&#x27;</span>)</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>)</span><br><span class="line">          <span class="title class_">Message</span>(&#123;</span><br><span class="line">            <span class="attr">message</span>: error.<span class="property">message</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">            <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">await</span> <span class="title class_">MessageBox</span>.<span class="title function_">confirm</span>(<span class="string">&#x27;登录失败，请刷新重试&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">confirmButtonText</span>: <span class="string">&#x27;确定&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">          <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// in the free login whitelist, go directly</span></span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// other pages that do not have permission to access are redirected to the login page.</span></span><br><span class="line">      <span class="title function_">next</span>(<span class="string">`/login`</span>)</span><br><span class="line">      <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// finish progress bar</span></span><br><span class="line">  <span class="title class_">NProgress</span>.<span class="title function_">done</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历后台传来的路由字符串，转换为组件对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterAsyncRouter</span>(<span class="params">asyncRouterMap</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> asyncRouterMap.<span class="title function_">filter</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (route.<span class="property">component</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.<span class="property">component</span> === <span class="string">&#x27;Layout&#x27;</span>) &#123;</span><br><span class="line">        route.<span class="property">component</span> = <span class="title class_">Layout</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        route.<span class="property">component</span> = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/table/APIManage&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (route.<span class="property">children</span> &amp;&amp; route.<span class="property">children</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      route.<span class="property">children</span> = <span class="title function_">filterAsyncRouter</span>(route.<span class="property">children</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分和框架原本一样，注意细节即可</p><h1 id="处理后"><a href="#处理后" class="headerlink" title="处理后"></a>处理后</h1><h2 id="跳到首页"><a href="#跳到首页" class="headerlink" title="跳到首页"></a>跳到首页</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/views/login/oauth.vue</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/login&#x27;</span>, ticket).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> originUrl = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">origin</span></span><br><span class="line">  history.<span class="title function_">replaceState</span>(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, originUrl)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/dashboard&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里因为url已经改变了(添加了<code>token</code>)等参数，所以需要对url进行处理，然后push首页的路径到路由即可</p><h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><ol><li>改了源码f12大量报错怎么办<br>：建议一开始不要删除源代码，而且不要乱改原本变量名，待功能可行后再删掉不用代码和修改一些全局变量名等</li><li>修改路由后浏览器白屏怎么办<ul><li>这里主要是通过看f12报的异常信息，如果浏览器突然卡顿，不能正常退出，多半是路由死循环，可以看下<code>src/permission.js</code>部分<br>本次实战：修改<code>src/store/modules/user.js</code>中的<code>login</code>方法后未同步修改<code>getInfo</code>方法，导致<code>await store.dispatch(&#39;user/getInfo&#39;)</code>报错，在<code>src/permission.js</code>中try catch捕捉后又重定向到login页面（因为出了异常还没有登录成功）,所以接着循环这个过程，导致路由死循环，浏览器不断刷新卡死<br>tips：在catch里面可以把打印error变为打印error.message，同时添加sleep，避免频繁刷新</li><li>浏览器不卡顿的话多半是<code>login</code>方法和<code>getInfo</code>方法没有修改对</li><li>刷新后一直白屏：这种可能是值没有保存好，导致刷新后值为空，路由部分异常</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 动态路由 </tag>
            
            <tag> oauth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置无显示器Linux环境远程使用</title>
      <link href="/2020/09/03/%E9%85%8D%E7%BD%AE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8Linux%E7%8E%AF%E5%A2%83%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/03/%E9%85%8D%E7%BD%AE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8Linux%E7%8E%AF%E5%A2%83%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>使用Windows内网远程Linux用于开发，让Linux专注于开发</p><span id="more"></span><h1 id="安装Linux以及配置"><a href="#安装Linux以及配置" class="headerlink" title="安装Linux以及配置"></a>安装Linux以及配置</h1><p>本次安装的是Arch，具体教程略过，可参考</p><p><a href="https://greenhathg.github.io/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/">Arch安装配置笔记 - GreenHatHGのBlog</a></p><h1 id="安装xorg以及配置"><a href="#安装xorg以及配置" class="headerlink" title="安装xorg以及配置"></a>安装xorg以及配置</h1><ul><li><p>安装xorg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg-server xorg-xinit</span><br></pre></td></tr></table></figure></li><li><p>无显示器配置还需要安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xf86-video-dummy</span><br></pre></td></tr></table></figure></li><li><p>正常来说，新版xorg能够自动配置，但是对于无显示器方案，我们需要自己添加配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/etc/X11/xorg.conf.d/10-headless.conf</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">        Identifier &quot;dummy_monitor&quot;</span><br><span class="line">        HorizSync 28.0-80.0</span><br><span class="line">        VertRefresh 48.0-75.0</span><br><span class="line">        Modeline &quot;1920x1080&quot; 172.80 1920 2040 2248 2576 1080 1081 1084 1118</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Device&quot;</span><br><span class="line">        Identifier &quot;dummy_card&quot;</span><br><span class="line">        VideoRam 256000</span><br><span class="line">        Driver &quot;dummy&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">        Identifier &quot;dummy_screen&quot;</span><br><span class="line">        Device &quot;dummy_card&quot;</span><br><span class="line">        Monitor &quot;dummy_monitor&quot;</span><br><span class="line">        SubSection &quot;Display&quot;</span><br><span class="line">        EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure><p>如此，就能够在远程中直接显示图像页面，但是有个注意点，插入显示器后不会出现任何内容，如果需要可以去掉配置</p></li></ul><h1 id="配置远程"><a href="#配置远程" class="headerlink" title="配置远程"></a>配置远程</h1><p>使用过两种常见的方案，一种是Teamviewer，另外一种是TigerVNC</p><ul><li>Teamviewer<ul><li>好处在于不需要配置什么，直接安装完就能够使用，剪贴板传输文件传输，外网连接什么的方便</li><li>不足之处在于内网连接可能速度不如VNC快，而且Linux版本自启什么的可能有问题</li></ul></li><li>TigerVNC<ul><li>好处在于内网内传输比较快，出问题比较少</li><li>不足之处在于配置略麻烦，剪贴板传输有点问题，比如中文乱码，传输不成功卡顿，外网使用需要内网穿透</li><li>这里选择的是VNC</li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S tigervnc </span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncserver</span><br></pre></td></tr></table></figure><p><code>:1</code>实际上是TCP端口5901（5900 + 1）</p><h2 id="配置启动脚本"><a href="#配置启动脚本" class="headerlink" title="配置启动脚本"></a>配置启动脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/.vnc/xstartup</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">unset SESSION_MANAGER</span><br><span class="line">unset DBUS_SESSION_BUS_ADDRESS</span><br><span class="line">exec startxfce4</span><br></pre></td></tr></table></figure><p>这里是xfce DE，其他的可以看ArchWiki</p><h2 id="可选配置自定义文件"><a href="#可选配置自定义文件" class="headerlink" title="可选配置自定义文件"></a>可选配置自定义文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">~/.vnc/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Supported server options to pass to vncserver upon invocation can be listed</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># in this file. See the following manpages for more: vncserver(1) Xvnc(1).</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Several common ones are shown below. Uncomment and modify to your liking.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">securitytypes=vncauth,tlsvnc</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">desktop=sandbox</span></span><br><span class="line">geometry=1920x1080</span><br><span class="line">dpi=130</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">localhost</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">alwaysshared</span></span><br></pre></td></tr></table></figure><h2 id="使用systemctl管理自启动"><a href="#使用systemctl管理自启动" class="headerlink" title="使用systemctl管理自启动"></a>使用systemctl管理自启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/systemd/system/vncserver@:1.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Remote desktop service (VNC)</span><br><span class="line">After=syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=cc</span><br><span class="line">WorkingDirectory=/home/cc</span><br><span class="line">ExecStartPre=/bin/sh -c &#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><span class="line">ExecStart=/usr/bin/vncserver %i -geometry 1440x900 -alwaysshared</span><br><span class="line">ExecStop=/usr/bin/vncserver -kill %i</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>Windows上可以使用VNC Viewer连接</p><p><img src="/2020/09/03/%E9%85%8D%E7%BD%AE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8Linux%E7%8E%AF%E5%A2%83%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8/1.png" alt></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>剪贴板传输有点问题，偶尔复制粘贴过去可能导致Linux暂时卡顿，暂时还没有解决，可能是VNC本身问题，也可能是VNC Viewer的问题</li><li>图片传输什么的是用石墨文档进行共享的，等于把在线文档当剪贴板</li></ul><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>开启全屏下效果挺好</p><p><img src="/2020/09/03/%E9%85%8D%E7%BD%AE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8Linux%E7%8E%AF%E5%A2%83%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8/2.png" alt></p><p>休眠状态下可以仿MAC当时钟，安装在aur的gluqlo，然后在ScreenSaver里面配置就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S gluqlo</span><br></pre></td></tr></table></figure><p><img src="/2020/09/03/%E9%85%8D%E7%BD%AE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8Linux%E7%8E%AF%E5%A2%83%E8%BF%9C%E7%A8%8B%E4%BD%BF%E7%94%A8/3.png" alt></p><hr><p>参考：</p><p><a href="https://htmlgtmk.github.io/blog/2019/10/18/Linux-%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/">Linux 远程控制 | GT Blog</a></p><p><a href="https://wiki.archlinux.org/index.php/Xorg">Xorg - ArchWiki</a></p><p><a href="https://wiki.archlinux.org/index.php/TigerVNC">TigerVNC - ArchWiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制常见操作总结</title>
      <link href="/2020/08/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/19/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>常见二进制奇技淫巧</p><span id="more"></span><h2 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == (a &amp; <span class="number">1</span>)) &#123;</span><br><span class="line"> <span class="comment">//偶数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断二进制某个位是否为1"><a href="#判断二进制某个位是否为1" class="headerlink" title="判断二进制某个位是否为1"></a>判断二进制某个位是否为1</h2><p>把1左移N-1位，再进行and操作，如果大于0则代表该二进制位就为1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&amp;(<span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="减去低位的最后一个1-将最右边的1变成0"><a href="#减去低位的最后一个1-将最右边的1变成0" class="headerlink" title="减去低位的最后一个1|将最右边的1变成0"></a>减去低位的最后一个1|将最右边的1变成0</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x&amp;(x<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="O-1-时间检测整数-n-是否是-2-的幂次"><a href="#O-1-时间检测整数-n-是否是-2-的幂次" class="headerlink" title="O(1) 时间检测整数 n 是否是 2 的幂次"></a>O(1) 时间检测整数 n 是否是 2 的幂次</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&amp;(x<span class="number">-1</span>) == <span class="number">0</span> <span class="comment">//是</span></span><br></pre></td></tr></table></figure><h2 id="高低位交换"><a href="#高低位交换" class="headerlink" title="高低位交换"></a>高低位交换</h2><p>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = (a &gt;&gt; <span class="number">8</span>) | (a &lt;&lt; <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h2 id="将最右边的0变成1"><a href="#将最右边的0变成1" class="headerlink" title="将最右边的0变成1"></a>将最右边的0变成1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x|(x<span class="number">+1</span>)</span><br></pre></td></tr></table></figure><h2 id="在最后一位加一个1"><a href="#在最后一位加一个1" class="headerlink" title="在最后一位加一个1"></a>在最后一位加一个1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;&lt; <span class="number">1</span><span class="number">+1</span></span><br></pre></td></tr></table></figure><h2 id="最后一位取反"><a href="#最后一位取反" class="headerlink" title="最后一位取反"></a>最后一位取反</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ^ <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="把右数第k位变成1"><a href="#把右数第k位变成1" class="headerlink" title="把右数第k位变成1"></a>把右数第k位变成1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x | (<span class="number">1</span> &lt;&lt; (k<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="把右数第k位变成0"><a href="#把右数第k位变成0" class="headerlink" title="把右数第k位变成0"></a>把右数第k位变成0</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp; ~ (<span class="number">1</span> &lt;&lt; (k<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="右数第k位取反"><a href="#右数第k位取反" class="headerlink" title="右数第k位取反"></a>右数第k位取反</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x ^ (<span class="number">1</span> &lt;&lt; (k<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><h2 id="取末k位"><a href="#取末k位" class="headerlink" title="取末k位"></a>取末k位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp; (<span class="number">1</span> &lt;&lt; k<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="取右数第k位"><a href="#取右数第k位" class="headerlink" title="取右数第k位"></a>取右数第k位</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt;&gt; (k<span class="number">-1</span>) &amp; <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p>参考:</p><p><a href="https://www.zhihu.com/question/38206659/answer/736472332">https://www.zhihu.com/question/38206659/answer/736472332</a></p><p><a href="https://zhuanlan.zhihu.com/p/37909700">https://zhuanlan.zhihu.com/p/37909700</a></p><p><a href="http://www.matrix67.com/blog/archives/263">http://www.matrix67.com/blog/archives/263</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git提交前校验方案</title>
      <link href="/2020/08/07/git%E6%8F%90%E4%BA%A4%E5%89%8D%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%A1%88/"/>
      <url>/2020/08/07/git%E6%8F%90%E4%BA%A4%E5%89%8D%E6%A0%A1%E9%AA%8C%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>拦截commit事件，进行前置处理，校验通过则允许commit否则拒绝</p><span id="more"></span><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Git有一种在发生某些重要操作时触发自定义脚本的方法，称为<code>Git Hooks</code>。 这些<code>hooks</code>有两种：客户端和服务器端。 客户端<code>hooks</code>由诸如提交和合并之类的操作触发，而服务器<code>hooks</code>由网络操作（如接收推送的提交）运行</p><p><a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks</a></p><p>本次是客户端方案</p><h1 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h1><ul><li><p>目的：在<code>git commit</code>之前，对变更的文件进行检查，如果通过，则允许提交，否则拒绝提交</p></li><li><p>流程：</p></li></ul><ol><li><code>git diff</code>获取变更文件 </li><li>执行检查脚本，将未通过文件列表保存到文本 </li><li>从文本中获取所有出错文件 </li><li>与变更文件列表比较 </li><li>如果存在出错文件则拒绝<code>commit</code>，否则<code>commit</code></li></ol><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p><code>git diff</code>获取变更文件时，如果git中对应的编码没有设置对，获取的文件名可能是一串数字</p><p>这里有两个解决方案：</p><ul><li><p>手动设置git编码正确，<code>Windows</code>和<code>*nix</code>两个系统操作方式不一样</p></li><li><p>添加编码设置到<code>~/.gitconfig</code></p></li></ul><p>这里采用第二种方案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">add_git_config</span>():</span><br><span class="line">        git_config = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#tapd</span></span><br><span class="line"><span class="string">[core]</span></span><br><span class="line"><span class="string">   quotepath = false</span></span><br><span class="line"><span class="string">[gui]</span></span><br><span class="line"><span class="string">   encoding = utf-8</span></span><br><span class="line"><span class="string">[i18n]</span></span><br><span class="line"><span class="string">   commitencoding = utf-8</span></span><br><span class="line"><span class="string">[svn]</span></span><br><span class="line"><span class="string">   pathnameencoding = utf-8</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        git_config_path = os.path.join(os.path.expanduser(<span class="string">&quot;~&quot;</span>), <span class="string">&#x27;.gitconfig&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(git_config_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            content = f.read()</span><br><span class="line">        <span class="keyword">if</span> content.find(<span class="string">&#x27;#tapd&#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(git_config_path, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(git_config)</span><br></pre></td></tr></table></figure><h1 id="pre-commit实现"><a href="#pre-commit实现" class="headerlink" title="pre-commit实现"></a>pre-commit实现</h1><p>在<code>.git/hooks</code>文件夹下添加文件<code>pre-commit</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取git变更文件</span></span><br><span class="line">diff=`git diff --cached --name-only`</span><br><span class="line">echo $diff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转换成数组</span></span><br><span class="line">updated_file_arr=($&#123;diff// /&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取文件执行绝对路径</span></span><br><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd -P)</span><br><span class="line">echo $SHELL_FOLDER</span><br><span class="line">cd $SHELL_FOLDER</span><br><span class="line">cd ../../src</span><br><span class="line"></span><br><span class="line">PYTHON_PATH=`head -n +1 python_info.txt`</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;PYTHON_PATH&#125; local_conversion.py &gt; /dev/null</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取错误列表</span></span><br><span class="line">content=`cat notification_list`</span><br><span class="line">error_file_arr=($&#123;content//~~~/ &#125;)</span><br><span class="line"></span><br><span class="line">for err_file in $&#123;error_file_arr[*]&#125;</span><br><span class="line">do</span><br><span class="line">  for updated_file in $&#123;updated_file_arr[*]&#125;</span><br><span class="line">  do</span><br><span class="line">    echo $err_file</span><br><span class="line">    echo $updated_file</span><br><span class="line">    [ &quot;$err_file&quot; == &quot;$updated_file&quot; ] &amp;&amp; echo &#x27;Check failed&#x27; &amp;&amp; exit 1</span><br><span class="line">  done</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &#x27;success!&#x27;</span><br></pre></td></tr></table></figure><p>这里需要注意二点，有些Shell命令在Windows和Mac下不兼容的，这里需要验证一下，(上面的命令已经经过验证)；非windows系统需要执行<code>chmod</code>对该文件授予可执行权限</p><p>主要有两条不兼容：</p><ul><li><p>获取文件执行绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd -P)</span><br></pre></td></tr></table></figure></li><li><p>文件替换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PROJECT_PATH=$&#123;SHELL_FOLDER/&#x27;.git/hooks&#x27;/ &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="自动配置git-hooks脚本"><a href="#自动配置git-hooks脚本" class="headerlink" title="自动配置git hooks脚本"></a>自动配置git hooks脚本</h1><p>这里主要有几个功能点：</p><ol><li>文件夹和文件合法性检验</li><li>复制<code>pre-commit</code>到<code>.git/hooks</code>，如果是非windows系统再执行<code>chmod</code>授予权限</li><li>获得python执行路径保持到<code>src/python_info.txt</code>，用于<code>pre-commit</code>脚本执行python命令</li><li>添加gitconfig配置，避免使用git命令得到文件列表是乱码的</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> shutil <span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> platform <span class="keyword">as</span> _platform</span><br><span class="line"></span><br><span class="line">base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">pre_commit = os.path.join(base_dir, <span class="string">&#x27;pre-commit&#x27;</span>)</span><br><span class="line">git_path = os.path.join(base_dir, <span class="string">&#x27;.git&#x27;</span>)</span><br><span class="line">hooks_path = os.path.join(git_path, <span class="string">&#x27;hooks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_file</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (os.path.isfile(pre_commit) <span class="keyword">and</span> os.path.getsize(pre_commit) &gt; <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">raise</span> Exception(pre_commit + <span class="string">&#x27;文件为空或者不存在&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_pre_commit</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(git_path):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;.git文件夹不存在&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(hooks_path):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;hooks文件夹不存在&#x27;</span>)</span><br><span class="line">    check_file()</span><br><span class="line">    copy(pre_commit, hooks_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> _platform == <span class="string">&quot;win32&quot;</span> <span class="keyword">and</span> <span class="keyword">not</span> _platform == <span class="string">&quot;win64&quot;</span>:</span><br><span class="line">        subprocess.Popen(<span class="string">&#x27;chmod +x &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(os.path.join(hooks_path, <span class="string">&#x27;pre-commit&#x27;</span>)), shell=<span class="literal">True</span>).wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>():</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;3.6&#x27;</span> &gt; platform.python_version():</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;请更新到python3.6版本以上&#x27;</span>)</span><br><span class="line">    python_path = sys.executable</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(base_dir, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;python_info.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(python_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始执行.......&#x27;</span>)</span><br><span class="line">    copy_pre_commit()</span><br><span class="line">    get_info()</span><br><span class="line">    Util.add_git_config()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;执行完成.......&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hooks </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Caddy2使用在vue-history模式</title>
      <link href="/2020/07/21/Caddy2%E4%BD%BF%E7%94%A8%E5%9C%A8vue-history%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/07/21/Caddy2%E4%BD%BF%E7%94%A8%E5%9C%A8vue-history%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Caddy2在vue-history模式下的配置</p><span id="more"></span><h1 id="Caddy是什么"><a href="#Caddy是什么" class="headerlink" title="Caddy是什么"></a>Caddy是什么</h1><p>Caddy是一个像<code>Apache</code>，<code>Nginx</code>的web服务器</p><p>在使用了web服务器的网站中，有30%+使用了Nginx，是市面上使用最广泛的web服务器之一</p><p><strong>对于个人开发者来说</strong>，Caddy可能是你的较好选择，在市面上Caddy占有额会非常的微小，但是它方便的配置就足够了</p><h1 id="Caddy2"><a href="#Caddy2" class="headerlink" title="Caddy2"></a>Caddy2</h1><p>Caddy的最新版本是2.x， 功能强大了很多，但是资料/dome 都比较少，这里记录一下使用过程，下面是一些Caddy2的参考资料：</p><p><a href="https://caddyserver.com/v2">https://caddyserver.com/v2</a></p><p><a href="https://caddyserver.com/docs/caddyfile/directives">https://caddyserver.com/docs/caddyfile/directives</a></p><p><a href="https://github.com/caddyserver/caddy/wiki">https://github.com/caddyserver/caddy/wiki</a></p><p><a href="https://caddy.community/">https://caddy.community/</a></p><h1 id="配置机器"><a href="#配置机器" class="headerlink" title="配置机器"></a>配置机器</h1><p><img src="/2020/07/21/Caddy2%E4%BD%BF%E7%94%A8%E5%9C%A8vue-history%E6%A8%A1%E5%BC%8F/1.png" alt></p><h1 id="安装Caddy2"><a href="#安装Caddy2" class="headerlink" title="安装Caddy2"></a>安装Caddy2</h1><p>下载地址：<a href="https://github.com/caddyserver/caddy/releases">https://github.com/caddyserver/caddy/releases</a></p><p>这里下的是<a href="https://github.com/caddyserver/caddy/releases/download/v2.1.1/caddy_2.1.1_linux_amd64.tar.gz">https://github.com/caddyserver/caddy/releases/download/v2.1.1/caddy_2.1.1_linux_amd64.tar.gz</a></p><p>下载后解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf caddy_2.1.1_linux_amd64.tar.xz</span><br></pre></td></tr></table></figure><p>移动到<code>/usr/local/bin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv caddy /usr/local/bin</span><br></pre></td></tr></table></figure><p>输入命令显示v2.1.1版本号证明安装完成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caddy version</span><br></pre></td></tr></table></figure><h1 id="配置systemctl"><a href="#配置systemctl" class="headerlink" title="配置systemctl"></a>配置systemctl</h1><p>用systemctl管理Caddy2比较方便，方便开机自启，reload新的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /lib/systemd/system/caddy.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=Caddy</span><br><span class="line">Documentation=https://caddyserver.com/docs/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/local/bin/caddy run --environ --config /usr/local/bin/Caddyfile</span><br><span class="line">ExecReload=/usr/local/bin/caddy reload --config /usr/local/bin/Caddyfile</span><br><span class="line">TimeoutStopSec=5s</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">LimitNPROC=512</span><br><span class="line">PrivateTmp=true</span><br><span class="line">ProtectSystem=full</span><br><span class="line">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>注意这里我把Caddy的配置文件Caddyfile也放到了<code>/usr/local/bin</code></p><p>接着就可以使用<code>systemctl</code>一系列操作了</p><ul><li><p>开启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start caddy</span><br></pre></td></tr></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart caddy</span><br></pre></td></tr></table></figure></li><li><p>开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable caddy</span><br></pre></td></tr></table></figure></li><li><p>关闭开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable caddy</span><br></pre></td></tr></table></figure></li><li><p>停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop caddy</span><br></pre></td></tr></table></figure></li></ul><h1 id="配合vue-router-history模式"><a href="#配合vue-router-history模式" class="headerlink" title="配合vue-router history模式"></a>配合vue-router history模式</h1><p><a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html">HTML5 History 模式 | Vue Router</a></p><p>官方这里给出的Caddy配置是Caddy1的，但是Caddy2的配置和Caddy1的不一样</p><p><img src="/2020/07/21/Caddy2%E4%BD%BF%E7%94%A8%E5%9C%A8vue-history%E6%A8%A1%E5%BC%8F/2.png" alt></p><hr><p>下面是Caddy2的操作</p><ul><li><p>打包vue项目，得到dist文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>编辑Caddyfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:12345 &#123;</span><br><span class="line">        root * /root/gluten/dist</span><br><span class="line">        file_server</span><br><span class="line">        encode zstd gzip</span><br><span class="line">        try_files &#123;path&#125;  /index.html</span><br><span class="line">        log &#123;</span><br><span class="line">                output file /root/gluten/caddy_log</span><br><span class="line">                format single_field common_log</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意几点：</p><ul><li>配置后使用<code>localhost:12345</code>就可以打开网页，使用的是http</li><li>vue-router history模式Caddy1的<code>rewrite</code>在Caddy中应该用<code>try_files</code>，配置不对的话出现的问题可能有打开页面404，刷新页面404或者空白</li></ul></li><li><p>重新加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart caddy</span><br></pre></td></tr></table></figure></li></ul><p>参考：</p><p><a href="https://amattn.com/p/vuejs_vue-routers_history_mode_and_caddy2.html">https://amattn.com/p/vuejs_vue-routers_history_mode_and_caddy2.html</a></p><p><a href="https://caddy.community/t/rewrite-rule-for-vue-apps-in-caddy-v2/8438">https://caddy.community/t/rewrite-rule-for-vue-apps-in-caddy-v2/8438</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Caddy2的参考资料还少，需要不断查找资料</p><p>希望此篇文章能帮到你</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> caddy </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch分词入门</title>
      <link href="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>ES分词知识小整理</p><span id="more"></span><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0001.jpg" alt></p><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0002.jpg" alt="0002"></p><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0003.jpg" alt="0003"></p><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0004.jpg" alt="0004"></p><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0005.jpg" alt="0005"></p><p><img src="/2020/07/14/ElasticSearch%E5%88%86%E8%AF%8D%E5%85%A5%E9%97%A8/0006.jpg" alt="0006"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 分词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch入门</title>
      <link href="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>整理下知乎某篇文章</p><span id="more"></span><p>搬运整理至</p><p><a href="https://zhuanlan.zhihu.com/p/62892586">终于有人把Elasticsearch原理讲透了！ - 知乎</a></p><hr><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_1.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_2.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_3.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_4.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_5.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_6.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_7.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_8.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_9.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_10.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_11.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_12.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_13.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_14.JPG)</p><p><img src="/2020/07/13/ElasticSearch%E5%85%A5%E9%97%A8/es(0" alt>_15.JPG)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandas库总结</title>
      <link href="/2020/07/11/pandas%E5%BA%93%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/11/pandas%E5%BA%93%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>常见用法总结，方便查找</p><span id="more"></span><h1 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_csv</span>():</span><br><span class="line">    csv_path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    is_file_empty = <span class="literal">False</span> <span class="keyword">if</span> os.path.isfile(csv_path) <span class="keyword">and</span> os.path.getsize(csv_path) &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> is_file_empty:</span><br><span class="line">        <span class="keyword">raise</span> SystemExit(<span class="string">&#x27;File Empty&#x27;</span>)</span><br><span class="line">    <span class="comment"># 数据大时可能有内存溢出危险</span></span><br><span class="line">    df = pd.read_excel(csv_path)</span><br><span class="line">    <span class="comment"># pd.read_excel(&#x27;a.xlsx&#x27;, sheet_name=&#x27;sheet_name&#x27;, encoding=&#x27;utf-8-sig&#x27;)</span></span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="按行遍历iterrows"><a href="#按行遍历iterrows" class="headerlink" title="按行遍历iterrows"></a>按行遍历iterrows</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line"><span class="built_in">print</span>(index) <span class="comment"># 输出每行的索引值</span></span><br><span class="line"><span class="built_in">print</span>(row[<span class="string">&#x27;模块&#x27;</span>])</span><br></pre></td></tr></table></figure><h2 id="按行遍历apply"><a href="#按行遍历apply" class="headerlink" title="按行遍历apply"></a>按行遍历apply</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">row_global_parameter</span>(<span class="params">df_row</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> df_row[<span class="string">&#x27;可用&#x27;</span>] == <span class="string">&#x27;否&#x27;</span>:</span><br><span class="line">        <span class="comment"># 遍历每一列，v为该列的值</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> df_row.items():</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;模块&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(v)</span><br><span class="line">                </span><br><span class="line"><span class="comment"># 处理每一行，将每一行放到row_global_parameter处理</span></span><br><span class="line">df.apply(row_global_parameter, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="特定几列遍历"><a href="#特定几列遍历" class="headerlink" title="特定几列遍历"></a>特定几列遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">modules = df[<span class="string">&#x27;模块&#x27;</span>]</span><br><span class="line">names = df[<span class="string">&#x27;名字&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> module, name <span class="keyword">in</span> <span class="built_in">zip</span>(module, names):</span><br><span class="line">    <span class="built_in">print</span>(module)</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br></pre></td></tr></table></figure><h1 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">columns = [<span class="string">&#x27;模块&#x27;</span>, <span class="string">&#x27;名字&#x27;</span>]</span><br><span class="line">df = pd.DataFrame(columns=columns)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> data:</span><br><span class="line">    <span class="comment"># 插入一行</span></span><br><span class="line">    df.loc[df.shape[<span class="number">0</span>]] = [item, item]</span><br></pre></td></tr></table></figure><h1 id="新增列"><a href="#新增列" class="headerlink" title="新增列"></a>新增列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值为None（默认值）时，只有列名，没有数据</span></span><br><span class="line">data[<span class="string">&#x27;profession&#x27;</span>] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="nan"><a href="#nan" class="headerlink" title="nan"></a>nan</h1><h2 id="删除所有的nan"><a href="#删除所有的nan" class="headerlink" title="删除所有的nan"></a>删除所有的nan</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;all&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2 id="判断是不是nan"><a href="#判断是不是nan" class="headerlink" title="判断是不是nan"></a>判断是不是nan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.isna(...)</span><br></pre></td></tr></table></figure><h2 id="替换所有的nan"><a href="#替换所有的nan" class="headerlink" title="替换所有的nan"></a>替换所有的nan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(&#x27;&#x27;, inplace=True)</span><br></pre></td></tr></table></figure><h1 id="合并去重"><a href="#合并去重" class="headerlink" title="合并去重"></a>合并去重</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df_list = [read_csv(), read_csv()]</span><br><span class="line">all_pf = pd.concat(df_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要去重复的列名 遇到重复的时保留第一个还是保留最后一个 去除重复项，还是保留重复项的副本</span></span><br><span class="line">all_df.drop_duplicates([<span class="string">&#x27;模块&#x27;</span>], keep=<span class="string">&#x27;first&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">all_df.drop_duplicates(subset=[<span class="string">&#x27;模块&#x27;</span>, <span class="string">&#x27;接口&#x27;</span>], keep=<span class="string">&#x27;first&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h1 id="更新一个sheet保持其他sheet内容不变"><a href="#更新一个sheet保持其他sheet内容不变" class="headerlink" title="更新一个sheet保持其他sheet内容不变"></a>更新一个sheet保持其他sheet内容不变</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_sheet</span>(<span class="params">xlsx_file_path, update_sheet_name, df</span>):</span><br><span class="line">    <span class="comment"># update one sheet data, but keep other sheet data</span></span><br><span class="line">    book = load_workbook(xlsx_file_path)</span><br><span class="line">    writer = pd.ExcelWriter(xlsx_file_path, engine=<span class="string">&#x27;openpyxl&#x27;</span>)</span><br><span class="line">    writer.book = book</span><br><span class="line">    writer.sheets = <span class="built_in">dict</span>((ws.title, ws) <span class="keyword">for</span> ws <span class="keyword">in</span> book.worksheets)</span><br><span class="line">    df.to_excel(writer, update_sheet_name, index=<span class="literal">None</span>, encoding=<span class="string">&#x27;utf-8-sig&#x27;</span>)</span><br><span class="line">    writer.save()</span><br><span class="line">    writer.close()  </span><br></pre></td></tr></table></figure><h1 id="根据df-a删除df-b一行"><a href="#根据df-a删除df-b一行" class="headerlink" title="根据df_a删除df_b一行"></a>根据df_a删除df_b一行</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df_a.iterrows():</span><br><span class="line">    <span class="keyword">if</span> row[<span class="string">&#x27;模块&#x27;</span>] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">        <span class="comment"># drop rows from df_b that contains row[&#x27;模块&#x27;] string in a 模块 column</span></span><br><span class="line">        df_b = df_b[~df_b[<span class="string">&#x27;模块&#x27;</span>].isin([row[<span class="string">&#x27;模块&#x27;</span>]])]</span><br></pre></td></tr></table></figure><h1 id="创建excel"><a href="#创建excel" class="headerlink" title="创建excel"></a>创建excel</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&#x27;excel/a.xlsx&#x27;</span>)</span><br><span class="line">df_a.to_excel(writer, sheet_name=<span class="string">&#x27;name1&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, index=<span class="literal">None</span>)</span><br><span class="line">df_b.to_excel(writer, sheet_name=<span class="string">&#x27;name2&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, index=<span class="literal">None</span>)</span><br><span class="line">df_c.to_excel(writer, sheet_name=<span class="string">&#x27;name3&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, index=<span class="literal">None</span>)</span><br><span class="line">writer.save()</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><h2 id="删除特定数值的行"><a href="#删除特定数值的行" class="headerlink" title="删除特定数值的行"></a>删除特定数值的行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除价格小于10000</span></span><br><span class="line">df = df[ df[<span class="string">&#x27;价格&#x27;</span>] &gt; <span class="number">10000</span>]</span><br></pre></td></tr></table></figure><h2 id="删除某列包含特定字符的行"><a href="#删除某列包含特定字符的行" class="headerlink" title="删除某列包含特定字符的行"></a>删除某列包含特定字符的行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[ ~ df[<span class="string">&#x27;模块&#x27;</span>].<span class="built_in">str</span>.contains(<span class="string">&#x27;a&#x27;</span>) ]</span><br></pre></td></tr></table></figure><h2 id="删除某一列"><a href="#删除某一列" class="headerlink" title="删除某一列"></a>删除某一列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = df.drop(<span class="string">&#x27;模块&#x27;</span>,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="删除某一行"><a href="#删除某一行" class="headerlink" title="删除某一行"></a>删除某一行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除第3,4行，这里下表以0开始，并且标题行不算在类</span></span><br><span class="line">df = df.drop([<span class="number">2</span>, <span class="number">3</span>], axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h1 id="对比两个excel"><a href="#对比两个excel" class="headerlink" title="对比两个excel"></a>对比两个excel</h1><h2 id="找出新excel-新增和修改-和-删除-的行"><a href="#找出新excel-新增和修改-和-删除-的行" class="headerlink" title="找出新excel[新增和修改]和[删除]的行"></a>找出新excel[新增和修改]和[删除]的行</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">merged = old_df.merge(new_df, indicator=<span class="literal">True</span>, how=<span class="string">&#x27;outer&#x27;</span>)</span><br><span class="line">diff_new_df = merged[merged[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;right_only&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里<code>merged</code>用的上面那个，<code>left_only</code>其实是旧excel对比新excel所有的旧数据，所以我们要取一列为标准筛选出来，也就说选取那一列的值在旧的excel中有，新的没有，那么旧代表新的excel中删除了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left_only = merged[merged[<span class="string">&#x27;_merge&#x27;</span>] == <span class="string">&#x27;left_only&#x27;</span>]</span><br><span class="line">diff_delete_df = left_only[~left_only[<span class="string">&#x27;用例名称&#x27;</span>].isin(diff_new_df[<span class="string">&#x27;用例名称&#x27;</span>])]</span><br></pre></td></tr></table></figure><h2 id="分别找出excel-新增-修改-删除-的行"><a href="#分别找出excel-新增-修改-删除-的行" class="headerlink" title="分别找出excel[新增] [修改] [删除]的行"></a>分别找出excel[新增] [修改] [删除]的行</h2><p>这里对一行数据判定唯一的标准是用a列和b列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff_added_df = new_df[</span><br><span class="line">            (~new_df.set_index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]).index.isin(outdated_df.set_index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]).index))]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diff_removed_df = outdated_df[</span><br><span class="line">            (~outdated_df.set_index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]).index.isin(new_df.set_index([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]).index))]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diff_changed_df = pd.DataFrame(columns=diff_removed_df.columns)</span><br><span class="line">changed_rows = []</span><br><span class="line"><span class="keyword">for</span> index1, outdated_row <span class="keyword">in</span> outdated_df.iterrows():</span><br><span class="line">    <span class="keyword">for</span> index2, new_row <span class="keyword">in</span> new_df.iterrows():</span><br><span class="line">        <span class="comment"># pd.DataFrame.equals: The data type of columns of the two parameters must be the same before comparison</span></span><br><span class="line">        <span class="keyword">if</span> outdated_row[<span class="string">&#x27;a&#x27;</span>] == new_row[<span class="string">&#x27;a&#x27;</span>] <span class="keyword">and</span> outdated_row[<span class="string">&#x27;b&#x27;</span>] == new_row[</span><br><span class="line">            <span class="string">&#x27;b&#x27;</span>] <span class="keyword">and</span> <span class="keyword">not</span> pd.DataFrame.equals(outdated_row.drop(<span class="string">&#x27;ID&#x27;</span>),</span><br><span class="line">                                                new_row.drop(<span class="string">&#x27;ID&#x27;</span>)):</span><br><span class="line">            changed_rows.append(new_row.values)</span><br><span class="line">            diff_changed_df = diff_changed_df.append(</span><br><span class="line">                pd.DataFrame(changed_rows, columns=diff_changed_df.columns)).reset_index()</span><br></pre></td></tr></table></figure><h2 id="判断两个excel是否存在重复行"><a href="#判断两个excel是否存在重复行" class="headerlink" title="判断两个excel是否存在重复行"></a>判断两个excel是否存在重复行</h2><p>这里对一行数据判定唯一的标准是用a列和b列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check the table for duplicate data(用例名称 用例目录 are the same at the same time)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_multiple_name_directory</span>(<span class="params">df</span>):</span><br><span class="line">    res = df[df.duplicated(subset=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], keep=<span class="literal">False</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> res.empty <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="改变列宽"><a href="#改变列宽" class="headerlink" title="改变列宽"></a>改变列宽</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">writer = pd.ExcelWriter(outfile, engine=<span class="string">&#x27;xlsxwriter&#x27;</span>)</span><br><span class="line">df.to_excel(writer, sheet_name=sheet_name, index=<span class="literal">None</span>)</span><br><span class="line">_w = (<span class="number">10</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> width, col <span class="keyword">in</span> <span class="built_in">zip</span>(_w, string.ascii_uppercase[:<span class="number">12</span>]):</span><br><span class="line">    writer.sheets[sheet_name].set_column(<span class="string">f&#x27;<span class="subst">&#123;col&#125;</span>:<span class="subst">&#123;col&#125;</span>&#x27;</span>, width)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-admin-template动态路由</title>
      <link href="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
      <url>/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>vue-admin-template动态路由填坑</p><span id="more"></span><h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>不涉及权限简单要求动态侧边栏动态加载菜单（路由信息请求后台），然后根据不同的路由显示不同的表格数据</p><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/1.png" alt></p><h1 id="vue-admin-template刷新逻辑"><a href="#vue-admin-template刷新逻辑" class="headerlink" title="vue-admin-template刷新逻辑"></a>vue-admin-template刷新逻辑</h1><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/2.png" alt></p><p>在<code>src\layout\components\Sidebar\index.vue</code>文件中，每个item是根据路由的元信息（一个数组）去渲染的</p><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/3.png" alt></p><p>在<code>src\router\index.js</code>配置了项目的基本路由表，因为这个模板是简单模板，所以并没有带权限路由表</p><p>项目启动后，这里会创建路由表，然后由上面<code>sidebar</code>渲染，注意这里是异步创建路由表</p><p>根据上面所知，如果我们想要修改显示的侧边栏，是不是直接修改<code>constantRoutes</code>变量就行了？</p><p>这个是可以的，在渲染前将想要加载的侧边栏添加到变量里面，然后渲染时就可以加载了，但是有个问题</p><p>虽然可以显示了，但是点击动态显示的侧边栏后再刷新会显示404</p><h1 id="vue-router刷新后404"><a href="#vue-router刷新后404" class="headerlink" title="vue-router刷新后404"></a>vue-router刷新后404</h1><p>点击显示出来的sub-menu可以跳转进对应的表格，但是在当前表格页面刷新就会跳转到404，<strong>因为刷新页面<code>vuex</code>和<code>router</code>实例会重新初始化到初始状态，所以新增的动态路由会被刷掉（页面刷新的时候vuex中的数据和router实例对象会被重新初始化）</strong></p><p>所以我们可以设置全局路由前置守卫<code>beforeEach(to, from. next)</code>，用户刷新页面时，包括在动态路由页面刷新页面，此时触发<code>beforeEach()</code>，再使用<code>this.$router.addRoutes(this.userDynamicRouters)</code>向router对象中添加动态路由，之后执行前置守卫的<code>next()</code>方法跳转路由</p><p><a href="[https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#全局前置守卫">导航守卫 | Vue Router</a>)</p><h1 id="简化版实现"><a href="#简化版实现" class="headerlink" title="简化版实现"></a>简化版实现</h1><h2 id="获取路由数据"><a href="#获取路由数据" class="headerlink" title="获取路由数据"></a>获取路由数据</h2><p>因为需求是加载一次动态路由就行了，所以我们可以提前获取路由信息，然后保存到<code>localStorage</code></p><p>注意<code>localStorage</code>只能存储字符串，所以这里需要序列化一下再保存</p><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/4.png" alt></p><h2 id="动态路由添加"><a href="#动态路由添加" class="headerlink" title="动态路由添加"></a>动态路由添加</h2><p>因为<code>vue-admin-template</code>在<code>permission.js</code>已经有路由守卫了，所以直接在原基础上面改就行</p><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/5.png" alt></p><p>这里需要注意的是39行，404页面的路由需要在最后面加，否则可以会导致提前匹配到404页面，同理之前<code>src\router\index.js</code>的<code>constantRoutes</code>路由表需要去掉该信息</p><p>同时需要注意应该将41行改为42行那样：</p><p>直接 <code>next()</code>会发现 <code>addRoutes</code> 可能还没有把所有路由都成功挂载，将会看到一个空白页，什么都没有；但是在next中添加一个地址，会中断当前的导航，并创建一个新的导航，新的导航在开始时会确认routes，从而保证了addroutes完成并生效</p><h2 id="将字符串转为对应的组件"><a href="#将字符串转为对应的组件" class="headerlink" title="将字符串转为对应的组件"></a>将字符串转为对应的组件</h2><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/6.png" alt></p><p>这里需要注意的是转换非’Layout’组件的方法，79那里不能直接<code>route.component = ()=&gt; import(route.component)</code></p><p>是因为当异步执行的时候，<code>router.component</code>已经成了一个函数，不是一个字符串了</p><p>还有一个注意的地方，90行这里<code>@/views/$&#123;view&#125;</code>一定得是这种格式，否则会报404，这个原因未明</p><h2 id="拼接渲染路由"><a href="#拼接渲染路由" class="headerlink" title="拼接渲染路由"></a>拼接渲染路由</h2><p><img src="/2020/07/08/vue-admin-template%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/7.png" alt></p><p>最后渲染时，基础路由和动态路由合并</p><h2 id="请求不同的数据"><a href="#请求不同的数据" class="headerlink" title="请求不同的数据"></a>请求不同的数据</h2><p>可以由<code>this.$route.name</code>去获取对应的route名字，从而发不同请求获取不同的数据渲染</p><hr><p>参考：</p><p><a href="https://www.cnblogs.com/fqh123/p/11094296.html">vue-element-admin登录逻辑，以及动态添加路由，显示侧边栏 - 古墩古墩 - 博客园</a></p><p><a href="https://forum.vuejs.org/t/vue-router-3-0-1-router-addroutes/33181/6">Vue-router-3.0.1 使用router.addRoutes()设置动态路由，页面刷新后无效 - 中文 - Vue Forum</a></p><p><a href="https://github.com/PanJiaChen/vue-element-admin/issues/817">大神 我这个地方这么写怎么会死循环呢 · Issue #817 · PanJiaChen/vue-element-admin</a></p><p><a href="https://www.cnblogs.com/langhaoabcd/p/11346227.html">vue-element-admin 实现动态路由(从后台查询出菜单列表绑定侧边栏) - 胡椒面 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> 动态路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java执行Shell命令笔记</title>
      <link href="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ProcessBuilder类浅析以及Linux Shell执行逻辑</p><span id="more"></span><p>从Java代码运行Shell命令有两种方式</p><ul><li>使用<code>Runtime</code>类的<code>exec</code>方法</li><li>第二种是使用<code>ProcessBuilder</code>类</li></ul><p>使用第二种方法能够定制更多的内容，本文主要介绍的是第二种，第一种介绍下用法</p><p>环境约定：</p><ul><li><code>Arch Linux x86_64 Linux 5.4.44-1-lts</code></li><li><code>java version &quot;1.8.0_251&quot; Java HotSpot(TM) 64-Bit Server VM (build 25.251-b08, mixed mode)</code></li></ul><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTime</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//在单独的进程中执行指定的字符串命令（产生一个新的子进程）</span></span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;ls -al&quot;</span>);</span><br><span class="line">    <span class="comment">//将InputStream中的内容转成字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> IoUtil.read(process.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">//使当前线程等待，直到此Process对象表示的进程终止</span></span><br><span class="line">    <span class="comment">//如果子进程已经终止，则此方法立即返回。 如果子进程尚未终止，则调用线程将被阻塞，直到子进程退出</span></span><br><span class="line">    <span class="comment">//在读取输出之后才调用process.waitFor（），因为输出缓冲区可能会使进程停止</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">    System.out.println(<span class="string">&quot;exitCode: &quot;</span> + exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/1.png" alt></p><p>一个很简单的例子，执行<code>ls -al</code>命令获取项目文件夹下的文件信息</p><p>查看源码，在JDK1.0的时候就提供，使用单例模式返回一个Runtime对象</p><p><img src="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/2.png" alt></p><p>在<code>exec</code>方法中，实际最终也是调用了<code>ProcessBuilder</code>这个类去执行，所以我们研究<code>ProcessBuilder即可</code></p><p><img src="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/3.png" alt></p><h2 id="ProcessBuilder"><a href="#ProcessBuilder" class="headerlink" title="ProcessBuilder"></a>ProcessBuilder</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>此类用于创建操作系统进程</li><li>命令的有效性取决于操作系统</li><li>此类<strong>未同步</strong>。 如果多个线程同时访问ProcessBuilder实例，并且至少有一个线程在结构上修改了其中一个属性，则必须在外部对其进行同步</li></ol><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//参数必须以正确的顺序排列</span></span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-al&quot;</span>).start();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> IoUtil.read(process.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">exitCode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">    System.out.println(<span class="string">&quot;exitCode: &quot;</span> + exitCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是传入的命令是分割后的，格式<code>new ProcessBuilder(&quot;cmd&quot;, &quot;arg1&quot;, &quot;arg2&quot;, ...);</code></p><p>如果命令太长，我们可以使用<code>split()</code>方法分割，或者是使用<code>bash -c</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.command(<span class="string">&quot;/usr/bin/java -Djava.library.path=/Users/myusername/myproject/lib/DynamoDBLocal_lib/ -jar /Users/myusername/myproject/lib/DynamoDBLocal.jar  -sharedDb&quot;</span>.split(<span class="string">&quot;\\s+&quot;</span>)).start();</span><br><span class="line"></span><br><span class="line">.command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;/usr/bin/java -Djava.library.path=/Users/myusername/myproject/lib/DynamoDBLocal_lib/ -jar /Users/myusername/myproject/lib/DynamoDBLocal.jar  -sharedDb&quot;</span>.split(<span class="string">&quot;\\s+&quot;</span>)).start();</span><br></pre></td></tr></table></figure><h3 id="各个实例环境变量独立"><a href="#各个实例环境变量独立" class="headerlink" title="各个实例环境变量独立"></a>各个实例环境变量独立</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">    <span class="comment">//返回此ProcessBuilder执行命令时使用的环境变量</span></span><br><span class="line">    processBuilder.environment().forEach(((key, value) -&gt; System.out.println(key + value)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PATH: /usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl</span><br><span class="line">XAUTHORITY: /home/cc/.Xauthority</span><br><span class="line">XDG_DATA_DIRS: /usr/local/share:/usr/share</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建时ProcessBuilder时，该值都会初始化为当前环境变量的副本，每个ProcessBuilder实例始终包含独立的环境中，对每个ProcessBuilder实例修改环境变量并不会影响到别的ProcessBuilder实例获取到的环境变量的值</p><p><img src="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/4.png" alt></p><p>从上面我们也可以看到，每次返回的都是一个<code>clone()</code>后的对象</p><p><code>environ()</code>是个native方法，返回的是我们上面打印出来的那些环境变量</p><p><code>ProcessEnvironment</code>类有个<code>String getenv(String name)</code>方法</p><p><img src="/2020/06/06/Java%E6%89%A7%E8%A1%8CShell%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/5.png" alt></p><p>根据key返回<code>theUnmodifiableEnvironment</code>里面对应的值，从上面的图可以看出，<code>theUnmodifiableEnvironment</code>存储的应该是环境变量，加上注释说该方法仅用于<code>System.getenv(String)</code>，所以我们可以用该方法获取环境变量</p><hr><h3 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h3><p><strong>注意，这里修改的是启动新进程的环境变量，当我们修改时后新的进程还没有启动，所以我们command里面的可执行程序会在当前的PATH中找，也就是说执行顺序是先找到可执行程序，再传递我们修改后的环境变量给它。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">    processBuilder.command(<span class="string">&quot;/home/cc/sofeware/node/bin/w2&quot;</span>, <span class="string">&quot;help&quot;</span>);</span><br><span class="line">    processBuilder.environment().put(<span class="string">&quot;PATH&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;/home/cc/sofeware/node/bin/&quot;</span> + File.pathSeparator + System.getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> IoUtil.read(process.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>主要作用是添加了<code>/home/cc/sofeware/node/bin/</code>环境变量，<code>File.pathSeparator</code>值实际为<code>:</code>，这样我们就等于给先获得当前环境变量，然后把我们想要添加的环境变量通过<code>:</code>连接进而添加到<code>PATH</code></li><li><code>w2</code>程序依赖了<code>node.js</code>，<code>node.js</code>位于<code>/home/cc/sofeware/node/bin/</code>，所以得给加上PATH加上该变量，以便<code>w2</code>程序运行时能够从<code>PATH</code>中找到<code>node.js</code></li></ul><p>FAQ:</p><ol><li><p><code>command(&quot;/home/cc/sofeware/node/bin/w2&quot;)</code>能不能改为<code>command(&quot;w2&quot;)</code>，因为<code>w2</code>也在<code>/home/cc/sofeware/node/bin/</code></p><p>不行的，因为这里是用Java程序的环境变量去执行的w2，自然是找不到w2，但是我们可以使用Shell去执行，因为当前PATH是有bash的环境变量，当bash启动后，新的PATH会传递给bash，然后bash就可以找到w2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processBuilder.command(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;w2 stop -D /home/cc/test/whistle/config1&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>-c</code>：<a href="https://www.jianshu.com/p/198d819d24d1">bash -c 注意事项 - 简书</a></p><p>或者是我们可以改变ProcessBuilder的工作目录，然后用<code>./w2</code>启动，<code>./</code>表示当前目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;./w2&quot;</span>, <span class="string">&quot;help&quot;</span>);</span><br><span class="line">pb.directory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc/sofeware/node/bin/&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用修改后的工作目录启动进程"><a href="#使用修改后的工作目录启动进程" class="headerlink" title="使用修改后的工作目录启动进程"></a>使用修改后的工作目录启动进程</h3><p>默认值是当前进程的当前工作目录，通常是由系统属性<code>user.dir</code>命名的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">    processBuilder.command(<span class="string">&quot;ls&quot;</span>);</span><br><span class="line">    processBuilder.directory(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc&quot;</span>));</span><br><span class="line">    <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> IoUtil.read(process.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序我们将工作目录改为<code>/home/cc</code></p><p>需要注意的是，如果我们想要执行某个文件夹下的可执行文件：先使用<code>directory</code>方法定位到该文件夹，然后使用<code>command</code>命令去执行，这样是不行的。</p><p>因为command会从环境变量中找，而不是当前目录，如果要使用，记得加<code>./</code>表示当前目录</p><h3 id="重定向标准输入和输出"><a href="#重定向标准输入和输出" class="headerlink" title="重定向标准输入和输出"></a>重定向标准输入和输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    .redirectOutput(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc/ProcessBuilder.log&quot;</span>))</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure><p>上面是重定向结果输出到文本中，内容会覆盖</p><p>追加到日志文件而不是每次创建一个新文件时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    .redirectOutput(ProcessBuilder.Redirect.appendTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc/ProcessBuilder.log&quot;</span>)))</span><br><span class="line">    .start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>上面都不包括错误输出，输出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>).redirectErrorStream(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><strong>如有任何错误，错误输出将合并到正常过程输出文件中</strong></p><p>也可以错误输出和内容输出定位到不同文本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Process</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>)</span><br><span class="line">    .redirectErrorStream(<span class="literal">true</span>)</span><br><span class="line">    .redirectOutput((<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc/ProcessBuilder.log&quot;</span>)))</span><br><span class="line">    .redirectError(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/home/cc/ProcessBuilder_error.log&quot;</span>))</span><br><span class="line">    .start();</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.baeldung.com/run-shell-command-in-java">How to Run a Shell Command in Java | Baeldung</a></p><p><a href="https://www.baeldung.com/java-lang-processbuilder-api">Guide to java.lang.ProcessBuilder API | Baeldung</a></p><p><a href="https://blog.csdn.net/Pengjx2014/article/details/78607192">lang包源码解读之ProcessBuilder_凌霄的专栏-CSDN博客_processbuilder包</a></p><h2 id="Linux-Shell执行逻辑"><a href="#Linux-Shell执行逻辑" class="headerlink" title="Linux Shell执行逻辑"></a>Linux Shell执行逻辑</h2><h3 id="什么是Shell"><a href="#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>Shell是用户与操作系统的接口，是操作系统的最外层。Shell结合了一种编程语言来控制进程和文件，以及启动和控制其他程序。</p><p>Shell通过解析用户输入，然后处理操作系统产生的任何输出，来管理用户和操作系统之间的交互。</p><h3 id="Shell的建立-Linux-0-11"><a href="#Shell的建立-Linux-0-11" class="headerlink" title="Shell的建立(Linux 0.11)"></a>Shell的建立(Linux 0.11)</h3><h4 id="开机到执行main函数之前"><a href="#开机到执行main函数之前" class="headerlink" title="开机到执行main函数之前"></a>开机到执行main函数之前</h4><p>计算机通电后，内存中空空如也，通过CPU硬件的设计（Intel将所有<code>80x86</code>系列的CPU，包括最新型号的CPU的硬件设计为加电即进入16位实模式状态运行），加电瞬间强行将<code>CS:IP</code>（CS寄存器和IP寄存器）指向<code>0xFFFF0</code>，这块地方正好是BIOS所在地方，然后BIOS就启动了，准备实模式下的中断向量表和中断服务程序（后续程序要利用这些中断服务程序把系统内核从硬盘加载至内存）</p><p>然后程序加载第一部分内核代码—引导程序(bootsect)，其作用是陆续把银盘的操作程序加载入内存，接着bootsect【划分内存并加载第二部分内核代码—setup】和【加载第三部分内核代码—system模块】，之后setup程序开始运行，做的第一件事就是从设备上提取内核运行所需的机器系统数据</p><p>接下来是向32位模式转变，开始设置GDT和IDT（中断描述符和全局描述符表），打开A20地址线，实现32位寻址，为保护模式下执行<code>head.s</code>（system模块第一部分代码）做准备，head.s开始执行，重建GDT，建立内核分页机制，然后执行ret指令跳到main函数程序执行</p><h4 id="设备环境初始化以及激活进程0"><a href="#设备环境初始化以及激活进程0" class="headerlink" title="设备环境初始化以及激活进程0"></a>设备环境初始化以及激活进程0</h4><p>之后内核首先初始化根设备和硬盘，规划物理内存格局：除了内核代码和数据所占空间之外，其余物理内存主要分为三部分：主内存区（进程代码运行的空间）、缓存区（主机与外设进行数据交互的空间&amp;内核管理进程的数据结构）和虚拟盘（可选，将外设上的数据先复制进虚拟盘区，然后加以使用，加快执行效率）</p><p>接着初始化内存管理结构<code>mem_map</code>（对1MB以上的内存分页进行管理，记录一个页面的使用次数），开机启动时间设置（结合主板上面的一个小存储芯片CMOS上面记录的时间数据）等</p><p>然后初始化进程0（进程0是运行的第一个进程，是Linux操作系统父子进程创建机制的第一个父进程）。具备支持多线程轮流执行，处理系统调用等能力，这样才能保证将来在主机正常地运行，并将这些能力遗传给后续建立的进程</p><p> 最后开启中断，初始化缓冲区管理结构，硬盘等 ，以及用仿中断的方法将进程0的特权级由0变成3（Linux系统规定除进程0之外，所有进程都要由一个已有进程在3特权级下创建，进程0的代码和数据都是由操作系统的设计者写在内核代码、数据区，并且此前还处在0特权级，严格说还不是真正意义上的进程），实现激活进程0                                                                                                                                                                       </p><h4 id="进程1的创建及执行"><a href="#进程1的创建及执行" class="headerlink" title="进程1的创建及执行"></a>进程1的创建及执行</h4><p>进程0现在处在3特权级状态，即进程状态。正式开始运行要做的第一件事就是作为父进程调用fork函数创建第一个子进程——进程1，这是父子进程创建机制第一次实际运用。之后所有进程都是基于父子进程机制由父进程创建出来的。</p><p>设置进程1的分页管理和进程1在GDT中的表项，将进程1的状态设置为就绪态，使它可以参与进程调度。内核第一次调度，进程0切换到进程1执行，进程1第一次执行后开始设置硬盘信息，格式化虚拟盘，加载根文件系统等工作</p><h4 id="进程2的创建"><a href="#进程2的创建" class="headerlink" title="进程2的创建"></a>进程2的创建</h4><p>进程1打开创建shell所需要的终端标准输入文件、标准输出设备和标准错误输出设备（意味着可以在程序中使用<code>printf()</code>函数）。进程1通过fork()创建进程2，创建后fork函数返回2，调用<code>wait()</code>函数（函数作用是如果进程1有等待退出的子进程，就为该进程的退出做善后工作；如果有子进程，但并不等待退出，则进行进程切换，如果没有子进程，函数返回）</p><h4 id="进程2执行以及加载shell程序"><a href="#进程2执行以及加载shell程序" class="headerlink" title="进程2执行以及加载shell程序"></a>进程2执行以及加载shell程序</h4><p>轮转到进程2，关闭标准输入设备文件，并用rc文件替换它（rc文件是脚本文件，记录着一些命令，应用程序通过解析命令来执行任务）。rc文件打开后，调用<code>execve()</code>函数加载shell程序，参数（<code>/bin/sh</code>）和环境变量（<code>HOME=/</code>）都已在内核中事先准备好，然后检查shell程序的正确性</p><p>接着加载参数和环境变量到进程2的栈空间中。进程2有了主机对应的程序shell，因此要调整自己对应的管理结构和EIP、ESP，这样软中断iret返回后，进程2将从shell程序开始执行。</p><h4 id="执行shell程序"><a href="#执行shell程序" class="headerlink" title="执行shell程序"></a>执行shell程序</h4><p>shell程序开始执行后，其线性地址空间对应的程序并未加载，产生缺页中断，调用中断处理程序来分配页面并加载一页shell程序。之后内核会将该页内容映射到shell进程的线性地址空间内，建立页目录表-&gt;页表-&gt;页面的三级映射管理关系</p><p>系统创建update进程（有一项很重要的任务：将缓冲区中的数据同步到外设，为了提高系统整体效率），重建shell之后，操作系统用户将通过shell进程提供的平台与计算机交互。</p><hr><h3 id="shell处理用户指令工作原理"><a href="#shell处理用户指令工作原理" class="headerlink" title="shell处理用户指令工作原理"></a>shell处理用户指令工作原理</h3><p>用户通过键盘输入的信息，存储在指定的字符缓冲队列上。该缓冲队列上的内容，就是tty0文件的内容。shell进程会不断读取缓冲队列上的数据信息。如果用户没有下达指令，缓冲队列中就不会有数据。</p><p>shell进程将会被设置为可中断等待状态，即被挂起。如果用户通过键盘下达指令，将产生键盘中断，中断服务程序会将字符信息存储在缓冲队列上，并给shell<br>进程发信号，信号将导致shell进程被设置为就绪状态，即被唤醒，唤醒后的shell继续从缓冲队列中读取数据信息并处理，完毕后，shell进程将再次被挂起，等待下一次键盘中断被唤醒。</p><p>假设用户输入一个<code>date</code>命令后，shell创建一个子进程，提取第一个命令，搜索这个程序，如果找到这个程序，将运行<code>date</code>程序作为子进程。在该子进程运行期间，shell会将自己挂起等待它结束。在子进程结束后，shell再次显示提示符，等待下一次输入</p><hr><p>参考：</p><p>《Linux内核设计的艺术（第2版）》</p><p><a href="https://www.ibm.com/support/knowledgecenter/ssw_aix_72/osmanagement/shells.htm">Operating system shells</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习Gson序列化源码简单记录</title>
      <link href="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>简单按照源码实现下「 List to JsonStr」。直接实现也很简单，不过为了锻炼下阅读源码的能力，还是练习跟踪下源码，找出大体框架，不沉迷细节，把握整体。 </p><span id="more"></span><h1 id="Gson的使用"><a href="#Gson的使用" class="headerlink" title="Gson的使用"></a>Gson的使用</h1><h2 id="环境约定"><a href="#环境约定" class="headerlink" title="环境约定"></a>环境约定</h2><p>这里使用的 Java 环境，使用 Maven 管理依赖</p><ul><li>Oracle JDK8</li></ul><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/1.png" alt></p><ul><li><p>Gson2.8.6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.8</span><span class="number">.6</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.gson.Gson;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2020-05-12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GsonTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> grade)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getter方法省略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">        ArrayList&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2020</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">78</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3030</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">85</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">4040</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">99</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> gson.toJson(students);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/2.png" alt></p><h1 id="跟踪过程"><a href="#跟踪过程" class="headerlink" title="跟踪过程"></a>跟踪过程</h1><h2 id="找到的第一个抽象write方法"><a href="#找到的第一个抽象write方法" class="headerlink" title="找到的第一个抽象write方法"></a>找到的第一个抽象write方法</h2><ol><li>查看 <code>gson.toJson(students)</code>的源码，位于<code>Gson.java</code></li></ol><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/3.png" alt></p><ol><li>这里面很明显， 615 行代码不会执行，转向 618 行的源码，位于<code>Gson.java</code>。</li></ol><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/4.png" alt></p><ol><li><p>这时候一看就是知道是 638 行代码执行起的序列化作用，该行源代码同样位于<code>Gson.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/5.png" alt></p></li><li><p>依旧点进去 683 行的源代码，位于<code>Gson.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/6.png" alt></p><p>一看代码有点多，但是主要部分还是容易看出来的</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/7.png" alt></p></li><li><p>所以可以直接跳到 704 行代码，位于<code>TypeAdapter.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/8.png" alt></p><p>从类名带 <code>Adapter</code> 来看，运用了适配器模式，这方面这里不展开</p><p>这里是抽象方法，我们不知道会调用了哪个实现了它的方法，所以我们可以打上断点去调试，然后开启调试</p></li></ol><h2 id="找到的第二个抽象write方法"><a href="#找到的第二个抽象write方法" class="headerlink" title="找到的第二个抽象write方法"></a>找到的第二个抽象write方法</h2><ol><li><p>根据上面开启调试，会立马定位到该方法，位于<code>CollectionTypeAdapterFactory.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/9.png" alt></p></li><li><p>为了搞明白，我们依旧得利用调试去查看每个方法的作用，首先在 95 行断点，按照这里来看，序列化的内容应该会输出在<code>out</code>这个变量里面，目前<code>out</code>变量里面的内容：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/10.png" alt></p><p>经过 95 行后，变成</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/11.png" alt></p><p>可见<code>out.beginArray();</code>和<code>out.endArray();</code>只是在序列化字符串前后加个<code>[ ]</code>，我们直接模拟实现即可</p></li><li><p>那么重点应该是 96 那里了，我们可以看<code>collection</code>变量里面的内容</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/12.png" alt></p><p>里面是我们之前创建的三个<code>Student</code>对象，那么自然 97 行代码也就是对每个对象进行序列化了</p></li><li><p>点进去后同样跳到了抽象的<code>write</code>方法，位于<code>TypeAdapter.java</code>，用同样的加断点方法进行调试</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/13.png" alt></p></li></ol><h2 id="找到的第三个抽象write方法"><a href="#找到的第三个抽象write方法" class="headerlink" title="找到的第三个抽象write方法"></a>找到的第三个抽象write方法</h2><ol><li><p>根据上面调试，跳到如下位置，位于<code>TypeAdapterRuntimeTypeWrapper.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/14.png" alt></p><p>这时候我们可以选择直接断点在 69 行，查看序列化字符串变化情况。现在断点在 53 行的情况：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/15.png" alt></p><p>待程序执行到 69 行，<code>out</code>变量里面的内容依旧没有变化</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/16.png" alt></p><p>那么可以确定序列化代码在 69 行了。</p></li><li><p>点进 69 行代码，位于<code>TypeAdapter.java</code>，如下：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/17.png" alt></p><p>这时候我们可以看到其实每次调用的这些的抽象<code>write</code>方法都是一样的，但是实现类却不一样，每个都有自己的功能。</p><p><del>这个过程就好像套娃一样，老千层饼了</del></p><p>那么依旧断点在 127 行这个抽象的<code>write</code>方法，为了避免其他的断点的干扰，以及方便跳到我们想要的地方，我们可以把其他断点去掉先，选择后按<code>delete</code>键可以删除</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/18.png" alt></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/20.png" alt></p><p>然后我们再给 127 行打上断点</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/21.png" alt></p><p><strong>当然上面只是一种方法，要是你觉得这种方法比较麻烦，你可以直接按下面的红色小箭头直接进入源码，省去断点在接口的麻烦，但是这样就略去了接口的细节</strong></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/22.png" alt></p><p>FAQ：为什么不点蓝色箭头？</p><p>因为蓝色那个有的地方跳不进去</p></li></ol><h2 id="2020-years-later"><a href="#2020-years-later" class="headerlink" title="2020 years later"></a>2020 years later</h2><ol><li><p>根据上面，跳到<code>ObjectTypeAdapter.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/23.png" alt></p><p>这时候我们可以判断程序有没有执行 101 行里面的内容，<code>Step over F8</code>走下去，发现并没有进去，那么也就说，又到了我们最喜欢的抽象<code>write</code>方法环节了，emmm，点进去一如既往：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/17.png" alt></p><p>为了方便，就不调试断点，直接<code>Step into</code>进去</p></li><li><p>进到<code>ReflectiveTypeAdapterFactory.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/24.png" alt></p><p>同样我们需要确定 240 行的作用，先查看现在<code>out</code>变量的内容：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/25.png" alt></p><p>执行完 240 行后</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/26.png" alt></p><p>可以看到 240 行作用只不过是添加个<code>&#123;</code>而已，但是绝对不是直接添加<code>&#123;</code>那么简单</p><p>自然 251 行作用就是添加个<code>&#125;</code></p></li><li><p>然后接着<code>step over</code>执行到 244 行，为了确定 244 行作用，我们选择的做法依旧是先执行查看结果后再决定要不要<code>step into</code>进去。</p><p>这里 244 行并没有什么变化，反而是执行了 245 行后有变化了</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/27.png" alt></p></li></ol><h2 id="找到序列化属性名的代码"><a href="#找到序列化属性名的代码" class="headerlink" title="找到序列化属性名的代码"></a>找到序列化属性名的代码</h2><ol><li><p>进入到 245 行后的代码，位于<code>ReflectiveTypeAdapterFactory.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/28.png" alt></p></li><li><p>同样为了确定主要代码部分，先让程序执行到 127 行</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/29.png" alt></p><p>那么就可以确定是 127 行代码是主要部分，跳进去，又是一次套娃，emmm，这个我们在「找到第三个抽象write方法」那里就有出现过</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/14.png" alt></p><p>这里我们选择的是<code>step over</code>一步步进行，同时查看<code>out</code>方法的变化</p><p><code>step over</code>后，发现程序执行到 69 行<code>out</code>变量还没有变化，那么同样使用<code>step into</code>进去 69 行后，位于<code>TypeAdapters.java</code>，断点调试这行语句</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/30.png" alt></p><p>发现<code>out</code>变量内容由<code>[&#123;</code>变成了<code>[&#123;&quot;id&quot;:2020</code>，那么自然得进去看这个代码</p></li><li><p>调试 233 行，源码进入到<code>JsonWriter.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/31.png" alt></p><p>待执行完 526 行，序列化字符串内容添加了个<code>&quot;id&quot;</code></p></li></ol><h2 id="简单分析写入属性名"><a href="#简单分析写入属性名" class="headerlink" title="简单分析写入属性名"></a>简单分析写入属性名</h2><ol><li><p>调试 526 行代码，源码位于<code>JsonWriter.java</code></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/32.png" alt></p><p>​    这里可以看到<code>defferredName</code>的值为<code>id</code>，那么 401 行代码自然就是将其写入到序列化字符串中</p></li><li><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/33.png" alt></p><p>这里是有做了字符串替换处理，会将一些特殊字符转换为unicode编程格式。</p><p><code>replacements</code>正是一系列代替规则，<code>htmlSafe</code>是默认为<code>true</code>，替换规则默认如下：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/34.png" alt></p><p>​    写入序列化字符串的过程，比如 592 行，使用了<code>synchronized</code>进行加锁，<code>lock</code>变量是个<code>Object</code>的实例</p><p>​    <img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/35.png" alt></p><p>​    </p></li></ol><h3 id="htmlSafe是在哪里置为true的"><a href="#htmlSafe是在哪里置为true的" class="headerlink" title="htmlSafe是在哪里置为true的"></a>htmlSafe是在哪里置为true的</h3><p>我们先在原地方<code>JsonWrite.java</code>查看<code>htmlSafe</code>变量的使用情况</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/36.png" alt></p><p>发现有个<code>htmlSafe</code>属性，我们把其他的断点情况，将断点断在属性上面，运行debug</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/37.png" alt></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/38.png" alt></p><p>可以看到是有地方调了<code>setHtmlSafe</code>方法将其置为true</p><p>查看该方法的使用情况，发现在<code>Gson.java</code>有地方调用了该方法</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/39.png" alt></p><p>碰巧第 700 行有个<code>htmlSafe</code>变量，接着一样是查看该变量使用情况，然后定位到<code>Gson.java</code>也有个<code>htmlSafe</code>的变量，同样断点该变量</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/40.png" alt></p><p>发现这里有个构造函数，给该变量赋值为true，正好是使用默认构造函数创建<code>Gson</code>对象的时候会将<code>htmlSafe</code>变为true</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/41.png" alt></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/42.png" alt></p><h2 id="找到序列化属性值的代码"><a href="#找到序列化属性值的代码" class="headerlink" title="找到序列化属性值的代码"></a>找到序列化属性值的代码</h2><p>上面我们看到，在<code>JsonWrite.java</code>里面的 526 行，作用是序列化上属性名，我们接着执行</p><p>执行到 532 行代码，这个函数作用是给序列化字符串加个”:”</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/43.png" alt></p><p>那么，当我们执行玩 533 行时，就已经序列化好了属性名和属性值</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/44.png" alt></p><h2 id="是如何获取属性名和属性值的"><a href="#是如何获取属性名和属性值的" class="headerlink" title="是如何获取属性名和属性值的"></a>是如何获取属性名和属性值的</h2><p>在上面，我们在 521 行这个函数中得到了一个value值，这个是属性值，但是它是怎么得到的呢</p><p>我们可以查看这个函数的调用链：</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/45.png" alt></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/46.png" alt></p><p>从第一个函数来看，看不到什么</p><p>当我们查看第二个函数时，发现有个<code>deferredName</code>可疑，于是debug一下，正好这个值就是属性名，那么接下来我们需要得知它是如何被赋值的</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/47.png" alt></p><p><code>Find Usages</code>后，发现是个<code>JsonWrite</code>的一个属性，于是我们按照之前的方法给属性断点</p><p>然后断点停在了<code>JsonWriter.java</code>里</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/48.png" alt></p><p>很显然，我们需要知道这个<code>name</code>如何来，查看调用链</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/49.png" alt></p><p>这里找到一个比较可疑的变量<code>boundField</code>，位于<code>ReflectiveTypeAdapterFactory.java</code>，之所以说是可疑，因为它对比其他的变量特征显著，起码类型不是泛型，而是个具体的。</p><p>一看，在 201 行有被用到</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/50.png" alt></p><p>查看 201 行那个函数的使用情况，找到如下</p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/51.png" alt></p><p><img src="/2020/05/12/%E5%AD%A6%E4%B9%A0Gson%E5%BA%8F%E5%88%97%E5%8C%96%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/52.png" alt></p><p>这里看到，有好几处运用到了反射，比如 152 166等行，再结合反射特点，所以推断出应该是用反射获得到属性值和属性名的</p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span> grade;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">double</span> grade)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> grade;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">studentListToJson</span><span class="params">(List&lt;Student&gt; studentList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//beginArray</span></span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; studentList.size(); i++)&#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentList.get(i);</span><br><span class="line"></span><br><span class="line">            sb.append(<span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">            <span class="comment">//绑定当前student对象的属性名和值</span></span><br><span class="line">            Map&lt;String, Object&gt; boundField = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取属性名和值</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> student.getClass();</span><br><span class="line">            Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields)&#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">fieldName</span> <span class="operator">=</span> field.getName();</span><br><span class="line"></span><br><span class="line">                <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;get&quot;</span>+fieldName.substring(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">                    .toUpperCase()+fieldName.substring(<span class="number">1</span>);</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(methodName, <span class="literal">null</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">fieldValue</span> <span class="operator">=</span> method.invoke(student, <span class="literal">null</span>);</span><br><span class="line">                boundField.put(fieldName, fieldValue);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span>[] internalFirst = &#123;<span class="literal">true</span>&#125;;</span><br><span class="line">            boundField.forEach((k,v) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(!internalFirst[<span class="number">0</span>])&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(<span class="string">&quot;\&quot;&quot;</span>).append(k).append(<span class="string">&quot;\&quot;&quot;</span>).append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(v <span class="keyword">instanceof</span> Number)&#123;</span><br><span class="line">                    sb.append(v);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;\&quot;&quot;</span>).append(v).append(<span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                internalFirst[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            sb.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(i != studentList.size() - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//endArray</span></span><br><span class="line">        sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>,<span class="string">&quot;11&quot;</span>, <span class="number">1.11</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>,<span class="string">&quot;22&quot;</span>, <span class="number">2.22</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>,<span class="string">&quot;33&quot;</span>, <span class="number">3.33</span>));</span><br><span class="line">        System.out.println(Main.studentListToJson(students));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> gson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用书签（移至notion更新！）</title>
      <link href="/2020/02/11/bookmarks/"/>
      <url>/2020/02/11/bookmarks/</url>
      
        <content type="html"><![CDATA[<p>UpdateTime: 2020/03/12</p><span id="more"></span><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a href="https://yeasy.gitbooks.io/docker_practice/">Docker —— 从入门到实践 · GitBook (Legacy)</a></p><p><a href="https://segmentfault.com/a/1190000000628247">创建尽可能小的 Docker 容器 - yexiaoxiaobai - SegmentFault 思否</a></p><p><a href="https://www.cnblogs.com/sparkdev/p/7821376.html">查看 docker 容器使用的资源 - sparkdev - 博客园</a></p><p><a href="https://cizixs.com/2017/08/04/docker-resources-limit/">使用 docker 对容器资源进行限制 | Cizixs Write Here</a></p><p><a href="https://www.v2ex.com/t/348535">[求助]docker build 速度非常慢 - V2EX</a></p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程:打造炫酷网站 | Moorez</a></p><p><a href="https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/">手把手教你使用Hexo + Github Pages搭建个人独立博客 | 令狐葱@前端笔记</a></p><p><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置 | SORA</a></p><p><a href="https://sevencho.github.io/archives/14534beb.html">Hexo博客NexT主题从v5.x.x更新到v6.x.x的记录及总结 | 曹雪松de博客|CoderBoy’s Blog</a></p><p><a href="https://www.jianshu.com/p/e8d433a2c5b7">如何在 hexo 中支持 Mathjax？ - 简书</a></p><p><a href="http://www.mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></p><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/">超详细Hexo+Github博客搭建小白教程 | 韦阳的博客</a></p><p><a href="https://www.zybuluo.com/knight/note/96093">MathJax使用LaTeX语法编写数学公式教程 - 作业部落 Cmd Markdown 编辑阅读器</a></p><p><a href="https://www.zhijunkang.com/2019/06/05/front-matter-jie-shao/">Front-matter 选项详解 | BOLG_ZJK</a></p><p><a href="https://github.com/huiwang/hexo-recommended-posts/blob/master/README.md">Hexo跨博客文章推荐插件</a></p><p><a href="https://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/">使用Travis CI自动部署Hexo博客 | IT范儿</a></p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p><a href="https://www.kancloud.cn/thinkphp/mysql-design-optimalize/39325">字段类型与合理的选择字段类型 · Mysql设计与优化专题 · 看云</a></p><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="http://www.cplusplus.com/reference/">参考 - C ++参考</a><br><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a><br><a href="http://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a><br><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/">命名约定 — Google 开源项目风格指南</a></p><p><a href="https://www.cprogramming.com/">Learn C and C++ Programming - Cprogramming.com</a></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><a href="https://www.cnblogs.com/invisible2/p/6905892.html">c++多个文件中如何共用一个全局变量 - invisible_man - 博客园</a></p><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="网站-1"><a href="#网站-1" class="headerlink" title="网站"></a>网站</h2><p><a href="http://www.javahelp.com.cn/ittp.html">Java帮帮-IT技术图谱</a></p><p><a href="https://github.com/TeamStuQ/skill-map/issues/43">『 Java 』学习资源 · Issue #43 · TeamStuQ/skill-map</a></p><p><a href="https://www.52pojie.cn/thread-627889-1-1.html">Java api 1.8 中文 帮助文档 各个翻译版本</a></p><p><a href="https://blog.csdn.net/qq_26761229/article/details/78963593">JDK8 API文档(下载)记录 - CSDN博客</a></p><p><a href="https://how2j.cn/?p=76631">How2J 的 Java教程</a></p><p><a href="http://blog.didispace.com/">程序猿DD</a></p><p><a href="https://www.funtl.com/">千锋教育-李卫民</a></p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.zhihu.com/question/39888195">后端程序员技能树? - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/25418336">Java IO学习整理 - 知乎</a></p><p><a href="https://zhuanlan.zhihu.com/p/28286559">Java IO，硬骨头也能变软 - 知乎</a></p><p><a href="https://www.douban.com/doulist/2545443/">从表到里学习JVM实现 - 豆瓣</a></p><p><a href="https://jeremyxu2010.github.io/2016/04/jvm%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86%E5%A4%87%E5%BF%98/#%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-jvm-runtime">JVM底层知识备忘 - jeremy的技术点滴</a></p><p><a href="https://juejin.im/post/5c875a766fb9a049f06b1991">程序员笔记——springboot 之常用注解 - 掘金</a></p><p><a href="https://www.javazhiyin.com/22480.html">SpringBoot常用注解大全-Java知音</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html">深入探讨 Java 类加载器</a></p><p><a href="https://www.zhihu.com/question/36021012"> java web 中dao 层和service层都使用接口，是否是为使用接口而使用接口？ - 知乎</a></p><p><a href="https://www.ibm.com/developerworks/cn/web/1103_chenyan_restapi/index.html">最佳实践：更好的设计你的 REST API</a></p><p><a href="https://choerodon.io/zh/docs/contributor-guide/development/conventions/restful/">RESTful API 规范</a></p><p><a href="https://segmentfault.com/a/1190000013725928">Spring Data REST API集成Springfox、Swagger - Java码农 - SegmentFault 思否</a></p><p><a href="https://www.twelve21.io/how-to-use-argon2-for-password-hashing-in-java/">How to Use Argon2 for Password Hashing in Java - Twelve 21</a></p><p><a href="http://tengj.top/2017/05/05/javabook/#more">Java后端2019书单推荐 | 嘟嘟独立博客</a></p><p><a href="http://ifeve.com/introduction-to-optional-and-excludes-dependencies/">《Maven官方指南》可选的依赖和依赖排除 | 并发编程网 – ifeve.com</a></p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p><a href="https://pythonguidecn.readthedocs.io/zh/latest/">Python最佳实践指南！ — The Hitchhiker’s Guide to Python</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python教程 - 廖雪峰的官方网站</a></p><p><a href="https://blog.csdn.net/IDIOThh/article/details/82688095">Python3-模块调用示例(从一个文件夹中调用另外一个文件夹中的类） - CSDN博客</a></p><h1 id="计组"><a href="#计组" class="headerlink" title="计组"></a>计组</h1><p><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">原码, 反码, 补码 详解 - ziqiu.zhang - 博客园</a></p><p><a href="https://blog.csdn.net/u012861978/article/details/45562483">地址总线，字长，内存容量，寻址范围 之间的计算 - u012861978的专栏 - CSDN博客</a></p><p><a href="https://blog.csdn.net/u012468263/article/details/77920234">按字节编址与按字编址 - Lyons成长专栏 - CSDN博客</a></p><p><a href="https://blog.csdn.net/loverszhaokai/article/details/5988772">字、字长、字节、位 - loverszhaokai - CSDN博客</a></p><p><a href="https://zhidao.baidu.com/question/349691474/answer/2898335743?entrytime=1546051427400&amp;fr=index_ans&amp;word=%E5%9C%B0%E5%9D%80%E7%BA%BF%2C%E6%95%B0%E6%8D%AE%E7%BA%BF">什么是地址线和数据线，以及他们和计算机内存之间的关系？</a></p><h1 id="在线ide"><a href="#在线ide" class="headerlink" title="在线ide"></a>在线ide</h1><p><a href="https://www.tutorialspoint.com/codingground.htm">Free Online IDE and Terminal</a></p><h1 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h1><h2 id="网站-2"><a href="#网站-2" class="headerlink" title="网站"></a>网站</h2><p><a href="https://visualgo.net/en">VisuAlgo - 通过动画可视化数据结构和算法</a></p><p><a href="https://csacademy.com/app/graph_editor/">Graph Editor</a></p><p><a href="https://algorithm.yuanbin.me/zh-hans/">数据结构与算法/leetcode/lintcode题解</a></p><p><a href="https://www.kancloud.cn/digest/pieces-algorithm/163604">点滴算法 · 看云</a></p><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/00.01.html">程序员如何准备面试中的算法 | 编程之法：面试和算法心得</a></p><h2 id="文章-1"><a href="#文章-1" class="headerlink" title="文章"></a>文章</h2><p><a href="https://www.cnblogs.com/zhangtianq/p/5839909.html">从头到尾彻底理解KMP - Chris_z - 博客园</a></p><p><a href="https://blog.csdn.net/mengxiang000000/article/details/50532266">KMP算法：KMP算法个人理解+next数组细节处理的方法_ mengxiang000000-CSDN博客</a></p><h1 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h1><h2 id="网站-3"><a href="#网站-3" class="headerlink" title="网站"></a>网站</h2><p><a href="https://oi-wiki.org/">OI Wiki</a></p><p><a href="http://oeis.org/">The On-Line Encyclopedia of Integer Sequences® (OEIS®)</a></p><p><a href="https://www.acwing.com/about/">AcWing</a></p><h2 id="文章-2"><a href="#文章-2" class="headerlink" title="文章"></a>文章</h2><p><a href="http://acmicpc.info/archives/224">各大OJ近期比赛汇总 - ACM/ICPC信息站</a></p><p><a href="https://github.com/lyy289065406/POJ-Solving-Reports">北大ACM：POJ试题分类 · 解题报告</a></p><p><a href="http://exp-blog.com/gitbook/book/markdown/technical/algorithm/acm/ACM%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF.html">ACM 常用算法模板 · EXP-BLOG</a></p><p><a href="http://exp-blog.com/gitbook/book/markdown/technical/algorithm/acm/ACM绝版资源公开.html">ACM 绝版资源公开 · EXP-BLOG</a></p><p><a href="http://blog.greenwicher.com/2017/01/03/codeforces-problemset/?_client_version=7.0.0.0&amp;cuid=E25EB8FF3FC2477B203588E26E393EF5%7C864180730330268&amp;timestamp=1521915043054">Codeforces科学刷题指南，一图一表便够了 | Greenwicher’s Blog</a></p><p><a href="https://blog.csdn.net/hbhszxyb/article/details/19845559">OJ(Online Judge)系统及ACM测试题库大全_题库_hbhszxyb的专栏-CSDN博客</a></p><p><a href="https://wenku.baidu.com/view/40f6eb1bc281e53a5802ffab?pcf=2">acm常用词汇 - 百度文库</a></p><p><a href="https://github.com/Smith-Cruise/ACM_difficult_words_list">Smith-Cruise/ACM_difficult_words_list: 为中国ACM选手提供的单词表!</a></p><p><a href="https://menyf.gitbooks.io/acm-icpc-template/">ACM模板</a></p><h1 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h1><p><a href="http://blog.greenwicher.com/">Greenwicher’s Blog</a></p><p><a href="http://exp-blog.com/gitbook/book/index.html">首页 · EXP-BLOG</a></p><p><a href="https://moeclub.org/page/1/?spm=17.9">萌咖 | MoeClub.org</a></p><p><a href="https://laod.cn/">老D博客 | 关注谷歌服务，分享互联网精神！</a></p><p><a href="https://www.yangzhiping.com/">Home - 阳志平的网志</a></p><p><a href="https://teddysun.com/">秋水逸冰</a></p><p><a href="https://www.flyzy2005.com/">flyzy小站 - Learning on the way</a></p><p><a href="https://lala.im/">荒岛-分享创造快乐</a></p><p><a href="https://www.94ish.me/">就是爱生活-发现生活的另一面</a></p><p><a href="https://www.moerats.com/">Rat’s Blog - 相逢的人会再相逢</a></p><p><a href="https://odcn.top/">oD^Blog &gt; 记录点滴</a></p><p><a href="http://mindhacks.cn/">刘未鹏 | Mind Hacks – 思维改变生活</a></p><p><a href="https://hqidi.com/">笛声 – 寻常的人儿依旧</a></p><p><a href="http://xzm2001.cn/">某渣渣xzm的blog</a></p><p><a href="https://hui-wang.info/">王辉的博客</a></p><p><a href="http://xiehongfeng100.github.io/">Max’s Blog</a></p><p><a href="https://xzos.net/">xzOS - For Coding Life</a></p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p><a href="http://www.thinkwiki.org/wiki/Fan_control_scripts#Other">风扇控制脚本 - ThinkWiki</a></p><p><a href="https://sdkman.io/">Home - SDKMAN! the Software Development Kit Manager</a></p><p><a href="http://linux.vbird.org/new_linux.php">鳥哥的 Linux 私房菜 — 學習 Linux 新手的建議</a></p><p><a href="http://www.ttlsa.com/tools/axel-multi-thread-download-tool-detailed/">Axel多线程下载工具使用详解 – 运维生存时间</a></p><p><a href="https://upload.wikimedia.org/wikipedia/commons/9/96/Linux_Distribution_Timeline_08_Aug_2017.svg">GNU/Linux Distributions Timeline</a></p><p><a href="https://www.lulinux.com/archives/3614">论最适合开发用的几款Linux桌面系统 | 撸Linux</a></p><p><a href="https://alim0x.gitbooks.io/awesome-linux-software-zh_cn/content/">Introduction · 超赞的 Linux 软件</a></p><p><a href="https://mp.weixin.qq.com/s/wTrd8B_KTp3jGYc6QdFldg">一文了解十大 Linux 命令行工具！</a></p><p><a href="https://linux.cn/article-9767-1.html">分享|Linux 中一种友好的 find 替代工具</a></p><p><a href="https://ubuntuqa.com/article/416.html">是否有可能获得最近安装的软件包列表？ - Ubuntu问答</a></p><p><a href="https://linux.cn/article-10139-1.html?utm_source=oschina-app">技术|在 Linux 命令行中使用 ls 列出文件的技巧</a></p><p><a href="https://linux.cn/article-5777-1.html">技术|Linux 下如何处理包含空格和特殊字符的文件名</a></p><p><a href="https://twitter.com/shellexy/status/442631642549456896">双子雪梨 的 Twitter: “#tip 用 rsync -avP 代替 cp -av 拷贝文件夹速度快且可以显示进度条。”</a></p><p><a href="https://man.linuxde.net/">Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册</a></p><p><a href="https://linux.cn/article-9172-1.html">技术|详解如何用源代码安装软件，以及如何卸载它</a></p><p><a href="https://blog.csdn.net/u014114990/article/details/50310667">linux多核处理下提高编译速度 make -j - u014114990的专栏 - CSDN博客</a></p><p><a href="https://www.xuebuyuan.com/1796326.html">Linux make 保存错误日志 | 学步园</a></p><p><a href="https://linux.cn/article-10480-1.html">技术|tmux：适用于重度命令行 Linux 用户的终端复用器</a></p><p><a href="https://alternativeto.net/">AlternativeTo - Linux下软件代替方案</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html">xargs 命令教程 - 阮一峰的网络日志</a></p><p><a href="https://askubuntu.com/questions/142300/how-to-fix-error-unknown-filesystem-grub-rescue">如何解决“错误：未知的文件系统。grub rescue&gt; - 请求Ubuntu</a></p><p><a href="https://blog.jae.sh/article/zqle60.html#4.%E5%AE%89%E8%A3%85Powerline%E5%AD%97%E4%BD%93">Ubuntu终端美化:oh-my-zsh+Powerlevel9k|双鱼座</a></p><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><p><a href="https://github.com/helmuthdu/aui">helmuthdu/aui: Archlinux Ultimate Install—一键安装脚本</a></p><p><a href="https://github.com/NiiiKlaus/Get-my-Arch-Linux">保姆级Arch Linux安装+配置文档</a></p><p><a href="https://www.liushike.com/virtual/docker/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-v2ray.html">pacman/Tips and tricks (简体中文) - ArchWiki</a></p><p><a href="https://wiki.archlinux.org/index.php/General_recommendations">General recommendations (简体中文) - ArchWiki</a></p><p><a href="https://szp15.com/2017/08/16/pc-config/#_2-1-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86">PC系统配置 | 橡树屋</a></p><p><a href="https://blog.csdn.net/listener_ri/article/details/46230437">arch使用create_ap创建wifi热点_ListenerRi的博客-CSDN博客</a></p><p><a href="https://www.iteye.com/blog/willam2004-1299151">ArchLinux如何设值文件的默认打开程序 - - ITeye博客</a></p><p><a href="https://www.lulinux.com/archives/2327">antergos/ArchLinux于2017年5月7日滚挂之后修复过程记录与经验 | 撸Linux</a></p><p><a href="https://www.cnblogs.com/bluestorm/p/5929172.html">Arch Linux 安装、配置、美化和优化 - petercao - 博客园</a></p><p><a href="https://www.cnblogs.com/vachester/p/5649813.html">Archlinux下i3wm与urxvt的配置 - va_chester - 博客园</a></p><p><a href="https://ohmyarch.github.io/2017/01/15/Linux%E4%B8%8B%E7%BB%88%E6%9E%81%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/">Linux下终极字体配置方案 | Micheal’s Blog</a></p><p><a href="https://segmentfault.com/a/1190000008280278">ArchLinux搭建高效便捷的平铺式桌面 - 疯狂的爱因斯坦 - SegmentFault 思否</a></p><h1 id="V2ray"><a href="#V2ray" class="headerlink" title="V2ray"></a>V2ray</h1><p><a href="https://www.liushike.com/virtual/docker/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2-v2ray.html">使用Docker容器快速部署 V2Ray-留时刻运维网</a></p><h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p><a href="https://xiaozhou.net/introduction-of-cn2-and-cn2-vps-2017-12-11.html">CN2的那些事-CN2线路与VPS服务商介绍 | iTimothy</a></p><p><a href="https://www.vpscang.com/">VPS大全 - 你的VPS仓库,提供VPS列表, 库存, 机房, 价格等信息</a></p><p><a href="https://www.zhujiceping.com/">国外主机测评 - 国外VPS，国外服务器，国外主机，测评及优惠码</a></p><p><a href="https://www.vpsgo.com/domain-ns-cloudflare-dnspod.html#NS">域名解析教程：Cloudflare解析与DNSPod解析 - VPS GO</a></p><p><a href="https://www.douban.com/note/692461372/">VPS服务器行业术语黑话大全</a></p><p><a href="https://www.vpsgo.com/vps-ceping-properties.html">VPS测评的基本属性介绍：性能 / 路由 / 延迟 / 下载速度 - VPS GO</a></p><p><a href="https://affyun.com/">Affyun 🛒 – 每日推送新offers</a></p><p><a href="https://www.zrj96.com/post-762.html">分享我对于VPS主机的一些经验给入坑萌新 | 初行博客</a></p><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><p><a href="https://linux.cn/article-8337-1.html">技术|如何从 Vim 中访问 shell 或者运行外部命令</a></p><p><a href="http://blog.sina.cn/dpool/blog/s/blog_6fd48bff0102vcdm.html">Vim 不同窗口之间的复制粘贴_盛dmgy</a></p><p><a href="https://vimawesome.com/?q=solar">Vim Awesome</a></p><p><a href="http://www.360doc.com/content/14/0818/15/15064667_402843521.shtml">拼装的艺术：vim之IDE进化实录</a></p><p><a href="https://blog.csdn.net/u010871058/article/details/54253774">Vim的强大配置文件（一键配置）_u010871058的专栏-CSDN博客</a></p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><a href="https://segmentfault.com/a/1190000019203847">VsCode从零开始配置一个属于自己的Vue开发环境 - 日常记录 - SegmentFault 思否</a></p><p><a href="http://www.javanx.cn/20180720/vue-plug/">vue插件总结——总有你能用上的插件 _ Web秀</a></p><h1 id="斐讯N1"><a href="#斐讯N1" class="headerlink" title="斐讯N1"></a>斐讯N1</h1><p><a href="https://www.mivm.cn/phicomm-n1-linux/">斐讯N1折腾记：运行 Linux 及优化 | 米V米</a></p><p><a href="https://www.right.com.cn/FORUM/forum.php?extra=page=1&amp;filter=typeid&amp;mod=viewthread&amp;tid=321218&amp;typeid=21">N1安装Linux、私有云NextCloud、迅雷远程Xware、Aria2等</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=1&amp;filter=typeid&amp;mod=viewthread&amp;tid=323198&amp;typeid=21">[2018-6-9] 斐讯T1/N1 U盘启动基于 Linux 的第三方系统</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=9&amp;filter=typeid&amp;mod=viewthread&amp;tid=329008&amp;typeid=21">分享一个entware镜像,内置aria2,transmission,可道云,samba,frp</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=10&amp;filter=typeid&amp;mod=viewthread&amp;tid=322991&amp;typeid=21">应广大人民群众要求,搞个N1通过U盘跑LINUX(armbian)的教程 </a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=7&amp;filter=typeid&amp;mod=viewthread&amp;tid=326034&amp;typeid=21">[2018-6-16] 斐讯T1/N1 Armbian Linux 进阶使用</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=1&amp;filter=typeid&amp;mod=viewthread&amp;tid=327496&amp;typeid=21">成功！把Armbian 安装到 emmc并直接从 emmc 启动</a></p><p><a href="https://www.right.com.cn/forum/thread-327967-1-1.html">N1刷入Linux后可以删除掉的原分区及内容 </a></p><p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=342164">phicomm N1 armbian环境下安装功能丰富的开源NAS系统 OpenMediaVault</a></p><p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=341724">N1 盒子 Ubuntu 3.14 内核开启无线热点 + 配置 dnsmasq 解析自定义域名</a></p><p><a href="https://www.right.com.cn/forum/thread-335609-1-1.html">[2018-09-08更新5.60版本4.18.7内核]给N1/T1装上原生Armbian_4.18内核</a></p><p><a href="https://yadi.sk/d/pHxaRAs-tZiei">ARMBIAN — Yandex.Disk</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=1&amp;filter=typeid&amp;mod=viewthread&amp;tid=335867&amp;typeid=21">(9.27更新图)4.18内核刷入emmc后恢复分区表方法</a></p><p><a href="https://www.right.com.cn/forum/forum.php?extra=page=1&amp;filter=typeid&amp;mod=viewthread&amp;tid=342558&amp;typeid=21">小白教程N1 armbian5.62及以上写入eMMC，使用armbian-config安装OpenMediaVault等…</a></p><p><a href="https://www.right.com.cn/forum/thread-330262-1-1.html">N1刷Armbian进emmc后，如何重刷？</a></p><p><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;page=1&amp;tid=345514">N1能重复装armbian进emmc吗</a></p><p><a href="https://www.right.com.cn/FORUM/thread-338759-1-1.html">[2018-9-22]斐讯天天链N1 官改v2.2线刷包，精简版，扩展功能可选</a></p><p><a href="https://github.com/HouCoder/blog/blob/master/hacking/install-armbian-on-phicomm-n1/README.md">斐讯 N1 安装 Armbian 教程</a></p><h1 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h1><p><a href="http://www.fanzicai.com/blog_hexo/Phone/20160729-V5Max%E4%BC%98%E5%8C%96GPS%E8%AE%BE%E7%BD%AE.html">V5Max优化GPS设置 | fanzi.home@web</a></p><p><a href="https://bbs.letitfly.me/u/HuanZHIY/discussions">桓清山服务禁用配置</a><br><a href="http://www.sqlsec.com/2018/05/termux.html">Termux 高级终端安装使用配置教程 | 国光</a></p><p><a href="https://tonybai.com/2017/11/09/hello-termux/">Hello，Termux | Tony Bai</a></p><p><a href="https://wiki.termux.com/wiki/Hardware_Keyboard">硬件键盘 - Termux Wiki</a></p><p><a href="http://en.miui.com/">en-miui</a></p><p><a href="https://atmb.top/">主页-秋之盒</a></p><h1 id="GCU"><a href="#GCU" class="headerlink" title="GCU"></a>GCU</h1><p><a href="http://yxxt.gcu.edu.cn/">迎新系统</a></p><p><a href="http://jwxt.gcu.edu.cn/default2.aspx">正方教务管理系统</a></p><p><a href="http://sc.gcu.edu.cn/#a1_408">华广智慧校园</a></p><p><a href="http://gcu.fy.chaoxing.com/portal">华南理工大学广州学院网络教学平台</a></p><p><a href="http://sms.gcu.edu.cn/sms2/acegilogin.jsp">学生信息管理系统</a></p><p><a href="http://cst.gcu.edu.cn/">华南理工大学广州学院计算机工程学院</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://github.com/xirong/my-markdown">xirong/my-markdown: markdown 介绍/学习/工具/资料</a></p><p><a href="https://www.docs4dev.com/">首页 | Docs4dev</a></p><p><a href="http://www.ruanyifeng.com/blog/2019/02/password.html">找回密码的功能设计 - 阮一峰的网络日志</a></p><p><a href="https://www.zhihu.com/question/36991788">IT行业都有哪些职位，初学者（0基础，新人）该如何选择，才能够快速进入这个行业？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/48219401">你是如何学会正则表达式的？ - 知乎</a></p><p><a href="https://www.drivereasy.com/knowledge/samsung-mtp-usb-device-driver-was-not-successfully-installed-in-windows-7/">MTP USB设备驱动程序失败[已解决] - 驱动程序简单</a></p><p><a href="http://www.bubuko.com/infodetail-3068682.html">网络单位换算</a></p><p><a href="https://www.zhihu.com/question/21123049">国内外编程学习网站推荐？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/36149122">在校生为了面试，有必要强行记住一些复杂算法如红黑树、KMP等的实现吗？ - 知乎</a></p><p><a href="https://www.geeksforgeeks.org/quiz-corner-gq/#C%20Programming%20Mock%20Tests">TOPIC WISE Previous Year GATE Questions with Solutions</a></p><p><a href="https://www.androiddevtools.cn/">Android Studio版本大全</a></p><p><a href="https://grunmin.github.io/2018/09/%E6%8F%90%E9%AB%98pdf%E7%9A%84%E5%AF%B9%E6%AF%94%E5%BA%A6/">提高PDF的对比度</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用工具（移至notion更新！）</title>
      <link href="/2020/02/11/tools/"/>
      <url>/2020/02/11/tools/</url>
      
        <content type="html"><![CDATA[<p>UpdateTime: 2020/03/12</p><span id="more"></span><h1 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h1><p><a href="https://www.polishmywriting.com/">Check Spelling, Style, and Grammar with After the Deadline</a></p><p><a href="http://www.en998.com/sentence/">英语句子成分分析 在线英语句子结构分析器 语法分析软件 句解霸</a></p><p><a href="https://www.nounplus.net/grammarcheck/">Grammar Check Online - It’s a Free tool by NOUNPLUS</a></p><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p><a href="https://github.com/timmy3131/design-resource">timmy3131/design-resource: A list of design resources.</a></p><p><a href="https://linux.cn/article-9443-1.html">分享|440+ 个免费的编程 &amp; 计算机科学的在线课程</a></p><p><a href="http://jinxuliang.com/home/index">金老师的计算机技术自学网站</a></p><p><a href="https://www.houtouke.com/">猴头客 | 专注优质视频教程、网络资源的休闲小站</a></p><p><a href="https://windsys.whatk.me/">Windsys Project</a></p><p><a href="https://www.winos.me/">WINOS | 前沿的精简系统下载</a></p><h1 id="PDF下载"><a href="#PDF下载" class="headerlink" title="PDF下载"></a>PDF下载</h1><h2 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h2><p><a href="http://bestcbooks.com/">计算机书籍控</a></p><p><a href="http://it-ebooks.flygon.net/">计算机电子书</a></p><p><a href="https://github.com/justjavac/free-programming-books-zh_CN">免费的计算机编程类中文书籍</a></p><p><a href="https://itbook.download/">免费IT计算机电子书下载网站</a></p><p><a href="https://itpanda.net/book/">IT熊猫-计算机书籍下载</a></p><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><p><a href="https://www.pdfdrive.com/">PDF Drive - Search and download PDF files for free.</a></p><p><a href="https://www.jiumodiary.com/">Jiumo Search 鸠摩搜索 - 文档搜索引擎</a></p><p><a href="http://shuxiangjia.cn/">书享家-电子书下载导航</a></p><p><a href="http://gen.lib.rus.ec/">Library Genesis 英文pdf搜索引擎</a></p><p><a href="https://en.booksee.org/">Electronic Library. Download books for free. Over 2 million books and magazines</a></p><h1 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h1><p><a href="http://ilxdh.com/">龙轩导航-做个有用的导航</a></p><p><a href="http://www.giffox.com/">老司机导航</a></p><p><a href="https://www.jubt.net/cn/index.html">聚BT - 聚合最优质的BT、磁力资源 | BT搜索 磁力搜索 云盘搜索 影视APP 在线影视 磁力影视</a></p><p><a href="https://www.volf.club/">狼牌工作网址导航 - 导航</a></p><p><a href="https://www.egouz.com/">国外网站推荐-分享互联网-外国网站大全</a></p><p><a href="http://lackar.com/aa/">AnywhereAnything</a></p><p><a href="http://code.giffox.com/">程序员导航 - 代码如诗！</a></p><p><a href="http://chuangzaoshi.com/code">创造狮 创意工作者导航</a></p><p><a href="https://wht.im/">万花筒</a></p><h1 id="资讯"><a href="#资讯" class="headerlink" title="资讯"></a>资讯</h1><p><a href="https://www.solidot.org/">Solidot:奇客的资讯</a></p><p><a href="https://readspike.com/#top">Readspike - Simple news aggregator</a></p><p><a href="https://readhub.cn/topics">Readhub</a></p><p><a href="https://arxiv.org/">论文—arXiv.org e-Print archive</a></p><p><a href="https://www.ershicimi.com/">二十次幂-帮你发现更好的公众号内容</a></p><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p><a href="https://search.chongbuluo.com/">快搜 - 搜索快人一步 - Google</a></p><p><a href="http://data.chongbuluo.com/">数据搜索 - 让数据搜索更简单 - 国家数据</a></p><p><a href="https://weixin.sogou.com/">搜狗微信搜索_订阅号及文章内容独家收录，一搜即达</a></p><p><a href="http://www.4243.net/">Google学术搜索镜像<em>sci-hub网址</em>大木虫学术导航</a></p><p><a href="https://xtea.io/ts.html">名刀电报群组搜索</a></p><p><a href="http://zhishi.sssoou.com/">telegram频道搜索</a></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://flyoffline.enjoymore.fun/">马上下 种子,磁力链离线下载 按需下载 想下就下</a></p><p><a href="https://www.loadbt.com/zh">基于云端的BT种子离线下载和在线播放器 - Loadbt</a></p><p><a href="http://heikeyun.com/">黑科下载器-官方网站</a></p><h1 id="Windows软件"><a href="#Windows软件" class="headerlink" title="Windows软件"></a>Windows软件</h1><p><a href="https://www.mpyit.com/">老殁 | 殁漂遥 | 互联网分享精神，专注收藏分享「官方」</a></p><p><a href="https://www.appinn.com/">小众软件</a></p><p><a href="https://www.portablesoft.org/">精品绿色便携软件</a></p><p><a href="https://www.appcgn.com/">软件缘 - 精品绿软，品鉴独特！</a></p><p><a href="http://www.qiuquan.cc/">QiuQuan’ Blog | 精品软件分享博客，专注于软件的绿化、精简与优化。</a></p><p><a href="https://www.naodai.org/">脑袋瓜子</a></p><p><a href="https://masuit.com/misc/5">稀缺资源统一下载地址页<em>懒得勤快的博客</em>全栈开发者_互联网分享精神</a></p><h1 id="论坛"><a href="#论坛" class="headerlink" title="论坛"></a>论坛</h1><p><a href="https://yaohuo.me/">妖火网 - 分享你我</a></p><p><a href="https://www.v2ex.com/">V2EX</a></p><p><a href="https://www.hostloc.com/">全球主机交流论坛 - Powered by Discuz!</a></p><h1 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h1><h2 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h2><p><a href="在线工具 - 程序员的工具箱">在线工具 - 程序员的工具箱</a></p><p><a href="http://tool.mkblog.cn/">首页 - 孟坤工具箱网页版</a></p><p><a href="https://www.toolfk.com/">在线工具箱,一个为程序员服务并创建价值的在线工具转换网站 </a></p><p><a href="http://www.nicetool.net/">在线工具大全，用完即走，触手可及_好工具网</a></p><p><a href="http://c.runoob.com/">菜鸟工具 - 不止于工具</a></p><p><a href="https://tool.oschina.net/">在线工具 —— OSCHINA.NET社区</a></p><p><a href="http://www.atool9.com/classification_dev_tools.html">工具分类 - 在线代码转换 - aTool在线工具</a></p><p><a href="https://tools.miku.ac/">MikuTools - 一个轻量的工具集合</a></p><p><a href="https://zh.numberempire.com/">数字帝国 - 数学工具</a></p><h2 id="单一工具"><a href="#单一工具" class="headerlink" title="单一工具"></a>单一工具</h2><p><a href="https://www.draw.io/">在线画图</a></p><p><a href="http://jsonviewer.stack.hu/">Online JSON Viewer</a></p><p><a href="https://asciinema.org/">asciinema - 以正确的方式记录和分享您的终端会话</a></p><p><a href="https://www.ilovepdf.com/zh-cn/powerpoint_to_pdf">iLovePDF | 为PDF爱好者提供的PDF文件在线处理工具</a></p><p><a href="https://carbon.now.sh">在线代码高亮截图1</a></p><p><a href="https://www.dute.org/code-snapshot">在线代码高亮截图2</a></p><p><a href="https://tinypng.com/">在线压缩图片</a></p><p><a href="https://browserframe.com">在线生成浏览器外壳截图</a></p><p><a href="https://colorspark.app/">在线随机颜色</a></p><p><a href="https://fontspark.app/">在线预览字体</a></p><p><a href="https://explainshell.com/">分析LinuxShell</a></p><p><a href="https://unbug.github.io/codelf">变量名搜索</a></p><h2 id="临时传输"><a href="#临时传输" class="headerlink" title="临时传输"></a>临时传输</h2><p><a href="https://cp.anyknew.com/">拷贝兔(Copytool) - 轻量级纯Web跨平台文件、文字分享工具</a></p><p><a href="https://send.firefox.com/">Firefox Send</a></p><p><a href="https://cowtransfer.com/">奶牛快传 | 文件传输服务</a></p><p><a href="https://www.wenshushu.cn/">文叔叔 - 传文件，找文叔叔（永不限速）</a></p><h2 id="临时剪贴板"><a href="#临时剪贴板" class="headerlink" title="临时剪贴板"></a>临时剪贴板</h2><p><a href="https://paste.ubuntu.com/">Ubuntu Pastebin</a></p><p><a href="https://pastebin.aosc.io/">AOSC Pastebin</a></p><p><a href="https://cooltext.cn/">CoolText - 免费在线文本储存库</a></p><h1 id="表情包搜索"><a href="#表情包搜索" class="headerlink" title="表情包搜索"></a>表情包搜索</h1><p><a href="http://www.dbbqb.com/">逗比拯救世界—专业的表情包搜索网站</a></p><p><a href="http://www.doutula.com/">斗图啦 - 斗图大会 - 金馆长表情库 - 真正的斗图网站 - doutula.com</a></p><h1 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h1><p><a href="https://zhile.io/2018/08/17/jetbrains-license-server-crack.html">Jetbrains系列产品2019.3.3最新激活方法[持续更新] | 知了</a></p><p><a href="http://idea.medeming.com/jets/">程序员开发专属激活码，开启程序人生</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="http://git.aakkc.com/">Github中转下载</a></p><p><a href="https://docs.rsshub.app/">介绍 | RSSHub</a></p><p><a href="http://387099.blogspot.com/2018/03/ssssr.html">浅谈部分机场（SS/SSR提供商）的使用感受—持续更新中</a></p><p><a href="https://products.office.com/en-us/free-office-online-for-the-web">Free Microsoft Office for the web, Word, Excel, PowerPoint</a></p><p><a href="https://speechlogger.appspot.com/zh/">自动语音识别和即时翻译软件</a></p><p><a href="https://www.netnr.com/home/list/105">Git托管 代码托管 Pages服务 静态网站托管 NET牛人</a></p><p><a href="https://whoer.net/zh">查看自己的IP地址</a></p><p><a href="http://www.ucdrs.superlib.net/">全国图书馆参考咨询联盟</a></p><p><a href="http://www.suiyuanka.com/">Research - 探索未知</a></p><p><a href="https://jex.im/regulex/">正则可视化工具</a></p><p><a href="https://www.zhihu.com/question/22867411">作为程序员的你，常用的工具软件有哪些？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通俗理解数据库三大范式</title>
      <link href="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
      <url>/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>1NF 2NF 3NF</p><span id="more"></span><h1 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h1><p><em>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</em></p><p>第一范式是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，<strong>即每一个属性都是原子的，不能再分，也可以理解为不能表中套表</strong>。</p><hr><p>如下人员基本信息表：</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/1.png" alt></p><p>这样的表是不能创建的，我们可以把这个表拆为基本信息表和地址表，通过人员编号来建立联系</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/2.png" alt></p><p>或者是</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/3.png" alt></p><h1 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h1><p>第二范式是在第一范式基础上面提出来的，也就是说满足第二范式意味同时满足了第一范式。</p><p>第二范式：一张表中每个属性都是原子的，<strong>并且不存在对主键的部分函数依赖</strong>。（部分函数依赖比较晦涩，看例子好懂）</p><hr><p>下面是学生信息表，最后两项为课程号和该门课成绩</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/4.png" alt></p><p>在这张表里面学号是主键吗？<strong>学号不是主键，学号能决定姓名，年龄，地址，但是凭学号这一项，是决定不了成绩这一项，所以这里学号不是主键。</strong></p><p><strong>所以这张表的主键是（学号，课程号）</strong></p><p>凭（学号，课程号）可以决定成绩；但是凭学号就可以决定姓名，年龄和地址，不需要课程号。</p><p><strong>所以在这里尽管主键是（学号，课程号），但是姓名，年龄和地址只要学号就可以决定的，也就是说这三个属性对主键存在部分函数依赖，它只依赖于主键里面的学号这一项，只依赖于主键的一部分，所以不是第二范式。</strong></p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/5.jpg" alt></p><p>简单地说，第二范式要求每个非主属性完全依赖于主键，而不是仅依赖于其中一部分属性。</p><h2 id="不满足2NF问题"><a href="#不满足2NF问题" class="headerlink" title="不满足2NF问题"></a>不满足2NF问题</h2><h3 id="插入异常"><a href="#插入异常" class="headerlink" title="插入异常"></a>插入异常</h3><p>如计划开新课，由于没人选修，没有课程号信息，那么因为（学号，课程号）是主键，所以连学生基本信息也不能插入，只有学生选课之后，才能插入信息。</p><h3 id="删除异常"><a href="#删除异常" class="headerlink" title="删除异常"></a>删除异常</h3><p>若学生申请病假休学一学期，从当前数据库删除选修记录，那么学生的基本信息也就丢了。</p><h3 id="数据冗余"><a href="#数据冗余" class="headerlink" title="数据冗余"></a>数据冗余</h3><p>假设一个学生选修50门课，那么学生基本信息就重复了很多次，造成数据冗余。</p><h3 id="更新异常"><a href="#更新异常" class="headerlink" title="更新异常"></a>更新异常</h3><p>难以维护一致性，因为存在数据冗余，可能更改的时候漏掉了哪条记录</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>拆分成两个表，学生基本信息表和选课成绩表</p><p>总的来说，<strong>一张表只管一件事情</strong>，就不会出现这种问题。</p><h1 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h1><p>在2NF基础上，不存在属性对主键的<strong>传递依赖</strong>。看下面例子：</p><p>有一员工信息表，属性分别是员工号，工资级别，工资</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/5.png" alt></p><p>这张表的主键是员工号，一旦员工号确定了，工资级别也确定了，那么工资也就确定了。</p><p><strong>但是工资对员工号存在传递依赖</strong></p><p>具体看下图</p><p><img src="/2020/02/08/%E9%80%9A%E4%BF%97%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/6.jpg" alt></p><h2 id="3NF问题"><a href="#3NF问题" class="headerlink" title="3NF问题"></a>3NF问题</h2><h3 id="插入异常-1"><a href="#插入异常-1" class="headerlink" title="插入异常"></a>插入异常</h3><p>当工资级别还没有确定的时候，工资就无法确定。</p><h3 id="删除异常-1"><a href="#删除异常-1" class="headerlink" title="删除异常"></a>删除异常</h3><p>假设只有一个员工拿三级工资，当这个员工不在这个公司的时候，数据被删掉，那么这个工资级别与工资的对照关系就不存在了。</p><h3 id="数据冗余-1"><a href="#数据冗余-1" class="headerlink" title="数据冗余"></a>数据冗余</h3><p>同2NF，工资级别与工资信息大量重复</p><h3 id="更新异常-1"><a href="#更新异常-1" class="headerlink" title="更新异常"></a>更新异常</h3><p>同2NF，难以维护一致性</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>同2NF，拆表，一张表只维护一件事。</p><hr><p>参考：</p><p><a href="https://baike.baidu.com/item/1NF">第一范式_百度百科</a></p><p><a href="[https://baike.baidu.com/item/%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F](https://baike.baidu.com/item/第二范式">第二范式_百度百科</a>)</p><p><a href="[https://baike.baidu.com/item/%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F](https://baike.baidu.com/item/第三范式">第三范式_百度百科</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 三大范式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>水SpringBoot与SpringCloud</title>
      <link href="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/"/>
      <url>/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/</url>
      
        <content type="html"><![CDATA[<p>项目有感<br><span id="more"></span></p><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><p>微服务的具体概念或者优缺点可以看这个：</p><p><a href="https://www.funtl.com/zh/micro-service-intro/微服务-解决复杂问题.html#概述">微服务-解决复杂问题 | 千锋教育-李卫民</a></p><p>微服务架构，更好的进行分布式系统开发，拆分单体应用，将一个应用拆分成多个服务，每一个服务都是一个可以独立运行的项目。</p><p>微服务分布式开发会遇到这四个问题：</p><ol><li><strong>这么多服务，客户端如何访问</strong></li><li><strong>这么多服务，服务之间如何通信</strong></li><li><strong>这么多服务，如何治理</strong></li><li><strong>服务挂了，怎么办？</strong></li></ol><p>解决方案：</p><p><code>Spring Cloud</code>，是一套生态，是为了解决微服务架构遇到的问题，想要使用<code>Spring Cloud</code>必须基于<code>Spring Boot</code></p><hr><p>后来去了解了下，现在<code>Spring Cloud</code>微服务方案有三套：</p><h2 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h2><p> 目前市场上主流的 <strong>第一套微服务架构解决方案：Spring Boot + Spring Cloud Netflix</strong> </p><ul><li><code>Spring Cloud Netflix</code>为了解决第一个问题，提出了<code>API</code>网关组件—-&gt;<code>Zuul</code></li><li>为了解决服务之间如何通信问题，提出了<code>Feign</code>，它是基于<code>HTTP</code>通信的，同步并阻塞的</li><li>为了解决如何治理服务问题，提出了服务注册与发现组件—&gt;<code>Eureka</code></li><li>为了解决服务挂了的问题，提出了熔断机制—&gt;<code>Hystrix</code>组件</li></ul><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/5.png" alt></p><p>市面上面的教程很多都是这一套，不过这一套已经不维护了，所以不考虑这一个</p><h2 id="Dubbo-Zookeeper"><a href="#Dubbo-Zookeeper" class="headerlink" title="Dubbo + Zookeeper"></a>Dubbo + Zookeeper</h2><p> 目前市场上主流的 <strong>第二套微服务架构解决方案：Spring Boot + Dubbo + Zookeeper</strong> </p><ul><li><code>Apache Dubbo</code> 是一款高性能、轻量级的开源<code>Java RPC</code>框架。<strong>用于解决服务之间的通信问题</strong>。</li><li><code>ZooKeeper</code> 是一种分布式协调服务，用于管理大型主机。在分布式环境中协调和管理服务是一个复杂的过程。<strong>用于解决治理服务的问题，也就是服务注册与发现</strong></li><li><strong><code>API</code>网关没有现成的，得找第三方组件或自己实现</strong></li><li><strong>熔断机制组件也没有现成</strong></li></ul><p>所以该套方案不是很完善，但是新版在孵化，估计新版会解决这些问题</p><h2 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h2><p> 目前市场上主流的 <strong>第三套微服务架构解决方案：Spring Boot + Spring Cloud Alibaba</strong> </p><p><code>Spring Cloud Alibaba</code>致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过<code>Spring Cloud</code> 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托<code>Spring Cloud Alibaba</code>，您只需要添加一些注解和少量配置，就可以将<code>Spring Cloud</code>应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><ul><li>在<code>Spring Cloud Netflix</code>阶段我们采用<code>Eureka</code>做作为我们的<strong>服务注册与发现服务器</strong>，现利用<code>Spring Cloud Alibaba</code> 提供的<code>Nacos</code>组件替代该方案。 </li><li><strong>服务之间通信</strong>：<code>Feign</code></li><li><strong>熔断机制组件</strong>： 阿里巴巴开源了 <code>Sentinel</code> 组件，实现了熔断器模式 </li><li><code>API</code>网关： <code>Spring Cloud Gateway</code>， <strong>Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix ZUUL</strong>，其不仅提供统一的路由方式，并且基于 <code>Filter</code>链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。 </li></ul><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/6.png" alt></p><h2 id="下一代微服务架构—服务网格-service-mesh"><a href="#下一代微服务架构—服务网格-service-mesh" class="headerlink" title="下一代微服务架构—服务网格(service mesh)"></a>下一代微服务架构—服务网格(service mesh)</h2><p>可以去了解下微服务管理框架<code>service mesh</code>——<code>Istio</code></p><h1 id="SpringBoot转SringCloudAlibaba"><a href="#SpringBoot转SringCloudAlibaba" class="headerlink" title="SpringBoot转SringCloudAlibaba"></a>SpringBoot转SringCloudAlibaba</h1><p>为什么要转？一方面是因为项目使用了<code>shiro</code>，很多时候其他接口都要依赖<code>shiro</code>的检查之后才能用，也就是说流量得经过<code>shiro</code>检查，没有问题才放行给接口处理逻辑，这样的话接口就和<code>shiro</code>耦合在一起了，如果我们把<code>shiro</code>拆出来，当一个服务，流量经过这个服务检查，没问题才放行给其他服务使用，这里我们讲的其实就是微服务里面的网关。另一方面就是之前没有用过，想用用。当然，微服务也有很多缺点，比如增加开发成本，服务器开销等等。</p><h1 id="SpringCloud自动部署问题"><a href="#SpringCloud自动部署问题" class="headerlink" title="SpringCloud自动部署问题"></a>SpringCloud自动部署问题</h1><p>当我们使用<code>SpringCloud</code>的时候，意味着我们一个项目会有很多个服务，每个项目都是打包部署的，而我们可能会有几百个服务，所以要是像我们之前使用<code>SpringBoot</code>手动打包项目成<code>Jar</code>，然后再手动上传到服务器那样的话，那么肯定会累si。所以当我们这个很简单版的<code>SpringCloud</code>项目完成后，我就考虑如何去部署它。</p><p>既然这么多项目需要打包了，那么直觉就可以告诉我们要上自动部署了，所以这几天一直都在写那个自动部署的脚本。回归正题，其实这东西现在看来是一个<code>CI/CD</code>的过程，<code>CI/CD</code>又关系到<code>devops</code>，之前对这个词有点模糊，现在可以趁机补习一下。</p><h2 id="CI-CD与devops"><a href="#CI-CD与devops" class="headerlink" title="CI/CD与devops"></a>CI/CD与devops</h2><p>其实，<code>CI</code>的全称是<code>continuous integration</code>，<code>CD</code>的全称是<code>continuous delivery</code></p><p>翻译过来分别是<strong>持续集成</strong>和<strong>持续交付</strong></p><p>那么<code>devops</code>呢</p><blockquote><p>DevOps is a set of practices that combines software development (Dev) and information-technology operations (Ops) which aims to shorten the systems development life cycle and provide continuous delivery with high software quality.</p><p><a href="https://en.wikipedia.org/wiki/DevOps#Definition">DevOps - Wikipedia</a></p><p>DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。</p><p><a href="https://baike.baidu.com/item/devops/2613029">devops_百度百科</a></p></blockquote><p>baba什么的，其实我感觉它的作用应该就是让软件更快更好地交付给客户使用，所以它们的关系应该是</p><p><strong><code>CI</code>与<code>CD</code>是<code>devops</code>的最佳实践之一，可以更频繁更可靠得交付</strong></p><p>更多可点下面链接了解</p><p><a href="https://www.infoworld.com/article/3271126/what-is-cicd-continuous-integration-and-continuous-delivery-explained.html">What is CI/CD? Continuous integration and continuous delivery explained | InfoWorld</a></p><p><a href="https://www.infoq.cn/article/WHt0wFMDRrBU-dtkh1Xp">如何从零开始搭建 CI/CD 流水线-InfoQ</a></p><p><strong>总结</strong></p><blockquote><p>DevOps 是一种软件开发方法。它将持续开发、持续测试、持续集成、持续部署和持续监控贯穿于软件开发的整个生命周期</p><p>CI/CD可以将它们看作是类似于软件开发生命周期的过程</p></blockquote><h2 id="搭建CI-CD流水线"><a href="#搭建CI-CD流水线" class="headerlink" title="搭建CI/CD流水线"></a>搭建CI/CD流水线</h2><p>搭建<code>CI/CD</code>流水线的方法用很多，比如用<code>Jenkins</code>，<code>GitLab</code>，<code>Travis</code>，或者是最近刚出的<code>Github Actions</code>等等。之前我们团队尝试过使用<code>Jenkins</code>，优点就是自定义任务很多并且可以自己把控，缺点就是得有服务器部署它，（或许是本地虚拟机+内网穿透也行）。</p><p>权衡了下，决定使用<code>Travis</code>。</p><hr><p>第一步是在项目的根目录添加<code>.travis.yml</code></p><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/2.png" alt></p><p>这个文件会被<code>travis</code>发现，并且执行里面设置的逻辑达到自动部署的目的，其实这个本质上就是<code>travis</code>给你开一台机器，你写脚本去控制它，让这个机器帮你做一些事情，这个脚本的内容其实就是<code>Linux</code>上的一些命令。<code>travis</code>脚本的一些基础的命令可以在网上很容易的找到。</p><h3 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h3><p>下面是我当时写的<code>.travis.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">language: java</span><br><span class="line"></span><br><span class="line">jdk:</span><br><span class="line">  - openjdk8</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  - docker</span><br><span class="line"></span><br><span class="line">addons:</span><br><span class="line">  apt:</span><br><span class="line">    packages:</span><br><span class="line">    - sshpass</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - <span class="variable">$HOME</span>/.m2</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - ssh-keyscan <span class="variable">$&#123;gatewayip&#125;</span> &gt;&gt; ~/.ssh/known_hosts</span><br><span class="line"></span><br><span class="line">script:</span><br><span class="line">  - bash start.sh acm-dependencies acm-commons-controller acm-commons-utils</span><br><span class="line"></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line"></span><br><span class="line">notifications:</span><br><span class="line">  email: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line">  global:</span><br><span class="line">  - GH_REF=https://github.com/GreenHatHG/ACMRecentContests_SpringCloudAlibaba.git</span><br></pre></td></tr></table></figure><p>有几点说明一下：</p><ol><li><p>因为Java项目，所以<code>language</code>里面是<code>Java</code>， <code>travis</code>支持多语言，详情可看：<a href="https://stackoverflow.com/questions/27644586/how-to-set-up-travis-ci-with-multiple-languages">How to set up Travis CI with multiple languages - Stack Overflow</a>，大概是这样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">matrix:</span><br><span class="line">  include:</span><br><span class="line">    - language: python</span><br><span class="line">      python: 2.7</span><br><span class="line">      script: ...</span><br><span class="line">        ...</span><br><span class="line">    - language: objective-c</span><br><span class="line">      os: osx</span><br><span class="line">      script: ...</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure></li><li><p>当前<code>SpringCloud</code>项目使用了<code>maven</code>构建工具，因为<code>maven</code>在构建的时候需要下载很多依赖，所以为了加快构建的速度，我们缓存了<code>maven</code>所下载的依赖，当<code>travis</code>构建完成时清空其他东西而保存了依赖，下次再次构建的时候就可以直接使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - <span class="variable">$HOME</span>/.m2</span><br></pre></td></tr></table></figure></li></ol><ol><li>因为要用<code>sshpass</code>远程控制服务器，所以得<code>install</code>那里把ip地址填到<code>~/.ssh/known_hosts</code>文件，以免出现不能访问的情况</li></ol><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><p>因为要执行的逻辑比较多，所以把脚本写到了一个文件里面。<code>start.sh</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------install父类依赖---------------------</span></span><br><span class="line"><span class="keyword">for</span> arg;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mvn clean install -f <span class="variable">$arg</span>/pom.xml</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------创建dockerfile---------------------</span></span><br><span class="line"><span class="comment"># $1:项目名，$2:jar的相对路径</span></span><br><span class="line"><span class="function"><span class="title">createDokcerfiler</span></span>()&#123;</span><br><span class="line">    <span class="built_in">rm</span> <span class="variable">$1</span>/dockerfile || <span class="literal">true</span></span><br><span class="line">    <span class="built_in">touch</span> <span class="variable">$1</span>/dockerfile</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;FROM openjdk:8-alpine&#x27;</span> &gt;&gt; <span class="variable">$1</span>/dockerfile</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;RUN mkdir /app&#x27;</span> &gt;&gt; <span class="variable">$1</span>/dockerfile</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;COPY&#x27;</span> <span class="variable">$2</span>  <span class="string">&#x27; /app/&#x27;</span> &gt;&gt; <span class="variable">$1</span>/dockerfile</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;CMD java -jar /app/&#x27;</span><span class="variable">$2</span> &gt;&gt; <span class="variable">$1</span>/dockerfile</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------打包---------------------</span></span><br><span class="line">baseFolder=<span class="string">&#x27;/root/spring-cloud-alibaba/&#x27;</span></span><br><span class="line"><span class="comment"># 创建文件夹用来存放jar</span></span><br><span class="line"><span class="comment"># sshpass -p $pwd ssh -o StrictHostKeyChecking=no root@$ip &#x27;mkdir -p &#x27;$&#123;baseFolder&#125; || true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> `<span class="built_in">ls</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    flag=1</span><br><span class="line">    <span class="comment"># 判断是否是父类依赖，是的话则直接跳过</span></span><br><span class="line">    <span class="keyword">for</span> arg;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="variable">$path</span> == <span class="variable">$arg</span> ]; <span class="keyword">then</span></span><br><span class="line">            flag=0</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="comment"># 判断是不是文件夹</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$flag</span> == 1 ]&amp;&amp;[ -d <span class="variable">$path</span> ]; <span class="keyword">then</span></span><br><span class="line">        mvn clean package -f <span class="variable">$path</span>/pom.xml</span><br><span class="line">        <span class="comment"># sshpass -p $pwd scp $path/target/*.jar root@$ip:$&#123;baseFolder&#125;</span></span><br><span class="line">        jarPath=`<span class="built_in">ls</span> <span class="variable">$path</span>/target | grep <span class="string">&#x27;.jar$&#x27;</span>`</span><br><span class="line">        createDokcerfiler <span class="variable">$path</span> <span class="variable">$jarPath</span></span><br><span class="line">        <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$path</span>/target/<span class="variable">$jarPath</span>&quot;</span> <span class="variable">$path</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------上传到阿里云docker仓库---------------------</span></span><br><span class="line"><span class="keyword">time</span>=$(<span class="built_in">date</span> <span class="string">&quot;+%Y%m%d%H&quot;</span>)</span><br><span class="line"></span><br><span class="line">docker login --username=<span class="variable">$registryu</span> registry.cn-hongkong.aliyuncs.com --password=<span class="variable">$registryp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> path <span class="keyword">in</span> `<span class="built_in">ls</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="variable">$path</span>/dockerfile ]; <span class="keyword">then</span></span><br><span class="line">        docker build -t <span class="variable">$path</span>:<span class="variable">$time</span> <span class="variable">$path</span></span><br><span class="line">        docker tag <span class="variable">$path</span>:<span class="variable">$time</span> registry.cn-hongkong.aliyuncs.com/acm-recentcontests/<span class="variable">$path</span>:<span class="variable">$time</span></span><br><span class="line">        docker push registry.cn-hongkong.aliyuncs.com/acm-recentcontests/<span class="variable">$path</span>:<span class="variable">$time</span></span><br><span class="line">    <span class="keyword">fi</span> </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>里面执行的逻辑其实很简单，<strong>首先就是对<code>maven</code>所要依赖的公共项目进行编译安装，然后再去编译其他独立的一个个项目，最后制作<code>dockerfile</code>文件，编译打包上传到阿里云的<code>docker</code>仓库</strong>。</p><p>这里面有几个坑点，一个是多模块的<code>maven</code>项目怎么打包，这里面也花了我挺长时间，因为每个项目都是独立的，不像单体应用那么简单。除了我这个方法，还有一个方法就是构建一个<code>maven</code>私服，把自己的<code>jar</code>包上传上去，当构建别的项目的时候，它依赖了某个项目，这时候所要依赖的<code>jar</code>包可以从私服上面找到。</p><p>第二点就是<code>dockerfile</code>要和<code>jar</code>文件夹处在同一级目录才好打包，不然会报错，所以脚本有一处是将<code>jar</code>包移动到<code>dockerfile</code>的目录</p><p>第三点就是一些零零碎碎的<code>Linux Shell</code>知识了，比如赋值等号不能有空格，双引号与单引号的区别等等，需要注意。</p><h3 id="debug模式"><a href="#debug模式" class="headerlink" title="debug模式"></a>debug模式</h3><p>不过这里有个好方法可以去解决脚本问题，就是开启<code>debug</code>模式，这样我们可以<code>ssh</code>到<code>travis</code>的机器上面，然后我们可以在<code>travis</code>里面不断修改我们的脚本。</p><p><a href="https://docs.travis-ci.com/user/running-build-in-debug-mode/">Running Build in Debug Mode - Travis CI</a></p><p>跟着官网的脚本走就行了，不过需要注意几点就是</p><ol><li>需要给官方发邮件叫工作人员对你的某个配置开启<code>debug</code>模式后你才能用这个模式，注意时区2333，那时候工作人员可能还在睡觉</li></ol><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/3.png" alt></p><ol><li>因为<code>travis</code>服务器处于外国，直接连接会比较慢，所以可以考虑给<code>ssh</code>套代理，在<code>linux</code>使用<code>ssh</code>命令<code>我</code>并没有找到什么的好的让<code>ssh</code>走代理的方法，我是用<code>putty</code>解决的</li><li><code>ssh</code>上去后如果执行<code>exit</code>的话会直接导致这次的<code>debug</code>直接结束，如果需要退出，直接关闭窗口就行，下次连接的时候还是处于上次操作的位置，需要注意的是，一次<code>debug</code>模式只有三十分钟，超时了只能再发一次请求，并且数据会清空。</li></ol><h3 id="travis网页的设置"><a href="#travis网页的设置" class="headerlink" title="travis网页的设置"></a>travis网页的设置</h3><p>脚本配置好了后，就可以去<code>travis</code><a href="https://travis-ci.com/">官网</a>设置要关联的仓库，好像现在<code>travis</code>只能关联<code>Github</code>仓库，并且得是公开的，私有仓库得要钱。</p><p>然后在右上角头像那里打开<code>setting</code>，进去之后就有个<code>repositories</code></p><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/1.png" alt></p><p>记得之前官网是<code>travis.org</code>的时候有关联的设置，新版官方好像是没有，我们直接在我们要自动部署的仓库里面点一次构建，之后就可以一直构建了。</p><p><img src="/2019/11/21/%E6%B0%B4SpringBoot%E4%B8%8ESpringCloud/4.png" alt></p><p>然后查看每次的构建日志就行啦。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结来说，一共2步：</p><ol><li><strong>编写<code>.travis.yml</code>文件放到项目根目录并且推上仓库</strong></li><li><strong>在<code>travis</code>官网设置要关联的仓库</strong></li></ol><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>个人踩过的坑在<code>maven</code>的构建和<code>travis</code>脚本的编写上面，因为那时候在整一个项目下新建一个子项目都是手动的，有时候会打错某个文件夹名字，<strong>但是<code>idea</code>可以运行，命令行打包会报错，这时候可能是某个文件夹的名字错了，或者是某个文件的名字错了，</strong>所以手残党新建一个<code>SpringBoot</code>子项目的时候可以新建一个<code>maven</code>的<code>module</code>，然后删除多余的东西就行啦。</p><p>还有一个就是<code>pom.xml</code>找不到父模块的问题，或者托管这个<code>maven</code>子项目到<code>idea</code>的时候会报错，这时候<strong>只需要把<code>idea2019</code>版本换回<code>idea2018.2</code></strong>就行啦。</p><p>这2个前期最烦的问题，解决就顺畅很多了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> devops </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019上海网络赛B题</title>
      <link href="/2019/10/08/2019%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9BB%E9%A2%98/"/>
      <url>/2019/10/08/2019%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>上海站Ｂ题Light bulbs<br><span id="more"></span></p><h1 id="上海站B题Light-bulbs"><a href="#上海站B题Light-bulbs" class="headerlink" title="上海站Ｂ题Light bulbs"></a><a href="https://nanti.jisuanke.com/t/41399">上海站Ｂ题Light bulbs</a></h1><p><img src="/2019/10/08/2019%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9BB%E9%A2%98/timu1.png" alt></p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>签到题</p><p><img src="/2019/10/08/2019%E4%B8%8A%E6%B5%B7%E7%BD%91%E7%BB%9C%E8%B5%9BB%E9%A2%98/1.png" alt></p><ul><li>排序</li><li>前缀和</li><li>差分</li></ul><p><em>注意此题卡时间又卡空间，单纯普通类型一维数组长度不能超过1e6</em></p><hr><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为<br>“数列的前n项的和”</p><h3 id="通式"><a href="#通式" class="headerlink" title="通式"></a>通式</h3><p>给定一个数组A[1..n]，前缀和数组PrefixSum[1..n]定义为：<br>PrefixSum[i] = A[0]+A[1]+…+A[i-1]；<br><strong>举例</strong><br>A[5,6,7,8] —&gt; PrefixSum[5,11,18,26]</p><p>PrefixSum[0] =A[0] ;<br>PrefixSum[1] =A[0] + A[1] ;<br>PrefixSum[2] =A[0] + A[1] + A[2] ;<br>PrefixSum[3] =A[0] + A[1] + A[2] + A[3] ;</p><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>差分就是将数列中的每一项分别与前一项数做差</strong>，例如：<br>一个序列1 2 5 4 7 3，差分后得到1 1 3 -1 3 -4 -3</p><p>注意：</p><ul><li>得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）</li><li>差分序列最后比原序列多一个数（相当于0减最后一个数）</li></ul><h3 id="性质（省去证明）"><a href="#性质（省去证明）" class="headerlink" title="性质（省去证明）"></a>性质（省去证明）</h3><p>①差分序列求前缀和可得原序列；</p><p>②原序列区间[L,R]中的元素全部+K，可以转化操作为差分序列L处+K，R+1处-K；</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><ul><li><p>我们可以对题意进行转换</p><p>  <strong>n个点m个区间，每次区间内的数+1，求最后n个点中计数为奇数的点的个数</strong>。<br>  <strong>这个就是经典的差分问题</strong></p></li><li><p>因为n比较大，所以我们可以对m入手，存储所有操作区间的端点，所以下面操作的都是被操作后的区间，而不是所有的值。<br>  <strong>如果不对区间操作，序列中每个原始的值可以为0，代表是暗的，那么差分序列的值全是0；对区间[L,R]+1，等于L处+1，R+1处-1；操作完成后，这时候求前缀和正好对应的是操作次数。)</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 359ms256kB     c++14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左侧代表端点，右侧代表操作</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;p[<span class="number">2020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t1,t,n,m,l,r;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t1);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t1;k++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">p[tot++]=<span class="built_in">make_pair</span>(l,<span class="number">1</span>);</span><br><span class="line">p[tot++]=<span class="built_in">make_pair</span>(r<span class="number">+1</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(p,p+tot);</span><br><span class="line"><span class="comment">//now表示当前的位置</span></span><br><span class="line"><span class="comment">//sum表示从now到当前灯泡的开关状态</span></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>,now=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tot;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//不重叠</span></span><br><span class="line"><span class="keyword">if</span>(now!=p[i].first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans+=p[i].first-now;</span><br><span class="line">&#125;</span><br><span class="line">now=p[i].first;</span><br><span class="line">&#125;</span><br><span class="line">sum+=p[i].second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case #%d: %d\n&quot;</span>,k,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-观察者模式</title>
      <link href="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>《Head First Design Patterns》—The Observer Pattern</p><span id="more"></span><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="报纸订阅"><a href="#报纸订阅" class="headerlink" title="报纸订阅"></a>报纸订阅</h2><p>可以从报纸或杂志的订阅方式去了解观察者模式是什么</p><p>报纸或杂志的订阅方式：</p><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/1.png" alt></p><p>从上面的订阅方式可以这样认为观察者模式：</p><p><strong>Publishers + Subscribers = Observer Pattern</strong><br>报纸出版商 + 订阅者 = 观察者模式</p><p>we call the publisher the <strong>SUBJECT</strong> and the subscribers the <strong>OBSERVERS</strong>.<br>报纸出版商称为SUBJECT(目标)，订阅者称为OBSERVERS(观察者)</p><h2 id="继续解释"><a href="#继续解释" class="headerlink" title="继续解释"></a>继续解释</h2><h2 id="开始时"><a href="#开始时" class="headerlink" title="开始时"></a>开始时</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/2.png" alt></p><h2 id="状态改变时"><a href="#状态改变时" class="headerlink" title="状态改变时"></a>状态改变时</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/3.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/4.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/5.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/6.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/7.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/8.png" alt></p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>通过上面例子已经生动形象得展示了什么是观察者模式</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>The Observer Pattern</strong> defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.</p><p><strong>观察者模式</strong>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p><h2 id="结合定义与之前的例子"><a href="#结合定义与之前的例子" class="headerlink" title="结合定义与之前的例子"></a>结合定义与之前的例子</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/9.png" alt></p><p><code>Subject</code>和<code>Observer</code>定义了一对多的关系。<code>Observer</code>依赖于此<code>Subject</code>，只要<code>Subject</code>状态一有变化，<code>Observer</code>就会被通知。根据通知的风格，<code>Observer</code>可能因为值的更新而更新。<br>实现观察者模式的方法不只一种，但是以包含<code>Subject</code>与<code>Observer</code>接口的类设计的做法最常见。</p><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/10.png" alt></p><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/11.png" alt></p><p>观察者模式提供了一种对象设计，让<code>Subject</code>和<code>Observer</code>之间松耦合。</p><p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</p><hr><p><strong>为什么可以松耦合？</strong></p><ol><li><p><strong>关于<code>Observer</code>的一切，<code>Subject</code>只知道<code>Observer</code>实现了某个接口（也就是<code>Observer</code>接口）</strong>。<code>Subject</code>不需要知道<code>Observer</code>的具体类是谁、做了些什么或其他任何细节。</p></li><li><p><strong>任何时候我们都可以增加新的<code>Observer</code></strong>。因为<code>Subject</code>唯一依赖的东西是一个实现<code>Observer</code>接口的对象列表，所以我们可以随时增加<code>Observer</code>。事实上，在运行时我们可以用新的<code>Observer</code>取代现有的<code>Observer</code>，<code>Subject</code>不会受到任何影响。同样的，也可以在任何时候删除某些<code>Observer</code>。</p></li><li><p><strong>有新类型的<code>Observer</code>出现时，<code>Subject</code>的代码不需要修改</strong>。假如我们有个新的具体类需要当<code>Observer</code>，我们不需要为了兼容新类型而修改<code>Subject</code>的代码，所有要做的就是在新的类里实现此<code>Observer</code>接口，然后注册为<code>Observer</code>即可。<code>Subject</code>不在乎别的，它只会发送通知给所有实现了<code>Observer</code>接口的对象。</p></li><li><p><strong>我们可以独立地复用<code>Subject</code>或<code>Observer</code></strong>。如果我们在其他地方需要使用<code>Subject</code>或<code>Observer</code>，可以轻易地复用，因为二者并非紧耦合。</p></li><li>改变<code>Subject</code>或<code>Observer</code>其中一方，并不会影响另一方。因为两者是松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由地改变他们。</li></ol><h1 id="气象监测应用"><a href="#气象监测应用" class="headerlink" title="气象监测应用"></a>气象监测应用</h1><h2 id="情况介绍"><a href="#情况介绍" class="headerlink" title="情况介绍"></a>情况介绍</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/13.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/12.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/14.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/15.png" alt></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/17.png" alt></p><hr><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/16.png" alt></p><h3 id="Subject接口"><a href="#Subject接口" class="headerlink" title="Subject接口"></a>Subject接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这两个方法都需要一个Observer作为变量，该Observer是用来注册或被删除的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regeisterObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Subject状态改变时，这个方法会被调用，用以通知所有的Observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Observer接口"><a href="#Observer接口" class="headerlink" title="Observer接口"></a>Observer接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的Observer都必须实现update()方法，以实现Observer接口。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当气象观测值改变时，Subject会把这些状态作为方法参数传递给Observer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 温度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity 湿度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure 气压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DisplayElement接口"><a href="#DisplayElement接口" class="headerlink" title="DisplayElement接口"></a>DisplayElement接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisplayElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当布告板需要显示时，调用此方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WeatherData"><a href="#WeatherData" class="headerlink" title="WeatherData"></a>WeatherData</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册Observer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除Observer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer o)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们把状态告诉每一个Observer，因为Observer都实现了apdate（），所以我们知道如何通知它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当气象站得到更新观测值时，我们通知Observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">measurementsChanged</span><span class="params">()</span> &#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以从别的地方设置观测值，不一定从气象站</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布告板"><a href="#布告板" class="headerlink" title="布告板"></a>布告板</h3><h4 id="CurrentConditionsDisplay"><a href="#CurrentConditionsDisplay" class="headerlink" title="CurrentConditionsDisplay"></a>CurrentConditionsDisplay</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了Observer接口，所以可以从WeatherData对象获得值</span></span><br><span class="line"><span class="comment"> * 也实现了DisplayElement接口，因为规定所有的布告板都必须实现此接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么要保存WeacherData的引用？</span></span><br><span class="line"><span class="comment">     * 以后我们可能想要取消注册，如果已经有了对Subject的引用会比较方使。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weatherData</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CurrentConditionsDisplay</span><span class="params">(Subject weatherData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当update被调用时， 把温度和湿度保存起来，调用display()显示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity 湿度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure 气压</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只是将最近的温度和湿度显示出来</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current conditions: &quot;</span> + temperature</span><br><span class="line">                + <span class="string">&quot;F degrees and &quot;</span> + humidity + <span class="string">&quot;% humidity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StatisticsDisplay"><a href="#StatisticsDisplay" class="headerlink" title="StatisticsDisplay"></a>StatisticsDisplay</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StatisticsDisplay</span> <span class="keyword">implements</span> <span class="title class_">Observer</span>, DisplayElement &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">maxTemp</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> <span class="variable">minTemp</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> tempSum= <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numReadings;</span><br><span class="line">    <span class="keyword">private</span> WeatherData weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StatisticsDisplay</span><span class="params">(WeatherData weatherData)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temp, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        tempSum += temp;</span><br><span class="line">        numReadings++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &gt; maxTemp) &#123;</span><br><span class="line">            maxTemp = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; minTemp) &#123;</span><br><span class="line">            minTemp = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Avg/Max/Min temperature = &quot;</span> + (tempSum / numReadings)</span><br><span class="line">                + <span class="string">&quot;/&quot;</span> + maxTemp + <span class="string">&quot;/&quot;</span> + minTemp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentDisplay</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>(weatherData);</span><br><span class="line">        <span class="type">StatisticsDisplay</span> <span class="variable">statisticsDisplay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatisticsDisplay</span>(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span>);</span><br><span class="line">        weatherData.setMeasurements(<span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Current conditions: <span class="number">80.0F</span> degrees and <span class="number">65.0</span>% humidity</span><br><span class="line">Avg/Max/<span class="type">Min</span> <span class="variable">temperature</span> <span class="operator">=</span> <span class="number">80.0</span>/<span class="number">80.0</span>/<span class="number">80.0</span></span><br><span class="line">Current conditions: <span class="number">82.0F</span> degrees and <span class="number">70.0</span>% humidity</span><br><span class="line">Avg/Max/<span class="type">Min</span> <span class="variable">temperature</span> <span class="operator">=</span> <span class="number">81.0</span>/<span class="number">82.0</span>/<span class="number">80.0</span></span><br><span class="line">Current conditions: <span class="number">78.0F</span> degrees and <span class="number">90.0</span>% humidity</span><br><span class="line">Avg/Max/<span class="type">Min</span> <span class="variable">temperature</span> <span class="operator">=</span> <span class="number">80.0</span>/<span class="number">82.0</span>/<span class="number">78.0</span></span><br></pre></td></tr></table></figure><h2 id="JDK内置实现"><a href="#JDK内置实现" class="headerlink" title="JDK内置实现"></a>JDK内置实现</h2><h3 id="Implementation-with-Observer"><a href="#Implementation-with-Observer" class="headerlink" title="Implementation with Observer"></a>Implementation with Observer</h3><p>首先需要说明的是<code>java.util.observer</code>已经在<code>jdk9</code>中被弃用了：</p><p><a href="https://bugs.openjdk.java.net/browse/JDK-8154801">[JDK-8154801] deprecate Observer and Observable - Java Bug System</a></p><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/18.png" alt></p><h3 id="Implementation-with-PropertyChangeListener"><a href="#Implementation-with-PropertyChangeListener" class="headerlink" title="Implementation with PropertyChangeListener"></a>Implementation with PropertyChangeListener</h3><p><a href="https://stackoverflow.com/questions/46380073/observer-is-deprecated-in-java-9-what-should-we-use-instead-of-it">Observer is deprecated in Java 9. What should we use instead of it? - Stack Overflow</a></p><p><code>stackoverflow</code>相关讨论指出：我们可以使用 <strong>PropertyChangeEvent</strong> and <strong>PropertyChangeListener</strong>实现</p><h4 id="WeacherData"><a href="#WeacherData" class="headerlink" title="WeacherData"></a>WeacherData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdk9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyChangeListener;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyChangeSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须有PropertyChangeSupport实例的引用</span></span><br><span class="line"><span class="comment">     * 当类属性发生变化时，有助于发送通知给Observers</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> PropertyChangeSupport support;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeatherData</span><span class="params">()</span> &#123;</span><br><span class="line">        support = <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加Observer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pcl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPropertyChangeListener</span><span class="params">(PropertyChangeListener pcl)</span> &#123;</span><br><span class="line">        support.addPropertyChangeListener(pcl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removePropertyChangeListener</span><span class="params">(PropertyChangeListener pcl)</span> &#123;</span><br><span class="line">        support.removePropertyChangeListener(pcl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temperature</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> humidity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pressure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMeasurements</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        <span class="comment">//当状态改变时，通知Observers</span></span><br><span class="line">        <span class="comment">//参数:属性名称,新值,旧值</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;temperature&quot;</span>, <span class="built_in">this</span>.temperature, temperature);</span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;humidity&quot;</span>, <span class="built_in">this</span>.humidity, humidity);</span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;pressure&quot;</span>, <span class="built_in">this</span>.pressure, pressure);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里设置的顺序和Observer获得顺序保持一样</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = temperature;</span><br><span class="line">        <span class="built_in">this</span>.humidity = humidity;</span><br><span class="line">        <span class="built_in">this</span>.pressure = pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTemperature</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getHumidity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPressure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CurrentConditionsDisplay-1"><a href="#CurrentConditionsDisplay-1" class="headerlink" title="CurrentConditionsDisplay"></a>CurrentConditionsDisplay</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdk9;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyChangeEvent;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title class_">PropertyChangeListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">propertyChange</span><span class="params">(PropertyChangeEvent evt)</span> &#123;</span><br><span class="line">        <span class="comment">//获取值的顺序和WeatherData设置的顺序一样</span></span><br><span class="line">        <span class="built_in">this</span>.temperature = (<span class="type">float</span>) evt.getNewValue();</span><br><span class="line">        <span class="built_in">this</span>.humidity = (<span class="type">float</span>) evt.getNewValue();</span><br><span class="line">        <span class="built_in">this</span>.pressure = (<span class="type">float</span>) evt.getNewValue();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current conditions: &quot;</span> + temperature</span><br><span class="line">                + <span class="string">&quot;F degrees and &quot;</span> + humidity + <span class="string">&quot;% humidity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WeatherStation"><a href="#WeatherStation" class="headerlink" title="WeatherStation"></a>WeatherStation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdk9;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeatherStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherData</span> <span class="variable">weatherData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">CurrentConditionsDisplay</span> <span class="variable">currentDisplay</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CurrentConditionsDisplay</span>();</span><br><span class="line"></span><br><span class="line">        weatherData.addPropertyChangeListener(currentDisplay);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="观察者模式与MVC"><a href="#观察者模式与MVC" class="headerlink" title="观察者模式与MVC"></a>观察者模式与MVC</h1><p><strong>模型</strong>(Model)，<strong>视图</strong>(View)和<strong>控制器</strong>(Controller)</p><p><strong>模型</strong>可对应于观察者模式中的<code>Subject</code>，而<strong>视图</strong>对应于<code>Observer</code>，<strong>控制器</strong>可充当两者之间的中介者</p><p>当<strong>模型层</strong>的数据发生改变时，<strong>视图层</strong>将自动改变其显示内容</p><p><img src="/2019/10/05/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/19.png" alt></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>可以实现<strong>表示层和数据逻辑层的分离</strong></p></li><li><p>在观察目标和观察者之间<strong>建立一个抽象的耦合</strong></p></li><li><p>支持<strong>广播通信，简化了一对多系统设计的难度</strong></p></li><li><p><strong>符合开闭原则</strong>，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li><p>将所有的观察者都通知到会<strong>花费很多时间</strong></p></li><li><p>如果存在<strong>循环依赖</strong>时<strong>可能导致系统崩溃</strong></p></li><li><p><strong>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</strong>，而只是知道观察目标发生了变化</p></li></ol><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><ol><li><p>一个抽象模型有两个方面，其中<strong>一个方面依赖于另一个方面</strong>，将这两个方面封装在独立的对象中使它们<strong>可以各自独立地改变和复用</strong></p></li><li><p><strong>一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁</strong></p></li><li><p>需要在系统中<strong>创建一个触发链</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019徐州网络赛补题</title>
      <link href="/2019/09/08/2019%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%E8%A1%A5%E9%A2%98/"/>
      <url>/2019/09/08/2019%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>B-so easy</p><span id="more"></span><h1 id="B-so-easy"><a href="#B-so-easy" class="headerlink" title="B-so easy"></a><a href="https://nanti.jisuanke.com/t/41384">B-so easy</a></h1><p>参考：<a href="https://blog.csdn.net/liufengwei1/article/details/100606177">2019徐州网络赛 B so easy - binarycopycode - CSDN博客</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li>2000ms</li><li>262144K</li></ul><p><img src="/2019/09/08/2019%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%E8%A1%A5%E9%A2%98/1.png" alt></p><h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>有n个点，分别标号为<code>1-n</code>，两种操作：</p><ul><li><code>1 X</code>，表示去掉第X个点</li><li><code>2 X</code>，表示查询<code>[x,n]</code>内第一个存在的点。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>模拟并查集操作即可（当时并没有想到系列），具体看代码</p><p>注意，因为数据量大，所以得用<code>unordered_map</code>代替数组</p><p><em>（<code>unorderd_map</code>的存取查询操作都近似于<code>O(1)</code>，<code>map</code>是带<code>log</code>的，而且<code>1e6</code>太大，<code>map</code>会T）</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2019-09-08 21:36</span></span><br><span class="line"><span class="comment"> * 1089ms</span></span><br><span class="line"><span class="comment"> * 20096kB</span></span><br><span class="line"><span class="comment"> * c++11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map[x]存x右边第一个在哪，初始的是Map[x]=x+1</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;Map;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">father</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Map.<span class="built_in">count</span>(x) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> Map[x] = <span class="built_in">father</span>(Map[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="type">int</span> op, x, ans;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            Map[x] = <span class="built_in">father</span>(x<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">father</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>STL中，<code>map</code> 对应的数据结构是 红黑树。红黑树是一种近似于平衡的二叉查找树，里面的数据是有序的。在红黑树上做查找操作的时间复杂度为 <code>O(logN)</code>。而 <code>unordered_map</code> 对应 哈希表，哈希表的特点就是查找效率高，时间复杂度为常数级别 <code>O(1)</code>， 而额外空间复杂度则要高出许多。所以对于需要高效率查询的情况，使用 <code>unordered_map</code> 容器。而如果对内存大小比较敏感或者数据存储要求有序的话，则可以用 <code>map</code> 容器。</p><p><a href="https://www.sczyh30.com/posts/C-C/cpp-stl-hashmap/">C++ STL 之哈希表 | unordered_map | 「浮生若梦」 - sczyh30’s blog</a></p></blockquote><h1 id="E-XKC’s-basketball-team"><a href="#E-XKC’s-basketball-team" class="headerlink" title="E.XKC’s basketball team"></a><a href="https://nanti.jisuanke.com/t/41387">E.XKC’s basketball team</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><img src="/2019/09/08/2019%E5%BE%90%E5%B7%9E%E7%BD%91%E7%BB%9C%E8%B5%9B%E8%A1%A5%E9%A2%98/2.png" alt></p><h2 id="大意-1"><a href="#大意-1" class="headerlink" title="大意"></a>大意</h2><p>给定n个数，与一个数m，求ai右边最后一个至少比ai大m的数与这个数之间有多少个数</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>参考：<a href="https://www.codetd.com/article/7225701">2019 徐州icpc网络赛 E. XKC’s basketball team - 代码天地</a></p><p>对于每一个数，利用二分的方法求他右边大于等于<code>ai+m</code>的数的最后一个值</p><p>关键在于怎么二分呢？</p><p>利用线段树存储区间最大值，看这个区间的最大值是不是比<code>ai+m</code>大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2019-09-08 22:05</span></span><br><span class="line"><span class="comment"> * 445ms</span></span><br><span class="line"><span class="comment"> * 51132kB</span></span><br><span class="line"><span class="comment"> * c++11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,ma;</span><br><span class="line">&#125;tree[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].l = l;</span><br><span class="line">    tree[p].r = r;</span><br><span class="line">    tree[p].ma = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].ma = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,p*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid<span class="number">+1</span>,r,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    tree[p].ma = <span class="built_in">max</span>(tree[p*<span class="number">2</span>].ma,tree[p*<span class="number">2</span><span class="number">+1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == tree[p].l &amp;&amp; y == tree[p].r)</span><br><span class="line">        <span class="keyword">return</span> tree[p].ma;</span><br><span class="line">    <span class="type">int</span> mid = (tree[p].l + tree[p].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(x,y,p*<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(x,y,p*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(x,mid,p*<span class="number">2</span>),<span class="built_in">query</span>(mid<span class="number">+1</span>,y,p*<span class="number">2</span><span class="number">+1</span>));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,i,j,k,n,q,x,y,m,s,l,r,mid;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s=m+a[i];</span><br><span class="line">        l=i<span class="number">+1</span>;</span><br><span class="line">        r=n;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">              mid=(l+r<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(<span class="built_in">query</span>(mid,r,<span class="number">1</span>)&gt;=s)</span><br><span class="line">            &#123;</span><br><span class="line">                l=mid;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">query</span>(l,mid,<span class="number">1</span>)&gt;=s)</span><br><span class="line">             &#123;</span><br><span class="line">                 r=mid<span class="number">-1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> </span><br><span class="line">             &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[l]&gt;=s)</span><br><span class="line">        cout&lt;&lt;l-i<span class="number">-1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>从后向前维护一个递增的队列，从后往前遍历：</p><ul><li>若当前的数大于队尾就进队，否则从该队列中二分找最小的比自己大至少 的数，二者之间的距离即为答案</li><li>若当前数小于队尾，那这个数一定没有队尾的数优，因为它既比队尾的数靠前，又比它小。</li></ul><p>时间复杂度：<code>O(nlogn)</code></p><h3 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h3><p>此题也可以用ST表+二分等方法写出</p>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Shiro+Jwt填坑-3</title>
      <link href="/2019/09/07/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-3/"/>
      <url>/2019/09/07/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-3/</url>
      
        <content type="html"><![CDATA[<p>整合SpringBoot</p><span id="more"></span><p>省去建表，数据库读取代码。</p><h1 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h1><p>在<code>SpringBoot</code>中使用<code>JWT</code>来做接口权限认证，安全框架依旧使用<code>Shiro</code></p><ol><li>我们<code>POST</code>用户名与密码到<code>/login</code>进行登入，如果成功返回一个加密<code>token</code>，失败的话直接返回401错误。</li><li>之后用户访问每一个需要权限的网址请求必须在<code>header</code>中添加<code>Authorization</code>字段，例如<code>Authorization: token</code>，<code>token</code>为密钥。</li><li>后台会进行<code>token</code>的校验，如果不通过直接返回401。</li></ol><h2 id="Token加密说明"><a href="#Token加密说明" class="headerlink" title="Token加密说明"></a>Token加密说明</h2><ul><li>携带了 <code>username</code> 信息在 token 中。</li><li>设定了过期时间。</li><li>使用秘钥对 <code>token</code> 进行加密。</li></ul><h2 id="Token校验流程"><a href="#Token校验流程" class="headerlink" title="Token校验流程"></a>Token校验流程</h2><p>服务端接收到<code>token</code> 之后，会逆向构造过程，<code>decode</code> 出<code>JWT</code> 的三个部分，这一步可以得到<code>sign</code>的算法及 <code>payload</code>，结合服务端配置的 <code>secretKey</code>，可以再次进行 <code>Signature</code> 的生成得到新的 <code>​Signature</code>，与原有的 ​<code>Signature</code> 比对以验证 <code>token</code> 是否有效，完成用户身份的认证。</p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>添加依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">3.8</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.4</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="JWT工具类"><a href="#JWT工具类" class="headerlink" title="JWT工具类"></a>JWT工具类</h1><p>我们写一个简单的<code>JWT</code>加密，校验工具，并且使用用户自己的密码充当加密密钥， 这样保证了<code>token</code> 即使被他人截获也无法破解。并且我们在<code>token</code>中附带了<code>username</code>信息，并且设置密钥1天就会过期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期时间1天</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">24</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验token是否正确</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token    密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 登录名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret 秘钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(String token, String username, String secret)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//对秘钥进行加密后再与用户名混淆在一起</span></span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(secret);</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(algorithm)</span><br><span class="line">                    .withClaim(<span class="string">&quot;username&quot;</span>, username)</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得token中的信息无需secret解密也能获得</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token中包含的用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUsername</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">            <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;username&quot;</span>).asString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JWTDecodeException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret   用户的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密的token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">sign</span><span class="params">(String username, String secret)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定过期时间</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">        <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(secret);</span><br><span class="line">        <span class="comment">// 附带username信息</span></span><br><span class="line">        <span class="keyword">return</span> JWT.create()</span><br><span class="line">                .withClaim(<span class="string">&quot;username&quot;</span>, username)</span><br><span class="line">                .withExpiresAt(date)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成前端需要的用户信息，包括：</span></span><br><span class="line"><span class="comment">     * 1. token</span></span><br><span class="line"><span class="comment">     * 2. userInfo</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">generateUserInfo</span><span class="params">(UserInfo userInfo)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; responseBean = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> sign(userInfo.getUsername(), userInfo.getPassword());</span><br><span class="line">        responseBean.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">        userInfo.setPassword(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        responseBean.put(<span class="string">&quot;userInfo&quot;</span>, userInfo);</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildSuccessResult(responseBean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建JWTToken替换Shiro原生Token"><a href="#创建JWTToken替换Shiro原生Token" class="headerlink" title="创建JWTToken替换Shiro原生Token"></a>创建JWTToken替换Shiro原生Token</h1><ol><li><code>Shiro</code> 原生的 <code>Token</code> 中存在用户名和密码以及其他信息 [验证码，记住我]，因为是前后端分离，服务器无需保存用户状态，所以不需要<code>RememberMe</code>这类功能， 我们简单的实现下<code>AuthenticationToken</code>接口即可</li><li>在 <code>JWT</code> 的 <code>Token</code> 中因为<strong>已将用户名和密码通过加密处理整合到一个加密串中</strong>，所以只需要一个 <code>token</code> 字段即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTToken</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JWTToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(token.contains(<span class="string">&quot;Bearer&quot;</span>))&#123;</span><br><span class="line">            token = token.substring(<span class="number">7</span>, token.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建JWTFilter实现前端请求统一拦截及处理"><a href="#创建JWTFilter实现前端请求统一拦截及处理" class="headerlink" title="创建JWTFilter实现前端请求统一拦截及处理"></a>创建JWTFilter实现前端请求统一拦截及处理</h1><p>所有的请求都会先经过<code>Filter</code>，所以我们继承官方的<code>BasicHttpAuthenticationFilter</code>，并且重写鉴权的方法， 另外通过重写<code>preHandle</code>，实现跨域访问。</p><p><strong>代码的执行流程<code>preHandle-&gt;isAccessAllowed-&gt;isLoginAttempt-&gt;executeLogin</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建JWTFilter实现前端请求统一拦截及处理</span></span><br><span class="line"><span class="comment"> * 所有的请求都会先经过 Filter，所以我们继承官方的 BasicHttpAuthenticationFilter</span></span><br><span class="line"><span class="comment"> * 并且重写鉴权的方法</span></span><br><span class="line"><span class="comment"> * 代码的执行流程 preHandle -&gt; isAccessAllowed -&gt; isLoginAttempt -&gt; executeLogin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicHttpAuthenticationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">LOGIN_SIGN</span> <span class="operator">=</span> <span class="string">&quot;Authorization&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测用户是否登录</span></span><br><span class="line"><span class="comment">     * 检测header里面是否包含Authorization字段即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoginAttempt</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> req.getHeader(LOGIN_SIGN);</span><br><span class="line">        <span class="keyword">return</span> authorization != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * executeLogin() 方法中的 getSubject(request, response).login(token)</span></span><br><span class="line"><span class="comment">     * 就是触发 Shiro Realm 自身的登录控制，具体内容需要手动实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> httpServletRequest.getHeader(LOGIN_SIGN);</span><br><span class="line">        <span class="type">JWTToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JWTToken</span>(authorization);</span><br><span class="line">        <span class="comment">// 提交给realm进行登入，如果错误他会抛出异常并被捕获</span></span><br><span class="line">        getSubject(request, response).login(token);</span><br><span class="line">        <span class="comment">// 如果没有抛出异常则代表登入成功，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一般在isAccessAllowed中执行认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoginAttempt(request, response)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeLogin(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 认证出现异常，传递错误信息msg</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">                <span class="comment">// Token认证失败直接返回Response信息</span></span><br><span class="line">                <span class="built_in">this</span>.response401(response, msg);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里我们详细说明下为什么重写</span></span><br><span class="line"><span class="comment">     * 可以对比父类方法，只是将executeLogin方法调用去除了</span></span><br><span class="line"><span class="comment">     * 如果没有去除将会循环调用doGetAuthenticationInfo方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.sendChallenge(request, response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对跨域提供支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> WebUtils.toHttp(request);</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST,OPTIONS,PUT,DELETE&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Access-Control-Request-Headers&quot;</span>));</span><br><span class="line">        <span class="comment">// 跨域时会首先发送一个OPTIONS请求，这里我们给OPTIONS请求直接返回正常状态</span></span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无需转发，直接返回Response信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">response401</span><span class="params">(ServletResponse response, String msg)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> WebUtils.toHttp(response);</span><br><span class="line">        httpServletResponse.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        httpServletResponse.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        httpServletResponse.setContentType(<span class="string">&quot;application/json; charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> httpServletResponse.getWriter()) &#123;</span><br><span class="line">            <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> ResultFactory.buildUnauthorizedResult(<span class="string">&quot;无权访问(Unauthorized):&quot;</span> + msg);</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(result);</span><br><span class="line">            out.append(jsonObject.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomException</span>(<span class="string">&quot;直接返回Response信息出现IOException异常:&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实现Realm"><a href="#实现Realm" class="headerlink" title="实现Realm"></a>实现Realm</h1><p><code>realm</code>的用于处理用户是否合法的这一块，需要我们自己实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserRepository</span><span class="params">(UserRepository userRepository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userRepository = userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写Realm的supports()方法是通过JWT进行登录判断的关键</span></span><br><span class="line"><span class="comment">     * 因为前文中创建了JWTToken用于替换 Shiro 原生 token</span></span><br><span class="line"><span class="comment">     * 所以必须在此方法中显式的进行替换，否则在进行判断时会一直失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(AuthenticationToken token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> JWTToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行授权逻辑</span></span><br><span class="line"><span class="comment">     * 只有当需要检测用户权限的时候才会调用此方法，例如checkRole,checkPermission之类的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> JWTUtil.getUsername(principalCollection.toString());</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userRepository.findByUsername(username);</span><br><span class="line">        List&lt;String&gt; permissionList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; roleNameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;SysRole&gt; roleSet = userInfo.getRoleList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(roleSet)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SysRole role : roleSet) &#123;</span><br><span class="line">                <span class="comment">// 添加角色</span></span><br><span class="line">                roleNameList.add(role.getName());</span><br><span class="line">                <span class="comment">// 根据用户角色查询权限</span></span><br><span class="line">                Set&lt;SysPermission&gt; permissionSet = role.getPermissions();</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(permissionSet)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (SysPermission permission : permissionSet) &#123;</span><br><span class="line">                        <span class="comment">// 添加权限</span></span><br><span class="line">                        permissionList.add(permission.getUrl());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        info.addStringPermissions(permissionList);</span><br><span class="line">        info.addRoles(roleNameList);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行认证逻辑</span></span><br><span class="line"><span class="comment">     * 默认使用此方法进行用户名正确与否验证，错误抛出异常即可。</span></span><br><span class="line"><span class="comment">     * 登录的合法验证通常包括 token 是否有效 、用户名是否存在 、密码是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> (String) auth.getCredentials();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> JWTUtil.getUsername(token);</span><br><span class="line">        <span class="type">String</span> <span class="variable">secert</span> <span class="operator">=</span> userRepository.getCredentials(userName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * token为空或者不通过</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token) || !JWTUtil.verify(token, userName, secert)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;token校验不通过&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证成功，将用户信息封装成SimpleAuthenticationInfo</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(token, token, <span class="string">&quot;shiroRealm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置Shiro"><a href="#配置Shiro" class="headerlink" title="配置Shiro"></a>配置Shiro</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过滤器，将自定义的Filter加入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="comment">//用于定义主Shiro Filter</span></span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置要构造的Shiro Filter使用的SecurityManager实例</span></span><br><span class="line">        <span class="comment">//这是必填属性-设置失败将引发初始化异常</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 Shiro过滤器链上加入 JWTFilter</span></span><br><span class="line">        LinkedHashMap&lt;String, Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        filters.put(<span class="string">&quot;jwt&quot;</span>, <span class="keyword">new</span> <span class="title class_">JWTFilter</span>());</span><br><span class="line">        shiroFilterFactoryBean.setFilters(filters);</span><br><span class="line"></span><br><span class="line">        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 所有请求都要经过 jwt过滤器</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;jwt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">(ShiroRealm shiroRealm)</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">// 配置 SecurityManager，并注入 shiroRealm</span></span><br><span class="line">        securityManager.setRealm(shiroRealm());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Shiro自带的session</span></span><br><span class="line">        <span class="type">DefaultSubjectDAO</span> <span class="variable">subjectDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSubjectDAO</span>();</span><br><span class="line">        <span class="type">DefaultSessionStorageEvaluator</span> <span class="variable">defaultSessionStorageEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSessionStorageEvaluator</span>();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(<span class="literal">false</span>);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroRealm <span class="title function_">shiroRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置 Realm</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroRealm</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, String&gt; payload)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> payload.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> payload.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">errorMessage</span> <span class="operator">=</span> <span class="string">&quot;用户名或密码错误&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userRepository.findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(userInfo == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildFailResult(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!Argon2Util.verify(userInfo.getPassword(), password))&#123;</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildFailResult(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JWTUtil.generateUserInfo(userInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/123&quot;)</span></span><br><span class="line"><span class="comment">//需要登录才能获取</span></span><br><span class="line">    <span class="meta">@RequiresAuthentication</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">111</span>);</span><br><span class="line">        <span class="keyword">return</span> ResultFactory.buildSuccessResult(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.xncoding.com/2017/07/09/spring/sb-jwt.html">SpringBoot系列 - 集成JWT实现接口权限认证 | 飞污熊博客</a></p><p><a href="https://www.inlighting.org/archives/spring-boot-shiro-jwt.html">Shiro + JWT + Spring Boot Restful 简易教程 - 沧海月明</a></p><p><a href="http://asing1elife.com/java/springboot/shiro/vue/2018/08/09/SpringBoot+Shiro%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87JWT%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/">SpringBoot+Shiro+Vue前后端分离项目通过JWT实现自动登录 | asing1elife’s blog</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Shiro </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Shiro+Jwt填坑-2</title>
      <link href="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/"/>
      <url>/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/</url>
      
        <content type="html"><![CDATA[<p>jwt介绍</p><span id="more"></span><p>转载自：<a href="https://blog.csdn.net/xlgen157387/article/details/79191900">一步步带你了解前后端分离利器之JWT - 徐刘根的博客 - CSDN博客</a></p><h1 id="RESTful-API认证方式"><a href="#RESTful-API认证方式" class="headerlink" title="RESTful API认证方式"></a>RESTful API认证方式</h1><p>一般来讲，对于<code>RESTful API</code>都会有认证(<code>Authentication</code>)和授权(<code>Authorization</code>)过程，保证<code>API</code>的安全性。</p><p><em><code>Authentication</code>指的是确定这个用户的身份，<code>Authorization</code>是确定该用户拥有什么操作权限。</em></p><h2 id="Basic-Authentication"><a href="#Basic-Authentication" class="headerlink" title="Basic Authentication"></a>Basic Authentication</h2><p>这种方式是直接将用户名和密码放到<code>Header</code>中，使用<code>Authorization: Basic Zm9vOmJhcg==</code>，使用最简单但是最不安全。</p><h2 id="TOKEN认证"><a href="#TOKEN认证" class="headerlink" title="TOKEN认证"></a>TOKEN认证</h2><p>这种方式也是再HTTP头中，使用<code>Authorization: Bearer &lt;token&gt;</code>，使用最广泛的<code>TOKEN</code>是<code>JWT</code>，通过签名过的<code>TOKEN</code>。</p><h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><p>这种方式安全等级最高，但是也是最复杂的。如果不是大型API平台或者需要给第三方APP使用的，没必要整这么复杂。</p><p>一般项目中的<code>RESTful API</code>使用<code>JWT</code>来做认证就足够了</p><p>下面是<code>JWT</code>介绍</p><h1 id="HTTP的无状态性"><a href="#HTTP的无状态性" class="headerlink" title="HTTP的无状态性"></a>HTTP的无状态性</h1><p><code>HTTP</code> 是无状态协议，它不对之前发送过的请求和响应的状态进行管理。也就是说，<strong>无法根据之前的状态进行本次的请求处理。假设要求登录认证的 <code>Web</code> 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。</strong></p><p>不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 <code>CPU</code> 及内存资源的消耗。从另一侧面来说，也正是因为 <code>HTTP</code> 协议本身是非常简单的，所以才会被应用在各种场景里。</p><h1 id="Cookie-技术的引入"><a href="#Cookie-技术的引入" class="headerlink" title="Cookie 技术的引入"></a>Cookie 技术的引入</h1><p>如果让服务器管理全部客户端状态则会成为负担，保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了<code>Cookie</code>技术。<strong><code>Cookie</code>技术通过在请求和响应报文中写入<code>Cookie</code>信息来控制客户端的状态。</strong></p><p><code>Cookie</code>会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存 <code>Cookie</code>。<strong>当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入<code>Cookie</code>值后发送出去。</strong></p><ul><li>没有 <code>Cookie</code> 信息状态下的请求</li></ul><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/1.png" alt></p><ul><li>第 2 次以后（存有 <code>Cookie</code> 信息状态） 的请求</li></ul><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/2.png" alt></p><ul><li>Cookie 传输过程</li></ul><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/3.png" alt></p><p>服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后<strong>对比服务器上的记录</strong>， 最后得到之前的状态信息。</p><h1 id="基于表单的认证"><a href="#基于表单的认证" class="headerlink" title="基于表单的认证"></a>基于表单的认证</h1><p>目前用户的认证多半是基于表单的认证，基于表单的认证一般会使用 <code>Cookie</code> 来管理<code>Session</code>（<code>Session</code>会话，<code>Session</code>代表着服务器和客户端一次会话的过程，直到<code>Session</code>失效（服务端关闭）或者客户端关闭时结束<strong>）。</strong>基于表单认证本身是通过服务器端的 <code>Web</code>应用，将客户端发送过来的用户ID和密码与之前登录过的信息做匹配来进行认证的。**</p><p>但鉴于 HTTP 是无状态协议， 之前已认证成功的用户状态无法通过协议层面保存下来。 即无法实现状态管理， 因此即使当该用户下一次继续访问，也无法区分他与其他的用户。<strong>于是我们会使用<code>Cookie</code>来管理 <code>Session</code>，以弥补 <code>HTTP</code>协议中不存在的状态管理功能。</strong></p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/4.png" alt></p><p>简单的来说就是，<strong>用户在登录的时候，会在<code>Web</code>服务器中开辟一段内存空间<code>Session</code>用于保存用户的认证信息和其他信息，用户登录成功之后会通过<code>Set-Cookie</code>的首部字段信息，通知客户端保存<code>Cookie</code>，而这<code>Cookie</code>保存的就是服务器端<code>Session</code>的<code>ID</code></strong>，下次请求的时候客户端会带上该<code>Cookie</code>向服务器端发送请求，服务器端进行校验，<strong>如果<code>Session</code>中保存的有该<code>ID</code>的<code>Session</code>就表示用户认证通过，否则失败！</strong><br><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/5.png" alt></p><h1 id="Session存储位置以及集群情况下的问题"><a href="#Session存储位置以及集群情况下的问题" class="headerlink" title="Session存储位置以及集群情况下的问题"></a>Session存储位置以及集群情况下的问题</h1><p><code>Session</code> 是存储在<code>Web</code>服务器（例如：<code>Tomcat</code>）中的，并针对每个客户端（客户），通过<code>SessionID</code>来区别不同用户的。<strong><code>Session</code>是以<code>Cookie</code>技术或<code>URL</code>重写实现，默认以<code>Cookie</code>技术实现，服务端会给这次会话创造一个<code>JSESSIONID</code>的<code>Cookie</code>值。</strong></p><p>但是一个显著的问题就是，<strong>在集群模式下如果通过<code>Nginx</code>负载均衡的时候，如果有一个用户登录的时候请求被分配到服务器A上，登录成功后设置的<code>Session</code>就会存放在服务器A上了，但是在服务器B上却没有该用户的<code>Session</code>数据，当用户再次发起一个请求的时候，此时请求如果被分配到服务器B上，则就不会查询到该用户的登录状态，就会出现登录失败的情况！</strong></p><p>一种可以想到的方式就是将多个Web服务器上存储的<code>Session</code>统一存储到某一存储介质中，保证进集群中的每一台机器都可以看到所有相同<code>Session</code>数据，这里的同步体现在所有的<code>Session</code>存储在同一的存储介质里边。</p><p>幸运的是我们常用的<code>Tomcat</code>容器已经为我们提供了一个接口，可以让我们实现将<code>Session</code>存储到除当前服务器之外的其他存储介质上，例如<code>Redis</code>等。</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/6.png" alt></p><h1 id="小结与需求痛点"><a href="#小结与需求痛点" class="headerlink" title="小结与需求痛点"></a>小结与需求痛点</h1><p><code>Session</code>和<code>Cookie</code>的目的相同，都是为了克服<code>HTTP</code>协议无状态的缺陷，但完成的方法不同。<code>Session</code>通过<code>Cookie</code>，在客户端保存<code>SessionID</code>，而将用户的其他会话消息保存在服务端的<code>Session</code>对象中，与此相对的，<code>Cookie</code>需要将所有信息都保存在客户端。因此<code>Cookie</code>存在着一定的安全隐患，例如本地<code>Cookie</code>中保存的用户名密码被破译，或<code>Cookie</code>被其他网站收集。</p><p>上述过程我们简单的描述了<code>Session</code>的演进过程还有使用同步的方式解决<code>Session</code>在集群的时候出现的问题，但是我们意识到了使用<code>Spring Session</code>的方式来实现<code>Session</code>的同步是一件相对比较麻烦的事情，我们虽然使用<code>Redis</code>来进行同步，但是<code>Redis</code>并不是100%可靠的，<strong>我们需要对<code>Redis</code>搭建集群、进行主从同步复制、进行持久化等，显然这是一件很复杂的事情，因此有没有一种小而轻便的方式来实现我们的这种认证需求！那就是<code>JWT</code>了！</strong></p><p><em>除了上述我们遇到的问题之外，在目前前后端分离的大环境下经常会遇到需要根据用户来分配权限和显示相对应信息的问题，虽然传统的<code>Cookie</code>和<code>Session</code>机制可以解决这个问题，但就通用性而言，<code>JWT（JSON Web Tokens）</code>相对来说更好。</em></p><h1 id="JWT是什么"><a href="#JWT是什么" class="headerlink" title="JWT是什么"></a>JWT是什么</h1><p><code>Json web tokens (JWT)</code>，是为了在网络应用环境间传递声明而执行的一种基于<code>JSON</code>的开放标准(<code>RFC 7519</code>)。该标准被设计为紧凑且安全的，一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息。当然该标准也可直接被用于认证，也可被加密。</p><h2 id="JWT的几个特点"><a href="#JWT的几个特点" class="headerlink" title="JWT的几个特点"></a><strong>JWT的几个特点</strong></h2><ol><li><p>由于它们的尺寸较小，<code>JWT</code>可以通过<code>URL</code>，<code>POST</code>参数或<code>HTTP</code>头部发送。 另外，尺寸越小意味着传输速度越快。</p></li><li><p>有效载荷包含有关用户的所有必需信息，避免了多次查询数据库的需要。</p></li></ol><h2 id="JWT的使用场景"><a href="#JWT的使用场景" class="headerlink" title="JWT的使用场景"></a><strong>JWT的使用场景</strong></h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>这是使用<code>JWT</code>最常见的情况。 <strong>一旦用户登录，每个后续请求将包括<code>JWT</code>。它将允许用户访问该令牌允许的路由，服务和资源。 单点登录是当今广泛使用<code>JWT</code>的一项功能，因为它的开销很小，而且能够轻松地跨不同域使用。</strong></p><h3 id="信息交换"><a href="#信息交换" class="headerlink" title="信息交换"></a>信息交换</h3><p><code>JWT</code>是在各方之间安全传输信息的好方法， 因为<code>JWT</code>可以被签名（例如使用公钥/私钥对进行签名）。所以你可以确定发件人是他们说的那个人。 此外，由于使用头部（<code>header</code>）和有效载荷（<code>payload</code>）计算签名，因此您还可以验证内容是否未被篡改。</p><h1 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p><strong>JWT包含三个由点（.）分隔的部分</strong>，它们是：</p><ol><li>头部（<code>header</code>）</li><li>有效负载（<code>payload</code>）</li><li>签名（<code>signature</code>）</li></ol><p>因此，<code>JWT</code>通常看起来如下所示:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure><h2 id="头部（header）"><a href="#头部（header）" class="headerlink" title="头部（header）"></a>头部（header）</h2><p>头部（<code>heade</code>）通常由两部分组成：令牌的类型（即<code>JWT</code>）和正在使用的散列算法（如<code>HMAC SHA256</code>或<code>RSA</code>）。如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后，将这个<code>JSON</code>用<code>Base64</code>编码，形成<code>JWT</code>的第一部分。</p><blockquote><p><strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/二进制">二进制数据</a>的表示方法</p><p>Base64常用于在通常处理文本<a href="https://zh.wikipedia.org/wiki/数据">数据</a>的场合，表示、传输、存储一些二进制数据，包括<a href="https://zh.wikipedia.org/wiki/MIME">MIME</a>的<a href="https://zh.wikipedia.org/wiki/电子邮件">电子邮件</a>及<a href="https://zh.wikipedia.org/wiki/XML">XML</a>的一些复杂数据。</p></blockquote><h2 id="有效负载（payload）"><a href="#有效负载（payload）" class="headerlink" title="有效负载（payload）"></a>有效负载（payload）</h2><p>令牌的第二部分是包含声明的有效载荷。 声明是关于实体（通常是用户）和附加元数据的声明。 有三种类型的声明：</p><ol><li>标准中注册的声明；</li><li>公开声明；</li><li>私人声明；</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="标准中注册的声明"><a href="#标准中注册的声明" class="headerlink" title="标准中注册的声明"></a>标准中注册的声明</h3><p>标准中注册的声明：这是一组预先定义的声明，这些声明不是强制性的，但建议提供一套有用的，可互操作的声明。 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iss: jwt签发者</span><br><span class="line"></span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line"></span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line"></span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line"></span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的.</span><br><span class="line"></span><br><span class="line">iat: jwt的签发时间</span><br><span class="line"></span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</span><br></pre></td></tr></table></figure><p>注意：声明名称只有三个字符长，因为<code>JWT</code>是紧凑的。</p><h3 id="公开声明"><a href="#公开声明" class="headerlink" title="公开声明"></a>公开声明</h3><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p><h3 id="私人声明"><a href="#私人声明" class="headerlink" title="私人声明"></a>私人声明</h3><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为<code>base64</code>是对称解密的，意味着该部分信息可以归类为明文信息。</p><h2 id="签名（signature）"><a href="#签名（signature）" class="headerlink" title="签名（signature）"></a>签名（signature）</h2><p>要创建签名部分，您必须采用头部（<code>header</code>），有效载荷（<code>payload</code>），密钥（<code>secret</code>），以及头部中指定的算法。例如，如果你想使用<code>HMAC SHA256</code>算法，签名将按以下方式创建：</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/7.png" alt></p><p><strong>签名通常用于验证<code>JWT</code>的发件人是谁，并JWT在传送的过程中不被篡改</strong>。</p><p>注意：<strong>上图红框中的<code>secret</code>是保存在服务器端的，<code>JWT</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>JWT</code>的签发和<code>JWT</code>的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>，那就意味着客户端是可以自我签发<code>JWT</code>了。</strong></p><h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><p>下面显示了一个登录请求成功之后服务端返回的<code>Token</code>，它由编码头部（<code>header</code>）、编码有效载荷（<code>payload</code>）和签名（<code>signature</code>）通过（.）拼接而成：</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/8.png" alt></p><p>如果需要，你可以使用<a href="https://jwt.io/">jwt.io</a>的<code>Debugger</code>工具，来编码、验证和生成<code>JWT</code>。操作界面如下</p><p>刚开始没有输入<code>secret</code>则显示验证错误</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/9.png" alt></p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/14.png" alt></p><p>输入后<code>jwt</code>是一样的，并且验证通过了</p><h1 id="JWT的工作原理"><a href="#JWT的工作原理" class="headerlink" title="JWT的工作原理"></a>JWT的工作原理</h1><p>在身份验证中，当用户使用他们的凭证（如用户名、密码）成功登录时，后台服务器将返回一个<code>token</code>，前端接收到这个<code>token</code>将其保存在本地（通常在本地存储中，也可以使用<code>Cookie</code>，但不是传统方法中创建会话，服务器并返回一个<code>cookie</code>）。<strong>下次用户想要访问受保护的路由或资源时，就将本地保存的<code>token</code>放在头部<code>Header</code>中发送到后台服务器。服务器接收到请求，检查头部中<code>token</code>的存在，如果存在就允许访问受保护的路由或资源，否则就不允许</strong>。如下所示：<br><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/10.png" alt></p><p>一般默认的<code>Value</code>是以<code>Bearer</code>开始，注意这里的<code>Bearer</code>之后有一个空格，<strong>以便后端进行分割</strong>。</p><p>这是一种无状态身份验证机制，因为用户状态永远不会保存在服务器内存中。 由于<code>JWT</code>是独立的，所有必要的信息都在那里，所以减少了多次查询数据库的需求。</p><h1 id="JWT总结"><a href="#JWT总结" class="headerlink" title="JWT总结"></a>JWT总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li><p>因为<code>Json</code>的通用性，所以JWT是可以进行跨语言支持的，像<code>Java</code>、<code>JavaScript</code>、<code>NodeJS</code>、<code>PHP</code>等很多语言都可以使用。</p></li><li><p>因为有了<code>payload</code>部分，所以<code>JWT</code>可以在自身存储一些其他业务逻辑所必要的非敏感信息。</p></li><li><p>便于传输，<code>JWT</code>的构成非常简单，字节占用很小，所以它是非常便于传输的。</p></li><li><p>它不需要在服务端保存会话信息, 所以它易于应用的扩展</p></li></ol><h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><ol><li><p>不应该在<code>JWT</code>的<code>payload</code>部分存放敏感信息，因为该部分是客户端可解密的部分。</p></li><li><p>保护好<code>secret</code>私钥，该私钥非常重要。</p></li><li><p>如果可以，请使用<code>HTTPS</code>协议，不！是务必使用<code>HTTPS</code>!</p></li></ol><h1 id="session-cookie-jwt"><a href="#session-cookie-jwt" class="headerlink" title="session cookie jwt"></a>session cookie jwt</h1><p>转自：<a href="https://mp.weixin.qq.com/s/SY-5ETSjwSB28o95NIsxGw">五分钟带你了解Cookie、Session、Token 和 JWT</a></p><h2 id="基于session的用户认证"><a href="#基于session的用户认证" class="headerlink" title="基于session的用户认证"></a>基于session的用户认证</h2><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/11.jpg" alt>![](</p><h2 id="基于token的认证方案"><a href="#基于token的认证方案" class="headerlink" title="基于token的认证方案"></a>基于token的认证方案</h2><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/12.jpg" alt></p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-2/13.jpg" alt></p><hr><p>参考：</p><p><a href="https://www.xncoding.com/2017/07/09/spring/sb-jwt.html">SpringBoot系列 - 集成JWT实现接口权限认证 | 飞污熊博客</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Shiro </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Shiro+Jwt填坑-1</title>
      <link href="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/"/>
      <url>/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/</url>
      
        <content type="html"><![CDATA[<p>shiro介绍</p><span id="more"></span><h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><p>在了解<code>Shiro</code>之前，我们需要认知用户权限模型。</p><p>基于角色的权限访问控制（<code>Role-Based Access Control</code>）作为传统访问控制（自主访问，强制访问）的有前景的代替受到广泛的关注。在<code>RBAC</code>中，<strong>权限与角色相关联</strong>，用户通过成为适当角色的成员而得到这些角色的权限。这就极大地简化了权限的管理。</p><p>为实现一个较为灵活的用户权限数据模型，通常把<strong>用户信息单独用一个实体表示，用户权限信息用两个实体表示</strong>。</p><ol><li>用户信息用<code>LoginAccount</code>表示，最简单的用户信息可能只包含用户名<code>loginName</code>及密码<code>password</code>两个属性。实际应用中可能会包含用户是否被禁用，用户信息是否过期等信息。</li><li>用户权限信息用<code>Role</code>与<code>Permission</code>表示，<code>Role</code>与<code>Permission</code>之间构成多对多关系。<code>Permission</code>可以理解为对一个资源的操作，<code>Role</code>可以简单理解为<code>Permission</code>的集合。</li><li>用户信息与<code>Role</code>之间构成多对多关系。表示同一个用户可以拥有多个<code>Role</code>，一个<code>Role</code>可以被多个用户所拥有。</li></ol><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/3.jpg" alt></p><p>(图源：<a href="http://www.woshipm.com/pd/1150093.html">RBAC模型：基于用户-角色-权限控制的一些思考 | 人人都是产品经理</a>)</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/4.jpg" alt></p><p>(图源：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-shiro/">在 Web 项目中应用 Apache Shiro</a>)</p><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h2 id="Java常见安全管理框架"><a href="#Java常见安全管理框架" class="headerlink" title="Java常见安全管理框架"></a>Java常见安全管理框架</h2><p>一般项目都会有严格的认证和授权操作，在 Java 开发领域常见安全框架有<code>Shiro</code>和<code>Spring Security</code></p><ul><li><p><code>Shiro</code>是个轻级的安全管理框架，提供了认证、授权、会话管理、密码管理、缓存管理等功能</p></li><li><p><code>Spring Security</code>是个相对复杂的安全管理框架，功能比<code>Shiro</code>更加强大，权限控制细粒度更高，对 <code>OAuth</code>支持 更友好，又因为<code>Spring Security</code>源自<code>Spring</code>家族，因此可以和<code>Spring</code>框架无缝整合，特别是<code>Spring Boot</code>中提供的自动化配 方案，可以让<code>Spring Security</code>的使用更加便捷</p></li></ul><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/1.jpg" alt></p><p>(图源：<a href="http://www.liuhaihua.cn/archives/546461.html">学习springBoot（11）shiro安全框架 | Harries Blog™</a>)</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>验证用户身份</li><li>用户访问权限控制，比如：1、判断用户是否分配了一定的安全角色。2、判断用户是否被授予完成某个操作的权限</li><li>在非 <code>Web</code> 或 <code>EJB</code>容器的环境下可以任意使用 <code>Session API</code></li><li>可以响应认证、访问控制，或者 <code>Session</code> 生命周期中发生的事件</li><li>可将一个或以上用户安全数据源数据组合成一个复合的用户 <code>view</code>(视图)</li><li>支持单点登录(<code>SSO</code>)功能</li><li>支持提供<code>Remember Me</code>服务，获取用户关联信息而无需登录<br>…</li></ul><p>下图是Shiro的功能模块：</p><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/2.png" alt></p><p>(图源：<a href="https://shiro.apache.org/introduction.html">Apache Shiro | Simple. Java. Security.</a>)</p><ul><li><p><code>Authentication</code>：<strong>认证</strong>，有时也简称为“登录”，这是一个证明用户是他们所说的他们是谁的行为</p></li><li><p><code>Authorization</code>：<strong>授权</strong>，访问控制的过程，例如“用户是否允许编辑帐户”，“该用户是否允许查看此网页”，“该用户是否可以访问”到这个按钮？“这些都是决定用户有权访问的决定，因此都代表授权检查</p></li><li><code>Cryptography</code>：密码术是通过隐藏信息或将其转换为无意义的信息来保护源信息免受不良访问的做法，因此没有其他人可以阅读它。<code>Shiro</code>专注于密码学的两个核心要素：使用公钥或私钥加密数据的密码，以及对密码等数据进行不可逆转加密的哈希（也称为消息摘要）</li><li><code>Session Management</code>：<code>Session</code>会话，会话是您的用户在使用您的应用程序时携带一段时间的数据桶。传统上，会话专用于<code>Web</code>或<code>EJB</code>环境。Shiro支持任何应用程序环境的会话（即使在非<code>Web</code>或<code>EJB</code>应用程序中，也可以管理特定于用户的会话）。此外，Shiro还提供许多其他强大功能来帮助您管理会话</li><li><code>Web Support</code>：<code>Shiro</code>的<code>web</code>支持的<code>API</code>能够轻松地帮助保护 <code>Web</code> 应用程序。主要就是用来对<code>Web</code>程序进行一个好的支持的</li><li><code>Caching</code>：确保安全操作快速而又高效</li><li><code>Concurrency</code>：利用它的并发特性来支持多线程应用程序</li><li><code>Testing</code>：测试支持的存在来帮助你编写单元测试和集成测试，并确保你的能够如预期的一样安全</li><li><code>&quot;Run As&quot;</code>：其实这个就是有是有允许一个用户假设为另外一个用户身份的功能，有时候在管理脚本的时候很有效果</li><li><code>Remember Me</code>：在会话中记住用户的身份</li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><p>三大核心组件，<code>Subject</code>、<code>SecurityManager</code>和<code>Realms</code>。</p><ul><li><p><code>Subject</code>：即“当前操作用户”。但是，在<code>Shiro</code>中，<code>Subject</code>这一概念并不仅仅指人，也可以是第三方进程、后台帐户(<code>Daemon Account</code>)或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是<code>Shiro</code>的“用户”概念。Subject代表了当前用户的安全操作，<code>SecurityManager</code>则管理所有用户的安全操作。</p></li><li><p><code>SecurityManager</code>：它是<code>Shiro</code>框架的核心，典型的<code>Facade</code>模式，<code>Shiro</code>通过<code>SecurityManager</code>来管理内部组件实例，并通过它来提供安全管理的各种服务。可以理解成控制中心，所有请求最终基本上都通过它来代理转发，一般我们程序中不需要直接跟他打交道。</p><blockquote><p>外观模式(<code>Facade Pattern</code>)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式又称为门面模式，它是一种对象结构型模式。</p></blockquote></li><li><p><code>Realm</code>： <code>Realm</code>充当了<code>Shiro</code>与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，<code>Shiro</code>会从应用配置的<code>Realm</code>中查找用户及其权限信息。从这个意义上讲，<code>Realm</code>实质上是一个安全相关的<code>DAO</code>：<strong>它封装了数据源的连接细节，并在需要时将相关数据提供给<code>Shiro</code></strong>。当配置<code>Shiro</code>时，你必须至少指定一个<code>Realm</code>，用于认证和或授权。<em>配置多个<code>Realm</code>是可以的，但是至少需要一个</em>。 </p></li></ul><h2 id="认证与授权处理过程"><a href="#认证与授权处理过程" class="headerlink" title="认证与授权处理过程"></a>认证与授权处理过程</h2><ol><li>被<code>Shiro</code>保护的资源，才会经过认证与授权过程</li><li>用户访问受<code>Shiro</code>保护的<code>URL</code></li><li><code>Shiro</code> <strong>首先检查用户是否已经通过认证，如果未通过认证检查，则跳转到登录页面，否则进行授权检查</strong>。<strong>认证过程需要通过 <code>Realm</code> 来获取用户及密码信息，通常情况我们实现 <code>JDBC Realm</code>，此时用户认证所需要的信息从数据库获取</strong>。如果使用了缓存，除第一次外用户信息从缓存获取。</li><li><strong>认证通过后接受<code>Shiro</code>授权检查，授权检查同样需要通过<code>Realm</code>获取用户权限信息</strong>。<code>Shiro</code> 需要的用户权限信息包括<code>Role</code>或<code>Permission</code>，可以是其中任何一种或同时两者，具体取决于受保护资源的配置。如果用户权限信息未包含<code>Shiro</code>需要的<code>Role</code>或<code>Permission</code>，授权不通过。<strong>只有授权通过，才可以访问受保护<code>URL</code>对应的资源，否则跳转到“未经授权页面”。</strong></li></ol><p><img src="/2019/09/02/SpringBoot+Shiro+Jwt%E5%A1%AB%E5%9D%91-1/5.png" alt></p><p>(图源：<a href="https://whetherlove.github.io/2018/11/30/Shiro%E7%AE%80%E4%BB%8B/">Shiro简介 · 疯狂的小鸡</a>)</p><h2 id="Shiro的Filter链"><a href="#Shiro的Filter链" class="headerlink" title="Shiro的Filter链"></a>Shiro的Filter链</h2><p><code>Shiro</code>的认证和授权都离不开<code>Filter</code>，因此需要对<code>Shiro</code>的<code>Filter</code>的运行流程很清楚，才能自定义<code>Filter</code>来满足企业的实际需要。另外<code>Shiro</code>的<code>Filter</code>虽然原理都和<code>Servlet</code>的<code>Filter</code>相似，甚至都最终继承相同的接口，但是实际还是有些差别。<code>Shiro</code>中的<code>Filter</code>主要是在<code>ShiroFilter</code>内，对指定匹配的<code>URL</code>进行拦截处理，它有自己的<code>Filter</code>链；而<code>Servlet</code>的<code>Filter</code>和<code>ShiroFilter</code>是同一个级别的，即先走<code>Shiro</code>自己的<code>Filter</code>体系，然后才会委托给<code>Servlet</code>容器的<code>FilterChain</code>进行<code>Servlet</code>容器级别的<code>Filter</code>链执行</p><h1 id="与SpringBoot集成-没有jwt"><a href="#与SpringBoot集成-没有jwt" class="headerlink" title="与SpringBoot集成(没有jwt)"></a>与SpringBoot集成(没有jwt)</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="shiro-spring"><a href="#shiro-spring" class="headerlink" title="shiro-spring"></a>shiro-spring</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring-boot-starter-web"><a href="#spring-boot-starter-web" class="headerlink" title="spring-boot-starter-web"></a>spring-boot-starter-web</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他自己需要的依赖可以自行补全</p><h2 id="RBAC思想建表"><a href="#RBAC思想建表" class="headerlink" title="RBAC思想建表"></a>RBAC思想建表</h2><p>这里使用<code>Spring Data JPA</code>来处理持久层</p><p>按照<code>RBAC</code>思想，最简单的得有用户信息，角色信息，权限信息</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//帐号</span></span><br><span class="line">    <span class="meta">@Column(unique =true)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//名称（昵称或者真实姓名，不同系统不同定义）</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//密码;</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加密密码的盐</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用户状态,0:创建未认证（比如没有激活，没有输入验证码等等）--等待验证的用户</span></span><br><span class="line">    <span class="comment">//1:正常状态,2：用户被锁定.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多对多配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//立即从数据库中进行加载数据;</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch = FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name = &quot;SysUserRole&quot;, joinColumns = &#123; @JoinColumn(name = &quot;uid&quot;) &#125;, inverseJoinColumns =&#123;@JoinColumn(name = &quot;roleId&quot;) &#125;)</span></span><br><span class="line">    <span class="comment">// 一个用户具有多个角色</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysRole&gt; roleList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 get set 方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="角色信息"><a href="#角色信息" class="headerlink" title="角色信息"></a>角色信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysRole</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> Integer id; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 角色标识程序中判断使用,如&quot;admin&quot;,这个是唯一的:</span></span><br><span class="line">    <span class="keyword">private</span> String role; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 角色描述,UI界面显示使用</span></span><br><span class="line">    <span class="keyword">private</span> String description;   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否可用,如果不可用将不会添加给用户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">available</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//角色 -- 权限关系：多对多关系;</span></span><br><span class="line">    <span class="meta">@ManyToMany(fetch= FetchType.EAGER)</span></span><br><span class="line">    <span class="meta">@JoinTable(name=&quot;SysRolePermission&quot;,joinColumns=&#123;@JoinColumn(name=&quot;roleId&quot;)&#125;,inverseJoinColumns=&#123;@JoinColumn(name=&quot;permissionId&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysPermission&gt; permissions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户 - 角色关系定义;</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name=&quot;SysUserRole&quot;,joinColumns=&#123;@JoinColumn(name=&quot;roleId&quot;)&#125;,inverseJoinColumns=&#123;@JoinColumn(name=&quot;uid&quot;)&#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个角色对应多个用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserInfo&gt; userInfos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 get set 方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="权限信息"><a href="#权限信息" class="headerlink" title="权限信息"></a>权限信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysPermission</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnDefinition=&quot;enum(&#x27;menu&#x27;,&#x27;button&#x27;)&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//资源类型，[menu|button]</span></span><br><span class="line">    <span class="keyword">private</span> String resourceType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//资源路径</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//权限字符串,menu例子：role:*，button例子：role:create,role:update,role:delete,role:view</span></span><br><span class="line">    <span class="keyword">private</span> String permission; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父编号</span></span><br><span class="line">    <span class="keyword">private</span> Long parentId; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//父编号列表</span></span><br><span class="line">    <span class="keyword">private</span> String parentIds; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boolean</span> <span class="variable">available</span> <span class="operator">=</span> Boolean.FALSE;</span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable(name=&quot;SysRolePermission&quot;,joinColumns=&#123;@JoinColumn(name=&quot;permissionId&quot;)&#125;,inverseJoinColumns=&#123;@JoinColumn(name=&quot;roleId&quot;)&#125;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;SysRole&gt; roles;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 get set 方法</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>根据以上的代码会自动生成 <code>user_info</code>（用户信息表）、<code>sys_role</code>（角色表）、<code>sys_permission</code>（权限表）、<code>sys_user_role</code>（用户角色表）、<code>sys_role_permission</code>（角色权限表）这五张表</p><p>测试数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `user_info` (`uid`,`username`,`name`,`password`,`salt`,`state`) VALUES (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>, <span class="string">&#x27;d3c59d25033dbf980d29554025c23a75&#x27;</span>, <span class="string">&#x27;8d78869f470951332959580424d4bf4f&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">INSERT INTO `sys_permission` (`id`,`available`,`name`,`parent_id`,`parent_ids`,`permission`,`resource_type`,`url`) VALUES (<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;用户管理&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;0/&#x27;</span>,<span class="string">&#x27;userInfo:view&#x27;</span>,<span class="string">&#x27;menu&#x27;</span>,<span class="string">&#x27;userInfo/userList&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_permission` (`id`,`available`,`name`,`parent_id`,`parent_ids`,`permission`,`resource_type`,`url`) VALUES (<span class="number">2</span>,<span class="number">0</span>,<span class="string">&#x27;用户添加&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;0/1&#x27;</span>,<span class="string">&#x27;userInfo:add&#x27;</span>,<span class="string">&#x27;button&#x27;</span>,<span class="string">&#x27;userInfo/userAdd&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_permission` (`id`,`available`,`name`,`parent_id`,`parent_ids`,`permission`,`resource_type`,`url`) VALUES (<span class="number">3</span>,<span class="number">0</span>,<span class="string">&#x27;用户删除&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;0/1&#x27;</span>,<span class="string">&#x27;userInfo:del&#x27;</span>,<span class="string">&#x27;button&#x27;</span>,<span class="string">&#x27;userInfo/userDel&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_role` (`id`,`available`,`description`,`role`) VALUES (<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_role` (`id`,`available`,`description`,`role`) VALUES (<span class="number">2</span>,<span class="number">0</span>,<span class="string">&#x27;VIP会员&#x27;</span>,<span class="string">&#x27;vip&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_role` (`id`,`available`,`description`,`role`) VALUES (<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_role_permission` VALUES (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">INSERT INTO `sys_role_permission` (`permission_id`,`role_id`) VALUES (<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">INSERT INTO `sys_role_permission` (`permission_id`,`role_id`) VALUES (<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">INSERT INTO `sys_role_permission` (`permission_id`,`role_id`) VALUES (<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">INSERT INTO `sys_user_role` (`role_id`,`uid`) VALUES (<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Shiro配置"><a href="#Shiro配置" class="headerlink" title="Shiro配置"></a>Shiro配置</h2><h3 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h3><p>首先要配置的是 <code>ShiroConfig</code> 类，<code>Apache Shiro</code> 核心通过 <code>Filter</code>来实现，就好像 <code>SpringMvc</code> 通过 <code>DispachServlet</code> 来主控制一样。<br><strong>既然是使用 <code>Filter</code> 一般也就能猜到，是通过 <code>URL</code> 规则来进行过滤和权限校验，所以我们需要定义一系列关于 <code>URL</code> 的规则和访问权限。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">shirFilter</span><span class="params">(SecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="comment">//用于定义主Shiro Filter</span></span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">shiroFilterFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置要构造的Shiro Filter使用的SecurityManager实例</span></span><br><span class="line">        <span class="comment">//这是必填属性-设置失败将引发初始化异常</span></span><br><span class="line">        shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拦截器</span></span><br><span class="line">        <span class="comment">//LinkedHashMap是有序的</span></span><br><span class="line">        Map&lt;String,String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">// 配置不会被拦截的链接</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/static/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/logout&quot;</span>, <span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//过滤链定义，从上向下顺序执行，一般将/**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了;</span></span><br><span class="line">        <span class="comment">//authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果不设置默认会自动寻找Web工程根目录下的&quot;/login&quot;页面</span></span><br><span class="line">        shiroFilterFactoryBean.setLoginUrl(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">        <span class="comment">// 登录成功后要跳转的链接</span></span><br><span class="line">        shiroFilterFactoryBean.setSuccessUrl(<span class="string">&quot;/index&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//未授权界面;</span></span><br><span class="line">        shiroFilterFactoryBean.setUnauthorizedUrl(<span class="string">&quot;/403&quot;</span>);</span><br><span class="line">        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义MyShiroRealm类</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyShiroRealm <span class="title function_">myShiroRealm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyShiroRealm</span> <span class="variable">myShiroRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyShiroRealm</span>();</span><br><span class="line">        <span class="keyword">return</span> myShiroRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">securityManager</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        securityManager.setRealm(myShiroRealm());</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Filter Chain</code> 定义说明：</p><ul><li>一个<code>URL</code>可以配置多个 <code>Filter</code>，使用逗号分隔</li><li>当设置多个过滤器时，全部验证通过，才视为通过</li><li>部分过滤器可指定参数，如 <code>perms</code>，<code>roles</code></li></ul><h3 id="登录认证实现"><a href="#登录认证实现" class="headerlink" title="登录认证实现"></a>登录认证实现</h3><p>在认证、授权内部实现机制中都有提到，最终处理都将交给<code>Real</code>进行处理。因为在 <code>Shiro</code> 中，<strong>最终是通过 <code>Realm</code>来获取应用程序中的用户、角色及权限信息的</strong>。通常情况下，在 <code>Realm</code> 中会直接从我们的数据源中获取 <code>Shiro</code> 需要的验证信息。可以说，<code>Realm</code> 是专用于安全框架的 <code>DAO</code>.<br><code>Shiro</code> 的认证过程最终会交由 <code>Realm</code> 执行，这时会调用 <code>Realm</code> 的<code>getAuthenticationInfo(token)</code>方法。</p><p>该方法主要执行以下操作:</p><ol><li><p>检查提交的进行认证的令牌信息</p></li><li><p>根据令牌信息从数据源(通常为数据库)中获取用户信息</p></li><li><p>对用户信息进行匹配验证。</p></li><li><p>验证通过将返回一个封装了用户信息的<code>AuthenticationInfo</code>实例。</p></li><li><p>验证失败则抛出<code>AuthenticationException</code>异常信息。</p></li></ol><p><strong>而在我们的应用程序中要做的就是自定义一个 <code>Realm</code> 类，继承<code>AuthorizingRealm</code> 抽象类，重写<code>doGetAuthenticationInfo()</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *主要是用来进行身份认证的，也就是说验证用户输入的账号和密码是否正确</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span></span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取用户的输入的账号.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)token.getPrincipal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过username从数据库中查找 User对象，如果找到，没找到.</span></span><br><span class="line">    <span class="comment">//实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法</span></span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span> <span class="operator">=</span> userInfoService.findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(userInfo == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SimpleAuthenticationInfo</span> <span class="variable">authenticationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(</span><br><span class="line">            userInfo, <span class="comment">//用户名</span></span><br><span class="line">            userInfo.getPassword(), <span class="comment">//密码</span></span><br><span class="line">            ByteSource.Util.bytes(userInfo.getCredentialsSalt()),<span class="comment">//salt=username+salt</span></span><br><span class="line">            getName()  <span class="comment">//realm name</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链接权限的实现"><a href="#链接权限的实现" class="headerlink" title="链接权限的实现"></a>链接权限的实现</h3><p><code>Shiro</code>的权限授权是通过继承<code>AuthorizingRealm</code>抽象类，重载<code>doGetAuthorizationInfo()</code>；<strong>当访问到页面的时候，链接配置了相应的权限或者 <code>Shiro</code> 标签才会执行此方法否则不会执行，所以如果只是简单的身份认证没有权限的控制的话，那么这个方法可以不进行实现，直接返回 <code>null</code> 即可</strong>。在这个方法中主要是使用类<code>SimpleAuthorizationInfo</code>进行角色的添加和权限的添加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SimpleAuthorizationInfo</span> <span class="variable">authorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">    <span class="type">UserInfo</span> <span class="variable">userInfo</span>  <span class="operator">=</span> (UserInfo)principals.getPrimaryPrincipal();</span><br><span class="line">    <span class="keyword">for</span>(SysRole role:userInfo.getRoleList())&#123;</span><br><span class="line">        authorizationInfo.addRole(role.getRole());</span><br><span class="line">        <span class="keyword">for</span>(SysPermission p:role.getPermissions())&#123;</span><br><span class="line">            authorizationInfo.addStringPermission(p.getPermission());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以添加 <code>set</code> 集合：<code>roles</code> 是从数据库查询的当前用户的角色，<code>stringPermissions</code> 是从数据库查询的当前用户对应的权限</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authorizationInfo.setRoles(roles);</span><br><span class="line">authorizationInfo.setStringPermissions(stringPermissions);</span><br></pre></td></tr></table></figure><p>如果在<code>shiro</code>配置文件中添加了<code>filterChainDefinitionMap.put(“/add”, “perms[权限添加]”);</code>就说明访问<code>/add</code>这个链接必须要有“权限添加”这个权限才可以访问；</p><p>如果在<code>shiro</code>配置文件中添加了<code>filterChainDefinitionMap.put(“/add”, “roles[100002]，perms[权限添加]”);</code>就说明访问<code>/add</code>这个链接必须要有“权限添加”这个权限和具有“<code>100002</code>”这个角色才可以访问</p><h3 id="登录实现"><a href="#登录实现" class="headerlink" title="登录实现"></a>登录实现</h3><p>登录过程其实只是处理异常的相关信息，具体的登录验证交给 Shiro 来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpServletRequest request, Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录失败从request中获取shiro处理的异常信息。</span></span><br><span class="line">    <span class="comment">// shiroLoginFailure:就是shiro异常类的全类名.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exception</span> <span class="operator">=</span> (String) request.getAttribute(<span class="string">&quot;shiroLoginFailure&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;exception=&quot;</span> + exception);</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UnknownAccountException.class.getName().equals(exception)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;UnknownAccountException -- &gt; 账号不存在：&quot;</span>);</span><br><span class="line">            msg = <span class="string">&quot;UnknownAccountException -- &gt; 账号不存在：&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IncorrectCredentialsException.class.getName().equals(exception)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IncorrectCredentialsException -- &gt; 密码不正确：&quot;</span>);</span><br><span class="line">            msg = <span class="string">&quot;IncorrectCredentialsException -- &gt; 密码不正确：&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;kaptchaValidateFailed&quot;</span>.equals(exception)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;kaptchaValidateFailed -- &gt; 验证码错误&quot;</span>);</span><br><span class="line">            msg = <span class="string">&quot;kaptchaValidateFailed -- &gt; 验证码错误&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg = <span class="string">&quot;else &gt;&gt; &quot;</span>+exception;</span><br><span class="line">            System.out.println(<span class="string">&quot;else -- &gt;&quot;</span> + exception);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(<span class="string">&quot;msg&quot;</span>, msg);</span><br><span class="line">    <span class="comment">// 此方法不处理登录成功,由shiro进行处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考:</p><p><a href="http://www.justdojava.com/2019/04/12/java-Shiro/">Shiro框架详解 | Just Do Java</a></p><p><a href="http://www.liuhaihua.cn/archives/546461.html">学习springBoot（11）shiro安全框架 | Harries Blog™</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-shiro/">在 Web 项目中应用 Apache Shiro</a></p><p><a href="https://baike.baidu.com/item/RBAC/1328788">RBAC_百度百科</a></p><p><a href="https://www.cnblogs.com/ityouknow/p/7089177.html">Spring Boot (十四)： Spring Boot 整合 Shiro-登录认证和权限管理 - 纯洁的微笑 - 博客园</a></p><p><a href="https://www.javazhiyin.com/42283.html">Shrio使用Jwt达到前后端分离-Java知音</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Shiro </tag>
            
            <tag> jwt </tag>
            
            <tag> RBAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-单例模式</title>
      <link href="/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>对于系统中的某些类来说，只有一个实例很重要</p><span id="more"></span><h1 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h1><p><strong>对于系统中的某些类来说，只有一个实例很重要</strong>，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><hr><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？</p><p>定义一个全局变量可以确保对象随时都可以被访问，但<strong>不能防止我们实例化多个对象</strong></p><p>一个更好的解决办法是<strong>让类自身负责保存它的唯一实例</strong>。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h1 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h1><p>单例模式确保某一个类只有一个实例，而且<strong>自行实例化并向整个系统提供这个实例</strong>，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul><li>某个类只能有一个实例</li><li>它必须自行创建这个实例</li><li>它必须自行向整个系统提供这个实例</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.png" alt></p><p>(图源：<a href="http://www.jtahstu.com/blog/Singleton.html">设计模式从入门到放弃 - 单例模式 - jtahstu的博客</a>)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——<code>Singleton</code></p><p>单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。</p><p>除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，<strong>该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>在单例模式的实现过程中，需要注意如下三点：</p><ul><li>单例类的构造函数为私有；</li><li>提供一个自身的静态私有成员变量；</li><li>提供一个公有的静态工厂方法。</li></ul><p><strong>通常单例模式在Java语言中，有两种构建方式：</strong></p><ul><li>懒汉方式。指全局的单例实例在第一次被使用时构建。</li><li>饿汉方式。指全局的单例实例在类装载时构建。</li></ul><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><blockquote><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易<br>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 <code>synchronized</code>，所以严格意义上它并不算单例模式。<br>这种方式 <code>lazy loading</code> 很明显，不要求线程安全，在多线程不能正常工作。</p></blockquote><p><em>延迟初始化(<code>lazy initialization</code>)，也就是在真正被使用的时候才开始初始化的技巧。主要用于提高性能，避免浪费计算，并减少程序内存要求。(延迟初始化=延迟实例化)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态私有成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态公有工厂方法，返回唯一实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><blockquote><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式具备很好的 <code>lazy loading</code>，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 <code>synchronized</code> 才能保证单例，但加锁会影响效率。<br><code>getInstance()</code> 的性能对应用程序不是很关键（该方法使用不太频繁）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><blockquote><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于<code>classloder</code>机制避免了多线程的同步问题，不过，<code>instance</code>在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用<code>getInstance</code>方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化<code>instance</code>显然没有达到<code>lazy loading</code>的效果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双检锁-双检查锁（DCL，即-double-checked-locking）"><a href="#双检锁-双检查锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双检查锁（DCL，即 double-checked locking）"></a>双检锁/双检查锁（DCL，即 double-checked locking）</h2><blockquote><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂<br>描述：这种方式称为双重检查锁(Double-Check Locking)，需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量<code>instance</code>之前增加<strong>修饰符volatile</strong>，被<code>volatile</code>修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于<code>volatile</code>关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p></blockquote><p><img src="/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/2.png" alt></p><p>(图源：<a href="[https://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F#Java%E4%B8%AD%E7%9A%84volatile](https://zh.wikipedia.org/wiki/Volatile变量#Java中的volatile">Volatile变量 - Wikipedia</a>))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般<br>描述：饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。可见，无论是饿汉式单例还是懒汉式单例都存在这样那样的问题，有没有一种方法，能够将两种单例的缺点都克服，而将两者的优点合二为一呢？答案是：Yes！下面我们来学习这种更好的被称之为<strong>Initialization Demand Holder (IoDH)</strong>的技术。在<code>IoDH</code>中，我们在单例类中增加一个<strong>静态(static)内部类</strong>，在该内部类中创建单例对象，再将该单例对象通过<code>getInstance()</code>方法返回给外部使用。由于静态单例对象没有作为<code>Singleton</code>的成员变量直接实例化，因此类加载时不会实例化<code>Singleton</code>，第一次调用<code>getInstance()</code>时将加载内部类<code>SingletonHolder</code>，在该内部类中定义了一个<code>static</code>类型的变量<code>instance</code>，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于<code>getInstance()</code>方法没有任何线程锁定，因此其性能不会造成任何影响。<strong>通过使用<code>IoDH</code>，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式</strong>（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持<code>IoDH</code>）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.designpattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><blockquote><p>JDK 版本：JDK1.5 起</p><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是<code>Effective Java</code>作者<code>Josh Bloch</code>提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过<code>reflection attack</code>来调用私有构造方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whateverMethod</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例与懒汉式单例类比较"><a href="#饿汉式单例与懒汉式单例类比较" class="headerlink" title="饿汉式单例与懒汉式单例类比较"></a>饿汉式单例与懒汉式单例类比较</h2><ul><li>饿汉式单例类在自己被加载时就将自己实例化。单从<strong>资源利用效率角度来讲，这个比懒汉式单例类稍差些。从速度和反应时间角度来讲，则比懒汉式单例类稍好些</strong>。</li><li>懒汉式单例类在实例化时，必须<strong>处理好在多个线程同时首次引用此类时的访问限制问题</strong>，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过同步化机制进行控制</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现<code>lazy loading</code>效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="身份证号码"><a href="#身份证号码" class="headerlink" title="身份证号码"></a>身份证号码</h2><p>在现实生活中，居民身份证号码具有唯一性，同一个人不允许有多个身份证号码，第一次申请身份证时将给居民分配一个身份证号码，如果之后因为遗失等原因补办时，还是使用原来的身份证号码，不会产生新的号码。现使用单例模式模拟该场景</p><p><img src="/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/3.png" alt></p><p>(图源：<a href="https://blog.csdn.net/leehsiao/article/details/48297911">设计模式之单例模式 - leehsiao的专栏 - CSDN博客</a>）</p><h2 id="打印池"><a href="#打印池" class="headerlink" title="打印池"></a>打印池</h2><p>在操作系统中，打印池(<code>Print Spooler</code>)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计</p><p><img src="/2019/08/28/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/4.png" alt></p><p>(图源：<a href="https://blog.csdn.net/leehsiao/article/details/48297911">设计模式之单例模式 - leehsiao的专栏 - CSDN博客</a>）</p><h2 id="java-lang-Runtime"><a href="#java-lang-Runtime" class="headerlink" title="java.lang.Runtime"></a>java.lang.Runtime</h2><p><code>Runtime</code>类封装了Java运行时的环境。<strong>每一个java程序实际上都是启动了一个JVM进程，那么每个JVM进程都是对应这一个Runtime实例，此实例是由JVM为其实例化的。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接</strong>。</p><p>由于Java是单进程的，所以，在一个JVM中，Runtime的实例应该只有一个。所以应该使用单例来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码为JDK中<code>Runtime</code>类的部分实现，可以看到，这其实是饿汉式单例模式。在该类第一次被<code>classloader</code>加载的时候，这个实例就被创建出来了。</p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>提供了对唯一实例的受控访问</strong>。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此<strong>可以节约系统资源</strong>，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li><strong>允许可变数目的实例</strong>。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>由于单例模式中没有抽象层，因此<strong>单例类的扩展有很大的困难</strong>。</li><li><strong>单例类的职责过重</strong>，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li><strong>滥用单例将带来一些负面问题</strong>，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h1 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h1><p>在以下情况下可以使用单例模式：</p><ul><li><strong>系统只需要一个实例对象</strong>，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例<strong>只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例。</li><li><strong>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</strong>。</li></ul><hr><p>参考：</p><p><a href="http://tengj.top/2016/04/06/sjms4singleton/">设计模式干货系列：（四）单例模式【学习难度：★☆☆☆☆，使用频率：★★★★☆】 | 嘟嘟独立博客</a></p><p><a href="[https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F](https://zh.wikipedia.org/wiki/单例模式">单例模式 - 维基百科，自由的百科全书</a>)</p><p><a href="https://www.hollischuang.com/archives/1383">设计模式（三）——JDK中的那些单例-HollisChuang’s Blog</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性之Lambda表达式的基本语法</title>
      <link href="/2019/08/28/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/08/28/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>个人感觉Lambda用于内部类即可，其他地方可能还会造成效率低下，难于debug</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>官方文档:<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda Expressions (The Java™ Tutorials &gt; Learning the Java Language &gt; Classes and Objects)</a></p><hr><p><code>Lambda</code>表达式，也可称为闭包，它是推动 <code>Java8</code> 发布的最重要新特性。</p><p><code>Lambda</code> 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p><p>使用 <code>Lambda</code> 表达式可以使代码变的更加简洁紧凑</p><h1 id="表达式格式"><a href="#表达式格式" class="headerlink" title="表达式格式"></a>表达式格式</h1><p>在<code>Java8</code>语言中引入的一种新的语言元素和操作符，这个操作符为<code>-&gt;</code>，该操作符被称为<code>Lambda</code>操作符或箭头操作符,它将<code>Lambda</code>分为以下两个部分</p><ol><li>左侧 : 指定<code>Lambda</code>表达式需要的参数列表</li><li>右侧 : 制定了<code>Lambda</code>体,是抽象方法的实现逻辑，也既<code>Lambda</code>表达式要执行的功能</li></ol><p>表达式的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p>本质：作为接口的实例</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>可选类型声明 : 不需要声明参数类型,编译器可以统一识别参数值</li><li>可选的参数圆括号 : <strong>一个参数无需定义圆括号,但多个参数需要定义圆括号</strong></li><li>可选的大括号 : 如果主体包含了一个语句,就不需要使用大括号</li><li>可选的返回关键字 : <strong>如果主体只有一个表达式返回值则编译器会自动返回值,大括号需要指定明表达式返回了一个数值</strong></li></ul><h1 id="用于内部类的语法"><a href="#用于内部类的语法" class="headerlink" title="用于内部类的语法"></a>用于内部类的语法</h1><h2 id="无参-无返回值"><a href="#无参-无返回值" class="headerlink" title="无参,无返回值"></a>无参,无返回值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">r1.run();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Test1&quot;</span>);</span><br><span class="line">r2.run();</span><br></pre></td></tr></table></figure><h2 id="需要一个参数-但是没有返回值"><a href="#需要一个参数-但是没有返回值" class="headerlink" title="需要一个参数,但是没有返回值"></a>需要一个参数,但是没有返回值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c1.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c2 = (String s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c2.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="数据类型可以省略"><a href="#数据类型可以省略" class="headerlink" title="数据类型可以省略"></a>数据类型可以省略</h2><p>数据类型可以省略，因为可由编译器推断得出,称为”类型推断”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c1.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c2 = (s) -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c2.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><p>其他”类型推断”例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int[] arr = new int[]&#123;1,2,3&#125;;</span></span><br><span class="line"><span class="type">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="若需要一个参数时-参数的小括号可以省略"><a href="#若需要一个参数时-参数的小括号可以省略" class="headerlink" title="若需要一个参数时,参数的小括号可以省略"></a>若需要一个参数时,参数的小括号可以省略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c1.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; c2 = s -&gt; &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">c2.accept(<span class="string">&quot;Test2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="需要两个或以上的参数-多条执行语句-并且可以有返回值"><a href="#需要两个或以上的参数-多条执行语句-并且可以有返回值" class="headerlink" title="需要两个或以上的参数,多条执行语句,并且可以有返回值"></a>需要两个或以上的参数,多条执行语句,并且可以有返回值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt;&#123;</span><br><span class="line">    System.out.println(o1);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Lambda体只有一条语句时-return与大括号若有-都可以省略"><a href="#Lambda体只有一条语句时-return与大括号若有-都可以省略" class="headerlink" title="Lambda体只有一条语句时,return与大括号若有,都可以省略"></a>Lambda体只有一条语句时,return与大括号若有,都可以省略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer x, Integer y)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">System.out.println(comparator.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">System.out.println(comparator.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = Integer::compare;</span><br></pre></td></tr></table></figure><p>双冒号运算就是<code>Java</code>中的[方法引用],[方法引用]的格式是 <strong>类名::方法名</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用实例person的getName方法</span></span><br><span class="line">person -&gt; person.getName();</span><br><span class="line"></span><br><span class="line">Person::getName</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">HashMap::<span class="keyword">new</span></span><br></pre></td></tr></table></figure><hr><p>参考:</p><p><a href="https://www.runoob.com/java/java8-lambda-expressions.html">Java 8 Lambda 表达式 | 菜鸟教程</a></p><p><a href="https://github.com/YUbuntu0109/YUbuntu0109.github.io/blob/HexoBackup/source/_posts/JDK-8新特性之Lambda表达式的基本语法.md">JDK-8新特性之Lambda表达式的基本语法.md</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> Jdk8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized保证线程安全</title>
      <link href="/2019/08/26/synchronized%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2019/08/26/synchronized%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>synchronized笔记</p><span id="more"></span><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="主要诱因"><a href="#主要诱因" class="headerlink" title="主要诱因"></a>主要诱因</h2><ul><li>存在共享数据(也称临界资源)</li><li>存在多条线程共同操作共享数据</li></ul><h2 id="解决问题根本"><a href="#解决问题根本" class="headerlink" title="解决问题根本"></a>解决问题根本</h2><p><strong>同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</strong>。所以可以引入互斥锁去解决问题</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul><li><p>互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，<strong>这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问</strong>。互斥性也称为操作的原子性。</p></li><li><p>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即<strong>在获得锁时应获得最新共享变量的值</strong>），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。</p></li></ul><hr><p>在 Java 中，关键字<code>synchronized</code>可以保证<strong>在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到<code>synchronized</code>另外一个重要的作用，<code>synchronized</code>可<strong>保证一个线程的变化(主要是共享数据的变化)被其他线程所看到</strong>（保证可见性，完全可以替代<code>Volatile</code>功能），这点确实也是很重要的</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Java语言的关键字，可用来给<strong>对象</strong>和<strong>方法或者代码块</strong>加锁（<strong>注意，这里加锁是说可以用在对象或代码块上面，但是<code>synchronized</code>锁的是对象，不是代码，重要！！！</strong>），当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。</p><p>当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，<strong>当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块</strong>。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>根据获取的锁的分类：获取对象锁和类锁</p><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>获取对象锁的两种用法：</p><ol><li>同步代码块（<code>synchronized(this)</code>，<code>synchronized(类实例对象)</code>），<strong>锁是小括号()中的实例对象</strong>。</li><li>同步非静态方法（<code>synchronized method</code>），<strong>锁是当前对象的实例对象</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对某个对象加锁</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized_01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//obj指向堆内存种new出来的对象</span></span><br><span class="line">    <span class="comment">//而synchronized锁的在堆内存中new出来的对象，而不是obj的引用</span></span><br><span class="line">    <span class="comment">//如果obj指向别的对象，那么锁的对象就变了</span></span><br><span class="line">    <span class="comment">//也就是说申请锁的时候，申请锁的信息是记录在堆内存对象里面的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//任何线程想要执行下面代码，必须先拿到obj的锁</span></span><br><span class="line">        <span class="comment">//也可以写成sychronized(this)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>获取类锁的两种用法：</p><ol><li>同步代码块（<code>synchronized(类.class)</code>），<strong>锁是小括号()中的类对象</strong>(<code>Class</code>对象)。</li><li>同步静态方法（<code>synchronized static method</code>），<strong>锁是当前对象的类对象</strong>(Class对象)。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized_02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里等同于synchronized (Synchronized_02.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里不能写(synchronized)</span></span><br><span class="line">        <span class="comment">//因为静态方法没有new对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Synchronized_02.class)&#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; count = &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步与非同步混用"><a href="#同步与非同步混用" class="headerlink" title="同步与非同步混用"></a>同步与非同步混用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步与非同步混用，出现脏读</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized_03</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String name, <span class="type">double</span> balance)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//放大2个线程的间隔，更加显示错误</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Synchronized_03</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Synchronized_03</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;account.set(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100.0</span>)).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.0</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure><p>只对写加锁，而不对读加锁，可能产生脏读现象，虽然锁了<code>set()</code>，但是<code>getBalance()</code>并没有。所以正确的思路就是对读和写都加锁。</p><h1 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h1><p>一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁，也就是说<code>synchronized</code>获得的锁是可重入的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可重入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Synchronized_04</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        m2();</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2 start&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;m2 end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Synchronized_04</span>().m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m1 start</span><br><span class="line">m2 start</span><br><span class="line">m2 end</span><br><span class="line">m1 end</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://juejin.im/post/5c9f782de51d4534c15b711f">Java并发编程—synchronized保证线程安全的原理分析 - 掘金</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程的状态</title>
      <link href="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>线程的6种状态，sleep与wait的区别，notify与notifyAll的区别，yield，中断线程</p><span id="more"></span><h1 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h1><h2 id="初识6种状态"><a href="#初识6种状态" class="headerlink" title="初识6种状态"></a>初识6种状态</h2><p>由jdk8中的<code>java.lang.Thread.State</code>可知，</p><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/4.png" alt></p><p>线程有6个状态</p><ul><li>NEW<br>尚未启动的线程处于此状态。</li><li>RUNNABLE<br>在Java虚拟机中执行的线程处于此状态。</li><li>BLOCKED<br>被阻塞等待监视器锁定的线程处于此状态。</li><li>WAITING<br>正在等待另一个线程执行特定动作的线程处于此状态。</li><li>TIMED_WAITING<br>正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</li><li>TERMINATED<br>已退出的线程处于此状态。</li></ul><p>一个线程可以在给定时间点处于一个状态。 这些状态是不反映任何操作系统线程状态的虚拟机状态。</p><p><code>Thread.State</code>继承关系：</p><blockquote><p>public static enum Thread.State extends Enum<Thread.State></Thread.State></p><p>java.lang.Object</p><p>​    java.lang.Enum<Thread.State></Thread.State></p><p>​        java.lang.Thread.State</p></blockquote><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/1.png" alt></p><p>(图源：<a href="https://www.cnblogs.com/doit8791/p/9067073.html">Java线程及线程池状态 - 时间朋友 - 博客园</a>)</p><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/2.jpg" alt></p><p>(图源：<a href="http://www.ishenping.com/ArtInfo/1194756.htmll">线程状态 - 神评网</a>)</p><h2 id="6种状态解释"><a href="#6种状态解释" class="headerlink" title="6种状态解释"></a>6种状态解释</h2><h3 id="初始-NEW"><a href="#初始-NEW" class="headerlink" title="初始(NEW)"></a>初始(NEW)</h3><p>新创建了一个线程对象，但还没有调用<code>start()</code>方法。</p><p>实现<code>Runnable</code>接口和继承<code>Thread</code>可以得到一个线程类，<code>new</code>一个实例出来，线程就进入了初始状态。</p><h3 id="运行-RUNNABLE"><a href="#运行-RUNNABLE" class="headerlink" title="运行(RUNNABLE)"></a>运行(RUNNABLE)</h3><p><strong><code>Java</code>线程中将就绪（<code>ready</code>）和运行中（<code>running</code>）两种状态笼统的称为“运行”。</strong></p><ul><li><p>线程对象创建后，其他线程(比如<code>main</code>线程）调用了该对象的<code>start()</code>方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取<code>CPU</code>的使用权，此时处于就绪状态（<code>ready</code>）。就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。除了<code>start()</code>方法让线程进入就绪状态，下面三种情况也可以：</p><ul><li>当前线程<code>sleep()</code>方法结束，其他线程<code>join(</code>)结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的<code>yield()</code>方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul></li><li><p>就绪状态的线程在获得CPU时间片后变为运行中状态（<code>running</code>）。</p></li></ul><h3 id="阻塞-BLOCKED"><a href="#阻塞-BLOCKED" class="headerlink" title="阻塞(BLOCKED)"></a>阻塞(BLOCKED)</h3><p>表示线程阻塞于锁。</p><p>是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块(获取锁)时的状态。</p><h3 id="等待-WAITING"><a href="#等待-WAITING" class="headerlink" title="等待(WAITING)"></a>等待(WAITING)</h3><p>进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p><p>处于这种状态的线程不会被分配<code>CPU</code>执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p><h3 id="超时等待-TIMED-WAITING"><a href="#超时等待-TIMED-WAITING" class="headerlink" title="超时等待(TIMED_WAITING)"></a>超时等待(TIMED_WAITING)</h3><p>该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</p><p><em>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</em></p><h3 id="终止-TERMINATED"><a href="#终止-TERMINATED" class="headerlink" title="终止(TERMINATED)"></a>终止(TERMINATED)</h3><p>表示该线程已经执行完毕。</p><ol><li><p>当线程的<code>run()</code>方法完成时，或者主线程的<code>main()</code>方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</p></li><li><p>在一个终止的线程上调用<code>start()</code>方法，会抛出<code>java.lang.IllegalThreadStateException</code>异常。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-04 10:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fight&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Current Thread is: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                attack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current main thread is: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//结束线程</span></span><br><span class="line">        t.join();</span><br><span class="line">        <span class="comment">//线程不会复活，抛出异常</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Current main thread is: main</span><br><span class="line">Fight</span><br><span class="line">Current Thread is: Thread-<span class="number">0</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalThreadStateException</span><br><span class="line">at java.lang.Thread.start(Thread.java:<span class="number">708</span>)</span><br><span class="line">at thread.demo01.main(demo01.java:<span class="number">24</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/3.jpeg" alt></p><p>(图源：<a href="http://www.ishenping.com/ArtInfo/1194756.htmll">Java线程的6种状态及切换(透彻讲解) - 潘建南的博客 - CSDN博客</a>)</p><h1 id="sleep与wait的区别"><a href="#sleep与wait的区别" class="headerlink" title="sleep与wait的区别"></a>sleep与wait的区别</h1><ul><li><code>jdk8</code>中的<code>sleep</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数</span></span><br><span class="line"><span class="comment"> * 具体取决于系统计时器和调度程序的精度和准确性。</span></span><br><span class="line"><span class="comment"> * 该线程不会失去任何monitor的所有权。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">java.lang.Thread <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><ul><li><code>jdk8</code>中的<code>wait</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>区别：</p><ol><li><p><code>sleep</code>是<code>Thread</code>类的方法,<code>wait</code>是<code>Object</code>类中定义的方法</p></li><li><p><code>sleep</code>可以在任何地方使用； 而<code>wait</code>只能在<code>synchronize</code>方法或者<code>synchronize</code>块中使用</p></li><li><strong><code>Thread.sleep</code>只会让出<code>CPU</code>，不会导致锁行为的改变；<code>Object.wait</code>不仅让出<code>CPU</code>，还会释放已经占有的同步资源锁</strong></li></ol><p>总结起来就是：</p><ul><li><code>sleep</code>方法是<code>Thread</code>类里面的，主要的意义就是让当前线程停止执行，让出<code>CPU</code>给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态。</li><li><code>wait</code>方法是<code>Object</code>类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动<code>notify</code>方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> sleep与wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-05 15:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread A is waiting to get lock&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取同步锁才能执行里面的代码</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread A get lock&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">30</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread A do wait method&quot;</span>);</span><br><span class="line">                        <span class="comment">//等待1s自动被唤醒</span></span><br><span class="line">                        lock.wait(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread A is done&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//第一个线程开启后，sleep 10 ms再开启第二个线程</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread B is waiting to get lock&quot;</span>);</span><br><span class="line">                    <span class="comment">//获取同步锁才能执行里面的代码</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread B get lock&quot;</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread B is sleeping 10 ms&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                        System.out.println(<span class="string">&quot;Thread B is done&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread A is waiting to get lock</span><br><span class="line">Thread A get lock</span><br><span class="line">Thread B is waiting to get lock</span><br><span class="line">Thread A <span class="keyword">do</span> wait method</span><br><span class="line">Thread B get lock</span><br><span class="line">Thread B is sleeping <span class="number">10</span> ms</span><br><span class="line">Thread B is done</span><br><span class="line">Thread A is done</span><br></pre></td></tr></table></figure><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/5.png" alt></p><h1 id="notify与notifyAll的区别"><a href="#notify与notifyAll的区别" class="headerlink" title="notify与notifyAll的区别"></a>notify与notifyAll的区别</h1><p>上面的例子只是在线程1的时候只是<code>lock.wait(1000);</code>，如果我们把它改为<code>lock.wait();</code>那么就会进入无限期状态，需要唤醒才能执行下一步，所以程序就不会停下来，这时候在线程2的<code>synchronized</code>代码块里面的最后一行加一个<code>lock.notify()</code>或者<code>lock.notifyAll()</code>就可以让程序正常终止</p><hr><p>为了了解两者区别，我们需要知道如下概念，锁池(<code>EntryList</code>)和等待池(<code>WaitSet</code>)</p><h2 id="锁池"><a href="#锁池" class="headerlink" title="锁池"></a>锁池</h2><p>如果线程A拥有了某个对象的锁的话，其他线程B、C想调用这个对象的<code>synchronized</code>方法（或者进入方法块）的话，就必须获得该对象锁的拥有权。</p><p>而这时该对象的锁被线程A锁占用，因此B、C线程就会被阻塞，进入到一个地方等待锁的释放，这个地方就是锁池。</p><h2 id="等待池"><a href="#等待池" class="headerlink" title="等待池"></a>等待池</h2><p>假设线程A调用了某个对象的<code>wait()</code>方法，线程A就会释放该对象的锁，同时线程A就进入到该对象的等待池中，进入等待池的线程都不会去竞争该对象的锁。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line">    </span><br><span class="line">java.lang.Object <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><strong><code>notify</code>和<code>notifyAll</code>的作用就是在某个线程调用了<code>wait()</code>方法之后，对等待池中的这些线程进行一个唤醒操作</strong>，区别就是</p><p><strong><code>notify</code></strong>只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p><p><strong><code>notifyAl</code>l</strong>会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>当调用<code>Thread.yield</code>函数时，会给线程调度器一个当前线程愿意让出<code>CPU</code>使用的暗示，但是线程调度器可能会忽略这个暗示。对已有的锁不产生影响。</p><p>下面这个代码主要是判断在i等于5的时候当前线程会不会让位给别的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> yield</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-06 9:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">yieldTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + i);</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                        Thread.<span class="keyword">yield</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(yieldTask, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(yieldTask, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">A1</span><br><span class="line">A2</span><br><span class="line">A3</span><br><span class="line">A4</span><br><span class="line">A5</span><br><span class="line">B1</span><br><span class="line">B2</span><br><span class="line">B3</span><br><span class="line">B4</span><br><span class="line">B5</span><br><span class="line">B6</span><br><span class="line">B7</span><br><span class="line">B8</span><br><span class="line">B9</span><br><span class="line">B10</span><br><span class="line">A6</span><br><span class="line">A7</span><br><span class="line">A8</span><br><span class="line">A9</span><br><span class="line">A10</span><br></pre></td></tr></table></figure><h1 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h1><ul><li><code>Thread.stop</code>, <code>Thread.suspend</code>, <code>Thread.resume</code></li></ul><p>都已经被废弃了。因为它们太暴力了，是不安全的，这种暴力中断线程是一种不安全的操作，会引发难以预期的异常。</p><ul><li><code>interrupt</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>目前应该用的是<code>interrupt()</code>方法，它是通知线程应该中断了：</p><ul><li>如果线程处于阻塞状态，那么线程将立即退出被阻塞的状态，并抛出一个<code>InterruptedException</code>异常。</li><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为<code>true</code>。被设置中断标志的线程将继续正常运行，不受影响</li></ul><p><strong>interrupt() 并不能真正的中断线程，这点要谨记。需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就需要这样做：</strong></p><ul><li><p>在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。</p></li><li><p>在调用阻塞方法时正确处理<code>InterruptedException</code>异常。（例如：catch异常后就结束线程。）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> interrupt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-08-06 16:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">interruptTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//正常运行时，经常检查本线程的中断标志位</span></span><br><span class="line">                    <span class="comment">//如果被设置了中断标志就自行停止线程</span></span><br><span class="line">                    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        i++;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">&quot;(&quot;</span> + Thread.currentThread().getState()</span><br><span class="line">                                + <span class="string">&quot;) loop&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//在调用阻塞方法时正确处理InterruptedException异常。</span></span><br><span class="line">                    <span class="comment">//例如catch异常后就结束线程</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;(&quot;</span> + Thread.currentThread().getState()</span><br><span class="line">                            + <span class="string">&quot;) catch InterruptedException&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(interruptTask, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        System.out.println(t1.getName() + <span class="string">&quot;(&quot;</span> + t1.getState() + <span class="string">&quot;) is new&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(t1.getName() + <span class="string">&quot;(&quot;</span> + t1.getState() + <span class="string">&quot;) is started&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程休眠300s，然后主线程给t1发中断指令</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        System.out.println(t1.getName() + <span class="string">&quot;(&quot;</span> + t1.getState() + <span class="string">&quot;) is interrupted&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程休眠300ms，然后查看t1状态</span></span><br><span class="line">        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        System.out.println(t1.getName() + <span class="string">&quot;(&quot;</span> + t1.getState() + <span class="string">&quot;) is interrupted now&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1(NEW) is <span class="keyword">new</span></span><br><span class="line"><span class="title class_">t1</span>(RUNNABLE) is started</span><br><span class="line"><span class="title function_">t1</span><span class="params">(RUNNABLE)</span> loop1</span><br><span class="line"><span class="title function_">t1</span><span class="params">(RUNNABLE)</span> loop2</span><br><span class="line"><span class="title function_">t1</span><span class="params">(TIMED_WAITING)</span> is interrupted</span><br><span class="line"><span class="title function_">t1</span><span class="params">(RUNNABLE)</span> <span class="keyword">catch</span> InterruptedException</span><br><span class="line"><span class="title function_">t1</span><span class="params">(TERMINATED)</span> is interrupted now</span><br></pre></td></tr></table></figure><p><img src="/2019/08/04/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/6.jpg" alt></p><p>(图源：<a href="https://my.oschina.net/mingdongcheng/blog/139263">一张图让你看懂JAVA线程间的状态转换 - 程明东 - OSCHINA</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Thread <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p><em><code>thread.join</code>把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的<code>join()</code>方法，直到线程A执行完毕后，才会继续执行线程B。</em></p><p>参考：</p><p><a href="https://blog.csdn.net/pange1991/article/details/53860651">Java线程的6种状态及切换(透彻讲解) - 潘建南的博客 - CSDN博客</a></p><p><a href="https://www.icode9.com/content-4-179207.html">问二十：说说notify和notifyAll的区别？</a></p><p><a href="https://www.jianshu.com/p/e0ff2e420ab6">线程中断机制(interrupt) - 简书</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程的状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倍增求LCA</title>
      <link href="/2019/07/27/%E5%80%8D%E5%A2%9E%E6%B1%82LCA/"/>
      <url>/2019/07/27/%E5%80%8D%E5%A2%9E%E6%B1%82LCA/</url>
      
        <content type="html"><![CDATA[<p>LCA—最近公共祖先</p><span id="more"></span><h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><p>所谓<code>LCA</code>，是当给定一个有根树T时，对于任意两个结点u、v，找到一个离根最远的结点x，使得x同时是u和v的祖先，x 便是u、v的最近公共祖先（原问题涵盖一般性的有根树，为了简化，多使用二叉树来讨论）。例如下面：</p><p><img src="/2019/07/27/%E5%80%8D%E5%A2%9E%E6%B1%82LCA/1.jpg" alt></p><p>结点3和结点4的最近公共祖先是结点2，即LCA（3， 4）=2 。在此，需要注意到当两个结点在同一棵子树上的情况，如结点3和结点2的最近公共祖先为2，即 LCA（3，2）=2。同理：LCA（5，6）=4，LCA（6，10）=1。</p><hr><p>求<code>LCA</code>的方法主要有：</p><ol><li>倍增求<code>LCA</code></li><li><code>ST-RMQ</code>求<code>LCA</code></li><li><code>Tarjan</code>求<code>LCA</code></li></ol><p>前面两者都是在线算法，最后一个是离线算法</p><blockquote><p><strong>在线</strong>和<strong>离线</strong>可以简单的理解为<strong>对于所有的操作是否需要读入完毕</strong>。</p><p>在线的要求是可以不用先知道所有的操作（类似询问、修改），边读入边执行，类似<strong>“走一步，做一步”</strong>的思想。</p><p>离线则与在线相反，要求必须知道所有的操作，类似<strong>“记录所有步，回头再做”</strong>的思想，一般用Query[]记录所有操作</p><p>转自：<a href="https://www.jianshu.com/p/2f21f9d125df">在线和离线算法 - 简书</a></p></blockquote><h1 id="倍增求LCA"><a href="#倍增求LCA" class="headerlink" title="倍增求LCA"></a>倍增求LCA</h1><h2 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h2><p>所谓倍增，就是按2的倍数来增大，也就是跳 <code>1,2,4,8,16,32 ……</code> 不过在这我们不是按从小到大跳，而是从大向小跳，即按<code>……32,16,8,4,2,1</code>来跳，如果大的跳不过去，再把它调小。这是因为从小开始跳，可能会出现“悔棋”的现象。拿 5为例，从小向大跳，$5≠1+2+4$,所以我们还要回溯一步，然后才能得出$5=1+4$；而从大向小跳，直接可以得出$5=4+1$。这也可以拿二进制为例，5(101)，从高位向低位填很简单，如果填了这位之后比原数大了，那我就不填，这个过程是很好操作的。</p><hr><h2 id="求LCA"><a href="#求LCA" class="headerlink" title="求LCA"></a>求LCA</h2><p>程序开始时选取任意节点为树根，进行<code>dfs</code>，得到所有点的深度与<code>pre[i][j]</code>。<code>pre[i][j]</code> 指节点 i 的第 $2^j$个祖先</p><p><img src="/2019/07/27/%E5%80%8D%E5%A2%9E%E6%B1%82LCA/1.jpg" alt></p><p>如上图中，10 的第 1 个祖先是 9，第二个祖先是 8，第三个祖先是 7，第四个祖先是 1。所以 10 的第 2 的 0 次方个祖先是 9($2^0=1$)，10 的第 2 的 1 次方个祖先是 8($2^1=2$)，10 的第 2 的 2 次方个祖先是 1($2^2=4$)。很显然，10 没有 2 的 3 次方个祖先。所以<code>pre[10][0]=9,pre[10][1]=8,pre[10][2]=1</code></p><p>而且通过倍增的思想，<strong>我们不难发现 i 的第 $2^j$ 个祖先就是 i 的第 $2^{j-1}$个祖先的第 $2^{j-1}$个祖先（$j&gt;=1$）。</strong></p><p>比如当<code>i=10，j=1</code>的时候，<code>pre[10][1]=8</code>，<code>pre[10][0]=9</code>，<code>pre[9][0]=8</code>；或者由下面推出</p><p>$2^i = 2*2^{i-1} = 2^{i-1} + 2^{i-1}$</p><p><strong>所以<code>pre[i][j]=pre[pre[i][j-1]][j-1]</code></strong>。</p><p>有了这个规律，我们就可以在 <code>dfs</code> 中预处理所有的 pre 了！</p><hr><p>有了<code>pre</code>，接着看看怎么求<code>LCA</code></p><p>x、y分别是树上的两个点，找他们的最近的公共祖先</p><p>开头用一个判断，规定 x 的深度一定比 y 大，否则就交换一下。</p><ul><li>首先让 x 往上跳，去找y的所在层<ul><li>如果 x 和 y 重合了，就已经是答案了</li></ul></li><li>否则 让 x 和 y 一起向上跳，直到找到答案</li></ul><hr><h2 id="洛谷-P3379最近公共祖先"><a href="#洛谷-P3379最近公共祖先" class="headerlink" title="洛谷-P3379最近公共祖先"></a><a href="https://www.luogu.org/problem/P3379">洛谷-P3379最近公共祖先</a></h2><p><img src="/2019/07/27/%E5%80%8D%E5%A2%9E%E6%B1%82LCA/2.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">P3379 【模板】最近公共祖先（LCA）</span></span><br><span class="line"><span class="comment">评测状态</span></span><br><span class="line"><span class="comment">Accepted</span></span><br><span class="line"><span class="comment">评测分数</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">提交时间</span></span><br><span class="line"><span class="comment">2019-08-03 22:31:54</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, len = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//d数组存储的就是每个节点的深度（默认根节点深度为1）</span></span><br><span class="line"><span class="comment">//pre[i][j]: 指节点 i 的第 2^j个祖先</span></span><br><span class="line"><span class="comment">//h数组：邻接表</span></span><br><span class="line"><span class="type">int</span> d[MAXN], pre[MAXN][<span class="number">30</span>], h[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, gg;</span><br><span class="line">&#125;b[MAXN*<span class="number">2</span>];<span class="comment">//存边：双向边，所以数据要开够</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len++;</span><br><span class="line">    b[len].x = x;</span><br><span class="line">    b[len].y = y;</span><br><span class="line">    b[len].gg = h[x];</span><br><span class="line">    h[x] = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//x 去找所有的 y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i &gt; <span class="number">0</span>; i = b[i].gg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = b[i].y;</span><br><span class="line">        <span class="keyword">if</span>(d[y] == <span class="number">0</span>) <span class="comment">// y 未被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            d[y] = d[x] + <span class="number">1</span>;<span class="comment">// y 是x的儿子，所以层数+1</span></span><br><span class="line">            pre[y][<span class="number">0</span>] = x; <span class="comment">// y向上跳一格，一定是到 x</span></span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//查找 x 与 y 的最近公共祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x] &lt; d[y]) <span class="built_in">swap</span>(x,y);<span class="comment">// 要求 x 比较深， 去找 y</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--) <span class="comment">//先让 x 跳到 y 的同层</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[pre[x][i]] &gt;= d[y])</span><br><span class="line">        &#123;</span><br><span class="line">            x = pre[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x; <span class="comment">//如果重合，就已经结束了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)<span class="comment">//不重合，x 和 y 一起往上跳</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[x][i] != pre[y][i]) <span class="comment">//只要父亲不同，就跳，父亲相同，就停了</span></span><br><span class="line">        &#123;                    <span class="comment">// 最后一次，是没有跳上去的</span></span><br><span class="line">            x = pre[x][i];</span><br><span class="line">            y = pre[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[x][<span class="number">0</span>];<span class="comment">//要输出，必须要跳最后一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n, &amp;m, &amp;s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h[i] = d[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);</span><br><span class="line">        <span class="built_in">ins</span>(y,x);<span class="comment">//双向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认根节点深度为1</span></span><br><span class="line">    d[s] = <span class="number">1</span>;</span><br><span class="line">    pre[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//构树：分层+倍增</span></span><br><span class="line">    <span class="built_in">dfs</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">20</span>; i++)<span class="comment">//倍增数组的建立，这里是整个算法的核心</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">1</span>; x&lt;=n; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[x][i] = pre[pre[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)<span class="comment">//询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">lca</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://www.mina.moe/archives/401">【算法】倍增求 LCA – MiNa!</a></p><p><a href="https://hangcc.cn/2018/11/12/计蒜客-节点最近的公共祖先/">节点的最近公共祖先 【倍增算法】 | Hang_c’s Blog</a></p><p><a href="https://www.luogu.org/blog/cccx2016/solution-p3379">题解 P3379 liusu201601 的博客 - 洛谷博客</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 倍增 </tag>
            
            <tag> ACM算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建NginxHttps本地测试环境</title>
      <link href="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>利用nginx搭建一个https本地可用的域名</p><span id="more"></span><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>利用到的工具：</p><ul><li><p><a href="https://github.com/FiloSottile/mkcert">mkcert—本地生成浏览器信任的本地 https 证书</a></p></li><li><p>Nginx</p></li><li>Docker（可选）</li></ul><p>本篇教程利用的是<code>docker nginx</code>，安装版也一样的，差不多。</p><p>本地环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本机：Arch Linux x86_64 5.2.2-arch1-1-ARCH</span><br><span class="line">Docker： Docker version 18.09.8-ce, build 0dd43dd87f</span><br><span class="line">Nginx：stable-alpine</span><br></pre></td></tr></table></figure><h1 id="安装mkcert"><a href="#安装mkcert" class="headerlink" title="安装mkcert"></a>安装mkcert</h1><p>其他系统的安装方法可以看<code>github</code>上面的介绍，本次按照的是<code>Arch</code>系统的安装方法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nss</span><br><span class="line">yay -S mkcert</span><br></pre></td></tr></table></figure><h1 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h1><ul><li><p>生成CA（certificate authority，即证书颁发机构），运行下面的命令可以在<code>~/.local/share/mkcert/</code>生成<code>rootCA.pem</code>和<code>rootCA-key.pem</code>a两个文件，这个命令只需运行一次，因为生成的CA可以反复使用；</p><p>使用<code>mkcert -install</code>命令即可</p></li></ul><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/1.png" alt></p><ul><li><p>创建自签名证书，例如要为域名：<code>hehe.com</code>和IP：<code>127.0.0.1</code>创建证书，可以使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkcert hehe.com 127.0.0.1</span><br></pre></td></tr></table></figure><p>上述命令会自动使用第1步创建的<code>CA</code>生成证书文件，其中<code>xxx.pem</code>为证书，<code>xxx-key.pem</code>为私钥，你也可以使    用<code>-cert-file</code>和<code>-key-file</code>两个参数设置生成文件的文件名。</p><p>注意：为了便于管理，建议在单独目录下生成本地证书及密钥*</p></li></ul><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/2.png" alt></p><p>生成了证书和私钥以后，就可以在web服务器开启https了</p><h1 id="Nginx开启https"><a href="#Nginx开启https" class="headerlink" title="Nginx开启https"></a>Nginx开启https</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>首先我们需要拉取一个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:stable-alpine</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/3.png" alt></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><strong>需要说明的是，在<code>nginx docker</code>里面，<code>Nginx</code>配置文件在<code>/etc/nginx</code>，静态资源在<code>/usr/share/nginx/html</code></strong></p><p>这里准备一个<code>Nginx</code>文件<code>default.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  hehe.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    # 相对于/etc/nginx</span><br><span class="line">    ssl_certificate hehe.com+1.pem;</span><br><span class="line">    ssl_certificate_key hehe.com+1-key.pem;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启用docker"><a href="#启用docker" class="headerlink" title="启用docker"></a>启用docker</h2><p>然后启用镜像，启动镜像的过程中可以配置映射，映射我们的静态资源文件夹，端口映射以及<code>https</code>文件映射</p><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/4.png" alt></p><p>更多可参考：<a href="https://hub.docker.com/_/nginx">nginx - Docker Hub</a></p><p>这里本地静态资源文件夹目录为<code>/home/cc/vue/ACMRecentContests_UI/dist</code>，<code>default.con</code>和两个秘钥分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/cc/https/hehe.com+1-key.pem</span><br><span class="line">/home/cc/https/hehe.com+1.pem</span><br><span class="line">/home/cc/https/default.conf</span><br></pre></td></tr></table></figure><p>所以我们可以映射如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx -d \</span><br><span class="line">-v nginx -v /home/cc/vue/ACMRecentContests_UI/dist:/usr/share/nginx/html:ro \</span><br><span class="line">-v /home/cc/https/hehe.com+1.pem:/etc/nginx/hehe.com+1.pem \</span><br><span class="line">-v /home/cc/https/hehe.com+1-key.pem:/etc/nginx/hehe.com+1-key.pem \</span><br><span class="line">-v /home/cc/https/default.conf:/etc/nginx/conf.d/default.conf \</span><br><span class="line">-p 9091:80 -p 9092:443 nginx:stable-alpine</span><br></pre></td></tr></table></figure><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/5.png" alt></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="Chrome75"><a href="#Chrome75" class="headerlink" title="Chrome75"></a>Chrome75</h2><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/6.png" alt></p><h2 id="Firefox69"><a href="#Firefox69" class="headerlink" title="Firefox69"></a>Firefox69</h2><p><img src="/2019/07/25/%E6%90%AD%E5%BB%BANginxHttps%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/7.png" alt></p><h1 id="关于docker-nginx的其他命令"><a href="#关于docker-nginx的其他命令" class="headerlink" title="关于docker nginx的其他命令"></a>关于docker nginx的其他命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">docker start nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">docker stop nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入</span></span><br><span class="line">docker exec -it nginx sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除容器，需要先停止</span></span><br><span class="line">docker rm nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi nginx:stable-alpine</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://aeric.io/post/mkcert-valid-https-certificates-for-localhost/">mkcert:本地有效的https证书-吕啸腾的博客</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> Nginx </tag>
            
            <tag> Https </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程拾遗--start与run--Thread与Runnable</title>
      <link href="/2019/07/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%BE%E9%81%97--start%E4%B8%8Erun--Thread%E4%B8%8ERunnable/"/>
      <url>/2019/07/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%BE%E9%81%97--start%E4%B8%8Erun--Thread%E4%B8%8ERunnable/</url>
      
        <content type="html"><![CDATA[<p>尝试从源码分析start与run的区别，Thread与Runnable的区别</p><span id="more"></span><h1 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h1><p>先来看两个程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: runable与start的区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-07-23 09:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;attack&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Current Thread is: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                attack();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;current main thread is: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        t.run();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current main thread is: main</span><br><span class="line">attack</span><br><span class="line">Current Thread is: main</span><br></pre></td></tr></table></figure><p>然后启动线程那里，改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.start();</span><br><span class="line"><span class="comment">//之前是t.run()</span></span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current main thread is: main</span><br><span class="line">attack</span><br><span class="line">Current Thread is: Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p>从程序运行的结果很简单的看出，使用<code>run()</code>方法会使用主线程来运行，而<code>start()</code>方法则使用非主线程来运行</p><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java虚拟机调用此线程的run方法，使该线程开始执行</span></span><br><span class="line"><span class="comment"> * 结果是两个线程并发运行：当前线程（从调用start方法返回）和另一个线程（执行其run方法）。</span></span><br><span class="line"><span class="comment"> * 多次启动线程是不合法的。特别是，一旦完成执行，线程可能无法重新启动。</span></span><br><span class="line"><span class="comment"> * 如果该线程已经启动，则再次调用start()方法，就会抛出IllegalThreadStateException异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法不会被VM创建或者是设置的主线程或“系统”组线程调用</span></span><br><span class="line"><span class="comment">         * 将来添加到该方法中的任何新功能可能也必须添加到VM中。</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 新的线程threadState值是0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 通知线程组该线程将要开始运行，这样该线程就会被添加到线程列表中</span></span><br><span class="line"><span class="comment">         * 此时列表的unstarted数将会减少。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用原生方法态方法启动线程</span></span><br><span class="line">            start0();</span><br><span class="line">            <span class="comment">// 已经运行的标记设置为true</span></span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">//若开始运行标记未设置成功，则通知线程组该线程尝试运行失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再看该方法里面的<code>start0()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果该线程是使用独立的Runnable运行对象构造的,则调用该Runnable对象的run方法</span></span><br><span class="line"><span class="comment"> * 否则，此方法不执行任何操作并返回</span></span><br><span class="line"><span class="comment"> * Thread的子类应该重写此方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>start0()</code>是<code>native</code>方法，我们可以查看<code>openjdk</code>里面对应的实现<a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/native/java/lang/Thread.c">Thread.c</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>可以看到，它是调用的<code>JVM</code>的<code>JVM_StartThread</code>方法</p><p>然后再去看对应的源码<a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/prims/jvm.cpp">jvm.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">  native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，会通过<code>new JavaThread</code>方法创建一个新的线程，再看其形参<code>thread_entry</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="function">HandleMark <span class="title">hm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class="line">  <span class="function">JavaValue <span class="title">result</span><span class="params">(T_VOID)</span></span>;</span><br><span class="line">  JavaCalls::<span class="built_in">call_virtual</span>(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          <span class="built_in">KlassHandle</span>(THREAD, SystemDictionary::<span class="built_in">Thread_klass</span>()),</span><br><span class="line">                          vmSymbols::<span class="built_in">run_method_name</span>(),</span><br><span class="line">                          vmSymbols::<span class="built_in">void_method_signature</span>(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>thread_entry</code>会通过让虚拟机创建一个线程，然后去执行<code>run()</code>方法里面的内容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的源码执行过程来看，它们的调用如下：</p><p><img src="/2019/07/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8B%BE%E9%81%97--start%E4%B8%8Erun--Thread%E4%B8%8ERunnable/1.png" alt></p><ul><li><p>调用<code>start()</code>方法会创建一个新的子线程并启动</p></li><li><p><code>run()</code>方法只是<code>Thread</code>的一个普通方法调用</p></li></ul><h1 id="Thread与Runnable"><a href="#Thread与Runnable" class="headerlink" title="Thread与Runnable"></a>Thread与Runnable</h1><p><code>Thread</code>是一个类，其实现了<code>Runnable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runnable接口实现的类，应该是任何实例想要由线程执行的类</span></span><br><span class="line"><span class="comment">     * 该类必须定义一个没有参数的方法，称为run</span></span><br><span class="line"><span class="comment">     * 设计该接口的目的是希望为在活动时执行代码的对象提供通用协议</span></span><br><span class="line"><span class="comment">     * 例如，Runnable由Thread类实现。</span></span><br><span class="line"><span class="comment">     * 活动只是意味着一个线程已经启动但尚未停止</span></span><br><span class="line"><span class="comment">     * 此外，Runnable为非Thread子类别的类别提供了一种启动方式</span></span><br><span class="line"><span class="comment">     * 通过实例化某个Thread实例并将自身作为运行目标，就可以运行为Runnable的类别而无需创建Thread的子类别。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面看来，<code>Runnable</code>接口并没有具备多线程的特性，是依赖<code>Thread</code>里面的<code>start()</code>方法去创建一个子线程</p><p>看下面例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Thread与Runnable区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-07-23 10:18</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thread2</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread start: &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,i: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>(<span class="string">&quot;threa1&quot;</span>);</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>(<span class="string">&quot;threa2&quot;</span>);</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>(<span class="string">&quot;threa3&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th2.start();</span><br><span class="line">        th3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><h2 id><a href="#" class="headerlink" title></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread start: threa1,i: <span class="number">0</span></span><br><span class="line">Thread start: threa1,i: <span class="number">1</span></span><br><span class="line">Thread start: threa1,i: <span class="number">2</span></span><br><span class="line">Thread start: threa1,i: <span class="number">3</span></span><br><span class="line">Thread start: threa2,i: <span class="number">0</span></span><br><span class="line">Thread start: threa2,i: <span class="number">1</span></span><br><span class="line">Thread start: threa2,i: <span class="number">2</span></span><br><span class="line">Thread start: threa2,i: <span class="number">3</span></span><br><span class="line">Thread start: threa3,i: <span class="number">0</span></span><br><span class="line">Thread start: threa3,i: <span class="number">1</span></span><br><span class="line">Thread start: threa3,i: <span class="number">2</span></span><br><span class="line">Thread start: threa3,i: <span class="number">3</span></span><br></pre></td></tr></table></figure></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: Thread与Runnable区别</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: GreenHatHG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-07-23 10:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRunnable</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyRunnable start: &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;,i: &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;threa1&quot;</span>);</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;threa2&quot;</span>);</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">th3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>(<span class="string">&quot;threa3&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th3);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread start: threa3,i: <span class="number">0</span></span><br><span class="line">Thread start: threa3,i: <span class="number">1</span></span><br><span class="line">Thread start: threa3,i: <span class="number">2</span></span><br><span class="line">Thread start: threa3,i: <span class="number">3</span></span><br><span class="line">Thread start: threa1,i: <span class="number">0</span></span><br><span class="line">Thread start: threa1,i: <span class="number">1</span></span><br><span class="line">Thread start: threa1,i: <span class="number">2</span></span><br><span class="line">Thread start: threa1,i: <span class="number">3</span></span><br><span class="line">Thread start: threa2,i: <span class="number">0</span></span><br><span class="line">Thread start: threa2,i: <span class="number">1</span></span><br><span class="line">Thread start: threa2,i: <span class="number">2</span></span><br><span class="line">Thread start: threa2,i: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>Thread</code>是实现了<code>Runnable</code>接口的类，使得<code>run</code>支持多线程</li><li>因类的单一继承原则，推荐多使用<code>Runnable</code>接口</li></ul><hr><p>参考：</p><p><a href="https://www.cnblogs.com/yufeng218/p/9940562.html">同一个线程多次调用start()会出现的问题 - 风止雨歇 - 博客园</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs序</title>
      <link href="/2019/07/19/dfs%E5%BA%8F/"/>
      <url>/2019/07/19/dfs%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>树的dfs</p><span id="more"></span><h1 id="dfs序"><a href="#dfs序" class="headerlink" title="dfs序"></a>dfs序</h1><p><img src="/2019/07/19/dfs%E5%BA%8F/1.png" alt></p><p>这棵树的 DFS 序列就是 <code>C 1 A E 7 H B 8 3 4 F 5 6 9 I G 2 D</code>(按照左优先)</p><p>定义子树 x表示结点x及其所有的子孙结点，该序列有一个很重要的性质：<br><strong>每棵子树x在 DFS 序列中一定是连续的一段，结点x一定在这段的开头</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C 1[A E 7 H B 8 3 4 F]5 6 9 I G 2 D</span><br><span class="line">          子树A</span><br><span class="line"></span><br><span class="line">C 1 A[E 7 H B]8 3 4 F 5 6 9 I G 2 D</span><br><span class="line">       子树E</span><br><span class="line"></span><br><span class="line">C 1 A E 7 H B 8 3 4 F[5 6 9 I G 2 D]</span><br><span class="line">                          子树5</span><br><span class="line"></span><br><span class="line">C 1 A E 7 H B 8 3 4 F 5[6 9]I G 2 D</span><br><span class="line">                       子树6</span><br></pre></td></tr></table></figure><p>这使得在子树上进行的修改、查询可以转化为区间修改、区间查询。结合树状数组 or 线段树食用均可</p><p>所以dfs序的作用是</p><ul><li>相当于把树上的问题转化成了序列上的问题</li><li>辅以各种数据结构进行计算</li><li>比如ST表、树状数组、线段树</li><li><strong>子树求和-&gt;区间求和</strong></li></ul><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历到x这个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">start[x] = ++dfs_clock;</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历x的子节点</span></span><br><span class="line"><span class="keyword">for</span>(every y connected to x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[y])</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    end[x] = dfs_clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h1><p>给一棵n个节点的树，以1为根，每个节点有权值value[i]，共有m个询问，每个问题要求给出x这个点的子树的权值和。N&lt;=1000000, M &lt;= 1000000, value[i] &lt;= 1e9</p><hr><p>做法:</p><p>按照dfs序将value[i]放成一列，用前缀和即可，即</p><p><code>Ans = sum[end[x]] – sum[start[x] – 1]</code></p><p><img src="/2019/07/19/dfs%E5%BA%8F/2.png" alt></p><h1 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h1><p>给一棵n个节点的树，以1为根，每个节点有权值value[i]。</p><p>共有m个操作：</p><p>• <code>Change(x, v)</code>将x这个点的权值改成v<br>• <code>Ask(x)</code> 询问x的子树的权值和</p><p>N, M &lt;= 100000</p><hr><p>做法：</p><p>同样将value[i]按照dfs序放成一排，用树状数组进行单点修改区间查询。单点修改、子树查询-&gt;单点修改、区间查询。</p><h1 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h1><p>给一棵n个节点的树，以1为根，每个节点有权值value[i]。</p><p>共有m个操作：</p><ul><li><code>Change(x, v)</code> 将x的子树中每个点的权值都加上v</li><li><code>Ask(x)</code>询问x的权值</li></ul><p>N, M &lt;= 100000</p><hr><p>做法：</p><p>dfs序将树上问题变成序列问题。区间修改，单点查询，树状数组即可</p><h1 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h1><p>有一棵n个点的树，以1为根，设根节点深度为0，有m个询问，每次查询要求找出x的子树中，深度为dep的节点有多少个。</p><p>N,M &lt;= 100000</p><p>做法：</p><ul><li>对每个深度都建一个数组，将该深度的点按照dfs序放进去。</li><li>深度为dep的数组中，属于x的子树的就一定会是连续的一段，用二分法即可求出。</li><li>变形：询问x的子树中，距离x为y的点有多少个。</li></ul><hr><p>参考:</p><p><a href="https://www.luogu.org/blog/P6174/dfs-xu-ru-men">DFS 序入门 - 6174 的星球 - 洛谷博客</a></p><p><a href="https://acm.sjtu.edu.cn/w/images/3/35/树的dfs序及其应用（闫鸿宇）.pdf">树的dfs及其应用</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记--垃圾回收</title>
      <link href="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收算法与 JVM 垃圾回收器</p><span id="more"></span><h1 id="一览"><a href="#一览" class="headerlink" title="一览"></a>一览</h1><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/32.png" alt></p><h1 id="对象被判定为垃圾的标准"><a href="#对象被判定为垃圾的标准" class="headerlink" title="对象被判定为垃圾的标准"></a>对象被判定为垃圾的标准</h1><p>GC主要是回收Java堆中的对象，即此对象已经没有了价值，就是变成了“垃圾”，那么对象被判定为垃圾的标准是什么呢？——<strong>没有被其他对象引用</strong>。</p><h1 id="判定对象是否为垃圾的算法"><a href="#判定对象是否为垃圾的算法" class="headerlink" title="判定对象是否为垃圾的算法"></a>判定对象是否为垃圾的算法</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p><strong>主要是判断对象的引用数量</strong></p><ul><li>通过判断对象的引用数量来决定对象是否可以被回收</li><li><strong>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</strong></li><li><strong>任何引用计数为0的对象实例都可以被当作垃圾收集</strong></li></ul><p>下面就是对一个引用计数的举例：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.png" alt></p><p>引用计数法有一个致命的缺陷，如下图，就是当两个对象相互引用时，这两个对象实际是不可获得的，但是由于引用计数不为零，所以均不会被回收。</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.png" alt></p><p><strong>优点：执行效率高，程序被影响小</strong><br><strong>缺点：无法解决循环引用问题 导致内存泄漏，所以在 Java 的垃圾回收器中没有使用这种算法</strong></p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p><strong>通过判断对象的引用链遍历（从GC Root开始）是否可达来决定对象是否可以被回收。</strong></p><p>如下图，从GC Root不能到达ObjD，ObjF ，ObjE，所以这三个对象是不可用的。</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.png" alt></p><p><strong>可作为GC Root的对象：</strong></p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li><li>方法区中的常量引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>本地方法栈中JNI（Native方法）的引用对象</li><li>活跃线程的引用对象</li></ul><h1 id="回收垃圾的算法"><a href="#回收垃圾的算法" class="headerlink" title="回收垃圾的算法"></a>回收垃圾的算法</h1><h2 id="标记-清除算法（Mark-and-Sweep）"><a href="#标记-清除算法（Mark-and-Sweep）" class="headerlink" title="标记-清除算法（Mark and Sweep）"></a>标记-清除算法（Mark and Sweep）</h2><ul><li>标记：从根集合进行扫描，对存活的对象进行标记（可达性分析算法）</li><li>清除：对堆内存从头到尾进行线性遍历，回收不可达的对象内存</li></ul><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/5.jpg" alt></p><p>上图是标记/清除算法的示意图，在标记阶段，从对象GC Root 1可以访问到B对象，从B对象又可以访问到E对象，因此从GC Root 1到B、E都是可达的，同理，对象F、G、J、K都是可达对象；到了清除阶段，所有不可达对象都会被回收。</p><p>缺点：</p><ul><li>效率问题</li></ul><p><strong>标记和清除两个阶段的效率都不高</strong>，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。</p><ul><li>空间问题</li></ul><p>标记清除之后会<strong>产生大量不连续的内存碎片</strong>（从上图可以看出），内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/6.jpg" alt></p><h2 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h2><ul><li>将可用内存按容量分为对象面和空闲面大小相等的两块</li><li>对象在对象面上创建</li><li>存活的对象被从对象面复制到空闲面</li><li>回收时将对象面所有对象内存清除</li></ul><p>回收前：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7.jpg" alt></p><p>回收后：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/8.jpg" alt></p><p>整体上看：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/10.jpg" alt></p><p><strong>复制算法每次都是对整个半区进行内存回收，这样就减少了标记对象遍历的时间</strong>，在清除使用区域对象时，不用进行遍历，直接清空整个区域内存，<strong>而且在将存活对象复制到保留区域时也是按地址顺序存储的</strong>，这样就解决了内存碎片的问题，在分配对象内存时不用考虑内存碎片等复杂问题，只需要按顺序分配内存即可。</p><p>优点：</p><ul><li>优化了标记/清除算法的效率低、内存碎片多的问题</li><li>顺序分配内存，简单高效</li></ul><p>缺点：</p><ul><li>将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；</li><li>如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍，耗费的时间代价也是不可忽视的。</li></ul><p><strong>适用场景</strong>：适用于对象存活率低的场景（年轻代）</p><h2 id="标记-整理算法（Compacting）"><a href="#标记-整理算法（Compacting）" class="headerlink" title="标记-整理算法（Compacting）"></a>标记-整理算法（Compacting）</h2><ul><li>标记：从根集合进行扫描，对存活的对象进行标记</li><li>清除：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。</li></ul><p>回收前：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/11.jpg" alt></p><p>回收后：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/12.jpg" alt></p><p>整体上看：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/13.jpg" alt></p><p>可以看到，<strong>回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中</strong>。这样一来，当我们给新对象分配内存时，jvm只需要持有内存的起始地址即可。标记/整理算法不仅<strong>弥补了标记/清除算法存在内存碎片的问题，也消除了复制算法内存减半的高额代价</strong>，可谓一举两得。但<strong>标记/整理算法的缺点就是效率也不高</strong>，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。</p><p><strong>适用场景</strong>：适用于存活率高的场景（老年代）</p><h2 id="标记分代收集算法（Generational-Collector）"><a href="#标记分代收集算法（Generational-Collector）" class="headerlink" title="标记分代收集算法（Generational Collector）"></a>标记分代收集算法（Generational Collector）</h2><ul><li>垃圾回收算法的组合拳</li><li>按照对象生命周期的不同划分区域以采用不同的垃圾回收算法</li><li>目的：用于提高JVM垃圾回收的效率</li></ul><p>先看堆内存分布：</p><ul><li>jdk6，jdk7</li></ul><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/14.png" alt></p><p>大致分为<code>Young Generation</code>年轻代，<code>Old Generation</code>老年代和<code>Permanent Generation</code>永久代这三部分</p><ul><li>jdk8以及之后版本</li></ul><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.jpg" alt></p><p>永久代被去除掉，如图所示。新加了一个称为”元空间“的空间，它与永久代最大的区别就是元空间使用本地内存，而永久代使用的是<code>JVM</code>内存 </p><p>在jdk6,7,8以及后面的版本中，年轻代和老年代均被保留了下来。<strong>年轻代的对象存活率低，就会采用复制算法，而老年代存活率高，则会采用标记-清除算法，或者标记-整理算法。</strong></p><hr><p>标记分代收集算法分为<code>Minor GC</code>和<code>Full GC</code>两类</p><hr><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>在年轻代<code>Young space</code>(包括<code>Eden</code>区和<code>Survivor</code>区)中的垃圾回收称之为 <code>Minor GC</code>，所采用的是算法是复制算法。</p><p>年轻代（<code>Young Generation</code>）：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/16.jpg" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/15.png" alt></p><p>年轻代几乎是所有Java对象出生的地方，即Java内存的申请和存放都是在这个地方进行的。该区域的对象几乎都是“朝生夕灭”。</p><p>年轻代分为两部分：</p><ul><li><p><code>Eden</code>（伊甸园）区</p><ol><li>正常情况对象刚被创建出来的时候在<code>Eden</code>区，当<code>Eden</code>区内存不足时会放到<code>Survivor</code>区，对象很大时会放入老年代。 </li><li>发生<code>Minor GC</code>后有用对象年龄+1并被放入到<code>Suvivor</code>区 </li><li><code>Eden</code>默认占年轻代8的权重，<code>Survivor</code>区两空间分别占1</li></ol></li><li><p>两个<code>Survivor</code>区（<code>from</code>、<code>to</code>）</p><p>发生<code>Minor GC</code>后有用对象年龄+1，并将存活对象从<code>From</code>使用复制算法到<code>To</code>中，清空<code>From</code>空间，当对象年龄达到一定值后进入老年区（默认15岁时进入）</p></li></ul><hr><p>年轻代垃圾回收的过程演示：</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/17.jpg" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/18.png" alt></p><p>首次<code>Minor GC</code>的过程：有用对象年龄+1并被放入到<code>Suvivor</code>区 ，然后清除<code>Eden</code>区</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/19.png" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/20.png" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/21.png" alt></p><p><code>Eden</code>区再次填满，又会触发一次<code>Minor GC</code>，此时便将其他两个区存活的对象拷贝到<code>S1</code>区中，年龄相对应增加，然后清除<code>Eden</code>和<code>S0</code>区，完成了第二次<code>Minor GC</code>。</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/22.png" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/23.png" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/24.png" alt></p><p>假设<code>Eden</code>区又满了，<code>S1</code>区有个无用的对象，此时又触发一次<code>Minor GC</code>，将其他区的对象拷贝到<code>S0</code>区，年龄对应增加，拷贝完成后清除<code>Eden</code>和<code>S1</code>区，完成了第三次<code>Minor GC</code></p><hr><p><strong>对象如何晋升为老年代</strong></p><ul><li>经历一定<code>Minor GC</code>次数依然存活的对象</li><li><code>Survivor</code>区放不下的对象</li><li>新生成的大对象（可以设置<code>-XX:+PretenuerSizeThreshold</code>设置大对象大小，超过这个大小的大对象会直接放入老年代）</li></ul><p><strong>常用的调优参数</strong></p><ul><li><code>-XX:SurvivorRatio</code>:<code>Eden</code>和<code>Survivor</code>的比值，默认8:1:1</li><li><code>-XX:NewRatio</code>:老年代和年轻代内存的大小比例</li><li><code>-XX:MAXTenuringThreshold</code>:对象从年轻代晋升到老年代进过GC次数的最大阈值</li></ul><h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>主要对老年代（该区域的对象是“幸存”下来的对象，一般不会再轻易“死亡”）的回收，但同时包含了对年轻代的回收（即包含了<code>Minor GC</code>）。采用的收集算法是标记-清除和标记-整理。相比<code>Minor GC</code>慢，执行频率低。</p><hr><p>老年代：<strong>存放生命周期较长的对象</strong></p><p><strong>触发<code>Full GC</code>的条件</strong></p><ul><li><p>老年代空间不足</p></li><li><p>永久代空间不足（JDK1.8之前）</p></li><li><p><code>CMS GC</code>时出现<code>promotion failed，concurrent mode failure</code></p></li><li><p><code>Minor GC</code>晋升到老年代的平均大小大于老年代的剩余空间</p></li><li><p>调用<code>System.gc()</code>（仅是通知，不保证何时执行）</p></li><li><p>使用<code>RMI</code>来进行<code>RPC</code>或管理的<code>JDK</code>应用，每小时执行1此<code>Full GC</code></p></li></ul><blockquote><p>CMS gc：CMS并行GC收集器</p><p>promotion failed：该问题是在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的</p><p>RMI：Java远程方法调用，Java编程语言里，一种用于实现远程过程调用的应用程序编程接口</p><p>RPC：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</p></blockquote><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/33.png" alt></p><h1 id="垃圾收集器相关名词"><a href="#垃圾收集器相关名词" class="headerlink" title="垃圾收集器相关名词"></a>垃圾收集器相关名词</h1><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop-the-World"></a>Stop-the-World</h2><p>不管选择哪种GC算法，<code>stop-the-world</code>都是不可避免的。<em><code>Stop-the-world</code></em>意味着从应用中停下来并进入到<code>GC</code>执行过程中去。一旦<code>Stop-the-world</code>发生，除了<code>GC</code>所需的线程外，其他线程都将停止工作，中断了的线程直到<code>GC</code>任务结束才继续它们的任务。<code>GC</code>调优通常就是为了改善<code>stop-the-world</code>的时间。</p><h2 id="Safepoint"><a href="#Safepoint" class="headerlink" title="Safepoint"></a>Safepoint</h2><ul><li>分析过程中对象引用关系不会发生变化的点</li><li>产生<code>Safepoint</code>的地方：方法调用、循环跳转、异常跳转等</li><li>安全点数量要适中（太少会让GC等待太长的时间，太多增加了程序运行的负荷）</li></ul><h1 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h1><h2 id="JVM两种运行模式"><a href="#JVM两种运行模式" class="headerlink" title="JVM两种运行模式"></a>JVM两种运行模式</h2><ul><li>Server：重量级级启动，速度较慢，优化更多</li><li>Client：轻量级启动，速度快</li></ul><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/25.png" alt></p><h2 id="年轻代常见的垃圾收集器"><a href="#年轻代常见的垃圾收集器" class="headerlink" title="年轻代常见的垃圾收集器"></a>年轻代常见的垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>设置<code>-XX:+UseSerialGC</code>可以让年轻代使用该垃圾收集器</p><p><code>Serial</code>收集器是最基本、发展历史最久的收集器，是一个采用复制算法的单线程的年轻代收集器</p><p>特点：</p><ol><li><p>针对年轻代</p></li><li><p>采用复制算法 </p></li><li><p>单线程。 </p><p>它的“单线程”意义： </p><p>​    a. 它只会使用一个CPU或一条线程去完成垃圾收集工作 </p><p>​    b. 它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束（<code>STW，Stop The World</code>）。</p></li></ol><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/26.png" alt></p><p><strong>应用场景：</strong> <code>Serial</code>收集器是虚拟机运行在<code>Client</code>模式下的默认年轻代收集器 <strong>优点：</strong> 简单高效。对于单个CPU环境而言，<code>Serial</code>收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>设置<code>-XX:+UseParNewGC(UseParallelOldGC</code>可以让年轻代使用该垃圾收集器</p><p><code>ParNew</code>收集器其实就是<code>Serial</code>收集器的多线程版本，在可用控制参数、收集算法、<code>Stop The World</code>、对象分配规则、回收策略等都与<code>Serial</code>收集器完全一样。是一个采用复制算法的并行多线程收集器，是一个年轻代收集器。</p><p><strong>特点：</strong> </p><ol><li>与<code>Serial</code>收集器相同的特点： a. 针对年轻代； b. 采用复制算法； c. STW</li><li>主要特点： 多线程。使用多线程进行垃圾收集。</li></ol><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/27.png" alt></p><p><strong>应用场景：</strong> 它是<code>Server</code>模式下的虚拟机首选的新生代收集器。但在单个CPU环境中，不会比<code>Serail</code>收集器有更好的效果，因为存在线程交互的开销。</p><h3 id="Parrallel-Scanvenge收集器"><a href="#Parrallel-Scanvenge收集器" class="headerlink" title="Parrallel Scanvenge收集器"></a>Parrallel Scanvenge收集器</h3><p>设置`-xx:+UseParallelGC可以让年轻代使用该垃圾收集器</p><p><code>Parallel Scavenge</code>收集器也是一个采用复制算法的并行多线程收集器，是一个年轻代收集器。<code>Parallel Scavenge</code>收集器因为与吞吐量关系密切，也称为吞吐量收集器</p><blockquote><p>所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%</p></blockquote><p><strong>特点：</strong></p><ol><li>与<code>ParNew</code>收集器相同的特点： a. 新生代收集器； b. 采用复制算法； c. 多线程收集；</li><li>主要特点： <code>Parallel Scavenge</code>收集器的目标是达一个可控制的吞吐量，而<code>CMS</code>等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。</li></ol><p><strong>应用场景：</strong> 1.高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间。 2.当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/28.png" alt></p><h2 id="老年代常见的垃圾收集器"><a href="#老年代常见的垃圾收集器" class="headerlink" title="老年代常见的垃圾收集器"></a>老年代常见的垃圾收集器</h2><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>设置<code>-XX:+UseSerialOldGC</code>可以让老年代使用该垃圾收集器</p><p><code>Serial Old</code> 是 <code>Serial</code>收集器的老年代版本，它同样是一个<strong>单线程收集器</strong>，使用<strong>“标记-整理”（Mark-Compact）</strong>算法。</p><p>收集器的主要意义也是在于给<code>Client</code>模式下的虚拟机使用。如果在<code>Server</code>模式下，它还有两大用途：</p><ul><li>在JDK1.5 以及之前版本（<code>Parallel Old</code>诞生以前）中与<code>Parallel Scavenge</code>收集器搭配使用。</li><li>作为<code>CMS</code>收集器的后备预案，在并发收集发生<strong>Concurrent Mode Failure</strong>时使用。</li></ul><p>它的工作流程与<code>Serial</code>收集器相同。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>设置<code>-xx:+UseParallelOldGC</code>可以让老年代使用该垃圾收集器</p><hr><p><code>Parallel Old</code>收集器是<code>Parallel Scavenge</code>收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在JDK1.6中才开始提供，在此之前，新生代选择了<code>Parallel Scavenge</code>收集器，老年代只能选择<code>Serial Old</code>，因为<code>Parallel Scavenge</code>是多线程收集器，但是到了老年代只能用<code>Serial Old</code>收集器，这样相当于只能在新生代达到提高吞吐量的效果。</p><p>直到老年代也提供了这种以提高吞吐量为主的收集器，新生代使用<code>Parallel Scavenge</code>收集器，老年代使用<code>Parallel Old</code>收集器就形成了以吞吐量优先的收集器组合。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑这种场合。</p><p>它的工作流程与<code>Parallel Scavenge</code>收集器相同。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>设置<code>-XX:+UseConcMarkSweepGC</code>可以让老年代使用该垃圾收集器</p><p><strong>CMS（Concurrent Mark Sweep）</strong>收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。从名字上（“Mark Sweep”）就可以看出它是基于<strong>“标记-清除”</strong>算法实现的。</p><p><code>CMS</code>收集器工作的整个流程：</p><ul><li><p>初始标记：仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快，需要<code>Stop The World</code>。并发标记：并发追溯标记，程序不会停顿</p></li><li><p>并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象</p></li><li><p>重新标记：暂停虚拟机，扫描CMS堆中的剩余对象。仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快，需要<code>Stop The World</code>。</p></li><li><p>并发清理：清理垃圾对象，程序不会停顿</p></li><li><p>并发重置：重置CMS收集器的数据结构</p></li></ul><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/29.png" alt></p><p>优点：</p><p>CMS是一款优秀的收集器，它的主要<strong>优点</strong>在名字上已经体现出来了：<strong>并发收集</strong>、<strong>低停顿</strong>，因此CMS收集器也被称为<strong>并发低停顿收集器（Concurrent Low Pause Collector）</strong>。</p><p>缺点：</p><ul><li><p><strong>CMS收集器对CPU资源非常敏感</strong>。在并发标记和并发清除时是和用户线程一起运行的，收集过程中肯定占用了用户程序的CPU资源。默认启动的回收线程数是（cpu数量+3）/4，当cpu数较少的时候，会分掉大部分的cpu去执行收集器线程，影响用户，降低吞吐量。</p></li><li><p><strong>CMS收集器无法处理浮动垃圾</strong>。在并发清除阶段，用户程序并没有停止，所以还会继续产生垃圾，而这部分垃圾只能等待着下一次收集时才能进行回收。</p></li><li><p><strong>CMS收集器会产生空间碎片</strong>。因为CMS收集器是基于“标记-清除”算法实现的，所以在进行大量的垃圾回收时，会产生很多不连续的内存空间。这是使用“标记-清除”算法都会有的缺点。</p></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>设置<code>-XX:+UseG1GC</code>可以让老年代使用该垃圾收集器</p><p>G1（<code>Garbage First</code>）收集器是目前最新的收集器了，<strong>java9以及java10默认的垃圾收集器就是G1。</strong>在<code>JDK6u14</code>中就有<code>Early Access</code>版本的G1收集器提供开发人员试用。到<code>JDK 7u4</code>才算是正是发布。G1是基于“标记-整理”算法来实现的，可以独立的维护新生代以及老年代两个部分</p><p>与其他的GC收集器相比，G1有如下特点：</p><ul><li><p><strong>并行与并发</strong>，G1充分利用多CPU资源来缩短停顿时间，即执行GC过程中用户程序扔可继续执行。</p></li><li><p><strong>分代收集，</strong>虽然G1可以不需要与其他收集器配合就可以独立管理整个GC堆，但分代感念在G1中依然保留，这样可以让G1采用不同的方式来处理年轻代和老年代的对象。</p></li><li><p><strong>空间整合</strong>，因为G1是基于“标记-整理”算法实现的，所以不会产生空间碎片，内存空间很好的整合起来了。</p></li><li><p><strong>可预测的停顿，</strong>这个特点是相对CMS收集器的一个优势，G1可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在牢记收集上的时间不得超过N秒。</p></li></ul><p>前面介绍的几个收集器，要么是作用在新生代，要么是作用在老年代，<strong>G1作用于整个堆</strong>，它将整个堆分为多个大小相等的独立区域（<code>Region</code>）,虽然仍保留了分代，但不再是物理隔离，都是一部分<code>Region</code>的集合。</p><p>G1收集器运行过程大致分为以下几步：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><strong>初始标记阶段</strong>和<code>CMS</code>收集器类似，也是仅仅标记一下<code>GC Roots</code>能直接关联到的对象，并且修改<code>TAMS（Next Top at Mark Start）</code>的值，让下一阶段用户程序并发运行时可以在正确的<code>Reginon</code>中创建新对象。<strong>并发标记阶段</strong>是对堆中对象进行可达性分析，找出存活对象，这个阶段可以与用户线程并发进行，而<strong>最终标记阶段</strong>是为了修正在并发标记期间因为用户程序并发运行，而导致标记产生变动的那部分标记记录，这阶段需要用户线程停顿，但是可并发进行。在最后的<strong>筛选回收阶段</strong>首先对各个Region的回收价值和成本进行排序，然后根据用户所期望的GC停顿时间来制定回收计划</p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/30.jpeg" alt></p><h3 id="JDK11-Epsilon-GC与ZGC"><a href="#JDK11-Epsilon-GC与ZGC" class="headerlink" title="JDK11:Epsilon GC与ZGC"></a>JDK11:Epsilon GC与ZGC</h3><p><code>Epsilon GC</code>：无操作实验垃圾收集器，处理内存分配但没有实现任何实际的内存回收机制。一旦可用的Java堆耗尽，JVM就会关闭。</p><p><code>Epsilon</code>垃圾回收器和其他的垃圾回收器一样，使用<code>-XX:+UseEpsilonGC</code>开启。</p><hr><p><code>ZGC</code>：Java 11 新加入的ZGC号称可以达到10ms 以下的 GC 停顿</p><h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/31.png" alt></p><p><img src="/2019/07/16/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0--%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/34.png" alt></p><hr><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/26386634">JVM 垃圾回收 - 知乎</a></p><p><a href="https://juejin.im/post/5d241fcf6fb9a07ecd3d826b">Java 垃圾回收机制(GC) - 掘金</a></p><p><a href="https://www.cnblogs.com/fangfuhai/p/7203468.html">Java虚拟机：GC算法深度解析 - 风中程序猿 - 博客园</a></p><p><a href="https://colobu.com/2015/04/07/minor-gc-vs-major-gc-vs-full-gc/">JVM 垃圾回收 Minor gc vs Major gc vs Full gc | 鸟窝</a></p><p><a href="https://my.oschina.net/shadowolf/blog/1834231">006. 深入JVM学习—年轻代 - 易冥天 - OSCHINA</a></p><p><a href="https://my.oschina.net/pentakill/blog/3049804">java 面试知识点笔记（四）垃圾回收 上篇 - 风格源于执着 - OSCHINA</a></p><p><a href="https://segmentfault.com/a/1190000004233812">[译]GC专家系列1：理解Java垃圾回收 - 牧曦之晨 - SegmentFault 思否</a></p><p><a href="https://www.cnblogs.com/jimoer/p/9038648.html">JVM学习记录-垃圾收集器 - 纪莫 - 博客园</a></p><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">深入理解JVM(3)——7种垃圾收集器 - 王泽远的博客 | Crow’s Blog</a></p><p><a href="https://juejin.im/post/5bb4866df265da0a914559b5">java11新特性—Epsilon:A No-Op Garbage Collector - 掘金</a></p><p><a href="https://www.baeldung.com/jvm-epsilon-gc-garbage-collector">An Introduction to Epsilon GC: A No-Op Experimental Garbage Collector – Baeldung</a></p><p><a href="https://juejin.im/entry/5b86a276f265da435c4402d4">Java程序员的荣光，听R大论JDK11的ZGC - 后端 - 掘金</a></p><p><a href="https://blog.csdn.net/liujiahan629629/article/details/85215655">JVM(二)——垃圾回收（GC Garbage Collection） - 学会改变自己——才能突破 - CSDN博客</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主席树</title>
      <link href="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
      <url>/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>主席树又名可持久化线段树</p><span id="more"></span><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>传统意义上的主席树就是可持久化线段树，什么叫可持久化呢？就是这棵树啊，<strong>可以记录每一次修改的内容</strong>，换句话说，就是可以访问这棵树的历史记录。</p><h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><ul><li>区间/树上路径第 K 大</li><li>区间不同数的个数</li></ul><p><strong>很多问题如果用线段树处理的话需要采用离线思想，若用主席树则可直接在线处理。故很多时候离线线段树求解可以转化为在线主席树求解。</strong></p><p>注意，主席树本质就是线段树，变化就在其实现可持久化，后一刻可以参考前一刻的状态，二者共同部分很多<strong>。一颗线段树的节点维护的是当前节点对应区间的信息，倘若每次区间都不一样，就会给处理带来一些困难</strong>。有时可以直接细分区间然后合并，此种情况线段树可以直接搞定；但有时无法通过直接划分区间来求解，如频繁询问区间第k小元素，当然，此问题有比较特殊的数据结构-划分树。其实还有一个叫做归并树，是根据归并排序实现的，每个节点保存的是该区间归并排序后的序列，因此，时间、空间复杂度都及其高， 所以一般不推荐去用。当然，主席树也是可以解决的。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>由若干棵线段树组成（若是权值线段树通常需先对数据离散化），按照输入顺序，每插入一个数保存一份当前版本的线段树。也就是说，<strong>对于 n 个数的输入数据，它会保存 n 棵线段树</strong>。</p><h1 id="建树过程"><a href="#建树过程" class="headerlink" title="建树过程"></a>建树过程</h1><p>下面我们以求区间第 K 大的实例来讲解一下如何建立主席树。</p><p><strong>比如有4个数500 30 6000 9432424，求区间$[2,4]$第2小的数。</strong></p><p>我们可以对区间离散化，离散化变成2 1 3 4</p><blockquote><p>离散化：当数据只与它们之间的相对大小有关，而与具体是多少无关时，可以进行离散化。</p></blockquote><p>主席树就是很多线段树的总体，而这些线段树就是按给定序列的所有前缀建立的。所以我们定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T[i]表示第i棵线段树的根节点编号，L[i]表示节点i的左子节点编号，R[i]表示节点i的右子节点编号，sum[i]表示节点i对应区间中数的个数。 </span><br></pre></td></tr></table></figure><p>接着，从T[0]开始建立空树，之后依次加入第i个数建立T[i]。 </p><p><strong>注意，如果我们直接以序列的所有前缀建立线段树肯定会MLE，这里主席树最精妙的地方就出来了。我们建立的这些线段树的结构，维护的区间是相同的，主席树充分利用了这些线段树中的相同部分，大大减少了空间消耗，达到优化目的。</strong></p><hr><p>按照新数组建立权值线段树，初始为空</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/1.png" alt></p><p><strong>图中每个节点上面为节点编号，节点下面为对应区间，节点中数为区间中含有的数的个数</strong></p><hr><p>接下来我们需要按照输入顺序依次插入数据，首先插入2</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/8.png" alt></p><p><strong>我们知道，更新一个叶节点只会影响根节点到该叶节点的一条路径，故只需修改该路径上的信息即可，那么其他的部分就可以共用，不同的部分只需要新建节点即可</strong></p><p>因为上一颗树的最大节点编号为7，所以这颗根节点编号为8。</p><p>因为要插入数据为2，根据线段树特点，共三个节点受到影响，受到影响的节点则重新创建节点，那么对应的编号也会变，如上图的编号为9和10的节点，其他节点没有影响的话则继续用上一个节点的信息，不需要改变。</p><p>精简后的树如下面所示</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/2.png" alt></p><p><em>省略部分节点信息</em></p><hr><p>接着插入1</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/3.png" alt></p><hr><p>插入3</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/4.png" alt></p><hr><p>插入4</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/5.png" alt></p><hr><p>下面为所有线段树组合成主席树</p><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/7.png" alt></p><p>从图中应该可以看出主席树是怎么充分利用这些线段树的相同结构来减少空间消耗的。当要新建一个线段树时最多只需要新增$log2n$个节点，相当于只更新了一条链，其它节点与它的前一个线段树公用。</p><p>至此，主席树建树完成，时间复杂度$O(nlog2n)$。</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>建完主席树后我们看看它是怎么查找区间$[2,4]$第2小的数的。 </p><p>T[i]表示处理完前i个数之后所形成的线段树，即具有了前缀和的性质，那么$T[r] - T[l-1]$即表示处理的$[l, r]$区间。当要查询区间$[1,3]$的时候，我们只要将T[3] 和T[0]节点相减即可得到要处理的线段树</p><p>这样我们得到区间$[l, r]$的数要查询第k大就很容易了，设左节点中存的个数为cnt，当$k&lt;=cnt$时，我们直接查询左儿子中第k小的数即可，如果$k&gt;cnt$，我们只要去查右儿子中第$k-cnt$小的数即可，这边是一道很简单的线段树了。</p><p><em>离散化的过程已经排序，所以上面的查找方法类似于二分查找</em></p><h1 id="POJ2104-K-th-Number"><a href="#POJ2104-K-th-Number" class="headerlink" title="POJ2104 K-th Number"></a><a href="http://poj.org/problem?id=2104">POJ2104 K-th Number</a></h1><p><img src="/2019/07/15/%E4%B8%BB%E5%B8%AD%E6%A0%91/9.png" alt></p><p>题目大意：</p><p>就是很简单的给出一个长为n的序列a，然后给出m个询问，每次给出三个数x,y,k，然后需要我们求出在序列a的区间$[x,y]$中，第k大的数是哪个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Problem: 2104User: heigua</span></span><br><span class="line"><span class="comment">Memory: 22072KTime: 1250MS</span></span><br><span class="line"><span class="comment">Language: C++Result: Accepted</span></span><br><span class="line"><span class="comment">2019-07-15 02:47:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本代码中所有数据均按从下标 1 开始存放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主席树中的线段树结点，sum 表示此区间内元素个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum, l, r;</span><br><span class="line">&#125; hjt[MAXN*<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN], sorted[MAXN], num;    <span class="comment">// sorted: 离散化后的数组 num: 离散化后的数组长度</span></span><br><span class="line"><span class="type">int</span> root[MAXN], cnt;    <span class="comment">// root: 主席树中用来保存每棵线段树树根的数组 cnt: 线段树结点数（用于数组方式动态开点）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找离散化之后的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetIdx</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(sorted<span class="number">+1</span>, sorted<span class="number">+1</span>+num, v) - sorted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">CreateNode</span><span class="params">(<span class="type">int</span> sum, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = ++cnt;</span><br><span class="line">    hjt[idx].sum = sum;</span><br><span class="line">    hjt[idx].l = l;</span><br><span class="line">    hjt[idx].r = r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建一棵线段树，只沿更新路径新建出较上个版本有修改的结点</span></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line"><span class="comment">// root: 插入后新生成的线段树的根结点会赋值到 root 中存储</span></span><br><span class="line"><span class="comment">// pre_rt: 上一棵线段树的根</span></span><br><span class="line"><span class="comment">// pos: 本次要插入的数在线段树中的位置</span></span><br><span class="line"><span class="comment">// l, r: 递归参数。默认填写 1, num</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> &amp;root, <span class="type">int</span> pre_rt, <span class="type">int</span> pos, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态创建结点，直接根据上一个版本复制对应的结点，sum+1</span></span><br><span class="line">    root = <span class="built_in">CreateNode</span>(hjt[pre_rt].sum<span class="number">+1</span>, hjt[pre_rt].l, hjt[pre_rt].r);</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> m = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;= m)</span><br><span class="line">        <span class="built_in">Insert</span>(hjt[root].l, hjt[pre_rt].l, pos, l, m);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Insert</span>(hjt[root].r, hjt[pre_rt].r, pos, m<span class="number">+1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数适用于查询区间 [l, r] 中的第 k 小。通常需要自行变通</span></span><br><span class="line"><span class="comment">// 调用参数</span></span><br><span class="line"><span class="comment">// s, e: 要查询区间所需的两个线段树的根，如要查询区间 [l, r]，则传入 root[l-1], root[r]</span></span><br><span class="line"><span class="comment">// k: 要查询区间第几小</span></span><br><span class="line"><span class="comment">// l, r: 递归参数。默认填写 1, num</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> m = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = hjt[hjt[e].l].sum - hjt[hjt[s].l].sum;    <span class="comment">// 计算左子树的元素数量</span></span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sum)    <span class="comment">// 如果 k &lt;= sum，则 k 在左子树，否则在右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Query</span>(hjt[s].l, hjt[e].l, k, l, m);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Query</span>(hjt[s].r, hjt[e].r, k-sum, m<span class="number">+1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, l, r, k;</span><br><span class="line">    <span class="keyword">while</span>(~ <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            sorted[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(sorted<span class="number">+1</span>, sorted<span class="number">+1</span>+n);    <span class="comment">// 按值排序</span></span><br><span class="line">        num = <span class="built_in">unique</span>(sorted<span class="number">+1</span>, sorted<span class="number">+1</span>+n) - (sorted<span class="number">+1</span>);    <span class="comment">// 去重，返回去重后的元素数量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;    <span class="comment">// 按顺序插入，建立 n 棵权值线段树</span></span><br><span class="line">            <span class="built_in">Insert</span>(root[i], root[i<span class="number">-1</span>], <span class="built_in">GetIdx</span>(a[i]), <span class="number">1</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sorted[<span class="built_in">Query</span>(root[l<span class="number">-1</span>], root[r], k, <span class="number">1</span>, num)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.jvruo.com/archives/171/">【蒟蒻数据结构】主席树 - 蒟蒻のBLOG</a></p><p><a href="https://dreamer.blue/blog/post/2018/03/01/aiabs_hjt.dream">算法有点甜之主席树 - bLue’s blog</a></p><p><a href="http://www.fdlly.com/p/182447363.html">主席树（静态） 图文讲解让你一次就懂 hdu2665为例</a></p><p><a href="https://www.cnblogs.com/zyf0163/p/4749042.html">树状结构之主席树 - 殇雪 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL中的EXISTS</title>
      <link href="/2019/07/02/SQL%E4%B8%AD%E7%9A%84EXISTS/"/>
      <url>/2019/07/02/SQL%E4%B8%AD%E7%9A%84EXISTS/</url>
      
        <content type="html"><![CDATA[<p>SQL中的EXISTS与SQL中的NOT EXISTS</p><span id="more"></span><h1 id="从SQL中基础的WHERE字句开始"><a href="#从SQL中基础的WHERE字句开始" class="headerlink" title="从SQL中基础的WHERE字句开始"></a>从<code>SQL</code>中基础的<code>WHERE</code>字句开始</h1><p>有一学生信息表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno, Sname FROM Student WHERE Sdept = &#x27;IS&#x27;;</span><br></pre></td></tr></table></figure><p>很显然，在执行这条 <code>SQL</code>语句的时候，<code>DBMS</code>会扫描 <code>Student</code>表中的每一条记录，然后把符合 <code>Sdept = &#39;IS&#39;</code>这个条件的所有记录筛选出来，并放到结果集里面去。也就是说 <strong><code>WHERE</code>关键字的作用就是判断后面的逻辑表达式的值是否为 <code>True</code>。如果为 <code>True</code>，则将当前这条记录（经过<code>SELECT</code>关键字处理后）放到结果集里面去，如果逻辑表达式的值为 <code>False</code>则不放</strong>。</p><h1 id="使用EXISTS关键字"><a href="#使用EXISTS关键字" class="headerlink" title="使用EXISTS关键字"></a>使用<code>EXISTS</code>关键字</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE EXISTS</span><br><span class="line">(SELECT * FROM SC WHERE</span><br><span class="line">     Sno = Student.Sno AND Cno = &#x27;1&#x27;);</span><br></pre></td></tr></table></figure><p>这条<code>SQL</code>语句的作用，就是<strong>查找所有选修了 1 号课程的课程的学生，并显示他们的姓名</strong>。</p><p>我们先不管<code>EXISTS</code>关键字在其中起了什么作用，而是先来看子查询中的<code>WHERE</code> 关键字后的表达式 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sno = Student.Sno AND Cno = &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>其中的 <code>Sno = Student.Sno</code>是怎么一回事？这就涉及到 SQL 中的<strong>不相关子查询与相关子查询</strong>了</p><h1 id="不相关子查询与相关子查询"><a href="#不相关子查询与相关子查询" class="headerlink" title="不相关子查询与相关子查询"></a>不相关子查询与相关子查询</h1><h2 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h2><p>我们常见的带子查询的<code>SQL</code>语句是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sno FROM SC WHERE Cno IN</span><br><span class="line">(SELECT Cno FROM Course WHERE </span><br><span class="line">    Cname = &#x27;数据结构&#x27;);</span><br></pre></td></tr></table></figure><p>查询过程如下：</p><ol><li>首先通过子查询得到课名为 “数据结构” 的课程的课号</li><li><p>然后遍历 <code>SC</code> （选课）表中的每一条选课记录</p><ul><li>若当前这条记录的课号为 “数据结构” 这门课的课号，则将这条记录的 Sno 列的值放到结果集里面去。</li></ul></li><li>最终我们可以得到所有选修了 ”数据结构“ 这门课的学生的学号。</li></ol><hr><p>这种类型的查询，叫做”不相关子查询”：</p><p><strong>这种类型的查询是先执行子查询，得到一个集合（或值），然后将这个集合（或值）作为一个常量带入到父查询的 WHERE 子句中去。如果单纯地执行子查询，也是可以成功的。</strong></p><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p>大多数情况下，不相关子查询已经够用了，但是如果有这样的一个查询要求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询每个学生超过自身选修的所有课程的平均成绩的课程的课程号</span><br></pre></td></tr></table></figure><p>子查询我们可以先查询出<strong>每个学生自身选修的所有课程的平均成绩</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(Grade) FROM SC WHERE Sno = ?</span><br></pre></td></tr></table></figure><p>那么问题来了，<code>WHERE</code>后面应该怎么写？也就<code>Sno=？</code>这里面怎么填</p><p>关键问题就是，？ 处这个常量，并不是一个确定的值，而<strong>应该是不断地将 <code>Student</code>表中的每一条记录中的 <code>Sno</code>列的值代入此处，然后求出该<code>Sno</code>对应的平均成绩。我们需要的是输入一系列的值，然后得到一系列对应的输出。</strong></p><hr><p>这个时候，我们就要用到另一种嵌套查询，叫做 “相关子查询”。<strong>“相关子查询” 的意思就是，子查询中需要用到父查询中的值。</strong></p><p>对于这个查询要求，我们可以使用以下<code>SQL</code> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cno FROM SC X WHERE Grade &gt;=</span><br><span class="line">(SELECT AVG(Grade) FROM SC Y WHERE</span><br><span class="line">    Y.Sno = X.Sno);</span><br></pre></td></tr></table></figure><p>其工作原理就是：</p><ol><li>先扫描父查询中数据来源（如 <code>SC</code> 表）中的每一条记录</li><li>然后将当前这条记录中的，在子查询中会用到的值代入到子查询中去</li><li>接着执行子查询并得到结果（可以看成是返回值）</li><li>然后再将这个结果代入到父查询的条件中，判断父查询的条件表达式的值是否为 <code>True</code><ul><li>若为 <code>True</code>，则将当前 <code>SC</code> 表中的这条记录（经过 <code>SELECT</code> 处理）后放到结果集中去</li><li>若为 <code>False</code> 则不放</li></ul></li></ol><p>在这个例子中：</p><ol><li><p>父查询先从 SC 表中取出第一条记录（如 95001）</p></li><li><p>然后将当前这条记录的 Sno 列的值（95001）代入到子查询中，求出学号为 95001 的学生选修的所有课程的平均分（如 80 分）</p></li><li><p>然后将这个 80 作为 <code>Grade &gt;=</code> 后面的值代入</p><ul><li>若 <code>SC</code> 表中的第一条记录的<code>Grade</code>列的值为 90，那么 <code>Grade &gt;= 80</code>这个条件表达式的值为 True，则将当前这条记录中的 <code>Cno</code>列的值（如1）放入结果集中去。</li></ul></li><li><p>以此类推，遍历 <code>SC</code>表中的所有记录，即可得到每个超过学生超过他/她所有课程平均分的课程的课号了。</p></li></ol><p><strong>判断是否是 “相关子查询” 也很简单，只要子查询不能脱离父查询单独执行，那么就是 “相关子查询”。</strong></p><h1 id="EXISTS关键字的作用"><a href="#EXISTS关键字的作用" class="headerlink" title="EXISTS关键字的作用"></a><code>EXISTS</code>关键字的作用</h1><p>它的作用，就是判断子查询得到的结果集是否是一个空集，如果不是，则返回 <code>True</code>，如果是，则返回 <code>False</code>。EXISTS 本身就是 “存在” 的意思，用我们可以理解的话来说，<strong>就是如果在当前的表中存在符合条件的这样一条记录，那么返回<code>True</code>，否则返回 <code>False</code>。</strong></p><p>有一条语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE EXISTS(</span><br><span class="line">SELECT * FROM SC WHERE</span><br><span class="line">    SC.Sno=Student.Sno AND Cno=&#x27;1&#x27;);</span><br></pre></td></tr></table></figure><p>在这个查询中：</p><ol><li>首先会取出 <code>Student</code>表中的第一条记录，得到其 Sno 列（因为在子查询中用到了）的值（如 95001）</li><li>然后将该值代入到子查询中。若能找到这样的一条记录，那么说明学号为 95001 的学生选修了 1 号课程。<ul><li>因为能找到这样的一条记录，所以子查询的结果不为空集，那么 <code>EXISTS</code>会返回 <code>True</code>，从而使 <code>Student</code>表中的第一条记录中的 <code>Sname</code>列的值被放入结果集中去。</li><li>以此类推，遍历 <code>Student</code>表中的所有记录后，就能得到所有选修了 1 号课程的学生的姓名。</li></ul></li></ol><h1 id="NOT-EXISTS关键字"><a href="#NOT-EXISTS关键字" class="headerlink" title="NOT EXISTS关键字"></a><code>NOT EXISTS</code>关键字</h1><p>与<code>EXISTS</code>关键字相对的是<code>NOT EXISTS</code>，作用与 <code>EXISTS</code>正相反，<strong>当子查询的结果为空集时，返回 <code>True</code>，反之返回 <code>False</code>。也就是所谓的 ”若不存在“。</strong></p><p>对于下面的查询要求，只能通过<code>NOT EXISTS</code>关键字来实现，因为 <code>SQL</code> 中并未直接提供关系代数中的除法功能。</p><ul><li>查询选修了全部课程的学生的姓名</li></ul><p>可以通过以下步骤的思路来实现：</p><ol><li>先取 <code>Student</code> 表中的第一个元组，得到其 <code>Sno</code> 列的值。也就是获取到学生对应的学号</li><li>再取<code>Course</code>表中的第一个元组，得到其<code>Cno</code> 列的值。也就是获取到课程对应的课程号</li><li><p>根据 <code>Sno</code> 与 <code>Cno</code> 的值，遍历 <code>SC</code> 表中的所有记录（也就是选课记录）。若对于某个 <code>Sno</code>和 <code>Cno</code>的值来说，<strong>在 <code>SC</code> 表中找不到相应的记录，则说明该 <code>Sno</code> 对应的学生没有选修该 <code>Cno</code> 对应的课程。</strong></p></li><li><p>对于某个学生来说，若在遍历 <code>Course</code>表中所有记录（也就是所有课程）后，<strong>仍找不到任何一门他/她没有选修的课程，就说明此学生选修了全部的课程。</strong></p></li><li>将此学生放入结果元组集合中</li><li>回到第一步，取<code>Student</code>中的下一个元组</li><li>将所有结果元组集合显示</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Sname FROM Student WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM Course WHERE NOT EXISTS</span><br><span class="line">    (SELECT * FROM SC WHERE</span><br><span class="line">    Sno=Student.Sno AND Cno=Course.Cno));</span><br></pre></td></tr></table></figure><p>其中第一个 <code>NOT EXISTS</code>对第四步，第二个 <code>NOT EXISTS</code>对应第三步。</p><hr><p>同理，对于类似的查询要求</p><ul><li>查询被所有学生选修的课程的课名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Cname FROM Course WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM Stuent WHERE NOT EXISTS</span><br><span class="line">    (SELECT * FROM SC WHERE</span><br><span class="line">        Sno=Student.Sno AND Cno=Course.Cno));</span><br></pre></td></tr></table></figure><ul><li>查询选修了95001号学生选修的全部课程的学生的学号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Sno FROM SC X WHERE NOT EXISTS</span><br><span class="line">(SELECT * FROM SC Y WHERE Y.Sno=&#x27;95001&#x27; AND NOT EXISTS</span><br><span class="line">    (SELECT * FROM SC Z WHERE </span><br><span class="line">        Z.Sno=X.Sno AND Z.Cno=Y.Cno));</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/20005249">SQL 中的 EXISTS 到底做了什么？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> EXISTS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-字节码文件中的常量池</title>
      <link href="/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>常量池（Constant Pool）</p><span id="more"></span><h1 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">21</span>         <span class="comment">// indi/greenhat/bytecode/Test1.a:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">22</span>            <span class="comment">// indi/greenhat/bytecode/Test1</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               a</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lindi/greenhat/bytecode/Test1;</span><br><span class="line">  #<span class="number">14</span> = Utf8               getA</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">16</span> = Utf8               setA</span><br><span class="line">  #<span class="number">17</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               Test1.java</span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// a:I</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               indi/greenhat/bytecode/Test1</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>紧接着主次版本号之后的是常量池入口</p><p>常量池可以理解为<strong>Class文件之中的资源仓库</strong>，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p><p><strong>常量池中主要存放两大类常量：字面量（<code>Literal</code>）和符号引用（<code>Symbolic References</code>）。</strong></p><ul><li>字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。</li><li>而符号引用则属于编译原理方面的概念，包括了下面三类常量：<ul><li>类和接口的全限定名（<code>Fully Qualified Name</code>） </li><li>字段的名称和描述符（<code>Descriptor</code>） </li><li>方法的名称和描述符</li></ul></li></ul><p><em>Java代码在进行<code>Javac</code>编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，<strong>在Class文件中不会保存各个方法、字段的最终内存布局信息</strong>，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</em></p><hr><p>常量池的总体结构：<strong>Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同组成</strong>。<strong>常量池数量紧跟在主版本号后面</strong>，占据2个字节（<code>u2</code>类型数据）；<strong>常量池数组则紧跟在常量池数量之后</strong>。常量池数组与一般数组不同的是，<strong>常量池数组中不同的元素的类型、结构都是是不同的，长度当然也就不同</strong>；但是，<strong>每一种元素的第一个数据都是一个<code>u1</code>类型</strong>，该字节是个标志位，占据1个字节，JVM在解析常量池时，会根据这个<code>u1</code>类型来获取元素的具体类型。</p><hr><p>由上面的16进制图可以看到，常量池数量为<code>0x18</code>，即24个常量，我们也可以看反编译的结果：<code>#1～#23</code></p><p>值得注意的是，<code>常量池数组中的元素个数=常量池数-1（其中0暂时不使用）</code>，目的是满足某些常量池索引值的数据在特定情况下需要表达<code>不引用任何一个常量池</code>的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应<code>null</code>值；所以，常量池的索引从1开始而非0开始。</p><h1 id="常量池中数据类型结构"><a href="#常量池中数据类型结构" class="headerlink" title="常量池中数据类型结构"></a>常量池中数据类型结构</h1><p>常量池中的每一项常量都是一个表，在 JDK 7 之前共有 11 种结构不同的表，在 JDK 7 中为了更好的支持动态语言调用，又增加了3种。都是<code>CONSTANT</code>开头，<code>info</code>结尾</p><p><img src="/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/4.png" alt></p><p>其中 <code>CONSTANT_Utf8_info</code> 类型的常量，它的 <code>length</code> 值说明了这个 UTF-8 编码的字符串长度是多少字节，<code>bytes</code> 的值为长度为 <code>length</code> 字节的 UTF-8 缩略编码表示的字符串</p><p><em>由于 Class 文件中方法、字段等都需要引用 <code>CONSTANT_Utf8_info</code> 型常量来描述名称，所以 <code>CONSTANT_Utf8_info</code> 型常量的最大长度也就是 Java 中方法、字段名的最大长度，即 <code>u2</code> 的 65535，也就是说最大 65535 字节，即 64KB。</em></p><h1 id="分析常量池中的数值"><a href="#分析常量池中的数值" class="headerlink" title="分析常量池中的数值"></a>分析常量池中的数值</h1><p>从<code>0a</code>开始，<code>0x0a</code>的十进制为10，因为每一个元素的第一个数据都是一个标志位，查<code>数据类型结构</code>表得u1为10的常量：</p><p><img src="/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/2.png" alt></p><p>发现其后面两个值都是索引值，其对应的十六进制为<code>00 04 00 14</code>，转换为十进制分别是4和20，那么4和20分别是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">#<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">23</span> = Utf8               java/lang/Object</span><br><span class="line">#<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">#<span class="number">8</span> = Utf8               ()V</span><br></pre></td></tr></table></figure><p>所以第一个元素<code>0a 00 04 00 14</code>代表的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure><p>那么<code>&lt;init&gt;</code>和<code>:()v</code>代表什么呢？</p><hr><p>在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，<strong>基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符工加对象的全限定名称来表示</strong>。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：</p><p><code>B-byte，C-char，D-double，F-float，I-int，J-long，S-short，Z-boolean，V-void，L-对象类型</code>，如<code>Ljava/lang/String</code></p><p>对于数组类型来说，每一个维度使用一个前置的<code>[</code>来表示，如<code>int[]</code>被记录为<code>[I</code>，<code>String[][]</code>被记录为<code>[[Ljava/lang/string</code></p><p>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组<code>()</code>之内，如方法：<code>String name(int id，String name)</code>的描述符为：<code>(I,Ljava/lang/String)Ljava/lang/String</code></p><hr><p>回归正题，<code>&lt;init&gt;</code>表示类的构造方法，<code>()v</code>：括号里面内容为空，则代表该方法没有参数，v则代表是<code>void</code>类型，那么连起来就是代表没有参数返回值为<code>void</code>的构造函数，因为我们没有定义这个构造方法，所以这个构造方法是自动生成的，其父类是<code>object</code>类</p><hr><p>接着，<code>0x09</code>的十进制为9，也刚好有两个索引值：<code>00 03 00 15</code>，转换为十进制分别是<code>3和21</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">21</span>         <span class="comment">// indi/greenhat/bytecode/Test1.a:I</span></span><br><span class="line">#<span class="number">3</span>= Class              #<span class="number">22</span>            <span class="comment">// indi/greenhat/bytecode/Test1</span></span><br><span class="line">#<span class="number">22</span> = Utf8               indi/greenhat/bytecode/Test1    </span><br></pre></td></tr></table></figure><p>正好对应的是样例类，<code>a：I</code>说明有个属性为a，类型是<code>int</code></p><hr><p>对应一些字符串的常量可以将其转换为ascii码查看其值，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">10</span> = Utf8               LineNumberTable</span><br></pre></td></tr></table></figure><p>其对应的十六进制为</p><p><code>0f 4c 69 6e 65 4e 75 6d 62 65 72</code></p><p><img src="/2019/06/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0/3.png" alt></p><p>使用的工具：<a href="http://www.ab126.com/goju/1711.html">ASCII 在线转换器-ASCII码-十六进制-二进制-十进制-字符串-ascii查询器-懒人计算器</a></p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">#<span class="number">21</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// a:I</span></span><br></pre></td></tr></table></figure><p><code>CONSTANT_NameAndType_info</code>确定唯一的成员变量，比如上面的#20表明是无参的构造方法，<code>a:I</code>代表是<code>int a</code></p><p>参考：</p><p>《深入理解java虚拟机（第二版 周志明）》</p><p><a href="https://blog.nekolr.com/2018/04/18/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">类文件结构 | nekolr’s blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 字节码 </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法</title>
      <link href="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>莫队算法</p><span id="more"></span><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>莫队算法使用分块的思想，可以解决一类离线区间询问问题</p><p>莫队算法（<code>mo&#39;s algorithm</code>）一般分为两类，一是莫队维护区间答案，二是维护区间内的数据结构。当然也有树上莫队，带修改莫队、二维莫队等等</p><h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><p>莫队的精髓就在于，离线得到了一堆需要处理的区间后，合理的安排这些区间计算的次序以得到一个较优的复杂度。</p><p>我们考虑一个问题，给一个序列，m次询问，每次询问你区间$[l,r]$有多少种不同的颜色。 $n,m\leq 100000n,m≤100000$</p><p>先考虑暴力，对每次询问遍历一遍 $[l,r]$，这样是$O(nm)$的</p><hr><p>换种方式暴力，定义ql和qr，表示区间 $[ql,qr]$内有多少颜色，再定义cnt数组， 表示第i种颜色在区间 $[ql,qr]$出现了多少次。那么现在的情况就是已经 $[ql,qr]$的答案，需要我们去转移求$[l,r]$区间的答案</p><p>因为这个是莫队算法的基础，所以模拟一下这个过程：</p><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/1.png" alt></p><p>我们的初始在这个状态，假设蓝色为1，红色为2，绿色为3，区间$[ql,qr]$有</p><p>那么$cnt_1=3, cnt_2=3, cnt_3=1$，然后我们把qr向右移动</p><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/2.png" alt></p><p>这样多了一个绿色，$cnt_3$的值+1，继续移动</p><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/3.png" alt></p><p>多了一个红色，$cnt_2$的值+1</p><p>此时我们发现，我们的右指针已经和询问的右端点重合了，接下来移动ql</p><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/4.png" alt></p><p>少了个蓝色，$cnt_1-1$</p><p>所以得到答案为$cnt_1=2, cnt_2=4, cnt_3=2$</p><p>这部分代码可表示为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    <span class="comment">//ans为不同颜色答案数</span></span><br><span class="line">    <span class="keyword">if</span>(cnt[x]==<span class="number">1</span>)ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    <span class="keyword">if</span>(cnt[x]==<span class="number">0</span>)ans--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//待求左区间比原区间小，则需要将原区间左指针左移，颜色块变多，那么就需要加值，其他同样</span></span><br><span class="line"><span class="keyword">while</span>(l&gt;ql) <span class="built_in">add</span>(a[--l]);</span><br><span class="line"><span class="keyword">while</span>(r&lt;qr) <span class="built_in">add</span>(a[++r]);</span><br><span class="line"><span class="keyword">while</span>(l&lt;ql) <span class="built_in">del</span>(a[l++]);</span><br><span class="line"><span class="keyword">while</span>(r&gt;qr) <span class="built_in">del</span>(a[r--]);</span><br></pre></td></tr></table></figure><p>我们发现，每次挪动都都是$O(1)$的，每次询问我们最多要移动n次，所以时间复杂度还是$O(nm)$。</p><p>我们有没有办法来加速呢？</p><p>这种暴力的耗时就耗在移动次数上，我们要让他移动的次数尽量少</p><p>最直接的一个想法就让每个所求区间尽量靠近，那么我们就可以减少了移动次数。</p><hr><p>一种直观的办法是按照左端点排序，再按照右端点排序。但是这样的表现不好。特别是面对精心设计的数据，这样方法表现得很差。</p><p>举个例子，有6个询问如下：(1, 100), (2, 2), (3, 99), (4, 4), (5, 102), (6, 7)</p><p>这个数据已经按照左端点排序了。用上述方法处理时，左端点会移动6次，右端点会移动移动<code>98+97+95+98+95=483</code>次。右端点大幅度地来回移动，严重影响了时间复杂度</p><p>其实我们稍微改变一下询问处理的顺序就能做得更好：(2, 2), (4, 4), (6, 7), (5, 102), (3, 99), (1, 100)</p><p>左端点移动次数为<code>2+2+1+2+2=9</code>次，比原来稍多。右端点移动次数为<code>2+3+95+3+1=104</code>，右端点的移动次数大大降低了。</p><p>所以，在排序时，我们并不是按照左右端点严格升序排序询问，而只是令其左右端点处于“大概是升序”的状态。具体的方法是，<strong>把所有的区间划分为不同的块，将每个询问按照左端点的所在块序号排序，左端点块一样则按照右端点排序。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a.r/block)==(b.r/block)?a.l&lt;b.l:a.r&lt;b.r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一种更快的排序，据说是这样能快是因为指针移到右边后不用再跳回左边，而跳回左边后处理下一个块又要跳回右边，这样能减少一半操作，理论上能快一倍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pos[a.l]^pos[b.l]?pos[a.l]&lt;pos[b.l]:pos[a.l]&amp;<span class="number">1</span>?a.r&lt;b.r:a.r&gt;b.r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>所以其基本思路为：按照分块思想，将区间分块，接着将每个询问按照块序号排序（一样则按照右端点排序）。之后，我们从排序后第一个询问开始，逐个计算答案。</strong></p><p>设区间长度为n，询问m次，那么莫队时间复杂度是$O(m\sqrt{n})$</p><h1 id="P1972-SDOI2009-HH的项链"><a href="#P1972-SDOI2009-HH的项链" class="headerlink" title="P1972 [SDOI2009]HH的项链"></a><a href="https://www.luogu.org/problemnew/show/P1972">P1972 [SDOI2009]HH的项链</a></h1><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/5.png" alt></p><p>因为这道题加强了数据卡莫队，所以会t两个点，但是拿来写裸莫队还是可以的</p><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/6.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN], block, ans = <span class="number">0</span>, Ans[MAXN], cnt[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(a.l/block)^(b.l/block)?a.l&lt;b.l:(((a.l/block)&amp;<span class="number">1</span>)?a.r&lt;b.r:a.r&gt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[arr[x]]) ans++;</span><br><span class="line">    cnt[arr[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt[arr[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[arr[x]]) ans--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i].l);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i].r);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>, q+m<span class="number">+1</span>, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].l, qr = q[i].r;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;ql)<span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;ql)<span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;qr)<span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;qr)<span class="built_in">del</span>(r--);</span><br><span class="line">        Ans[q[i].id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="带修改的莫队"><a href="#带修改的莫队" class="headerlink" title="带修改的莫队"></a>带修改的莫队</h1><p>普通的莫队只能解决没有修改的问题，那么带修改的问题怎么解决呢？带修莫队就是一种支持单点修改的莫队算法。</p><p>在进行修改操作的时候，修改操作是会对答案产生影响的(废话)</p><p>那么我们如何避免修改操作带来的影响呢？</p><hr><p>它与普通莫队不同的是，多了一个时间戳，用来记录到当前这个询问时已经进行了多少次修改操作。</p><p>我们把询问和修改分别存下来。对于每一个询问，我们不仅要做到左右端点与当前询问一致，还要使修改次数与当前询问相同。如果我们修改得过多，那么应该删去多余的修改，修改过少则反之。</p><p>比如，我们现在已经进行了3次修改，本次查询是在第5次修改之后，那我们就执行第4,5次修改</p><p>这样就可以避免修改操作对答案产生的影响了</p><p>因为莫队是离线查询，需要先读取全部需要查询的区间再开始处理的，有修改的话，就类似于普通莫队那样左右移动端点，所以我们可以加一个时间戳，也让时间戳同步于左右端点进行移动。这样的话我们就需要对时间戳进行处理，让结果最优。</p><p>带修莫队在原来四个while循环的基础上加了两个while循环处理时间戳。</p><p>分块的话<code>block = pow(n, 0.6666666666);</code>这样比较好</p><h1 id="P1903-国家集训队-数颜色-维护队列"><a href="#P1903-国家集训队-数颜色-维护队列" class="headerlink" title="P1903 [国家集训队]数颜色 / 维护队列"></a><a href="https://www.luogu.org/problemnew/show/P1903">P1903 [国家集训队]数颜色 / 维护队列</a></h1><p><img src="/2019/06/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/7.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码 C++11，1.9KB</span></span><br><span class="line"><span class="comment">提交时间 2019-06-28 11:44:21</span></span><br><span class="line"><span class="comment">耗时/内存 6414ms, 9876KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN], block, ans = <span class="number">0</span>, cntQ = <span class="number">0</span>, cntR = <span class="number">0</span>, cnt[<span class="number">1000005</span>], Ans[MAXN];</span><br><span class="line"><span class="type">int</span> where[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//l = 左端点，r = 右端点，t = 已修改次数（时间戳），id = 询问编号</span></span><br><span class="line">    <span class="type">int</span> l, r, id, t;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Update</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos, k; <span class="comment">//把第 pos 个数变为 k</span></span><br><span class="line">&#125;u[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.l / block != y.l / block)</span><br><span class="line">        <span class="keyword">return</span> x.l &lt; y.l;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x.r / block != y.r / block)</span><br><span class="line">        <span class="built_in">return</span> ((x.l / block) &amp; <span class="number">1</span>) ? x.r &lt; y.r : x.r &gt; y.r;</span><br><span class="line">    <span class="keyword">return</span> x.t &lt; y.t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(++cnt[x] == <span class="number">1</span>)</span><br><span class="line">        ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(--cnt[x] == <span class="number">0</span>)</span><br><span class="line">        ans--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> i)</span> <span class="comment">//在第 i 个询问进行第 now 次修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u[now].pos &gt;= q[i].l &amp;&amp; u[now].pos &lt;= q[i].r) <span class="comment">//修改的位置在询问区间内才会产生影响 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">del</span>(arr[u[now].pos]); <span class="comment">//删掉第 pos 位上的数 </span></span><br><span class="line">        <span class="built_in">add</span>(u[now].k); <span class="comment">//增加修改完的数 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果我们这一次修改把 x 变成了 y，下次如果要改回来就不是把 x 变成 y 了，</span></span><br><span class="line">    <span class="comment">//而是应当把 y 变成 x，所以我们修改完后我们要把 x 和 y 交换</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[u[now].pos], u[now].k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(q<span class="number">+1</span>, q+cntQ<span class="number">+1</span>, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, now = <span class="number">0</span>; <span class="comment">//初始左端点为 1，右端点为 0，进行了 0 次修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntQ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ql = q[i].l, qr = q[i].r, qt=q[i].t;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;ql)<span class="built_in">add</span>(arr[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;qr)<span class="built_in">add</span>(arr[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;ql)<span class="built_in">del</span>(arr[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;qr)<span class="built_in">del</span>(arr[r--]);</span><br><span class="line">        <span class="keyword">while</span>(now&lt;qt) <span class="built_in">upd</span>(++now, i);</span><br><span class="line">        <span class="keyword">while</span>(now&gt;qt) <span class="built_in">upd</span>(now--, i);</span><br><span class="line">        Ans[q[i].id] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    block = <span class="built_in">pow</span>(n, <span class="number">0.6666666666</span>);</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c %d %d&quot;</span>, &amp;op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cntQ++; <span class="comment">//记录共 cntQ 个查询</span></span><br><span class="line">            q[cntQ].l = l;</span><br><span class="line">            q[cntQ].r = r;</span><br><span class="line">            q[cntQ].t = cntR;</span><br><span class="line">            q[cntQ].id = cntQ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cntR++; <span class="comment">//记录共 cntR 个修改 </span></span><br><span class="line">            u[cntR].pos = l;</span><br><span class="line">            u[cntR].k = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mo</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntQ; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.luogu.org/blog/codesonic/Mosalgorithm">莫队算法初探 - #include<codesonic> - 洛谷博客</codesonic></a></p><p><a href="https://zhuanlan.zhihu.com/p/25017840">莫队算法 (Mo’s Algorithm) - 知乎</a></p><p><a href="https://www.cnblogs.com/CsOH/p/5904430.html">莫队算法良心讲解 - 张瑯小强 - 博客园</a></p><p><a href="https://ouuan.github.io/%E8%8E%AB%E9%98%9F%E3%80%81%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%E3%80%81%E6%A0%91%E4%B8%8A%E8%8E%AB%E9%98%9F%E8%AF%A6%E8%A7%A3/">莫队、带修莫队、树上莫队详解 | ouuan的博客</a></p><p><a href="https://www.cnblogs.com/zwfymqz/p/7154145.html">带修改莫队算法 - 自为风月马前卒 - 博客园</a></p><p><a href="https://heartlessly.github.io/problems/luogu-p1903/">「Luogu P1903」「国家集训队」数颜色/维护队列 | Heartlessly’s Blog</a></p><p><a href="https://blog.csdn.net/can919/article/details/79393546">莫队算法、及带修改操作的莫队算法 - CaptainChen的博客 - CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 莫队算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-字节码格式</title>
      <link href="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> .class文件</p><span id="more"></span><p>Java从刚开始的时候就有两套 规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨平台的角度去设计的</p><h1 id="Java语言的平台无关性"><a href="#Java语言的平台无关性" class="headerlink" title="Java语言的平台无关性"></a>Java语言的平台无关性</h1><p>在虚拟机出现之前，程序要想正确运行在计算机上，首先要将代码编译成二进制本地机器码，而这个过程是和电脑的操作系统OS、CPU指令集强相关的，所以可能代码只能在某种特定的平台下运行，而换一个平台或操作系统就无法正确运行了。随着虚拟机的出现，直接将程序编译成机器码，已经不再是唯一的选择了。越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。Java就是这样一种语言。“一次编写，到处运行”于是成立Java的宣传口号。</p><p><strong>正是虚拟机和字节码(ByteCode)构成了平台无关性的基石，从而实现“一次编写，到处运行”</strong></p><p>Java虚拟机将.java文件编译成字节码,而.class字节码文件经过JVM转化为当前平台下的机器码后再进行程序执行。这样，程序猿就无需重复编写代码来适应不同平台了，而是一套代码处处运行，至于字节码怎样转化成对应平台下的机器码，那就是Java虚拟机的事情了。</p><h1 id="JVM的语言无关性"><a href="#JVM的语言无关性" class="headerlink" title="JVM的语言无关性"></a>JVM的语言无关性</h1><p>时至今日，商业机构和开源机构以及在Java语言之外发展出一大批在Java虚拟机之上运行的语言，如<code>Groovy</code>,<code>JRuby</code>,<code>Jython</code>,<code>Scala</code>等等。这些语言通过各自的编译器编译成为.class文件，从而可以被JVM所执行。</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/1.jpg" alt></p><p>所以，由于Java虚拟机设计之初的定位，以及字节码(<code>ByteCode</code>)的存在，使得JVM可以执行不同语言下的字节码.class文件，从而构成了语言无关性的基础。</p><h1 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h1><h2 id="总体概况"><a href="#总体概况" class="headerlink" title="总体概况"></a>总体概况</h2><p><strong>注意，任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用到java内置的一个反编译工具<code>javap</code>可以反编译字节码文件。 通过<code>javap -help</code>可了解javap的基本用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类</span><br><span class="line">                           和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的</span><br><span class="line">                           系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><p>反编译上面的java代码后出现的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">Classfile /home/cc/IdeaProjects/test/out/production/test/indi/greenhat/bytecode/Test1.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified Jun <span class="number">23</span>, <span class="number">2019</span>; size <span class="number">485</span> bytes</span><br><span class="line">  MD5 checksum 6c83e799a2a04ca1ae44b4eb2e46ae35</span><br><span class="line">  Compiled from <span class="string">&quot;Test1.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">indi</span>.greenhat.bytecode.Test1</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">4.</span>#<span class="number">20</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">3.</span>#<span class="number">21</span>         <span class="comment">// indi/greenhat/bytecode/Test1.a:I</span></span><br><span class="line">   #<span class="number">3</span> = Class              #<span class="number">22</span>            <span class="comment">// indi/greenhat/bCC`ytecode/Test1</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">5</span> = Utf8               a</span><br><span class="line">   #<span class="number">6</span> = Utf8               I</span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">12</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">13</span> = Utf8               Lindi/greenhat/bytecode/Test1;</span><br><span class="line">  #<span class="number">14</span> = Utf8               getA</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">16</span> = Utf8               setACC`</span><br><span class="line">  #<span class="number">17</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">18</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">19</span> = Utf8               Test1.java</span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">21</span> = NameAndType        #<span class="number">5</span>:#<span class="number">6</span>          <span class="comment">// a:I</span></span><br><span class="line">  #<span class="number">22</span> = Utf8               indi/greenhat/bytecode/Test1</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> indi.greenhat.bytecode.Test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: iconst_1### attribute_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="number">6</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">4</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:### attribute_count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">10</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/greenhat/bytecode/Test1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">         <span class="number">4</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/greenhat/bytecode/Test1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: iload_1</span><br><span class="line">         <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">5</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/greenhat/bytecode/Test1;</span><br><span class="line">            <span class="number">0</span>       <span class="number">6</span>     <span class="number">1</span>     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;Test1.java&quot;</span></span><br></pre></td></tr></table></figure><p>在linux下我们可以用<code>hexyl</code>工具在终端下查看文件的16进制表示，或者使用<code>vim -b filename</code>然后键入<code>%!xxd -g1</code>命令查看</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/2.png" alt></p><p>可以看到，Class文件是一组以8位字节（由八个二进制数位组成的字节，通常可表示一个字符，即2个字符占一个字节。因为2的4次方表示16，）为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎 全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项 时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>一个class文件的结构：</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/2.jpg" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/7.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/9.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/21.png" alt></p><h2 id="字节码中的数据类型"><a href="#字节码中的数据类型" class="headerlink" title="字节码中的数据类型"></a>字节码中的数据类型</h2><p>Class字节码中有两种数据类型 </p><ul><li>字节数据直接量：这是基本的数据类型。共细分为u1，u2， u4，u8四种，分别代表连续的1个字节、2个字节、4个字节、8个字节组成的整体数据。</li><li>表（数组）：表是由多个基本数据或其他表， 按照既定顺序组成的大的数据集合。表是有结构的，它的结构体现在：组成表的成分所在的位置和顺序都是已经严格定义好的。 </li></ul><h2 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h2><p><strong>每个Class文件的头4个字节称为魔数（0xCAFEBABE），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</strong></p><p>很多文件存储标准中都使用魔数来进行身份识别， 譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别 主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由 地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。否被声明为final等。具体的标志位以及标志的含义：否被声明为final等。具体的标志位以及标志的含义：</p><h2 id="Class文件的版本"><a href="#Class文件的版本" class="headerlink" title="Class文件的版本"></a>Class文件的版本</h2><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（<code>Minor Version</code>），第7和第8个字节是主版本号（<code>Major Version</code>）。<strong>Java的版本号是从45开始的</strong>，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的 版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文 件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/3.png" alt></p><p>从上面反编译的结果可以看到 <code>minor version: 0 major version: 52</code>，或者<code>0x34</code>，正好52对应了jdk1.8，</p><p>最后面的0为次版本号</p><p> <strong>Class文件版本号</strong></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/4.png" alt></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p><a href="Java虚拟机笔记-字节码文件中的常量池 | 葵花妈妈开课辣">Java虚拟机笔记-字节码文件中的常量池 | 葵花妈妈开课辣</a></p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>在常量池结束之后， 紧接着的两个字节代表访问标志（<code>access_flags</code>） ， 这个标志用于识别一些类或者接口层次的访问信息， 包括： 这个Class是类还是接口； 是否定义为<code>public</code>类型； 是否定义为<code>abstract</code>类型； 如果是类的话， 是否被声明为<code>final</code>等。具体的标志位以及标志的含义：</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/3.jpg" alt></p><p><code>00 21</code>为此Class文件的一个访问标志符，查看访问表格没有值为21的标志。是因为JVM并不是枚举每一个标志值。</p><p><code>0x00 21</code>是<code>0x0001</code>和<code>0x0020</code>的并集，表示<code>ACC_PUBLIC</code>与<code>ACC_SUPER</code></p><h2 id="类索引、-父类索引与接口索引集合"><a href="#类索引、-父类索引与接口索引集合" class="headerlink" title="类索引、 父类索引与接口索引集合"></a>类索引、 父类索引与接口索引集合</h2><ol><li><p>类索引(<code>this_class</code>) 和父类索引(<code>super_class</code>) 都是一个<code>u2</code>类型的数据， 而接口索引集合(<code>interfaces</code>)是一组<code>u2</code>类型的数据的集合， <strong>Class文件中由这三项数据来确定这个类的继承关系</strong>。 <strong>类索引用于确定这个类的全限定名， 父类索引用于确定这个类的父类的全限定名</strong>。 由于Java语言不允许多重继承， 所以父类索引只有一个， 除了<code>java.lang.Object</code>之外， 所有的Java类都有父类，<strong>因此除了<code>java.lang.Object</code>外， 所有Java类的父类索引都不为0</strong>。<strong>接口索引集合就用来描述这个类实现了哪些接口</strong>， 这些被实现的接口将按<code>implements</code>语句（ 如果这个类本身是一个接口， 则应当是<code>extends</code>语句） 后的接口顺序从左到右排列在接口索引集合中。</p></li><li><p>类索引和父类索引各自指向一个类型<code>为CONSTANT_Class_info</code>的类描述符常量， 通过<code>CONSTANT_Class_info</code>类型的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串</p></li><li><p>对于接口索引集合， 入口的第一项——u2类型的数据为接口计数器(<code>interfaces_count</code>) ， 表示索引表的容量。 如果该类没有实现任何接口， 则该计数器值为0，后面接口的索引表不再占用任何字节</p></li></ol><p><code>00 03</code>为一个类索引，通过寻找<code>utf-8</code>类型确定类的全限定名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">3</span> = Class              #<span class="number">22</span>            <span class="comment">// indi/greenhat/bCC`ytecode/Test1</span></span><br><span class="line">#<span class="number">22</span> = Utf8               indi/greenhat/bytecode/Test1</span><br></pre></td></tr></table></figure><p><code>00 04</code>是一个父类索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">4</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">#<span class="number">23</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p><code>00 00</code>为接口索引集合，因为值为0，所以没有后续接口内容</p><h2 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h2><p>字段表(<code>field_info</code>)用于描述接口或者类中声明的变量。 字段(<code>field</code>)包括类级变量以及实例级变量， 但不包括在方法内部声明的局部变量。</p><p>字段表的结构如下所示：</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/5.png" alt></p><h3 id="access-flags"><a href="#access-flags" class="headerlink" title="access_flags"></a>access_flags</h3><p>字段修饰符放在<code>access_flags</code>项目中， 它与类中的<code>access_flags</code>项目是非常类似的， 都是一个<code>u2</code>的数据类型</p><p>其中可以设置的标志位和含义:</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/6.png" alt></p><p>很明显， 在实际情况中， <code>ACC_PUBLIC</code>，<code>ACC_PRIVATE</code>，<code>ACC_PROTECTED</code>三个标志最多只能选择其一，<code>ACC_FINAL</code>，<code>ACC_VOLATILE</code>不能同时选择。 接口之中的字段必须有<code>ACC_PUBLIC</code>，<code>ACC_STATIC</code>，<code>ACC_FINAL</code>标志， 这些都是由Java本身的语言规则所决定的。</p><h3 id="name-index与descripor-index"><a href="#name-index与descripor-index" class="headerlink" title="name_index与descripor_index"></a>name_index与descripor_index</h3><p>跟随<code>access_flags</code>标志的是两项索引值： <code>name_index</code>和<code>descriptor_index</code>。它们都是对常量池的引用， <strong>分别代表着字段的简单名称以及字段和方法的描述符。</strong></p><p><em>简单名称是指没有类型和参数修饰的方法或者字段名称， 比如一个类中的inc()方法和m字段的简单名称分别是<code>inc</code>和<code>m</code>。描述符可以参考：<a href="Java虚拟机笔记-字节码文件中的常量池 | 葵花妈妈开课辣">Java虚拟机笔记-字节码文件中的常量池 | 葵花妈妈开课辣</a></em></p><h3 id="attribute-count"><a href="#attribute-count" class="headerlink" title="attribute_count"></a>attribute_count</h3><p>在<code>descriptor_index</code>之后跟随着一个属性表集合用于存储一些额外的信息， 字段都可以在属性表中描述零至多项的额外信息。</p><hr><p><code>00 01</code>表示的是属性的数量，表明只有一个字段，然后可以从字段表结构出发，分析这个字段的结构</p><p><code>00 02</code>为<code>access_flags</code>，表示是<code>private</code></p><p><code>00 05</code>为<code>name_index</code>，表示的是<code>a</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">5</span> = Utf8               a</span><br></pre></td></tr></table></figure><p><code>00 06</code>为<code>descripor_index</code>，表示的是<code>I</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">6</span> = Utf8               I</span><br></pre></td></tr></table></figure><p><code>00 00</code>表示<code>attribute_count</code>的值为0</p><h2 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h2><p>Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式</p><ul><li>方法表结构：</li></ul><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/8.png" alt></p><ul><li><code>attribute_info</code>结构：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info&#123;</span><br><span class="line">    u2 attribute_name_index;  <span class="comment">//属性名的索引</span></span><br><span class="line">    u4 attribute_length;   <span class="comment">//属性的长度</span></span><br><span class="line">    u1 info[attribute_length];  <span class="comment">//具体的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>访问标志：</li></ul><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/4.jpg" alt></p><hr><p><code>00 03</code>为方法表的数量，转换为十进制有3个，也就是</p><ol><li><code>getA()</code></li><li><code>setA()</code></li><li>编译器自动生成的默认构造方法</li></ol><p><code>00 01</code>为<code>ACC_public</code>访问标志</p><p><code>00 07</code>和<code>00 08</code>为常量池索引，分别表示<code>name_index</code>与<code>descripor_index</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">#<span class="number">8</span> = Utf8               ()V</span><br></pre></td></tr></table></figure><p><code>00 01</code>为<code>attribute_count</code>，也就是说共有一个属性表</p><p><code>00 09</code>为<code>attribute_info</code>里面的<code>attribute_name_index</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">9</span> = Utf8               Code</span><br></pre></td></tr></table></figure><p>方法里的Java代码， 经过编译器编译成字节码指令后， 存放在方法属性表集合中一个名为<code>Code</code>的属性里面</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">       <span class="number">4</span>: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/greenhat/bytecode/Test1;</span><br></pre></td></tr></table></figure><p><code>00 00 00 38</code>为<code>attribute_length</code>，转换为十进制为56，也就是说会用56个字节作为<code>code</code>里面的值</p><h3 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h3><p><strong>Java程序方法体中的代码经过<code>Javac</code>编译器处理后， 最终变为字节码指令存储在<code>Code</code>属性内</strong>。 <code>Code</code>属性出现在方法表的属性集合之中， 但并非所有的方法表都必须存在这个属性， 譬如接口或者抽象类中的方法就不存在<code>Code</code>属性， 如果方法表有<code>Code</code>属性存在， 那么它的结构如下所示：</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/5.jpg" alt></p><ul><li><p><code>attribute_name_index</code>是一项指向<code>CONSTANT_Utf8_info</code>型常量的索引， 常量值固定为<code>Code</code>， 它代表了该属性的属性名称</p></li><li><p><code>attribute_length</code>指示了属性值的长度， 由于属性名称索引与属性长度一共为6字节， 所以属性值的长度固定为整个属性表长度减去6个字节</p></li><li><p><code>max_stack</code>代表了操作数栈(<code>Operand Stacks</code>)深度的最大值。 在方法执行的任意时刻，操作数栈都不会超过这个深度。 虚拟机运行的时候需要根据这个值来分配栈帧(<code>Stack Frame</code>)中的操作栈深度</p></li><li><p><code>max_locals</code>代表了局部变量表所需的存储空间。</p><p><em>在这里， <code>max_locals</code>的单位是<code>Slot</code>,<code>Slot</code>是虚拟机为局部变量分配内存所使用的最小单位。 对于<code>byte</code>，<code>char</code>，<code>float</code>，<code>int</code>，<code>short</code>，<code>boolean</code>和<code>returnAddress</code>等长度不超过32位的数据类型， 每个局部变量占用1个<code>Slot</code>， 而<code>double</code>和<code>long</code>这两种64位的数据类型则需要两个<code>Slot</code>来存放</em></p></li><li><p><code>code_length</code>和<code>code</code>用来存储Java源程序编译后生成的字节码指令。<code>code_length</code>代表字节码长度， <code>code</code>是用于存储字节码指令的一系列字节流</p><p> <em>既然叫字节码指令， 那么每个指令就是一个u1类型的单字节， 当虚拟机读取到code中的一个字节码时， 就可以对应找出这个字节码代表的是什么指令， 并且可以知道这条指令后面是否需要跟随参数， 以及参数应当如何理解</em></p><p><em>关于<code>code_length</code>， 有一件值得注意的事情， 虽然它是一个u4类型的长度值， 理论上最大<br>值可以达到<code>2^32-1</code>， 但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，<br>即它实际只使用了u2的长度， 如果超过这个限制， Javac编译器也会拒绝编译。 一般来讲， 编<br>写Java代码时只要不是刻意去编写一个超长的方法来为难编译器， 是不太可能超过这个最大<br>值的限制。 但是， 某些特殊情况， 例如在编译一个很复杂的JSP文件时， 某些JSP编译器会把<br>JSP内容和页面输出的信息归并于一个方法之中， 就可能因为方法生成字节码超长的原因而<br>导致编译失败</em></p></li><li><p><code>exception_table</code>用来存放的是异常处理的信息，每个<code>exception_table</code>表项由<code>start_pc</code>，<code>end_pc</code>，<code>handler_pc</code>以及<code>catch_type</code>组成</p></li></ul><hr><p>我们可以用<a href="https://github.com/ingokegel/jclasslib">jclasslib</a>这个软件来帮助我们查看字节码</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/10.png" alt></p><p>可以看到Code里面其实是一系列的助记符，其对应的十六进制为</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/11.png" alt></p><p>也就是说<code>0x2A</code>对应的就是<code>aload_0</code></p><p><code>0xB7</code>对应的就是<code>invokespecial</code>，后面的<code>00 01</code>代表<code>java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code>，也就是<code>invokespecial</code>后面所要接受的参数值</p><p>对应的助记符解释（来自《Java虚拟机规范 JavaSE8》）</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/12.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/13.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/14.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/15.png" alt></p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/16.png" alt></p><h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><p><code>LineNumberTable</code>属性用于描述Java源码行号与字节码行号（ 字节码的偏移量） 之间的对应关系。 它并不是运行时必需的属性， 但默认会生成到Class文件之中</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/17.png" alt></p><p><code>line_number_table</code>是一个数量为<code>line_number_table_length</code>，类型为<code>line_number_info</code>的集<br>合， <code>line_number_info</code>表包括了<code>start_pc</code>和<code>line_number</code>两个<code>u2</code>类型的数据项， 前者是字节码行<br>号， 后者是Java源码行号。当程序运行抛出异常时，异常堆栈中显示出错的行号就是根据这个对应关系来显示的。</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/18.png" alt></p><h4 id="LocalVariableTable属性"><a href="#LocalVariableTable属性" class="headerlink" title="LocalVariableTable属性"></a>LocalVariableTable属性</h4><p><code>LocalVariableTable</code>属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系， 它也不是运行时必需的属性， 但默认会生成到Class文件之中</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/6.jpg" alt></p><p><code>local_variable_info</code>结构:</p><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/19.png" alt></p><ul><li><code>start_pc</code>和<code>length</code>属性分别代表了这个局部变量的生命周期开始地字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</li><li><code>name_index</code>和<code>descriptor_index</code>都是指向常量池中<code>CONSTANT_Utf8_info</code>型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</li><li><code>index</code>是这个局部变量在栈帧局部变量表中<code>Slot</code>的位置。当这个变量数据类型是 64位类型时（<code>double</code>和<code>long</code>），他占用的<code>Slot</code>为<code>index</code>和<code>index+1</code>两个</li></ul><p><img src="/2019/06/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%A0%BC%E5%BC%8F/20.png" alt></p><p><strong>可以看到默认构造函数有一个局部变量this，代表类自身</strong></p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/45003974">Java虚拟机—Class文件结构 - 知乎</a></p><p><a href="https://juejin.im/post/5aca2c366fb9a028c97a5609">轻松看懂Java字节码 - 掘金</a></p><p><a href="https://blog.nekolr.com/2018/04/18/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">类文件结构 | nekolr’s blog</a></p><p><a href="https://lijiankun24.com/%E8%AE%A4%E8%AF%86-class-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%BB%93%E6%9E%84/">认识 .class 文件的字节码结构 | 一些无处安放的代码和故事</a></p><p><a href="https://yq.aliyun.com/articles/640924">Java Class文件结构解析-云栖社区-阿里云</a></p><p>《深入理解java虚拟机（第二版 周志明）》</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 字节码 </tag>
            
            <tag> 常量池 </tag>
            
            <tag> class文件结构 </tag>
            
            <tag> 字段表 </tag>
            
            <tag> 方法表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-JDBC驱动加载机制</title>
      <link href="/2019/06/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-JDBC%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/06/21/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-JDBC%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p> 通过JDBC驱动加载理解线程上下文加载器</p><span id="more"></span><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p><code>JDBC</code>提供了独立于数据库的统一<code>API</code>，<code>MySQL</code>，<code>Oracle</code>等数据库公司都可以基于这个标准接口来进行开发。包括<code>java .sql</code>包下的<code>Driver</code>，<code>Connection</code>，<code>Statement</code>，<code>ResultSet</code>是<code>JDBC</code>提供的接口。而<code>DriverManager</code>是用于管理<code>JDBC</code>驱动的服务类，主要用于获取<code>Connection</code>对象（此类中全是静态方法）</p><p>下面是一个简单的jdbc连接数据库过程。重点不在能不能连接，而是其加载过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mytest&quot;</span>;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">                url, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>查看<code>forName</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回与具有给定字符串名称的类或接口关联的Class对象。</span></span><br><span class="line"><span class="comment"> * 调用此方法等效于：Class.forName（className，true，currentLoader）</span></span><br><span class="line"><span class="comment"> * 其中currentLoader表示当前类的定义类加载器。</span></span><br><span class="line"><span class="comment"> * @ param className 所需类的完全限定名称</span></span><br><span class="line"><span class="comment"> * @ return 具有指定名称的类的Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>查看<code>forName0</code>，其是一个<code>native</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                            ClassLoader loader,</span><br><span class="line">                                            Class&lt;?&gt; caller)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException;</span><br></pre></td></tr></table></figure><h1 id="com-mysql-cj-jdbc-Driver"><a href="#com-mysql-cj-jdbc-Driver" class="headerlink" title="com.mysql.cj.jdbc.Driver"></a>com.mysql.cj.jdbc.Driver</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用DriverManager注册自己</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上边可以看到，它是用静态代码块实现的。根据类加载机制，当执行<code>Class.forName(driverClass)</code>获取其<code>Class</code>对象时，<code>com.mysql.jdbc.Driver</code>就会被<code>JVM</code>加载连接，并进行初始化，初始化就会执行静态代码块，也就会执行下边这句代码：</p><p><code>DriverManager.registerDriver(new Driver());</code></p><p>这里会注册驱动，调用的是<code>DriverManager</code>的<code>registerDriver</code>方法，那么在调用之前，也会初始化<code>DriverManager</code>类。</p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DriverManager</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//通过检查System属性jdbc.properties加载初始JDBC驱动程序，然后使用ServiceLoader机制</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">&quot;JDBC DriverManager initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DriverManager</code>类有一个静态代码块，会在初始化的时候执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadInitialDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;String&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> String <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(<span class="string">&quot;jdbc.drivers&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果驱动程序打包为服务提供程序，请加载它</span></span><br><span class="line">        <span class="comment">// 通过作为java.sql.Driver.class服务公开的类加载器获取所有驱动程序。</span></span><br><span class="line">        <span class="comment">// ServiceLoader.load（）替换了sun.misc.Providers（）</span></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                 * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">                 * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">                 * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">                 * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">                 * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">                 * and load the service.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">                 * if driver not available in classpath but it&#x27;s</span></span><br><span class="line"><span class="comment">                 * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;DriverManager.initialize: jdbc.drivers = &quot;</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers == <span class="literal">null</span> || drivers.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] driversList = drivers.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">        println(<span class="string">&quot;number of Drivers:&quot;</span> + driversList.length);</span><br><span class="line">        <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;DriverManager.Initialize: loading &quot;</span> + aDriver);</span><br><span class="line">                Class.forName(aDriver, <span class="literal">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>balabala大半天意思就是说如果<code>jdbc.drivers</code>这个系统属性为空，则会用ServerLoader机制去加载jdbc驱动。</p><p><code>ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</code>会加载所有在<code>META-INF/services/java.sql.Driver</code>文件里边的类到JVM内存，完成驱动的自动加载，也就我们讲的<code>ServiceLoader</code>加载JDBC驱动机制</p><p>这个自动加载采用的技术叫做<code>SPI</code>，<strong>在JDBC 4.0之后实际上我们不需要再调用<code>Class.forName</code>来加载驱动程序了，我们只需要把驱动的jar包放到工程的类加载路径里，那么驱动就会被自动加载</strong></p><p>这就是<code>SPI</code>的优势所在，能够自动的加载类到JVM内存。这个技术在阿里的<code>dubbo</code>框架里面也占到了很大的分量。</p><h2 id="registerDriver"><a href="#registerDriver" class="headerlink" title="registerDriver"></a>registerDriver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用DriverManager注册给定的驱动程序。 </span></span><br><span class="line"><span class="comment"> * 新加载的驱动程序类应调用方法registerDriver使其自身为DriverManager所知。 </span></span><br><span class="line"><span class="comment"> * 如果驱动程序当前已注册，则不执行任何操作。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver 要在DriverManager中注册的新JDBC驱动程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span><br><span class="line">        <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        registerDriver(driver, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>registerDriver(driver, null);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span><br><span class="line"><span class="params">            DriverAction da)</span></span><br><span class="line">        <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果它还没有被添加到驱动的列表,则注册驱动程序</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="literal">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> <span class="title class_">DriverInfo</span>(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">&quot;registerDriver: &quot;</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个驱动列表定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已注册JDBC驱动程序列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h1 id="DriverManager-getConnection"><a href="#DriverManager-getConnection" class="headerlink" title="DriverManager.getConnection"></a>DriverManager.getConnection</h1><p>我们加载完驱动后就可以连接数据库，但是我们并没有看到mysql相关信息，接着我们看下<code>getConnection</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试建立到给定数据库URL的连接。</span></span><br><span class="line"><span class="comment"> * 驱动程序管理器尝试从已注册的JDBC驱动程序集中选择适当的驱动程序。</span></span><br><span class="line"><span class="comment"> * 注意:如果user或password属性也指定为url的一部分，则实现定义为哪个值优先。</span></span><br><span class="line"><span class="comment"> * 为了获得最大的可移植性，应用程序应该只指定一个属性一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(String url,</span></span><br><span class="line"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        java.util.<span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="literal">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//Reflection.getCallerClass():调用者的类加载器实例，在本程序中即main的类加载器</span></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着会发现会去调用getConnection三个参数的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(</span></span><br><span class="line"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当callerCl为null时，我们应检查应用程序（间接调用此类）类加载器，</span></span><br><span class="line"><span class="comment">     * 以便可以从此处加载rt.jar外部的JDBC驱动程序类。</span></span><br><span class="line"><span class="comment">     * 从这个简单程序来看，这个caller其实是系统类加载器，因为main类的加载器就是系统类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">callerCL</span> <span class="operator">=</span> caller != <span class="literal">null</span> ? caller.getClassLoader() : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// 同步加载正确的类加载器</span></span><br><span class="line">     <span class="comment">// 如果为根类加载器的话，则会返回当前线程的上下文类加载器</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="literal">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line"><span class="comment">//DriverInfo:已注册驱动程序的包装类</span></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line"><span class="comment">//如果调用者没有加载驱动程序的权限，则跳过它。</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="literal">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个项目里边很可能会即连接MySQL，又连接Oracle，这样在一个工程里边就存在了多个驱动类，那么这些驱动类又是怎么区分的呢？</p><p>关键点就在于<code>getConnection</code>的步骤，<code>DriverManager.getConnection</code>中会遍历所有已经加载的驱动实例去创建连接，当一个驱动创建连接成功时就会返回这个连接，同时不再调用其他的驱动实例。如上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是每个驱动实例都真真实实的要尝试建立连接呢？不是的！</p><p>每个驱动实例在getConnetion的第一步就是按照url判断是不是符合自己的处理规则，是的话才会和db建立连接。比如，MySQL驱动类中的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acceptsURL</span><span class="params">(String url)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> (parseURL(url, <span class="literal">null</span>) != <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Properties <span class="title function_">parseURL</span><span class="params">(String url, Properties defaults)</span></span><br><span class="line">            <span class="keyword">throws</span> java.sql.SQLException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">urlProps</span> <span class="operator">=</span> (defaults != <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">Properties</span>(defaults)</span><br><span class="line">                : <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.startsWithIgnoreCase(url, URL_PREFIX)</span><br><span class="line">                &amp;&amp; !StringUtils.startsWithIgnoreCase(url, MXJ_URL_PREFIX)</span><br><span class="line">                &amp;&amp; !StringUtils.startsWithIgnoreCase(url,</span><br><span class="line">                        LOADBALANCE_URL_PREFIX)</span><br><span class="line">                &amp;&amp; !StringUtils.startsWithIgnoreCase(url,</span><br><span class="line">                        REPLICATION_URL_PREFIX)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p><a href="https://www.mygu.club/java-dyna-load-db-drv.html">Java动态加载数据库驱动 | Mingyu’s Blog | 我荒废的今日，正是昨天殒身之人祈求的明日</a></p><p><a href="http://www.voidcn.com/article/p-gqtpvojz-bro.html">JDBC驱动加载机制 - 程序园</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql外键与级联操作</title>
      <link href="/2019/06/20/Mysql%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/06/20/Mysql%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>外键与级联更新删除</p><span id="more"></span><p>之前没用过外键与级联更新，所以总结一下，用的数据库版本：</p><p><code>mysql  Ver 8.0.15 for linux-glibc2.12 on x86_64 (MySQL Community Server - GPL)</code></p><hr><h1 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>外键（foreign key）</strong> 是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。</p><p>MySQL有两种常用的引擎类型：<code>MyISAM</code>和<code>InnoDB</code>。目前只有<code>InnoDB</code>引擎类型支持外键约束。</p><p>外键的好处：可以使得两张表关联，保证数据的一致性和实现一些级联操作；</p><h2 id="外键术语"><a href="#外键术语" class="headerlink" title="外键术语"></a>外键术语</h2><ul><li>外键约束</li><li>外键字段：某个字段添加外键约束之后，该字段称为外键字段</li><li>外键值：外键字段中的每一个数据都是外键值</li></ul><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p>什么？看完定义还不知道是什么？那就试试看下面咯</p><hr><p>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>小明</td></tr><tr><td>2</td><td>小红</td></tr></tbody></table></div><p>我们还可以在<code>classes</code>表中确定任意一个班级记录：</p><div class="table-container"><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table></div><p>但是我们如何确定<code>students</code>表的一条记录，例如，<code>id=1</code>的小明，属于哪个班级呢？</p><p>由于一个班级可以有多个学生，在关系模型中，这两个表的关系可以称为“一对多”，即一个<code>classes</code>的记录可以对应多个<code>students</code>表的记录。</p><p>为了表达这种一对多的关系，我们需要在<code>students</code>表中加入一列<code>class_id</code>，让它的值与<code>classes</code>表的某条记录相对应：</p><div class="table-container"><table><thead><tr><th>id</th><th>class_id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>小明</td></tr><tr><td>2</td><td>1</td><td>小红</td></tr><tr><td>5</td><td>2</td><td>小白</td></tr></tbody></table></div><p>这样，我们就可以根据<code>class_id</code>这个列直接定位出一个<code>students</code>表的记录应该对应到<code>classes</code>的哪条记录。</p><p>例如：</p><ul><li>小明的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小红的<code>class_id</code>是<code>1</code>，因此，对应的<code>classes</code>表的记录是<code>id=1</code>的一班；</li><li>小白的<code>class_id</code>是<code>2</code>，因此，对应的<code>classes</code>表的记录是<code>id=2</code>的二班。</li></ul><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code></p><p>结论：为了保证<code>students</code>表中的<code>class_id</code>字段中的数据必须来自于<code>classes</code>表中<code>id</code>字段中的数据，有必要给<code>students</code>表中的<code>class_id</code>字段添加外键约束，<code>class_id</code>字段被称为外键字段，该字段中的1 2被称为外键值。<code>class_id</code>这里是一个单一外键字段</p><h2 id="注意事项与主从表"><a href="#注意事项与主从表" class="headerlink" title="注意事项与主从表"></a>注意事项与主从表</h2><ul><li><p>外键值可以为<code>null</code></p></li><li><p>外键字段去引用一张表的某个字段的时候，被引用的字段必须具有<code>unique</code>约束。</p></li><li><p>有了外键引用之后，表分为父表和子表</p><p>  <strong>当两个表建立一对多关系的时候，”一”的那一端是父表，”多”的那一端是子表。</strong></p><p> 父表设置一个主键<br> 子表设置一个外键<br> 外键与主键相关联<br> B表引用A表的字段作为外键，那么A表是主表，B表是从表。</p><p> 以上父表是：<code>classes</code>表<br> 字表是：<code>students</code>表<br> 创建表：先创建父表，再创建子表；<br> 删除数据：先删除子表中的数据，再删除父表中的数据；<br> 插入数据：先插入父表中的数据，再插入子表中的数据。</p></li></ul><h2 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h2><p><strong>建立外键关系的对应列必须建立了索引</strong></p><h3 id="Alter方式"><a href="#Alter方式" class="headerlink" title="Alter方式"></a>Alter方式</h3><p>外键并不是通过列名实现的，而是通过定义外键约束实现的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id);</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>外键约束的名称<code>fk_class_id</code>可以任意，不用名字的话可以去掉<code>CONSTRAINT fk_class_id</code></li><li><code>FOREIGN KEY (class_id)</code>指定了<code>class_id</code>作为外键</li><li><code>REFERENCES classes (id)</code>指定了这个外键将关联到<code>classes</code>表的<code>id</code>列（即<code>classes</code>表的主键）。</li></ul><h3 id="Create-Table方式"><a href="#Create-Table方式" class="headerlink" title="Create Table方式"></a>Create Table方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">    class_id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    INDEX(class_id),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(id),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (class_id) <span class="keyword">REFERENCES</span> classes (id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN KEY</span> fk_class_id;</span><br></pre></td></tr></table></figure><p>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN ...</code>实现的。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="单一外键"><a href="#单一外键" class="headerlink" title="单一外键"></a>单一外键</h3><p>给一个字段添加外键约束，如上面的样例</p><h3 id="复合外键"><a href="#复合外键" class="headerlink" title="复合外键"></a>复合外键</h3><p>给多个字段联合添加一个外键约束</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>通过一个表的外键关联到另一个表，我们可以定义出一对多关系。有些时候，还需要定义“多对多”关系。例如，一个老师可以对应多个班级，一个班级也可以对应多个老师，因此，班级表和老师表存在多对多关系。</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个中间表，关联两个一对多关系，就形成了多对多关系：</p><h3 id="teachers表"><a href="#teachers表" class="headerlink" title="teachers表"></a>teachers表</h3><div class="table-container"><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>张老师</td></tr><tr><td>2</td><td>王老师</td></tr><tr><td>3</td><td>李老师</td></tr><tr><td>4</td><td>赵老师</td></tr></tbody></table></div><h3 id="classes表"><a href="#classes表" class="headerlink" title="classes表"></a>classes表</h3><div class="table-container"><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>一班</td></tr><tr><td>2</td><td>二班</td></tr></tbody></table></div><h3 id="teacher-class表"><a href="#teacher-class表" class="headerlink" title="teacher_class表"></a>teacher_class表</h3><p>中间表<code>teacher_class</code>关联两个一对多关系：</p><div class="table-container"><table><thead><tr><th>id</th><th>teacher_id</th><th>class_id</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>2</td></tr><tr><td>3</td><td>2</td><td>1</td></tr><tr><td>4</td><td>2</td><td>2</td></tr><tr><td>5</td><td>3</td><td>1</td></tr><tr><td>6</td><td>4</td><td>2</td></tr></tbody></table></div><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><p>通过中间表<code>teacher_class</code>可知<code>teachers</code>到<code>classes</code>的关系：</p><ul><li><code>id=1</code>的张老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=2</code>的王老师对应<code>id=1,2</code>的一班和二班；</li><li><code>id=3</code>的李老师对应<code>id=1</code>的一班；</li><li><code>id=4</code>的赵老师对应<code>id=2</code>的二班。</li></ul><p>同理可知<code>classes</code>到<code>teachers</code>的关系：</p><ul><li><code>id=1</code>的一班对应<code>id=1,2,3</code>的张老师、王老师和李老师；</li><li><code>id=2</code>的二班对应<code>id=1,2,4</code>的张老师、王老师和赵老师；</li></ul><p>因此，通过中间表，我们就定义了一个“多对多”关系。</p><p><strong>多对多关系的外键则是在中间表中的两个字段上设置两个外键</strong></p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>一对一关系是指，一个表的记录对应到另一个表的唯一一个记录。</p><p>例如，<code>students</code>表的每个学生可以有自己的联系方式，如果把联系方式存入另一个表<code>contacts</code>，我们就可以得到一个“一对一”关系：</p><div class="table-container"><table><thead><tr><th>id</th><th>student_id</th><th>mobile</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>135xxxx6300</td></tr><tr><td>2</td><td>2</td><td>138xxxx2209</td></tr><tr><td>3</td><td>5</td><td>139xxxx8086</td></tr></tbody></table></div><p>有细心的童鞋会问，既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，<strong>一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表</strong>。</p><p><strong>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能</strong>。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><hr><p>为什么会提高查询速度？</p><ul><li>学生的联系信息不完整，有的没有手机号，在一个表格里就会有Null存在。而放在另一个表格里，没有手机号的学生就没有记录。避免null，性能更快</li><li>一般来说重要的核心信息是大家都明确有的一定要收集到的，比如名字和身份号。一些不核心的信息会根据情况表现不完整，且平常对这些信息的使用也不频繁，因此放在另一个表格中就<strong>避免每次访问数据库都要连带操作这些信息。</strong></li></ul><h1 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h1><p>在删除父表中的数据的时候，级联删除子表中的数据<code>on delete cascade</code></p><p>在更新父表中的数据时候，级联更新子表中的数据<code>on update cascade</code></p><p>级联操作在外键约束后面添加</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> students(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">    class_id <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    INDEX(class_id),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span>(id),</span><br><span class="line">    <span class="keyword">FOREIGN KEY</span> (class_id) <span class="keyword">REFERENCES</span> classes (id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> students</span><br><span class="line"><span class="keyword">ADD CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN KEY</span> (class_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> classes (id)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure><h1 id="外键的性能问题"><a href="#外键的性能问题" class="headerlink" title="外键的性能问题"></a>外键的性能问题</h1><ul><li>数据库需要维护外键的内部管理</li><li>外键等于把数据的一致性事务实现，全部交给数据库服务器完成</li><li>有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源</li><li>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况</li></ul><h1 id="是否使用外键"><a href="#是否使用外键" class="headerlink" title="是否使用外键"></a>是否使用外键</h1><p>外键是否采用看业务应用场景，以及开发成本的，大致列下什么时候适合，什么时候不适合使用：</p><h2 id="不适合"><a href="#不适合" class="headerlink" title="不适合"></a>不适合</h2><p>互联网行业应用不推荐使用外键： 用户量大，并发度高，为此数据库服务器很容易成为性能瓶颈，尤其受IO能力限制，且不能轻易地水平扩展；若是把数据一致性的控制放到事务中，也即让应用服务器承担此部分的压力，而引用服务器一般都是可以做到轻松地水平的伸缩；</p><h2 id="适合"><a href="#适合" class="headerlink" title="适合"></a>适合</h2><ul><li>软件应用的人数有限，换句话说是可控的</li><li>数据库服务器的数据量也一般不会超大，且活跃数据有限</li></ul><p>综合上述2句话描述，也即数据库服务器的性能不是问题，所以不用过多考虑性能的问题；另外，使用外键可以降低开发成本，借助数据库产品自身的触发器可以实现表与关联表之间的数据一致性和更新；最后一点，使用外键的方式，还可以做到开发人员和数据库设计人员的分工，可以为程序员承担更多的工作量；</p><p>参考：</p><p><a href="https://blog.51cto.com/wushank/1641308">MySQL的几个概念：主键，外键，索引，唯一索引 -秋天的童话-51CTO博客</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1218728424164736">外键 - 廖雪峰的官方网站</a></p><p><a href="https://www.jianshu.com/p/4517c3e13657">MySql—约束和级联操作 - 简书</a></p><p><a href="https://segmentfault.com/a/1190000007135310">mysql之外键约束（级联操作等） 父表子表 - 飞翔的大象 - SegmentFault 思否</a></p><p><a href="https://www.zhihu.com/question/19600081">大家设计数据库时使用外键吗？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 外键 </tag>
            
            <tag> 级联 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块算法</title>
      <link href="/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/"/>
      <url>/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>分块算法</p><span id="more"></span><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><ul><li><p>其实，分块是一种思想，而不是一种数据结构，<strong>整体维护，局部暴力</strong></p></li><li><p>分块算法实质上是一种是通过分成多块后在每块上打标记以实现快速区间修改，区间查询的一种算法。其均摊时间复杂度为$O(\sqrt{n})$，在$n=10^5$时，由于常数小，跟线段树可能差不多。</p></li><li><p>分块算法相较于各种树形数据结构，具有简便易写，方便调试等多种优点。在同等数据规模下，如 1e5 ，其时间效率并不会低太多，在考试时反而是一种有力的得分方法。</p></li></ul><h1 id="基本操作及性质"><a href="#基本操作及性质" class="headerlink" title="基本操作及性质"></a>基本操作及性质</h1><p>为了使得其有着最稳定的时间复杂度，我们经常把一个长度为 n 的序列分为 $\sqrt{n}$个大小为$\sqrt{n}$的块，如果 n 不是完全平方数，则序列最右端会多出一个角块（其实是根据均值不等式，这样划分是时间复杂度最小的）</p><p>如下图，就是一种序列的分块：</p><p><img src="/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/1.jpg" alt></p><p>该长度为 10 的序列被分为了 4 块，前三块的大小为 $\sqrt{10}$的近似值 3 ，最后一个角块大小为 1</p><hr><p>而我们要记录的一个值，就是每个序号代表的数，属于哪一块</p><p>如上图， 1,2,3就属于第一块， 4,5,6就属于第二块，7,8,9就属于第三块，10 就属于第四块</p><p>可以得到获取每一个序号的所在块的代码是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">//总个数</span></span><br><span class="line"><span class="type">int</span> block=<span class="built_in">sqrt</span>(n);<span class="comment">//每一块大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//belong[i]：第i个数所在块的编号</span></span><br><span class="line">    belong[i]=(i<span class="number">-1</span>)/block<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间最值"><a href="#区间最值" class="headerlink" title="区间最值"></a>区间最值</h1><p>但是，如何用分块来维护区间最值？</p><p>我们举个例子:</p><p>给定一个长的为n数列，求出任意区间$[l,r]$的最大值$(1&lt;=l,r&lt;=n)(l&lt;=r)$</p><p><img src="/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/2.png" alt></p><p><strong>我们现在给每个点上加了一个权值，每个块维护一下块内最大值</strong></p><p>当我们查询任意一个区间$ [l,r]$时：</p><ul><li><p>如果$l$所在的块与$r$所在的块相同，如$[1,2]$，则直接暴力查询即可，时间复杂度  $O(\sqrt{n})$（每块有 $\sqrt{n}$个数，角块除外）</p></li><li><p>若其不在一个块但是块是相邻的，一样是暴力查询，时间复杂度$O(\sqrt{n})$</p></li><li>若其块不相邻，如$[1,10]$，我们先处理两边的边块角块，先暴力查询$1$和$10$所在的块内最大值，最后直接查询中间块内最大值即可，时间复杂度$O(\sqrt{n})$（因为我们已经统计了个每个块的最大值了，所以查询中间块的最大值即是$O(\sqrt{n})$，最终加起来还是$O(\sqrt{n})$）</li></ul><h1 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h1><p>对于整块修改，我们打个加法标记，即当前块增加了多少，最大值相应的就增加了多少</p><p>所以总时间复杂度也是$O(\sqrt{n})$</p><h1 id="分块的实质"><a href="#分块的实质" class="headerlink" title="分块的实质"></a>分块的实质</h1><p>分块其实是一种树形结构，它是一种只有三层的树，形态如下：</p><p><img src="/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/3.png" alt></p><p>第一层为整个序列，第二层为$\sqrt{n}$个大小为$\sqrt{n}$的序列(近似)，第三层为$n$个大小为$1$的序列</p><h1 id="分块与树状数组，线段树对比"><a href="#分块与树状数组，线段树对比" class="headerlink" title="分块与树状数组，线段树对比"></a>分块与树状数组，线段树对比</h1><p>树状数组和线段树的效率均为$O(nlogn)$，树状数组常数较小，分块效率为$O(n\sqrt{n})$</p><p>一般树状数组常数优秀的话可以承受到1e6的数据范围</p><p>线段树可以承受5e5的数据范围</p><p>分块可以承受5e4的数据范围，常数优秀的话可以承受1e5的数据范围</p><p>树状数组最难理解，代码实现最简单</p><p>线段树较易理解，代码实现最复杂，常数较之树状数组会比较大</p><p>分块易理解，代码实现难度适中，复杂度较高</p><p>所以请根据实际情况选择不同的算法</p><h1 id="分块基本模板"><a href="#分块基本模板" class="headerlink" title="分块基本模板"></a>分块基本模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E5</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * num:分块个数</span></span><br><span class="line"><span class="comment"> * belong[i]:i属于哪一块</span></span><br><span class="line"><span class="comment"> * L[i]:i这块的左端点位置</span></span><br><span class="line"><span class="comment"> * R[i]:右端点位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> num, belong[MAXN], L[MAXN], R[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对序列进行分块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    num = n / block;</span><br><span class="line">    <span class="comment">//不是完全数，加一个角块</span></span><br><span class="line">    <span class="keyword">if</span>(n % block)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = (i<span class="number">-1</span>)*block<span class="number">+1</span>;</span><br><span class="line">        R[i] = i*block;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理多出来那个，角块</span></span><br><span class="line">    R[num] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        belong[i] = (i<span class="number">-1</span>)/block<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UESTC-1324"><a href="#UESTC-1324" class="headerlink" title="UESTC 1324"></a><a href="https://acm.uestc.edu.cn/problem/qing-xue-jie-yu-gong-zhu/description">UESTC 1324</a></h1><p><img src="/2019/06/16/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95/4.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Problem:卿学姐与公主</span></span><br><span class="line"><span class="comment">Time:2019-06-16 21:15:57</span></span><br><span class="line"><span class="comment">Lang:GNU G++</span></span><br><span class="line"><span class="comment">Case:12 / 12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span><span class="number">+7</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * num:分块个数</span></span><br><span class="line"><span class="comment"> * belong[i]:i属于哪一块</span></span><br><span class="line"><span class="comment"> * L[i]:第i块的左端点位置</span></span><br><span class="line"><span class="comment"> * R[i]:右端点位置</span></span><br><span class="line"><span class="comment"> * Max[i]:第i块中的最大值</span></span><br><span class="line"><span class="comment"> * arr[i]: 第i个士兵受到的伤害</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> block, belong[MAXN], num, L[MAXN], R[MAXN], n, q;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Max[MAXN] = &#123;<span class="number">0</span>&#125;, arr[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对序列进行分块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    num = n / block;</span><br><span class="line">    <span class="keyword">if</span>(n % block)</span><br><span class="line">        num++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = (i<span class="number">-1</span>) * block + <span class="number">1</span>;</span><br><span class="line">        R[i] = i * block;</span><br><span class="line">    &#125;</span><br><span class="line">    R[num] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        belong[i] = (i<span class="number">-1</span>) / block + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始化每一块中的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)</span><br><span class="line">            Max[i] = <span class="built_in">max</span>(Max[i], arr[j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[x] += y;</span><br><span class="line">    <span class="comment">//更新x所在块的最大值</span></span><br><span class="line">    Max[belong[x]] = <span class="built_in">max</span>(Max[belong[x]], arr[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//在同一块的话直接暴力</span></span><br><span class="line">    <span class="keyword">if</span>(belong[x] == belong[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= y; i++)</span><br><span class="line">            ans = <span class="built_in">max</span>(arr[i], ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理左端点所在块的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= R[belong[x]]; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, arr[i]);</span><br><span class="line">    <span class="comment">//处理除左端点所在块以外的块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = belong[x]<span class="number">+1</span>; i &lt; belong[y]; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, Max[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L[belong[y]]; i &lt;= y; i++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, arr[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="built_in">build</span>();</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;op, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">update</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">ask</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.luogu.org/blog/48265/qian-tan-ji-chu-gen-hao-suan-fa-fen-kuai">浅谈基础根号算法——分块</a></p><p><a href="https://oi-wiki.org/ds/square-root-decomposition/">OIWIKI-分块思想</a></p><p><a href="https://www.cnblogs.com/henry-1202/p/10124856.html">分块入门与分块的经典应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-ServiceLoader</title>
      <link href="/2019/06/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-ServiceLoader/"/>
      <url>/2019/06/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-ServiceLoader/</url>
      
        <content type="html"><![CDATA[<p>ServiceLoader-javaDoc</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Driver;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;drive:&quot;</span> + driver.getClass() + <span class="string">&quot;,loader:&quot;</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前上下文类加载器：&quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;ServiceLoader的类加载器:&quot;</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drive:<span class="keyword">class</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver,loader:sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">当前上下文类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">ServiceLoader的类加载器:<span class="literal">null</span></span><br></pre></td></tr></table></figure><h1 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceLoader</span>&lt;S&gt; <span class="keyword">extends</span> <span class="title class_">Object</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;S&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A simple service-provider loading facility.</span><br><span class="line">一个简单的服务提供商加载设施。</span><br><span class="line">A service is a well-known set of interfaces and (usually abstract) classes.</span><br><span class="line">服务是一组众所周知的接口和（通常是抽象的）类。</span><br><span class="line">A service provider is a specific implementation of a service.</span><br><span class="line">服务提供商是服务的具体实现。</span><br><span class="line">The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. </span><br><span class="line">提供者中的类通常实现接口并对服务本身定义的类进行子类化</span><br><span class="line">Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. </span><br><span class="line">服务提供者可以以扩展的形式安装在Java平台的实现中，即，将jar文件放入任何通常的扩展目录中。</span><br><span class="line">Providers can also be made available by adding them to the application&#x27;s class path or by some other platform-specific means.</span><br><span class="line">提供程序也可以通过将它们添加到应用程序的class path或其他特定于平台的方法来提供</span><br><span class="line">For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class. (A concrete class can be used, but this is not recommended.)</span><br><span class="line">出于加载的目的，服务由单个类型表示，即单个接口或抽象类。（可以使用具体类，但不建议这样做。）</span><br><span class="line">A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider.</span><br><span class="line">给定服务的提供者包提供程序类的详细信息往往是高度特定于服务的; 没有单个类或接口可以统一它们，所以这里没有定义这样的类型。含一个或多个具体类，这些类使用特定于提供者的数据和代码扩展此服务类型。</span><br><span class="line">The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand.</span><br><span class="line">提供者类通常不是整个提供者本身，而是包含足够信息的代理，以确定提供者是否能够满足特定请求以及可以按需创建实际提供者的代码</span><br><span class="line">The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here. </span><br><span class="line">提供者类的详细信息往往是高度特定于服务的; 没有单个类或接口可以统一它们，所以这里没有定义这样的类型。</span><br><span class="line">The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.</span><br><span class="line">此工具强制执行的唯一要求是提供者类必须具有零参数构造函数，以便可以在加载期间实例化它们。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services.</span><br><span class="line">通过将提供者配置文件放在资源目录META-INF/services中来标识服务提供者。</span><br><span class="line">The file&#x27;s name is the fully-qualified binary name of the service&#x27;s type.</span><br><span class="line">文件名是服务类型的完全限定二进制名称</span><br><span class="line">The file contains a list of fully-qualified binary names of concrete provider classes, one per line. </span><br><span class="line">该文件包含具体提供者类的完全限定二进制名称列表，每行一个。</span><br><span class="line">Space and tab characters surrounding each name, as well as blank lines, are ignored.</span><br><span class="line">每个名称周围的空格和制表符(tab)以及空行都将被忽略。</span><br><span class="line">The comment character is &#x27;#&#x27; (&#x27;\u0023&#x27;, NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</span><br><span class="line">注释字符为&#x27;＃&#x27;（&#x27;\ u0023&#x27;，NUMBER SIGN）; 在每一行上，忽略第一个注释字符后面的所有字符。 该文件必须以UTF-8编码。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. </span><br><span class="line">如果一个特定的具体提供程序类在多个配置文件中命名，或者在同一配置文件中多次命名，则忽略重复的配置文件。</span><br><span class="line">The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself.</span><br><span class="line">命名特定提供者的配置文件不必与提供程序本身位于同一jar文件或其他分发单元中。</span><br><span class="line">The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.</span><br><span class="line">提供程序必须可以从与定位寻找配置文件的类加载器加载; 请注意，这不一定是实际加载文件的类加载器。</span><br></pre></td></tr></table></figure><hr><p>从这里我们可以看出，<code>ServiceLoader</code>是从<code>META-INF/services</code>来定位jar包的，然后读取文件中的限定名</p><p><img src="/2019/06/11/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-ServiceLoader/1.png" alt></p><p>所以上面就的输出正好验证了这一个</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Providers are located and instantiated lazily, that is, on demand. </span><br><span class="line">提供者可以延迟地定位和实例化，即按需提供。</span><br><span class="line">A service loader maintains a cache of the providers that have been loaded so far.</span><br><span class="line">服务加载器会维护到目前为止已经加载的提供程序的缓存</span><br><span class="line">Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn.The cache can be cleared via the reload method.</span><br><span class="line">每次调用iterator方法都会返回一个迭代器，首先按照实例化顺序生成缓存的所有元素，然后延迟地定位和实例化任何剩余的提供程序，依次将每个元素添加到缓存中。 缓存可以通过reload方法清除。</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存提供程序，以实例化顺序排列</span></span><br><span class="line"><span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>通过上面可以看到的，缓存是通过一个HashMap来存储的</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Instances of this class are not safe for use by multiple concurrent threads.</span><br><span class="line">此类的实例不能安全地被多个并发线程使用。</span><br><span class="line">Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.</span><br><span class="line">除非另有说明，否则传递null参数到此类中的任何方法将导致抛出NullPointerException </span><br><span class="line">Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder/decoder pairs for some protocol. In this case it is an abstract class with two abstract methods:</span><br><span class="line">示例假设我们有一个服务类型com.example.CodecSet，用于表示一些协议的编码器/解码器对的集合。在这种情况下，它是一个抽象类，有两个抽象方法：</span><br><span class="line">public abstract Encoder getEncoder(String encodingName);</span><br><span class="line">public abstract Decoder getDecoder(String encodingName);</span><br><span class="line"></span><br><span class="line">Each method returns an appropriate object or null if the provider does not support the given encoding. Typical providers support more than one encoding.</span><br><span class="line">每个方法返回一个适当的对象，如果提供者不支持给定的编码，则返回null。 典型的提供程序支持多种编码</span><br><span class="line"></span><br><span class="line">If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named META-INF/services/com.example.CodecSet</span><br><span class="line">如果com.example.impl.StandardCodecs是CodecSet服务的实现，那么它的jar文件还包含一个名为META-INF/services/com.example.CodecSet的文件</span><br><span class="line"></span><br><span class="line">此文件包含单行：</span><br><span class="line">com.example.impl.StandardCodecs    # Standard codecs</span><br><span class="line"></span><br><span class="line">CodecSet类在初始化时创建并保存单个服务实例：</span><br><span class="line">private static ServiceLoader&lt;CodecSet&gt; codecSetLoader</span><br><span class="line">     = ServiceLoader.load(CodecSet.class);</span><br><span class="line">     </span><br><span class="line">为了找到一个给定的编码名称的编码器，它定义了一个静态工厂方法，它遍历已知和可用的提供者，只有当它找到一个合适的编码器或已经用完提供者时才返回。</span><br><span class="line"> public static Encoder getEncoder(String encodingName) &#123;</span><br><span class="line">     for (CodecSet cp : codecSetLoader) &#123;</span><br><span class="line">         Encoder enc = cp.getEncoder(encodingName);</span><br><span class="line">         if (enc != null)</span><br><span class="line">             return enc;</span><br><span class="line">     &#125;</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="load的调用链"><a href="#load的调用链" class="headerlink" title="load的调用链"></a>load的调用链</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用当前线程的上下文类加载器为给定的服务类型创建新的服务加载器。</span></span><br><span class="line"><span class="comment"> * 调用ServiceLoader.load(service)等于调用</span></span><br><span class="line"><span class="comment"> * ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> service 表示服务的接口或抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@type</span> parameter &lt;S&gt; 服务类型的类 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个新的服务加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为给定的服务类型和类加载器创建新的服务加载器。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> service 表示服务的接口或抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 用于加载提供程序配置文件和提供程序类的类加载器</span></span><br><span class="line"><span class="comment"> * 如果要使用系统类加载器（或者，失败，则使用引导类加载器），即为null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 一个新的服务加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    <span class="comment">//安全方面设置</span></span><br><span class="line">    acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除此加载程序的提供程序缓存，以便重新加载所有提供程序。</span></span><br><span class="line"><span class="comment"> * 在调用此方法之后，迭代器方法的后续调用将从头开始延时地查找和实例化提供程序，就像新创建的加载器一样</span></span><br><span class="line"><span class="comment"> * 此方法适用于可以将新提供程序安装到正在运行的Java虚拟机中的情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> <span class="title class_">ServiceLoader</span>.LazyIterator(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有内部类实现完全延时的提供者查找</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LazyIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;S&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="literal">null</span>;</span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">nextName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.service = service;</span><br><span class="line">            <span class="built_in">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * private static final String PREFIX = &quot;META-INF/services/&quot;;</span></span><br><span class="line"><span class="comment">                 * 可以看到，其寻找的路径还是规范中所写的路径</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取到驱动文件中每一行的内容，比如mysql.sql.jdbc.driver</span></span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName; </span><br><span class="line">            nextName = <span class="literal">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cn 之前获取到每一行的内容，即驱动的完全限定名</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> flase 代表不初始化</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> loader 指定了类加载器，这里即是线程上下文类加载器</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">                c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;   ...   &#125;</span><br><span class="line">        <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;   ...   &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;   ...   &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>可以看到，迭代器的方法实际上还是调用之前<code>reload</code>方法里面创建的<code>lookupIterator</code>里面的方法，有着延时加载的特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时加载此加载程序服务的可用提供程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> S <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="更改线程上下文类加载器"><a href="#更改线程上下文类加载器" class="headerlink" title="更改线程上下文类加载器"></a>更改线程上下文类加载器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Driver;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更改线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().</span><br><span class="line">                  setContextClassLoader(Test.class.getClassLoader().getParent());</span><br><span class="line"></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;drive:&quot;</span> + driver.getClass() + <span class="string">&quot;,loader:&quot;</span> + driver.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前上下文类加载器：&quot;</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;ServiceLoader的类加载器:&quot;</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前上下文类加载器：sun.misc.Launcher$ExtClassLoader@677327b6</span><br><span class="line">ServiceLoader的类加载器:<span class="literal">null</span></span><br></pre></td></tr></table></figure><p><code>Test.class.getClassLoader()</code>的classLoader是系统类加载器，那么其父加载器则是扩展类加载器，所以程序输出扩展类加载器，<strong>又因为扩展类加载器寻找的路径里面的文件不包含驱动所在文件，所以循环没有输出</strong>。</p><hr><p>修改线程上下文类加载器为默认后，可以打印出类加载器情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded indi.greenhat.jvm.Test from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br><span class="line">...</span><br><span class="line">[Loaded com.mysql.cj.jdbc.NonRegisteringDriver from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">[Loaded com.mysql.cj.jdbc.Driver from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">[Loaded com.mysql.cj.exceptions.CJException from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">...</span><br><span class="line">[Loaded com.mysql.cj.exceptions.UnsupportedConnectionStringException from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">...</span><br><span class="line">[Loaded com.mysql.cj.exceptions.UnableToConnectException from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">[Loaded com.mysql.cj.jdbc.AbandonedConnectionCleanupThread from file:/home/cc/Downloads/Hib/mysql-connector-java-<span class="number">8.0</span><span class="number">.15</span>.jar]</span><br><span class="line">...</span><br><span class="line">[Loaded com.mysql.cj.jdbc.AbandonedConnectionCleanupThread$$Lambda$<span class="number">1</span>/<span class="number">1595428806</span> from com.mysql.cj.jdbc.AbandonedConnectionCleanupThread]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-线程上下文加载器</title>
      <link href="/2019/06/10/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2019/06/10/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p> 线程上下文加载器</p><span id="more"></span><h1 id="线程上下文类加载器重要性"><a href="#线程上下文类加载器重要性" class="headerlink" title="线程上下文类加载器重要性"></a>线程上下文类加载器重要性</h1><p>首先我们看两行输出语句，第一个是输出Thread对象的上下文类加载器，而第二个是输出Thread类的加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * currentThread():</span></span><br><span class="line"><span class="comment">         * 返回对当前正在执行的线程对象的引用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * getContextClassLoader():</span></span><br><span class="line"><span class="comment">         * 返回此Thread的上下文ClassLoader</span></span><br><span class="line"><span class="comment">         * 上下文ClassLoader由线程的创建者提供，供加载类和资源时在此线程中运行的代码使用</span></span><br><span class="line"><span class="comment">         * 如果未设置，则默认为父线程的ClassLoader上下文</span></span><br><span class="line"><span class="comment">         * 原始线程的上下文ClassLoader通常设置为用于加载应用程序的类加载器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>我们先看null，表示的是启动类加载器，因为Thread类是位于Java核心包里面，所以当然是由启动类加载器加载的。</p><p>解释第一条例子前先看一点概念：</p><ul><li><strong>当前类加载器（Current ClassLoader）</strong></li></ul><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类），如果ClasssX引用了ClassY，那么ClassX的类加载器就会去加载ClassY（前提是ClassY尚未被加载）</p><ul><li><strong>线程上文类加载器（Context ClassLoader）</strong></li></ul><ol><li><p>线程上下文加载器是从JDK1.2开始引入的，类Thread中的<code>getContextClassLoader</code>与<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置上下文类加载器</p></li><li><p>如果没有通过<code>setContextClassLoader(ClassLoader cl)</code>进行设置的话，线程将继承其父线程的上下文类加载器。</p></li><li><p>Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类与资源。</p></li><li><p>线程上文类加载器重要性：</p></li></ol><p>其实很简单，<strong>就是为了解决类加载器命名空间的限制</strong>。在双亲委托机制下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。在SPI（Service Provider Interface）场景下，<strong>有些接口是Java核心库提供的，并且是由启动类加载器来加载的，而这些接口的实现却来自不同的jar包（实现厂商提供），Java的启动类加载器是不会加载其它来源的Jar包</strong>，这样传统的双亲委托机制无法满足SPI要求。通过给当前线程设置上下文类加载器，就可以由其负责加载接口实现的类。</p><p>就好像JDBC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(dataBase, usrName, passWord);</span><br><span class="line">stm = con.createStatement();</span><br></pre></td></tr></table></figure><p>一些接口是本来已经存在于JDK中，而驱动包（接口的实现）则是厂商提供的。</p><p><strong>所以，父ClassLoader可以使用当前线程<code>Thread.currentThread().getContextLoader()</code>所指定的ClassLoader加载的类。这样就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委派模型。</strong></p><p>当高层提供了统一的接口让底层去实现，同时又要在高层加载（或实例化）底层的类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。</p><hr><p><strong>线程上下文加载器就是当前线程的Current Loader</strong></p><p>因为Java应用运行时的初始线程的上下文类加载器是系统类加载器，所以第一行输出的是系统类加载器</p><p>为什么呢？</p><p>从Launcher类的构造函数就可以看出，默认是设置为系统类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="comment">//用于启动应用程序的类加载器</span></span><br><span class="line">       loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">...</span><br><span class="line">       <span class="comment">// 为原始线程设置上下文类加载器。</span></span><br><span class="line">       Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h1 id="线程上下文类加载器使用"><a href="#线程上下文类加载器使用" class="headerlink" title="线程上下文类加载器使用"></a>线程上下文类加载器使用</h1><p>线程上下文类加载器的一般使用模式：（获取—使用—还原）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.currentThread().setContextClassLoader(customerLoader);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用了Thread.currentThread().getContextClassLoader()</span></span><br><span class="line"><span class="comment">     * 获取当前线程上下文类加载器做某些事情</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    myMethod(); </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    Thread,currentThread().setContextClassLoader(classLoader); <span class="comment">//还原，以供下次使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 线程上下文类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在ArchLinux中使用最新的内核模块监控Ryzen温度</title>
      <link href="/2019/06/09/%E5%9C%A8ArchLinux%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7Ryzen%E6%B8%A9%E5%BA%A6/"/>
      <url>/2019/06/09/%E5%9C%A8ArchLinux%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7Ryzen%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>AMD Ryzen Temperatures</p><span id="more"></span><p>参考:</p><p><a href="https://linuxconfig.org/monitor-amd-ryzen-temperatures-in-linux-with-latest-kernel-modules">Monitor AMD Ryzen Temperatures In Linux with latest kernel modules</a></p><hr><p>因为需要查看一些硬件的温度，又加上目前<code>5.1.7-arch1-1-ARCH</code>内核只是显示cpu温度，所以需要自己加载一些模块，其实过程还是很简单的</p><p>要求：</p><p>使用内核4.11或更高版本以及root权限的Linux安装。</p><p>具体流程：</p><h1 id="确定modules"><a href="#确定modules" class="headerlink" title="确定modules"></a>确定modules</h1><p><code>Ryzen</code>板上一般有两种模块。他们是<code>it87</code>和<code>nct6775</code>。旧的主板一般是前者，新的一般是后者，具体的可以搜索下，本次使用的<code>MSI B450 TOMAHAWK</code>属于后者</p><h1 id="具体命令"><a href="#具体命令" class="headerlink" title="具体命令"></a>具体命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S linux-headers</span><br><span class="line">yay -S nct6775-master-dkms-git</span><br><span class="line">sudo vim /etc/modules-load.d/modules.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">往文件里面添加<span class="string">&quot;nct6775&quot;</span></span></span><br><span class="line">sudo modprobe nct6775</span><br><span class="line">sudo reboot</span><br><span class="line">sensors</span><br></pre></td></tr></table></figure><p><img src="/2019/06/09/%E5%9C%A8ArchLinux%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E7%9A%84%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9B%91%E6%8E%A7Ryzen%E6%B8%A9%E5%BA%A6/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记-迁移arch到不同硬盘</title>
      <link href="/2019/06/09/%E8%AE%B0-%E8%BF%81%E7%A7%BBarch%E5%88%B0%E4%B8%8D%E5%90%8C%E7%A1%AC%E7%9B%98/"/>
      <url>/2019/06/09/%E8%AE%B0-%E8%BF%81%E7%A7%BBarch%E5%88%B0%E4%B8%8D%E5%90%8C%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>迁移sata固态硬盘中的arch到空的nvme固态硬盘里面</p><span id="more"></span><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p><strong>记原本sata固态硬盘为/dev/sda，nvme固态固态为/dev/nvme</strong></p><p>原sata硬盘分区为，启动方式为uefi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/         --&gt; /dev/sda1</span><br><span class="line">/home     --&gt; /dev/sda2</span><br><span class="line">swap      --&gt; /dev/sda3</span><br><span class="line">/boot/efi --&gt; /dev/sda4</span><br></pre></td></tr></table></figure><p>则我们需要在新的nvme固态硬盘同样分四个区，并且分别格式化为对应的格式，新的硬盘分区不能小于旧的硬盘分区。</p><p>那么迁移过来我们的分区如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/         --&gt; /dev/nvme1 (ext4)</span><br><span class="line">/home     --&gt; /dev/nvme2 (ext4)</span><br><span class="line">swap      --&gt; /dev/nvme3 (linux-swap)</span><br><span class="line">/boot/efi --&gt; /dev/nvme4 (fat32)</span><br></pre></td></tr></table></figure><h1 id="linux-livecd"><a href="#linux-livecd" class="headerlink" title="linux livecd"></a>linux livecd</h1><p>原系统是哪个发行版，则最好用对应发行版的livecd。所以在此准备了个arch linux的livecd</p><p><strong>原本是用manjaro linuxcd的，后来发现有挺多的问题，转换为arch linux的livecd后一路顺畅。</strong></p><h1 id="livecd操作"><a href="#livecd操作" class="headerlink" title="livecd操作"></a>livecd操作</h1><p>接着进入linuxcd后联网。</p><p>这里因为之前在manjaro livecd的时候不小心把boot分区弄没了，所以现在的思路就是复制/和/home分区后，然后<code>arch-chroot</code>进去后弄grub，所以。</p><h2 id="dd拷贝"><a href="#dd拷贝" class="headerlink" title="dd拷贝"></a>dd拷贝</h2><p>拷贝对应的分区，因为dd的会把对应硬盘uuid也拷贝过去，所以不需要更改<code>/etc/fstab</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dd if=/dev/sda1 of=/dev/nvme1</span><br><span class="line">dd if=/dev/sda2 of=/dev/nvme2</span><br><span class="line"></span><br><span class="line">e2fsck -f /dev/nvme1</span><br><span class="line">resize2f /dev/nvme1</span><br><span class="line">e2fsck -f /dev/nvme2</span><br><span class="line">resize2f /dev/nvme2</span><br></pre></td></tr></table></figure><h2 id="操作boot分区"><a href="#操作boot分区" class="headerlink" title="操作boot分区"></a>操作boot分区</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/home</span><br><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line"></span><br><span class="line">mount /dev/nvme1 /mnt</span><br><span class="line">mount /dev/nvme2 /mnt/home</span><br><span class="line">mount /dev/nvme4 /mnt/boot/efi</span><br></pre></td></tr></table></figure><h2 id="arch-chroot"><a href="#arch-chroot" class="headerlink" title="arch-chroot"></a>arch-chroot</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -Sy</span><br><span class="line">pacman -S grub efibootmgr linux</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/mnt/boot/efi --bootloader-id=grub</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">pacman -S amd-ucode</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意此处需要安装linux包，因为部分boot分区也在linux包里面</span></span><br></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br><span class="line">umount -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>然后就可以了</p><p><img src="/2019/06/09/%E8%AE%B0-%E8%BF%81%E7%A7%BBarch%E5%88%B0%E4%B8%8D%E5%90%8C%E7%A1%AC%E7%9B%98/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-代理模式</title>
      <link href="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>代理模式</p><span id="more"></span><p>参考:<a href="https://segmentfault.com/a/1190000011291179">Java三种代理模式：静态代理、动态代理和cglib代理</a></p><p><a href="https://blog.csdn.net/LoveLion/article/details/8227953">C#设计模式之代理模式</a></p><p><a href="https://www.cnblogs.com/yangming1996/p/9254412.html">基于 JDK 的动态代理机制</a></p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><hr><p>举例歌手与经纪人</p><p><img src="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/2.png" alt></p><p><img src="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/3.png" alt></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层</p><p><img src="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/blog_md/Java设计模式-代理模式/1.jpg" alt></p><p><strong>Subject（抽象角色）：</strong>定义代理角色和真实角色的公共对外方法</p><p><strong>Proxy（代理角色）</strong>：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作</p><p><strong>RealSubject（真实角色）：</strong>实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。关注于真正的业务逻辑</p><h2 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a>核心作用</h2><ol><li>通过代理，控制对象的访问：可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即AOP的微观实现）</li><li>AOP(Aspect Oriented Programming 面向切面编程)的核心实现机制</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（<em>RMI</em>:远程方法调用(Remote Method Invocation)）</li><li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p></li><li><p>开发框架中的应用场景：</p><ul><li>struct2中拦截器的实现</li><li>数据库连接池关闭处理</li><li>Hibernate中延时加载的实现</li><li>mybatis中实现拦截器插件</li><li>AspectJ的实现</li><li>spring中AOP的实现：日志拦截，声明式事务处理</li><li>web service</li><li>RMI远程方法调用</li><li>…</li></ul></li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）<ul><li>JDK自带的动态代理</li><li>javaassist字节码操作库实现</li><li>CGLIB</li><li>ASM（底层使用指令，可维护性较差）</li></ul></li></ol><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>这种代理方式需要代理对象和目标对象实现一样的接口</p><ul><li><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能</p></li><li><p>缺点：</p><ol><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li><li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ol></li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>根据前面举例的经纪人和歌手关系来编写简单的实例</p><p><img src="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/4.png" alt></p><p><strong>Star是抽象角色，RealStar是真实角色，ProxyStar是代理角色，client是用户</strong></p><h3 id="Star-java"><a href="#Star-java" class="headerlink" title="Star.java"></a>Star.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StaticProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 面谈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签合同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订飞机票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bookTicket</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唱歌</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收尾款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">CollectMoney</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RealStar-java"><a href="#RealStar-java" class="headerlink" title="RealStar.java"></a>RealStar.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StaticProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真实角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealStar.confer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealStar.signContract&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bookTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealStar.bookTicket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealStar(歌星本人).sing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CollectMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealStar.CollectMoney&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProxyStar-java"><a href="#ProxyStar-java" class="headerlink" title="ProxyStar.java"></a>ProxyStar.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StaticProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyStar</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyStar</span><span class="params">(Star star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.confer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signContract</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.signContract&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bookTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.bookTicket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里和明星不同的是，经纪人不能唱歌</span></span><br><span class="line"><span class="comment">     * 所以只能交给歌手</span></span><br><span class="line"><span class="comment">     * 那么就需要一个歌手对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span> &#123;</span><br><span class="line">        star.sing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CollectMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxyStar.CollectMoney&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Client-java"><a href="#Client-java" class="headerlink" title="Client.java"></a>Client.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> StaticProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Star</span> <span class="variable">real</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealStar</span>();</span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyStar</span>(real);</span><br><span class="line"></span><br><span class="line">        proxy.confer();</span><br><span class="line">        proxy.signContract();</span><br><span class="line">        proxy.bookTicket();</span><br><span class="line">        proxy.sing();</span><br><span class="line">        proxy.CollectMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProxyStar.confer</span><br><span class="line">ProxyStar.signContract</span><br><span class="line">ProxyStar.bookTicket</span><br><span class="line">RealStar(歌星本人).sing</span><br><span class="line">ProxyStar.CollectMoney</span><br></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>抽象角色（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多方法。</p><p>静态代理与动态代理的区别主要在：</p><ul><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li><li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li></ul><h2 id="JDK自带的动态代理"><a href="#JDK自带的动态代理" class="headerlink" title="JDK自带的动态代理"></a>JDK自带的动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br></pre></td></tr></table></figure><p><code>Proxy</code>提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类</p><p>为某个接口创建代理<code>Foo</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(...);</span><br><span class="line">     Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);</span><br><span class="line">     <span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> (Foo) proxyClass.getConstructor(InvocationHandler.class).</span><br><span class="line">                     newInstance(handler); </span><br></pre></td></tr></table></figure><p>或更简单地：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Foo</span> <span class="variable">f</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),</span><br><span class="line">                                         <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; Foo.class &#125;,</span><br><span class="line">                                         handler);</span><br></pre></td></tr></table></figure><p><em>动态代理类</em> （以下简称为<em>代理类</em> ）是一个实现在类创建时在运行时指定的接口列表的类，具有如下所述的行为。</p><p><em>代理接口</em>是由代理类实现的接口。每个代理实例都有一个关联的调用处理程序对象，该对象实现了<code>InvocationHandler</code>接口。通过其代理接口之一对代理实例进行方法调用将被调度到实例调用处理程序的<code>invoke</code>方法，并传递代理实例<code>java.lang.reflect</code>。标识被调用方法的方法对象，以及包含参数的Object类型数组。调用处理程序根据需要处理编码的方法调用，并且它返回的结果将作为代理实例上的方法调用的结果返回。</p><p>代理类具有以下属性:</p><ul><li>代理类是public,final的，不是抽象的，不可继承</li><li>代理对象类名是没有明确定义的，但是以<code>$Proxy</code>开头的类名要给代理对象保留着，所以标准情况下如果发现某个class的类名以<code>$Proxy</code>开头，那它肯定是代理对象，</li><li>代理类扩展了<code>java.lang.reflect.proxy</code>。所以可以用<code>instanceof</code>来判断是否是代理对象</li></ul><hr><p><strong>JDK中生成代理对象主要涉及的类有</strong></p><h3 id="java-lang-reflect-Proxy"><a href="#java-lang-reflect-Proxy" class="headerlink" title="java.lang.reflect Proxy"></a>java.lang.reflect Proxy</h3><p>动态生成代理类和对象，其主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader:用于定义代理类的类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interfaces:要实现的代理类的接口列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h:将方法调用分派到的调用处理程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 具有指定的代理类调用处理程序的代理实例，该代理类由指定的类加载器定义并实现指定的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                          InvocationHandler h)</span> </span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-lang-reflect-InvocationHandler（处理类接口）"><a href="#java-lang-reflect-InvocationHandler（处理类接口）" class="headerlink" title="java.lang.reflect InvocationHandler（处理类接口）"></a>java.lang.reflect InvocationHandler（处理类接口）</h3><p>可以通过<code>invoke</code>方法对真实角色的代理访问，每次通过<code>Proxy</code>生成代理类对象时都要指定对应的处理器对象。其主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理代理实例上的方法调用并返回结果。</span></span><br><span class="line"><span class="comment"> * 在与其关联的代理实例上调用方法时，将在调用处理程序上调用此方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy:调用该方法的代理实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method:对应于在代理实例上调用的接口方法的方法实例。</span></span><br><span class="line"><span class="comment"> * 方法对象的声明类将是方法声明所在的接口，它可能是代理类继承方法的代理接口的超接口。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args:包含在代理实例上的方法调用中传递的参数值的对象数组，如果接口方法不带参数，则返回null。</span></span><br><span class="line"><span class="comment"> * 原始类型的参数包含在适当的原始包装类的实例中，例如java.lang.Integer或java.lang.Boolean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>Star.java，RealStar.java与静态代理的一样</p><p><img src="/2019/06/03/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/5.png" alt></p><h3 id="StarHandler-java"><a href="#StarHandler-java" class="headerlink" title="StarHandler.java"></a>StarHandler.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Star realStar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StarHandler</span><span class="params">(Star realStar)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realStar = realStar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;真正方法执行前！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;面谈，签合同...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;sing&quot;</span>))</span><br><span class="line">            method.invoke(realStar, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;真正方法执行后！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;收尾款&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所有的代理类方法内部都会调用处理器类的 invoke 方法并传入被代理类的当前方法，而这个 invoke 方法可以选择去让 method 正常被调用，也可以跳过 method 的调用，甚至可以在 method 真正被调用前后做一些额外的事情。</strong></p><h3 id="Client-java-1"><a href="#Client-java-1" class="headerlink" title="Client.java"></a>Client.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> DynamicProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Star</span> <span class="variable">realStar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealStar</span>();</span><br><span class="line">        <span class="type">StarHandler</span> <span class="variable">starHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StarHandler</span>(realStar);</span><br><span class="line"></span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;, starHandler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * proxy调用的方法都会跳转到StarHandler.invoke方法里面处理</span></span><br><span class="line"><span class="comment">         * 所以有时候在需要在invoke里面统一处理就行了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        proxy.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">真正方法执行前！</span><br><span class="line">面谈，签合同...</span><br><span class="line">RealStar(歌星本人).sing</span><br><span class="line">真正方法执行后！</span><br><span class="line">收尾款</span><br></pre></td></tr></table></figure><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><p>首先，一个处理器类的定义是必不可少的（比如<code>StarHandler</code>），它的内部必须得关联一个真实对象，即被代理类实例（比如<code>realStar</code>）。</p><p>接着，我们从外部调用代理类的任一方法，代理类方法会转而去调用处理器的 invoke 方法并传入方法签名和方法的形式参数集合（<code>StarHandler.invoke</code>）。</p><p>最后，方法能否得到正常的调用取决于处理器 invoke 方法体是否实实在在去调用了 method 方法。</p><p>其实，基于 JDK 实现的的动态代理是有缺陷的，并且这些缺陷是不易修复的，所以才有了 CGLIB 的流行。</p><h2 id="缺陷与不足"><a href="#缺陷与不足" class="headerlink" title="缺陷与不足"></a>缺陷与不足</h2><h3 id="单一的代理机制"><a href="#单一的代理机制" class="headerlink" title="单一的代理机制"></a>单一的代理机制</h3><p>虚拟机生成的代理类为了公用 Proxy 类中的 <code>InvocationHandler</code>字段来存储自己的处理器类实例而继承了 Proxy 类，那说明了什么？</p><p>Java 的单根继承告诉你，代理类不能再继承任何别的类了，那么被代理类父类中的方法自然就无从获取，即代理类无法代理真实类中父类的任何方法。</p><h3 id="不友好的返回值"><a href="#不友好的返回值" class="headerlink" title="不友好的返回值"></a>不友好的返回值</h3><p><code>newProxyInstance</code>返回值是object，要使用它得强制类型转换</p><p>那么问题来了，假如我们的被代理类实现了多个接口，请问你该强转为那个接口类型，现在假设被代理类实现了接口 A 和 B，那么最后的实例如果强转为 A ，自然被代理类所实现的接口 B 中所有的方法你都不能调用，反之亦然。</p><p>这样就直接导致一个结果，你得清楚哪个方法是哪个接口中的，调用某个方法之前强转为对应的接口，相当不友好的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-Launcher类</title>
      <link href="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/"/>
      <url>/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Launcher类部分内容分析<br> <span id="more"></span></p><h1 id="三种类加载器之间的关系"><a href="#三种类加载器之间的关系" class="headerlink" title="三种类加载器之间的关系"></a>三种类加载器之间的关系</h1><ol><li><p>内建于JVM中的启动类加载器会加载<code>java.lang.ClassLoder</code>以及其他Java平台类，当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器（Bootstrap）。</p></li><li><p>启动类加载器不是Java类，而其他的加载器则都是Java类，启动类加载器是特定于平台的机器指令，它负责开启整个过程。</p></li><li><p>所有类加载器（除了启动类加载器）都被实现为Java类。不过，总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。</p></li><li><p>启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括<code>java.util</code>与<code>java.lang</code>包中的类等等。</p></li></ol><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line"><span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>但是不能直接获取扩展类加载器和系统类加载器，因为没有声明这两个类为public</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Launcher</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们可以用Launcher类的类加载器验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Launcher.class.getClassLoader());</span><br><span class="line"><span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>所以扩展类加载器和系统类加载器也是由启动类加载器就加载的。</p><h1 id="getSystemClassLoader"><a href="#getSystemClassLoader" class="headerlink" title="getSystemClassLoader"></a>getSystemClassLoader</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getSystemClassLoader</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>jdk8文档中有下面内容：</p><blockquote><p>If the system property “java.system.class.loader” is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader</p></blockquote><p>如果在首次调用此方法时定义了系统属性“java.system.class.loader”，那么该属性的值将被视为系统类加载器返回的类的名称。使用默认的系统类加载器加载该类，并且必须定义一个公共构造函数，该构造函数接受类型为ClassLoader的单个参数，该参数用作委托父类。然后使用此构造函数创建一个实例，并使用默认的系统类加载器作为参数。生成的类加载器被定义为系统类加载器。</p><p>那么就是说，如果我们想要更改系统类加载器为自定义类加载器，一是得改变<code>java.system.class.loader</code>，二是在我们的自定义类加载器中添加一个参数为ClassLoader的构造函数</p><hr><p>首先，未更改<code>java.system.class.loade</code>时，输出其值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//indi.greenhat.jvm.Test.java</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">&quot;java.system.class.loader&quot;</span>));</span><br><span class="line"><span class="comment">//输出null</span></span><br></pre></td></tr></table></figure><p>可以发现此时该属性值为null，如果我们不加上面所说的构造函数，直接更改属性值去加载别的类，那么会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.system.class.loader=indi.greenhat.jvm.CustomClassLoader               indi.greenhat.jvm.Test</span><br></pre></td></tr></table></figure><p><img src="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/1.png" alt></p><p>在CustomClassLoader中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indi.greenhat.jvm.CustomClassLoader</span><br></pre></td></tr></table></figure><p>为什么要加入一个这样的方法呢？</p><p>这个与ClassLoader类里面的一个SystemClassLoaderAction类的run方法有关，此方法处理了用户自定义<code>java.system.class.loader</code>属性的情况。处理方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String cls = System.getProperty(&quot;java.system.class.loader&quot;)        </span></span><br><span class="line">Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="literal">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">sys</span> <span class="operator">=</span> (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; parent &#125;);</span><br></pre></td></tr></table></figure><p>因为这时候需要传递一个parent参数进去。</p><h1 id="Launcher构造方法"><a href="#Launcher构造方法" class="headerlink" title="Launcher构造方法"></a>Launcher构造方法</h1><p>来自openjdk8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Launcher</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建扩展类加载器</span></span><br><span class="line">    ClassLoader extcl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//ExtClassLoader:用于加载已安装扩展的类加载器</span></span><br><span class="line">        extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(</span><br><span class="line">            <span class="string">&quot;Could not create extension class loader&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在创建用于启动应用程序的类加载器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//与创建extcl的方法大同小异</span></span><br><span class="line">        loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(</span><br><span class="line">            <span class="string">&quot;Could not create application class loader&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还为原始线程设置上下文类加载器。</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，根据请求安装安全管理器</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.security.manager&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(s) || <span class="string">&quot;default&quot;</span>.equals(s)) &#123;</span><br><span class="line">            sm = <span class="keyword">new</span> <span class="title class_">java</span>.lang.SecurityManager();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sm = (SecurityManager)loader.loadClass(s).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.setSecurityManager(sm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(</span><br><span class="line">                <span class="string">&quot;Could not create SecurityManager: &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ExtClassLoader"><a href="#ExtClassLoader" class="headerlink" title="ExtClassLoader"></a>ExtClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//并行加载</span></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          ClassLoader.registerAsParallelCapable();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个ExtClassLoader,ExtClassLoader是在一个上下文中创建的</span></span><br><span class="line"><span class="comment"> * 该上下文限制了它可以读取的文件,即限制从哪里读取class文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> ExtClassLoader <span class="title function_">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//获得扩展类加载器读取的路径</span></span><br><span class="line">          <span class="keyword">final</span> File[] dirs = getExtDirs(); </span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 此doPrivileged（）块的先前实现通过调用</span></span><br><span class="line"><span class="comment">                * 私有方法ExtClassLoader.getContext（）来提供合成的ACC</span></span><br><span class="line"><span class="comment">                * 用于权限的校验</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">              <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                  <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;ExtClassLoader&gt;() &#123;</span><br><span class="line">                      <span class="keyword">public</span> ExtClassLoader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dirs.length;</span><br><span class="line">                          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                              MetaIndex.registerDirectory(dirs[i]);</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExtClassLoader</span>(dirs);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException e) &#123;</span><br><span class="line">              <span class="keyword">throw</span> (IOException) e.getException();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="ExtClassLoader继承树"><a href="#ExtClassLoader继承树" class="headerlink" title="ExtClassLoader继承树"></a>ExtClassLoader继承树</h2><p><img src="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-Launcher%E7%B1%BB/2.png" alt></p><p>可以看到<code>ExtClassLoader</code>最终还是继承于<code>ClassLoader</code></p><h3 id="getExtDirs"><a href="#getExtDirs" class="headerlink" title="getExtDirs"></a>getExtDirs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">    <span class="comment">//获得扩展类加载器系统属性集</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line">    File[] dirs;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * File.pathSeparator指的是分隔连续多个路径字符串的分隔符</span></span><br><span class="line"><span class="comment">         * 即将获取到的属性集进行分割</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(s, File.pathSeparator);</span><br><span class="line">        <span class="comment">// 得到分割后的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> st.countTokens();</span><br><span class="line">        dirs = <span class="keyword">new</span> <span class="title class_">File</span>[count];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            dirs[i] = <span class="keyword">new</span> <span class="title class_">File</span>(st.nextToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//s为空，dirs为空</span></span><br><span class="line">        dirs = <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getAppClassLoader"><a href="#getAppClassLoader" class="headerlink" title="getAppClassLoader"></a>getAppClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于从java.class.path加载的类加载器。 </span></span><br><span class="line"><span class="comment"> * 在受限制的安全上下文中运行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AppClassLoader</span> <span class="keyword">extends</span> <span class="title class_">URLClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 并行加载</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            ClassLoader.registerAsParallelCapable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader extcl)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.class.path&quot;</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] path = (s == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">File</span>[<span class="number">0</span>] : getClassPath(s);</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;AppClassLoader&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> AppClassLoader <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    URL[] urls =</span><br><span class="line">                        (s == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">URL</span>[<span class="number">0</span>] : pathToURLs(path);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppClassLoader</span>(urls, extcl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的AppClassLoader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">            AppClassLoader(URL[] urls, ClassLoader parent) &#123;</span><br><span class="line">            <span class="built_in">super</span>(urls, parent, factory);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-类加载器与web容器与OSGi</title>
      <link href="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8%E4%B8%8EOSGi/"/>
      <url>/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8%E4%B8%8EOSGi/</url>
      
        <content type="html"><![CDATA[<p>类加载器与 Web 容器，类加载器与 OSGi</p><span id="more"></span><p>参考:<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html">深入探讨 Java 类加载器</a></p><p><a href="https://juejin.im/post/5a59f2296fb9a01ca871eb8c">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a></p><h1 id="类加载器与Web容器"><a href="#类加载器与Web容器" class="headerlink" title="类加载器与Web容器"></a>类加载器与Web容器</h1><p>对于运行在<code>Java EE™</code>容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。</p><h2 id="Apache-Tomcat"><a href="#Apache-Tomcat" class="headerlink" title="Apache Tomcat"></a>Apache Tomcat</h2><p>以<code>Apache Tomcat</code>来说，每个 Web 应用都有一个对应的类加载器实例。<strong>该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的</strong>。这是 <code>Java Servlet</code>规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。<strong>这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</strong></p><p><img src="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8%E4%B8%8EOSGi/2.png" alt></p><h2 id="Tomcat加载过程"><a href="#Tomcat加载过程" class="headerlink" title="Tomcat加载过程"></a>Tomcat加载过程</h2><p><img src="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8%E4%B8%8EOSGi/1.png" alt></p><p>我们看到，前面3个类加载和默认的一致，<code>CommonClassLoader</code>，<code>CatalinaClassLoader</code>，<code>SharedClassLoader</code>和<code>WebappClassLoader</code>则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中<code>WebApp</code>类加载器和Jsp类加载器通常会存在多个实例，<strong>每一个Web应用程序</strong>对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p><ul><li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li><li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li><li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li><li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；</li></ul><hr><p><strong>图中的委派关系</strong></p><ol><li>CommonClassLoader能加载的类都可以被Catalina ClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，而CatalinaClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离。</li><li>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</li><li>而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：</p><ul><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 <code>WEB-INF/classes</code>和 <code>WEB-INF/lib</code>目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li></ul><h1 id="类加载器与-OSGi"><a href="#类加载器与-OSGi" class="headerlink" title="类加载器与 OSGi"></a>类加载器与 OSGi</h1><p><code>OSGi™</code>是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。</p><p>OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 <code>Import-Package</code>），也可以声明导出（export）自己的包和类，供其它模块使用（通过 <code>Export-Package</code>）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。<strong>OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 <code>java</code>开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载</strong>。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 <code>org.osgi.framework.bootdelegation</code>的值即可。</p><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><p><img src="/2019/06/02/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B8%8Eweb%E5%AE%B9%E5%99%A8%E4%B8%8EOSGi/3.png" alt></p><p>假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 <code>com.bundleA.Sample</code>，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 <code>com.bundleA.Sample</code>，并包含一个类 <code>com.bundleB.NewSample</code>继承自 <code>com.bundleA.Sample</code>。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 <code>com.bundleB.NewSample</code>，进而需要加载类 <code>com.bundleA.Sample</code>。由于 bundleB 声明了类 <code>com.bundleA.Sample</code>是导入的，classLoaderB 把加载类 <code>com.bundleA.Sample</code>的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类 <code>com.bundleA.Sample</code>并定义它，所得到的类 <code>com.bundleA.Sample</code>实例就可以被所有声明导入了此类的模块使用。对于以 <code>java</code>开头的类，都是由父类加载器来加载的。如果声明了系统属性 <code>org.osgi.framework.bootdelegation=com.example.core.*</code>，那么对于包 <code>com.example.core</code>中的类，都是由父类加载器来完成的。</p><hr><p>OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
            <tag> OSGI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-工厂模式Java实现</title>
      <link href="/2019/05/31/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/31/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>工厂模式的java实现</p><span id="more"></span><p>代码地址：</p><p><a href="https://github.com/GreenHatHG/blog_md/tree/master/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/Code">github</a></p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p><img src="/2019/05/31/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/1.png" alt></p><h2 id="pizza"><a href="#pizza" class="headerlink" title="pizza"></a>pizza</h2><h3 id="Pizza-java"><a href="#Pizza-java" class="headerlink" title="Pizza.java"></a>Pizza.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象Pizza类，其他种类都继承这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pizza名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 面团</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String dough;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调味汁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String sauce;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;String&gt; toppings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 准备</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 烘焙</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Baking &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cutting &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包装</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cutting &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">display</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        display.append(<span class="string">&quot;---- &quot;</span> + name + <span class="string">&quot; ----\n&quot;</span>);</span><br><span class="line">        display.append(<span class="string">&quot;dough:&quot;</span> + dough + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        display.append(<span class="string">&quot;sauce:&quot;</span> + sauce + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        display.append(<span class="string">&quot;toppings:&quot;</span> + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String topping : toppings)&#123;</span><br><span class="line">            display.append(topping + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> display.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CheesePizza-java"><a href="#CheesePizza-java" class="headerlink" title="CheesePizza.java"></a>CheesePizza.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheesePizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Cheese Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Regular Crust&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;Marinara Pizza Sauce&quot;</span>;</span><br><span class="line">        toppings.add(<span class="string">&quot;Fresh Mozzarella&quot;</span>);</span><br><span class="line">        toppings.add(<span class="string">&quot;Parmesan&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ClamPizza-java"><a href="#ClamPizza-java" class="headerlink" title="ClamPizza.java"></a>ClamPizza.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClamPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClamPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Clam Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Thin crust&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;White garlic sauce&quot;</span>;</span><br><span class="line">        toppings.add(<span class="string">&quot;Clams&quot;</span>);</span><br><span class="line">        toppings.add(<span class="string">&quot;Grated parmesan cheese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h2><h3 id="SimplePizzaFactory-java"><a href="#SimplePizzaFactory-java" class="headerlink" title="SimplePizzaFactory.java"></a>SimplePizzaFactory.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pizza.CheesePizza;</span><br><span class="line"><span class="keyword">import</span> pizza.ClamPizza;</span><br><span class="line"><span class="keyword">import</span> pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂用于制作pizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePizzaFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;clam&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ClamPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><h3 id="PizzaStore-java"><a href="#PizzaStore-java" class="headerlink" title="PizzaStore.java"></a>PizzaStore.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Factory.SimplePizzaFactory;</span><br><span class="line"><span class="keyword">import</span> pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pizza店，用于订购Pizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    SimplePizzaFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 工厂制作处type类型的Pizza</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pizza = factory.createPizza(type);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 烘焙，切片，打包等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Customer-java"><a href="#Customer-java" class="headerlink" title="Customer.java"></a>Customer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Factory.SimplePizzaFactory;</span><br><span class="line"><span class="keyword">import</span> Store.PizzaStore;</span><br><span class="line"><span class="keyword">import</span> pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟顾客购买pizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建工厂并且创建一个PizzaStore对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SimplePizzaFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimplePizzaFactory</span>();</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PizzaStore</span>(factory);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> store.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;We ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.println(pizza);</span><br><span class="line"></span><br><span class="line">        pizza = store.orderPizza(<span class="string">&quot;clam&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;We ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        System.out.println(pizza);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Preparing Cheese Pizza</span><br><span class="line">Baking Cheese Pizza</span><br><span class="line">Cutting Cheese Pizza</span><br><span class="line">Cutting Cheese Pizza</span><br><span class="line">We ordered a Cheese Pizza</span><br><span class="line"></span><br><span class="line">---- Cheese Pizza ----</span><br><span class="line">dough:Regular Crust</span><br><span class="line">sauce:Marinara Pizza Sauce</span><br><span class="line">toppings:</span><br><span class="line">Fresh Mozzarella</span><br><span class="line">Parmesan</span><br><span class="line"></span><br><span class="line">Preparing Clam Pizza</span><br><span class="line">Baking Clam Pizza</span><br><span class="line">Cutting Clam Pizza</span><br><span class="line">Cutting Clam Pizza</span><br><span class="line">We ordered a Clam Pizza</span><br><span class="line"></span><br><span class="line">---- Clam Pizza ----</span><br><span class="line">dough:Thin crust</span><br><span class="line">sauce:White garlic sauce</span><br><span class="line">toppings:</span><br><span class="line">Clams</span><br><span class="line">Grated parmesan cheese</span><br></pre></td></tr></table></figure><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p><img src="/2019/05/31/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/2.png" alt></p><h2 id="Pizza"><a href="#Pizza" class="headerlink" title="Pizza"></a>Pizza</h2><h3 id="Pizza-java-1"><a href="#Pizza-java-1" class="headerlink" title="Pizza.java"></a>Pizza.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String dough;</span><br><span class="line">    <span class="keyword">public</span> String sauce;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;String&gt; toppings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Prepare &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Tossing dough...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding sauce...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Adding toppings: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String topping : toppings) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;   &quot;</span> + topping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bake for 25 minutes at 350&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cut the pizza into diagonal slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Place pizza in official PizzaStore box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">display</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        display.append(<span class="string">&quot;---- &quot;</span> + name + <span class="string">&quot; ----\n&quot;</span>);</span><br><span class="line">        display.append(dough + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        display.append(sauce + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String topping : toppings) &#123;</span><br><span class="line">            display.append(topping + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> display.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NYStyle"><a href="#NYStyle" class="headerlink" title="NYStyle"></a>NYStyle</h3><h4 id="NYStyleCheesePizza-java"><a href="#NYStyleCheesePizza-java" class="headerlink" title="NYStyleCheesePizza.java"></a>NYStyleCheesePizza.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza.NYStyle;</span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纽约式CheesePizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NYStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NYStyleCheesePizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;NY Style Sauce and Cheese Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Thin Crust Dough&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;Marinara Sauce&quot;</span>;</span><br><span class="line"></span><br><span class="line">        toppings.add(<span class="string">&quot;Grated Reggiano Cheese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NYStyleClamPizza-java"><a href="#NYStyleClamPizza-java" class="headerlink" title="NYStyleClamPizza.java"></a>NYStyleClamPizza.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza.NYStyle;</span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纽约式ClamPizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NYStyleClamPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NYStyleClamPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;NY Style Clam Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Thin Crust Dough&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;Marinara Sauce&quot;</span>;</span><br><span class="line"></span><br><span class="line">        toppings.add(<span class="string">&quot;Grated Reggiano Cheese&quot;</span>);</span><br><span class="line">        toppings.add(<span class="string">&quot;Fresh Clams from Long Island Sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChicagoStyle"><a href="#ChicagoStyle" class="headerlink" title="ChicagoStyle"></a>ChicagoStyle</h3><h4 id="ChicagoStyleCheesePizza-java"><a href="#ChicagoStyleCheesePizza-java" class="headerlink" title="ChicagoStyleCheesePizza.java"></a>ChicagoStyleCheesePizza.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza.ChicagoStyle;</span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 芝加哥式CheesePizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoStyleCheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChicagoStyleCheesePizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Chicago Style Deep Dish Cheese Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Extra Thick Crust Dough&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;Plum Tomato Sauce&quot;</span>;</span><br><span class="line"></span><br><span class="line">        toppings.add(<span class="string">&quot;Shredded Mozzarella Cheese&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cutting the pizza into square slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ChicagoStyleClamPizza-java"><a href="#ChicagoStyleClamPizza-java" class="headerlink" title="ChicagoStyleClamPizza.java"></a>ChicagoStyleClamPizza.java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza.ChicagoStyle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 芝加哥式ClamPizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoStyleClamPizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChicagoStyleClamPizza</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Chicago Style Clam Pizza&quot;</span>;</span><br><span class="line">        dough = <span class="string">&quot;Extra Thick Crust Dough&quot;</span>;</span><br><span class="line">        sauce = <span class="string">&quot;Plum Tomato Sauce&quot;</span>;</span><br><span class="line"></span><br><span class="line">        toppings.add(<span class="string">&quot;Shredded Mozzarella Cheese&quot;</span>);</span><br><span class="line">        toppings.add(<span class="string">&quot;Frozen Clams from Chesapeake Bay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cutting the pizza into square slices&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Store-1"><a href="#Store-1" class="headerlink" title="Store"></a>Store</h2><h3 id="PizzaStore-java-1"><a href="#PizzaStore-java-1" class="headerlink" title="PizzaStore.java"></a>PizzaStore.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 制作item类型的Pizza</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 需要item类的Pizza</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Pizza</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String item)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span>&#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> createPizza(type);</span><br><span class="line">        System.out.println(<span class="string">&quot;--- Making a &quot;</span> + pizza.getName() + <span class="string">&quot; ---&quot;</span>);</span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NYPizzaStore-java"><a href="#NYPizzaStore-java" class="headerlink" title="NYPizzaStore.java"></a>NYPizzaStore.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Pizza.NYStyle.*;</span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纽约Pizza店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NYPizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String item)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYStyleCheesePizza</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;clam&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYStyleClamPizza</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChicagoPizzaStore-java"><a href="#ChicagoPizzaStore-java" class="headerlink" title="ChicagoPizzaStore.java"></a>ChicagoPizzaStore.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Pizza.ChicagoStyle.*;</span><br><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 芝加哥Pizza店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String item)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (item) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChicagoStyleCheesePizza</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;clam&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChicagoStyleClamPizza</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Customer-java-1"><a href="#Customer-java-1" class="headerlink" title="Customer.java"></a>Customer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"><span class="keyword">import</span> Store.ChicagoPizzaStore;</span><br><span class="line"><span class="keyword">import</span> Store.NYPizzaStore;</span><br><span class="line"><span class="keyword">import</span> Store.PizzaStore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟顾客购买pizza</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 开两家店</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">nyStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NYPizzaStore</span>();</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">chicagoStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChicagoPizzaStore</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 纽约式CheesePizza</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> nyStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Ethan ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 购买芝加哥式CheesePizza</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pizza = chicagoStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Joel ordered a &quot;</span> + pizza.getName() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- Making a NY Style Sauce and Cheese Pizza ---</span><br><span class="line">Prepare NY Style Sauce and Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Grated Reggiano Cheese</span><br><span class="line">Bake <span class="keyword">for</span> <span class="number">25</span> minutes at <span class="number">350</span></span><br><span class="line">Cut the pizza into diagonal slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Ethan ordered a NY Style Sauce and Cheese Pizza</span><br><span class="line"></span><br><span class="line">--- Making a Chicago Style Deep Dish Cheese Pizza ---</span><br><span class="line">Prepare Chicago Style Deep Dish Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Shredded Mozzarella Cheese</span><br><span class="line">Bake <span class="keyword">for</span> <span class="number">25</span> minutes at <span class="number">350</span></span><br><span class="line">Cutting the pizza into square slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Joel ordered a Chicago Style Deep Dish Cheese Pizza</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p><img src="/2019/05/31/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FJava%E5%AE%9E%E7%8E%B0/3.png" alt></p><p>篇幅较长，只贴上部分代码</p><h2 id="Ingredient"><a href="#Ingredient" class="headerlink" title="Ingredient"></a>Ingredient</h2><h3 id="Cheese-java"><a href="#Cheese-java" class="headerlink" title="Cheese.java"></a>Cheese.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Ingredient.Cheese;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">    String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MozzarellaCheese-java"><a href="#MozzarellaCheese-java" class="headerlink" title="MozzarellaCheese.java"></a>MozzarellaCheese.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Ingredient.Cheese;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Ingredient.Cheese.Cheese;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MozzarellaCheese</span> <span class="keyword">implements</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Shredded Mozzarella&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReggianoCheese-java"><a href="#ReggianoCheese-java" class="headerlink" title="ReggianoCheese.java"></a>ReggianoCheese.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Ingredient.Cheese;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReggianoCheese</span> <span class="keyword">implements</span> <span class="title class_">Cheese</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Reggiano Cheese&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IngredientFactory"><a href="#IngredientFactory" class="headerlink" title="IngredientFactory"></a>IngredientFactory</h2><h3 id="ChicagoPizzaIngredientFactory-java"><a href="#ChicagoPizzaIngredientFactory-java" class="headerlink" title="ChicagoPizzaIngredientFactory.java"></a>ChicagoPizzaIngredientFactory.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> IngredientFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Ingredient.Cheese.*;</span><br><span class="line"><span class="keyword">import</span> Ingredient.Dough.*;</span><br><span class="line"><span class="keyword">import</span> Ingredient.Sauce.*;</span><br><span class="line"><span class="keyword">import</span> Ingredient.Veggies.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 芝加哥原料工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoPizzaIngredientFactory</span> <span class="keyword">implements</span> <span class="title class_">PizzaIngredientFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dough <span class="title function_">createDough</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThickCrustDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Sauce <span class="title function_">createSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlumTomatoSauce</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cheese <span class="title function_">createCheese</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MozzarellaCheese</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Veggies[] createVeggies() &#123;</span><br><span class="line">        Veggies[] veggies = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BlackOlives</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Spinach</span>(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Eggplant</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> veggies;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pizza-1"><a href="#Pizza-1" class="headerlink" title="Pizza"></a>Pizza</h2><h3 id="CheesePizza-java-1"><a href="#CheesePizza-java-1" class="headerlink" title="CheesePizza.java"></a>CheesePizza.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Pizza;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> IngredientFactory.PizzaIngredientFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheesePizza</span> <span class="keyword">extends</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原料工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PizzaIngredientFactory ingredientFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheesePizza</span><span class="params">(PizzaIngredientFactory ingredientFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ingredientFactory = ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 原料工厂制作原料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Preparing &quot;</span> + name);</span><br><span class="line">        dough = ingredientFactory.createDough();</span><br><span class="line">        sauce = ingredientFactory.createSauce();</span><br><span class="line">        cheese = ingredientFactory.createCheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Store-2"><a href="#Store-2" class="headerlink" title="Store"></a>Store</h2><h3 id="ChicagoPizzaStore-java-1"><a href="#ChicagoPizzaStore-java-1" class="headerlink" title="ChicagoPizzaStore.java"></a>ChicagoPizzaStore.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Store;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> IngredientFactory.ChicagoPizzaIngredientFactory;</span><br><span class="line"><span class="keyword">import</span> IngredientFactory.PizzaIngredientFactory;</span><br><span class="line"><span class="keyword">import</span> Pizza.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 芝加哥Pizza店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoPizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Pizza <span class="title function_">createPizza</span><span class="params">(String item)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">PizzaIngredientFactory</span> <span class="variable">ingredientFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChicagoPizzaIngredientFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 制作item类型的Pizza</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (item)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;cheese&quot;</span>:</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>(ingredientFactory);</span><br><span class="line">                pizza.setName(<span class="string">&quot;Chicago Style Cheese Pizza&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;clam&quot;</span>:</span><br><span class="line">                pizza = <span class="keyword">new</span> <span class="title class_">ClamPizza</span>(ingredientFactory);</span><br><span class="line">                pizza.setName(<span class="string">&quot;Chicago Style Clam Pizza&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Customer-java-2"><a href="#Customer-java-2" class="headerlink" title="Customer.java"></a>Customer.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Pizza.Pizza;</span><br><span class="line"><span class="keyword">import</span> Store.ChicagoPizzaStore;</span><br><span class="line"><span class="keyword">import</span> Store.NYPizzaStore;</span><br><span class="line"><span class="keyword">import</span> Store.PizzaStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">nyStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NYPizzaStore</span>();</span><br><span class="line">        <span class="type">PizzaStore</span> <span class="variable">chicagoStore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChicagoPizzaStore</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> nyStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Ethan ordered a &quot;</span> + pizza + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        pizza = chicagoStore.orderPizza(<span class="string">&quot;cheese&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Joel ordered a &quot;</span> + pizza + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">--- Making a NY Style Sauce and Cheese Pizza ---</span><br><span class="line">Prepare NY Style Sauce and Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Grated Reggiano Cheese</span><br><span class="line">Bake <span class="keyword">for</span> <span class="number">25</span> minutes at <span class="number">350</span></span><br><span class="line">Cut the pizza into diagonal slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Ethan ordered a NY Style Sauce and Cheese Pizza</span><br><span class="line"></span><br><span class="line">--- Making a Chicago Style Deep Dish Cheese Pizza ---</span><br><span class="line">Prepare Chicago Style Deep Dish Cheese Pizza</span><br><span class="line">Tossing dough...</span><br><span class="line">Adding sauce...</span><br><span class="line">Adding toppings: </span><br><span class="line">   Shredded Mozzarella Cheese</span><br><span class="line">Bake <span class="keyword">for</span> <span class="number">25</span> minutes at <span class="number">350</span></span><br><span class="line">Cutting the pizza into square slices</span><br><span class="line">Place pizza in official PizzaStore box</span><br><span class="line">Joel ordered a Chicago Style Deep Dish Cheese Pizza</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式-工厂模式</title>
      <link href="/2019/05/30/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/30/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>《Head first设计模式》之工厂模式</p><span id="more"></span><p>按照这本书以披萨店为例子讲解，工厂模式分为<code>简单工厂模式</code>，<code>工厂方法模式</code>，<code>抽象工厂模式</code></p><p>参考：<a href="http://www.importnew.com/23499.html"><a href="http://www.importnew.com/23499.html">http://www.importnew.com/23499.html</a></a></p><p><a href="https://github.com/crazysunj/crazysunj.github.io/wiki/工厂模式">https://github.com/crazysunj/crazysunj.github.io/wiki/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F</a></p><p><a href="https://www.jianshu.com/p/78c4d93fab87">https://www.jianshu.com/p/78c4d93fab87</a></p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="预定披萨"><a href="#预定披萨" class="headerlink" title="预定披萨"></a>预定披萨</h2><p>假设有一家披萨店，预定披萨的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Pizza <span class="title function_">orderPizza</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pizza</span>();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 准备面皮，加调料等</span></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    <span class="comment">// 烘烤</span></span><br><span class="line">    pizza.bake();</span><br><span class="line">    <span class="comment">// 切片</span></span><br><span class="line">    pizza.cut();</span><br><span class="line">    <span class="comment">//包装</span></span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多披萨类型</p><p>刚刚只是一个Pizza类型，现在需要更多的披萨类型。所以代码可以改为如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在把披萨类型传入orderPizza</span></span><br><span class="line">Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据披萨的类型，我们实例化正确的具体类，然后将其赋值给pizza实例变量。</span></span><br><span class="line">    <span class="comment">// 请注意，这里的任何披萨都必须实现pizza接口</span></span><br><span class="line">     <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;greek&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">PepperoniPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 准备面皮，加调料等</span></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    <span class="comment">// 烘烤</span></span><br><span class="line">    pizza.bake();</span><br><span class="line">    <span class="comment">// 切片</span></span><br><span class="line">    pizza.cut();</span><br><span class="line">    <span class="comment">//包装</span></span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改披萨类型"><a href="#修改披萨类型" class="headerlink" title="修改披萨类型"></a>修改披萨类型</h2><p>现在需要对披萨类型进行增加和删除，假定去掉<code>greek</code>披萨，并且增加个<code>clam</code>披萨，所以可以修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在把披萨类型传入orderPizza</span></span><br><span class="line">Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span>&#123;</span><br><span class="line">    Pizza pizza;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据披萨的类型，我们实例化正确的具体类，然后将其赋值给pizza实例变量。</span></span><br><span class="line">    <span class="comment">// 请注意，这里的任何披萨都必须实现pizza接口</span></span><br><span class="line">     <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">        pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line"><span class="comment">//    &#125; else if (type.equals(&quot;greek&quot;)) &#123;</span></span><br><span class="line"><span class="comment">//        pizza = new GreekPizza();</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">          pizza = <span class="keyword">new</span> <span class="title class_">PepperoniPizza</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;clam&quot;</span>)) &#123;</span><br><span class="line">          pizza = <span class="keyword">new</span> <span class="title class_">clamPizza</span>();</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// 这里是我们不想改变的地方。因为披萨的准备、烘烤、包装，多年来持续不变</span></span><br><span class="line">    <span class="comment">// 所以这部分的代码不会改变，只有发生这些动作的披萨会改变</span></span><br><span class="line">    pizza.prepare();</span><br><span class="line">    pizza.bake();</span><br><span class="line">    pizza.cut();</span><br><span class="line">    pizza.box();</span><br><span class="line">    <span class="keyword">return</span> pizza;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此看来，我们又得去改方法里面的具体代码，但是改着改着，我们会发现，我们改的都是同一个地方，是的，具体的pizza不停的变，而其它的都没变。</p><p>现在我们已经知道哪些会改变，哪些不会改变，该是使用封装的时候了。封装可以让我们将要修改的部分放到别的地方，从而不用修改<code>orderPizza</code>类，专注于需要修改的地方。现在最好将创建对象移到<code>orderPizza()</code>之外，但怎么做呢？我们可以把创建披萨的代码移到另一个对象中，由这个新对象专职创建披萨。</p><hr><p><strong>我们称这个新对象为“工厂”</strong></p><p>工厂（<code>factory</code>）处理创建对象的细节。一旦有了<code>SimplePizzaFactory</code>，<code>orderPizza()</code>就变成此对象的客户。当需要披萨时，就叫披萨工厂做一个。</p><p>现在<code>orderPizza()</code>方法只关心从工厂得到了一个披萨，而这个披萨实现了Pizza接口，所以它可以调用<code>prepare()</code>，<code>bake()</code>，<code>cut()</code>，<code>box()</code>来分别进行准备、烘烤、切片、装盒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现在我们为PizzaStore加上一个对SimplePizzaFactory的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    SimplePizzaFactory factory;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// PizzaStore的构造器，需要一个工厂作为参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PizzaStore</span><span class="params">(SimplePizzaFactory factory)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// orderPizza()方法通过简单传入订单类型来使用工厂创建披萨。</span></span><br><span class="line">        <span class="comment">// 请注意，我们把new操作符替换成工厂对象的创建方法。这里不再使用具体实例化</span></span><br><span class="line">        pizza = factory.createPizza(type);</span><br><span class="line"> </span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimplePizzaFactory是我们的新类，它只做一件事情：帮它的客户创建披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimplePizzaFactory</span> &#123;</span><br><span class="line">    <span class="comment">// 首先，在这个工厂内定义一个createPizza()方法，所有客户用这个方法来实例化新对象。</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 这是从orderPizza()方法中移过来的代码</span></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">CheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">PepperoniPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;clam&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ClamPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式方法"><a href="#工厂模式方法" class="headerlink" title="工厂模式方法"></a>工厂模式方法</h1><h2 id="加盟店"><a href="#加盟店" class="headerlink" title="加盟店"></a>加盟店</h2><p>我们的品牌越做越大，总是并免不了加盟这玩意，作为老板，那么你必须严格细查这些加盟店的质量，加盟店可能来自不同的地区，风味不同，不妨说纽约、芝加哥、加州。</p><p>第一种想法就是，建立3个不同的工厂，传入PizzaStore即可。但是这种感觉是，3个厂加工了比萨之后，只能放在我的店里卖的节奏哈？</p><p>那我们为什么不把制造pizza抽象出来呢，同时店也抽象出来，不同的店去做不同类型的pizza，不是更好么？但都是在我品牌下。</p><hr><p>首先，我们先对<code>PizzaStore</code>做出改变，把<code>createPizza()</code>方法放回到PizzaStore中，不过要把它设置成“抽象方法”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">orderPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 现在createPizza()方法从工厂对象中移回PizzaStore</span></span><br><span class="line">        pizza = createPizza(type);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 这些都没变</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 现在把工厂对象移到这个方法中</span></span><br><span class="line">    <span class="comment">// 在PizzaStore里，“工厂方法”现在是抽象的</span></span><br><span class="line">    <span class="comment">// 每个子类都会覆盖createPizza()方法</span></span><br><span class="line">    <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经有一个PizzaStore作为超类；让加盟店（NYPizzaStore，ChicagoPizzaStore，CaliforniaPizzaStore）都继承这个PizzaStore，每个子类各自决定如何制作披萨。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果加盟店为顾客提供纽约风味的披萨，就使用NyStylePizzaStore，</span></span><br><span class="line"><span class="comment">// 因为此类的createPizza()方法会建立纽约风味的披萨</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NyStylePizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">NyStyleCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">NyStylePepperoniPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;clam&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">NyStyleClamPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;veggie&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">NyStyleVeggiePizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似的，利用芝加哥子类，我们得到了带芝加哥原料的createPizza()实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoStylePizzaStore</span> <span class="keyword">extends</span> <span class="title class_">PizzaStore</span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;cheese&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChicagoCheesePizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pepperoni&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChicagoPepperoniPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;clam&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChicagoClamPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;veggie&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChicagoVeggiePizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="地区差异材料不同"><a href="#地区差异材料不同" class="headerlink" title="地区差异材料不同"></a>地区差异材料不同</h2><p>每个加盟店因为口味不同所使用的材料也会不同，有的是A面团，有的是B面团，按照之前的那种观念，我们同样可以把pizza改为抽象类，这样就可以由加盟店自己决定材料了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;pizza&quot;</span>;<span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">dough</span> <span class="operator">=</span> <span class="string">&quot;dough&quot;</span>;<span class="comment">//面团</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">sauce</span> <span class="operator">=</span> <span class="string">&quot;sauce&quot;</span>;<span class="comment">//调味汁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preparing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cut&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 抽象类Pizza提供名称、面团、调味汁、配料的属性，子类可以在构造方法中赋值，这样就打造了不同的口味，更友好一点，可以在prepare()或者构造函数等地方赋值默认值。也可以指定默认材料，如果子类不更改，则造出默认pizza。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>现在加盟店打算使使用别的类型材料以减少它们的成本，所以我们需要改变材料的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;pizza&quot;</span>;<span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Dough</span> <span class="variable">dough</span> <span class="operator">=</span> <span class="string">&quot;dough&quot;</span>;<span class="comment">//面团</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Sauce</span> <span class="variable">sauce</span> <span class="operator">=</span> <span class="string">&quot;sauce&quot;</span>;<span class="comment">//调味汁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preparing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bake&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cut&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以根据类的不一样来实现不一样的原料，然后我们还需要原料工厂去实现这些原料，按照之前，我们先实现一个抽象原料工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PizzaIngredientFctory</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> Dough <span class="title function_">CreateDough</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Sauce <span class="title function_">CreateSauce</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后不同地区的加盟店就可以有不同的原料工厂去造不一样的原料</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChicagoPizzaIngredientFctory</span> implemets PizzaIngredientFctory&#123;</span><br><span class="line">    <span class="keyword">public</span> Dough <span class="title function_">CreateDough</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChicagoDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Sauce <span class="title function_">CreateSauce</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChicagoDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaIngredientFctory</span> implemets PizzaIngredientFctory&#123;</span><br><span class="line">    <span class="keyword">public</span> Dough <span class="title function_">CreateDough</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Sauce <span class="title function_">CreateSauce</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NYDough</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p> 工厂模式已经清晰了，所有工厂模式都用来封装对象的创建，它通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p><h1 id="三种对比"><a href="#三种对比" class="headerlink" title="三种对比"></a>三种对比</h1><h2 id="简单工厂模式-1"><a href="#简单工厂模式-1" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是类的创建模式，又叫做静态工厂方法（<code>Static Factory Method</code>）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。<br>结构如下：</p><p><img src="/2019/05/30/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.webp" alt></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>模式的核心是工厂类。这个类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建对象的责任（比如那个店长）。简单工厂模式通过这种做法实现了对责任的分割。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。并且简单工厂模式违背了开闭原则（对扩展的开放，对修改的关闭）。</p><h2 id="工厂模式方法-1"><a href="#工厂模式方法-1" class="headerlink" title="工厂模式方法"></a>工厂模式方法</h2><p>首先，在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做.这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><p>这种进一步抽象化的结果，使这种工厂方法模式可以用来予许系统在不修改具体工厂角色的情况下引进新的产品，也就遵循了开闭原则。</p><p>结构如下：</p><p><img src="/2019/05/30/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2.webp" alt></p><hr><ol><li><p>抽象工厂利用多态的优势将具体的产品的实例化放在具体工厂中实现。</p></li><li><p>抽象工厂创建的是抽象产品—提供的是抽象方法(<code>createPizza</code>)，但是具体的实现是推迟到具体的工厂中实现。</p></li><li><p>客户端中对用户可见的对象表面上看到的是两个抽象对象，但是具体工厂会创建用户指定类型的产品。</p></li></ol><h2 id="抽象工厂模式-1"><a href="#抽象工厂模式-1" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p><code>抽象工厂模式</code>是所有形态的工厂模式中最为抽象和最具一般性的一种形态。<code>抽象工厂模式</code>可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象。这就是抽象工厂的用意。</p><p>结构如下：</p><p><img src="/2019/05/30/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/3.webp" alt></p><h1 id="倒置原则"><a href="#倒置原则" class="headerlink" title="倒置原则"></a>倒置原则</h1><p>倒置原则：要依赖抽象，不要依赖具体类，这个原则说明了高层组件不能依赖底层组件，而且不管高层或底层组件，都应该依赖于抽象。</p><p>让我们再回顾一下上面的例子，PizzaStore就是高层组件，而Pizza就是底层组件，而且前者依赖后者，很清晰。那么，要符合这个原则，我们应该怎么做呢？现在我们来倒置你的思考方式：</p><ol><li>开始我们需要一家比萨店</li><li>我们得先从顶端开始，然后往下到具体类。但是，正如你所看到的你不想让比萨店实例这些具体类，要不然比萨店将全都依赖这些具体类。现在，开始”倒置”，别从顶端开始，而是从比萨开始，然后想想看能抽象化些什么</li><li>你得抽象抽象化一个比萨</li><li>你还得用一个工厂来将这些具体类取出比萨店，这样，各种不同的具体比萨类就只能依赖一个抽象，而比萨店也会依赖这个抽象，倒置完毕</li></ol><p>以下方法能帮你避免在OO设计中违反依赖倒置原则：</p><ul><li>变量不可以持有具体类的引用</li><li>不要让类派生自具体类</li><li>不要覆盖类中已实现的方法</li></ul><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ol><li>所有的工厂都是用来封装对象的创建</li><li>简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类解耦</li><li>工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象</li><li>抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中</li><li>所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合</li><li>工厂方法允许类将实例化延迟到子类进行</li><li>抽象工厂创建相关的对象家族，而不需要依赖它们的具体类</li><li>依赖倒置原则，知道我们避免依赖具体类型，而要尽量依赖抽象</li><li>工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-getProperty</title>
      <link href="/2019/05/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-getProperty/"/>
      <url>/2019/05/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-getProperty/</url>
      
        <content type="html"><![CDATA[<p>System.getProperty<br><span id="more"></span></p><h1 id="System-getProperty"><a href="#System-getProperty" class="headerlink" title="System.getProperty()"></a>System.getProperty()</h1><p>参考：<a href="https://www.jianshu.com/p/9b262628e041"><a href="https://www.jianshu.com/p/9b262628e041">https://www.jianshu.com/p/9b262628e041</a></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取指定键指示的系统属性</span></span><br><span class="line"><span class="comment">         * 首先，如果存在安全管理器，会调用其checkPropertiesAccess无参方法，有可能抛出安全异常</span></span><br><span class="line"><span class="comment">         * 当前系统属性集会通过Property对象返回（对象有getProperty()方法）</span></span><br><span class="line"><span class="comment">         * 如果当前没有系统属性集，会创建并初始化系统属性集。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//获得根类加载器系统属性</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line">        <span class="comment">//获得扩展类加载器系统属性</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">        <span class="comment">//获得系统类加载器系统属性</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/resources.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/rt.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jsse.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jce.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/charsets.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jfr.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/classes</span><br><span class="line"></span><br><span class="line">/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line"></span><br><span class="line">/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/charsets.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/deploy.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/cldrdata.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/jaccess.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/jfxrt.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/nashorn.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/sunec.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/ext/zipfs.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/javaws.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jce.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jfr.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jfxswt.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/jsse.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/management-agent.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/plugin.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/resources.jar:/usr/lib/jvm/java-<span class="number">8</span>-jdk/jre/lib/rt.jar:/home/cc/IdeaProjects/test/out/production/test:/home/cc/opt/idea-IU-<span class="number">191.7141</span><span class="number">.44</span>/lib/idea_rt.jar</span><br></pre></td></tr></table></figure><p>从这里可以看到<code>System.getProperty()</code>主要能够拿到一些关于Java的系统属性，如：java版本，java的vendor，操作系统版本等等。另外，还能够运行java命令时，通过-D参数来指定系统属性</p><h1 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h1><p>从上面可以到根类加载器的一个加载目录有<code>/usr/lib/jvm/java-8-jdk/jre/classes</code>，然后我们可以把一个<code>.class</code>放在这个目录下，尝试去让根类加载器去加载它。</p><p>我们用自定义类加载器去加载<code>indi.greenhat.jvm.Sample1</code>，把其<code>.class</code>文件复制到刚刚那个目录</p><p><img src="/2019/05/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-getProperty/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loder1&quot;</span>);</span><br><span class="line">        loader1.setPath(<span class="string">&quot;/home/cc/Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">&quot;indi.greenhat.jvm.Sample1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>可以看到，最终该类是由根类加载器加载，这正好也对应了双亲委派机制。</p><h1 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.crypto.provider.AESKeyGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">AESKeyGenerator</span> <span class="variable">aesKeyGenerator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AESKeyGenerator</span>();</span><br><span class="line">        System.out.println(aesKeyGenerator.getClass().getClassLoader());</span><br><span class="line">        System.out.println(Test.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$ExtClassLoader@12a3a380</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p><code>AESKeyGenerator</code>该类定义在扩展类加载器所对应的目录下，所有有扩展类加载器加载的，而<code>Test</code>类则是由系统类加载器加载的。</p><p>上面说过，可以通过-D参数来指定系统属性。</p><p><img src="/2019/05/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-getProperty/3.png" alt></p><p>我们通过-D改变扩展类的加载器寻找的目录，然后就会抛出异常。</p><p>正好说明了<code>AESKeyGenerator</code>类是由扩展类加载器加载的。</p><h1 id="java-ext-dirs"><a href="#java-ext-dirs" class="headerlink" title="java.ext.dirs"></a>java.ext.dirs</h1><p>如果将<code>java.ext.dirs</code>目录指定到含有某个类的.class的文件夹中，尝试用扩展类加载器加载，这样是不行的。</p><p>因为扩展类加载器查找的<code>.jar</code>文件。</p><p>所以可以运用<code>jar</code>命令将<code>.class</code>文件打包成jar包，例如</p><p><code>jar cvf test.jar test.class</code></p><h1 id="sun-boot-class-path"><a href="#sun-boot-class-path" class="headerlink" title="sun.boot.class.path"></a>sun.boot.class.path</h1><p>如果我们修改<code>sun.boot.class.path</code>对应的路径则会抛出异常。</p><p>因为<code>Object</code>类是每个类的父类，如果父类都没有了，那么不用说别的了。</p><p><img src="/2019/05/29/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-getProperty/4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql8-arch下二进制安装</title>
      <link href="/2019/05/18/MySql8-arch%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2019/05/18/MySql8-arch%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>二进制安装可控，方便</p><span id="more"></span><p><img src="/2019/05/18/MySql8-arch%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85/1.png" alt></p><p>参考：</p><p><a href="https://linuxops.org/blog/mysql/mysql8.html"><a href="https://linuxops.org/blog/mysql/mysql8.html">https://linuxops.org/blog/mysql/mysql8.html</a></a></p><p><a href="https://www.kancloud.cn/lengyueguang/linux/660448">https://www.kancloud.cn/lengyueguang/linux/660448</a></p><p>官方文档：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html"><a href="https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html">https://dev.mysql.com/doc/refman/8.0/en/binary-installation.html</a></a></p><h1 id="下载二进制包"><a href="#下载二进制包" class="headerlink" title="下载二进制包"></a>下载二进制包</h1><p>选择一个镜像站下载，查找起来比较方便，因为官网没有提供国内的源，所以挑了一个比较快的。</p><p><a href="http://mysql.inspire.net.nz/Downloads">http://mysql.inspire.net.nz/Downloads</a></p><p>然后下载<code>mysql-xxxx-linux-glibcxx-xx.xx</code>就行了</p><p>比如<a href="http://mysql.inspire.net.nz/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-i686.tar.xz">http://mysql.inspire.net.nz/Downloads/MySQL-8.0/mysql-8.0.15-linux-glibc2.12-i686.tar.xz</a></p><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf mysql-8.0.15-linux-glibc2.12-x86_64.tar.xz </span><br></pre></td></tr></table></figure><p>移动到<code>~/opt</code>（可选）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv  mysql-8.0.15-linux-glibc2.12-x86_64 ~/opt/mysql</span><br></pre></td></tr></table></figure><h1 id="配置用户和组（可选，这里用默认个人账号）"><a href="#配置用户和组（可选，这里用默认个人账号）" class="headerlink" title="配置用户和组（可选，这里用默认个人账号）"></a>配置用户和组（可选，这里用默认个人账号）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql  </span><br><span class="line">useradd -r -g mysql -s /bin/false mysql</span><br></pre></td></tr></table></figure><h1 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h1><p>log配置：<a href="https://segmentfault.com/a/1190000003072237"><a href="https://segmentfault.com/a/1190000003072237">https://segmentfault.com/a/1190000003072237</a></a></p><p>创建数据存放文件夹</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/opt/mysqlData/data</span><br><span class="line">mkdir -p ~/opt/mysqlData/log</span><br><span class="line">chmod 750 ~/opt/mysqlData/data ~/opt/mysqlData/log</span><br></pre></td></tr></table></figure><p>创建并编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">mkdir</span> -p /home/cc/opt/mysql/etc</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim /home/cc/opt/mysql/etc/my.cnf</span></span><br><span class="line">[mysql]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span></span><br><span class="line">basedir=/home/cc/opt/mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放目录</span></span><br><span class="line">datadir=/home/cc/opt/mysqlData/data</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">log</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记录启动、运行或停止mysqld时出现的问题</span></span><br><span class="line">log-error=/home/cc/opt/mysqlData/log/error.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">是指执行超过多久的sql会被<span class="built_in">log</span>下来，这里是2秒</span></span><br><span class="line">long_query_time=2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</span></span><br><span class="line">log-slow-queries=/home/cc/opt/mysqlData/log/slowquery.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">记录所有更改数据的语句，还用于复制</span></span><br><span class="line">log_bin=/home/cc/opt/mysqlData/log/log_bin.log</span><br></pre></td></tr></table></figure><p>MySQL配置文件条目很多，这边我们设置了常用的必须的一些配置项，如上，我们设置了<code>mysql</code>的监听端口、socket、安装目录、数据库文件存放目录等等配置。</p><p>MySQL的配置也是分段配置的，每一个段都有一个名称，例如上面的配置<code>[mysql]</code> 配置了mysql工具的默认设置，<code>[mysqld]</code>则为MySQL服务器的配置</p><p>MySQL配置项众多，对于每一个配置项官方都提供了一个默认值，如果你不确定使用它，可以不在配置文件中体现，这样MySQL会读取默认配置。</p><p>当然，如果你无法确定MySQL提供了那些配置，或者不确定配置项的名称，你可以通过<code>mysqld --verbose --help</code> 命令查看，配合<code>grep</code>你会快速找到你想要的内容。</p><hr><p>在MySQL8.0中，默认的密码认证插件更换为<code>caching_sha2_password</code>，一些老的客户端和程序并不支持这种认证插件，所以为了兼容性，我们可能需要将认证插件修改为<code>mysql_native_password</code></p><p>在配置文件中指定<code>default-authentication-plugin = mysql_native_password</code>，以后创建的用户都将使用<code>mysql_native_password</code>来验证，但是之前的账户并不会更改验证插件。</p><hr><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S libtinfo5</span><br><span class="line">sudo pacman -S numactl</span><br></pre></td></tr></table></figure><h1 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h1><p>装好了MySQL，也写好了配置文件，这个时候你并不能直接通过<code>mysqld</code>来启动MySQL。</p><p>因为还缺少系统必须的表，所以要通过命令先初始化MySQL，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure  --basedir=/home/cc/opt/mysql --datadir=/home/cc/opt/mysqlData/data</span><br></pre></td></tr></table></figure><p>初始化命令中<code>--initialize-insecure</code>告诉mysql不需要帮我生成root密码，这个时候mysql的root用户是没有密码的，你需要尽快修改它。</p><p>如果没有指定这个参数，MySQL会生成一个随机的密码，并且会告诉你密码存放在哪个文件中。</p><h1 id="配置启动mysqld服务"><a href="#配置启动mysqld服务" class="headerlink" title="配置启动mysqld服务"></a>配置启动mysqld服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">sudo</span> vim /usr/lib/systemd/system/mysqld.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=cc</span><br><span class="line">Group=cc</span><br><span class="line">Type=notify</span><br><span class="line">TimeoutSec=0</span><br><span class="line">PermissionsStartOnly=true</span><br><span class="line">ExecStart=/home/cc/mysql/bin/mysqld --basedir=/home/cc/opt/mysql --datadir=/home/cc/opt/mysqlData/data</span><br><span class="line">LimitNOFILE = 10000</span><br><span class="line">Restart=always</span><br><span class="line">RestartPreventExitStatus=1</span><br><span class="line">Environment=MYSQLD_PARENT_PID=1</span><br><span class="line">PrivateTmp=false</span><br></pre></td></tr></table></figure><p>接着</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable mysqld.service</span><br><span class="line">sudo systemctl start mysqld.service</span><br></pre></td></tr></table></figure><h1 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/18/MySql8-arch%E4%B8%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E8%A3%85/2.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-类加载器的命名空间</title>
      <link href="/2019/05/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2019/05/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>类加载器的命名空间</p><span id="more"></span><p>参考：<a href="https://blog.csdn.net/sureyonder/article/details/5564181">https://blog.csdn.net/sureyonder/article/details/5564181</a></p><p><a href="http://www.importnew.com/17093.html">http://www.importnew.com/17093.html</a></p><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>类加载体系为不同类加载器加载的类提供不同的命名空间，<strong>同一命名空间内的类可以互相访问，不同命名空间的类不知道彼此的存在(除非显式提供访问机制)</strong>。同一类可以再不同的命名空间内，但无法在同一命名空间内重复出现。</p><hr><p>命名空间是这样定义的：<strong>实际完成加载类的工作</strong>的加载器为定义类加载器，而<strong>加载的双亲委托路径上的所有加载器</strong>为初始类加载器，某个加载器的命名空间就是所有以该加载器为初始类加载器的类所组成。</p><hr><p>可以预见，<strong>子加载器的命名空间包括其父/祖先加载器的命名空间和只有自己才可以加载的类所组成</strong>。根据加载体系结构的安全机制，同一命名空间内的类可 以互相访问，所以<strong>父加载器所加载的类不一定可以访问子加载器所加载的类，但子加载器所加载的类必然可以访问父加载器加载的类</strong>。父加载器加载的类就好像小箱 子，子加载器加载的类可能用到父加载器加载的类，就像一个大箱子，只能把小箱子放进大箱子，而不能反过来做(当然显式的访问机制除外)</p><h1 id="命名空间的类型共享"><a href="#命名空间的类型共享" class="headerlink" title="命名空间的类型共享"></a>命名空间的类型共享</h1><p>前面提到过只有同一个命名空间内的类才可以直接进行交互，但是我们经常在由用户自定义类装载器定义的类型中直接使用JAVA API类，这不是矛盾了吗？这是类型共享 原因－<strong>如果某个类装载器把类型装载的任务委派给另外一个类装载器，而后者定义了这个类型，那么被委派的类装载器装载的这个类型，在所有被标记为该类型的初始类装载器的命名空间中共享</strong>。</p><h1 id="运行时包"><a href="#运行时包" class="headerlink" title="运行时包"></a>运行时包</h1><p>每个类装载器都有自己的命名空间，<strong>其中维护着由它装载的类型</strong>。<strong>所以一个JAVA程序可以多次装载具有同一个全限定名的多个类型</strong>。这样一个类型的全限定名就不足以确定在一个JAVA虚拟机中的唯一性。因此，当多个类装载器都装载了同名的类型时，为了唯一表示该类型，<strong>还要在类型名称前加上装载该类型的类装载器来表示－<code>[classloader class]</code></strong></p><p>在允许两个类型之间对包内可见的成员进行访问前，<strong>虚拟机不但要确定这个两个类型属于同一个包，还必须确认它们属于同一个运行时包－它们必须有同一个类装载器装载的</strong>。这样，<code>java.lang.Virus</code>和来自核心的<code>java.lang</code>的类不属于同一个运行时包，<code>java.lang.Virus</code>就不能访问<code>JAVA API</code>的<code>java.lang</code>包中的包内可见的成员。</p><h1 id="不同命名空间不能访问"><a href="#不同命名空间不能访问" class="headerlink" title="不同命名空间不能访问"></a>不同命名空间不能访问</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sample1.java</span></span><br><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sample1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample1 is loaderd by: &quot;</span> + <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Sample2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sample2.java</span></span><br><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sample2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample2 is loaderd by: &quot;</span> + <span class="built_in">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">&quot;Sample2 output Sample1.class:&quot;</span>);</span><br><span class="line">        System.out.println(Sample1.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader&quot;</span>);</span><br><span class="line">        loader.setPath(<span class="string">&quot;/home/cc/test/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;indi.greenhat.jvm.Sample1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>目录结构：</p><p><strong>已经把Sample1.class删除</strong></p><p><img src="/2019/05/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/2.png" alt></p><p>同时<code>/home/cc/test</code>目录下这个几个类的class文件</p><p><img src="/2019/05/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/3.png" alt></p><p>输出：</p><p><img src="/2019/05/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/1.png" alt></p><hr><p><code>Sample2在Sample1里面</code>，所以<code>Sample2</code>是由<code>Sample1</code>的加载器加载的，因为在项目目录下面没有<code>Sample1.class</code>，所以只能由自定义类加载器加载，如上图输出。</p><p>虽然<code>Sample1</code>是由自定义类加载器加载的，但是根据双亲委派机制，加载<code>Sample2</code>时先委派给父加载器，又因为项目目录下有<code>Sample2.class</code>，所以父加载器加载成功，所以<code>Sample2</code>是由系统类加载器加载的。</p><hr><p>因为这两个记载器是不同的，所以不能互相访问，故<code>Sample2</code>尝试输出<code>Sample1.class</code>时会抛出异常</p><hr><p>自定义类加载器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CustomClassLoader.java</span></span><br><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户自定义类加载器必须继承ClassLoader类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的扩展名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用方法getSystemClassLoader（）返回的ClassLoader作为父类加载器创建新的类加载器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName, ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="comment">//使用指定的父类加载器创建新的类加载器以进行委派</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findClass invoked: &quot;</span> + className);</span><br><span class="line">        System.out.println(<span class="string">&quot;class loader name: &quot;</span> + <span class="built_in">this</span>.classLoaderName);</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.loadClassDate(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassDate(String name)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换为磁盘对应的地址</span></span><br><span class="line">            name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.path+ name + <span class="built_in">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        loader1.setPath(<span class="string">&quot;/home/cc/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-类的卸载</title>
      <link href="/2019/05/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD/"/>
      <url>/2019/05/15/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E7%9A%84%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>jvm类的卸载</p><span id="more"></span><p>当<code>MySample</code>类被加载，连接和初始化后，它的生命周期就开始了。当代表<code>MySample</code>类的<code>Class</code>对象不再被引用，即不可触及时，<code>Class</code>对象就会结束生命周期，<code>MySample</code>类在方法区内的数据也会被卸载，从而结束<code>MySample</code>类的生命周期。</p><p>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</p><hr><p>由Java虚拟机自带的加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机自带的类加器包括根类加载器，扩展类加载器和系统类加载器。Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始引用它们所加载的类的<code>Class</code>对象，因此这<code>Class</code>对象终是可及的。</p><p>由用户自定义的类加载器所加载的类是可以被卸载的。</p><hr><p>Sample类中由<code>loader1</code>加载。在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个<code>Class</code>对象总是会引用它的类加载器，调用<code>Class</code>对象的<code>getClasslodar()</code>方法，就能获得它的类加载器。此可见，代表<code>Sample</code>类的<code>Class</code>实例与<code>loader1</code>之间为双向关取关系。<br>一个类的实例总是引用代表这个类的<code>C1ass</code>对象。在<code>Object</code>类中定义了<code>getClass()</code><br>方法，这个方法返回代表对象所属类的<code>Class</code>对象的引用。此外，所有的Java类都有<br>一个静态属性class.它引用代表这个类的Class对象。</p><h1 id="验证类的卸载"><a href="#验证类的卸载" class="headerlink" title="验证类的卸载"></a>验证类的卸载</h1><p>添加<code>-XX:+TraceClassUnloading</code>参数后可以看到类的卸载信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户自定义类加载器必须继承ClassLoader类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的扩展名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用方法getSystemClassLoader（）返回的ClassLoader作为父类加载器创建新的类加载器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName, ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="comment">//使用指定的父类加载器创建新的类加载器以进行委派</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findClass invoked: &quot;</span> + className);</span><br><span class="line">        System.out.println(<span class="string">&quot;class loader name: &quot;</span> + <span class="built_in">this</span>.classLoaderName);</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.loadClassDate(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassDate(String name)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换为磁盘对应的地址</span></span><br><span class="line">            name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.path+ name + <span class="built_in">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        loader1.setPath(<span class="string">&quot;/home/cc/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">        loader1 = <span class="literal">null</span>;</span><br><span class="line">        clazz = <span class="literal">null</span>;</span><br><span class="line">        object = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *运行垃圾回收器。</span></span><br><span class="line"><span class="comment"> *调用gc方法表明，Java虚拟机花费了回收未使用对象的努力，以使其当前占用的内存可以快速重用。</span></span><br><span class="line"><span class="comment">         *当控件从方法调用返回时，Java虚拟机已经尽力从所有丢弃的对象中回收空间。</span></span><br><span class="line"><span class="comment">         *等于Runtime.getRuntime().gc();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: indi.greenhat.jvm.Test</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">loader</span> name: loader1</span><br><span class="line">indi.greenhat.jvm.Test@677327b6</span><br><span class="line">-----------------</span><br><span class="line">[Unloading <span class="keyword">class</span> <span class="title class_">indi</span>.greenhat.jvm.Test <span class="number">0x0000000100061028</span>]</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的卸载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树模板</title>
      <link href="/2019/05/11/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/05/11/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>「LYOI2018 Summer」Hzy’s Rabbit Array                </p><span id="more"></span><p>参考：</p><p><a href="https://wyy603.github.io/2019/01/07/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/">wyy603</a></p><h1 id="「LYOI2018-Summer」Hzy’s-Rabbit-Array"><a href="#「LYOI2018-Summer」Hzy’s-Rabbit-Array" class="headerlink" title="「LYOI2018 Summer」Hzy’s Rabbit Array"></a><a href="https://lyoi.ac/problem/396">「LYOI2018 Summer」Hzy’s Rabbit Array</a></h1><p><img src="/2019/05/11/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF/1.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 500005</span></span><br><span class="line"><span class="comment">// 需要加的宏（模数可自行更改）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        ret = ret * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的辅助函数和结构体</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sqr</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x % MOD) * (x % MOD)) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T t = a;</span><br><span class="line">a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="comment">// 描述初始序列</span></span><br><span class="line">ll begin[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树的辅助函数和结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nod</span></span><br><span class="line">&#123;</span><br><span class="line">    ll sum, mx, mn, squ;</span><br><span class="line">    <span class="type">double</span> dsum;</span><br><span class="line">    <span class="built_in">nod</span> (ll isum, ll imx, ll imn, ll isqu, <span class="type">double</span> idsum)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = isum, mx = imx, mn = imn, </span><br><span class="line">        squ = isqu, dsum = idsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树主体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sgt</span></span><br><span class="line">&#123;</span><br><span class="line">    ll sum, mx, mn, squ, add, cov, mul;</span><br><span class="line">    <span class="type">double</span> dsum;</span><br><span class="line">    <span class="type">int</span> l, r, mid, siz;</span><br><span class="line">    sgt *lson, *rson;</span><br><span class="line">    <span class="built_in">sgt</span> (<span class="type">int</span> le, <span class="type">int</span> ri)</span><br><span class="line">    &#123;</span><br><span class="line">        l = le, r = ri, mid = (l + r) &gt;&gt; <span class="number">1</span>, siz = r - l + <span class="number">1</span>;</span><br><span class="line">        lson = rson = <span class="literal">NULL</span>, sum = mx = mn = squ = <span class="number">0</span>, </span><br><span class="line">        add = <span class="number">0</span>, mul = <span class="number">1</span>, cov = <span class="number">-1</span>, dsum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sum = (lson-&gt;sum + rson-&gt;sum) % MOD;</span><br><span class="line">        mx = <span class="built_in">max</span>(lson-&gt;mx, rson-&gt;mx);</span><br><span class="line">        mn = <span class="built_in">min</span>(lson-&gt;mn, rson-&gt;mn);</span><br><span class="line">        squ = (lson-&gt;squ + rson-&gt;squ) % MOD;</span><br><span class="line">        dsum = lson-&gt;dsum + rson-&gt;dsum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">plus</span><span class="params">(ll K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        squ = (squ + (((<span class="number">2</span> * (K % MOD)) % MOD) * sum) % MOD </span><br><span class="line">               + (<span class="built_in">sqr</span>(K) * siz) % MOD) % MOD;</span><br><span class="line">        sum = (sum + ((K % MOD) * siz) % MOD) % MOD;</span><br><span class="line">        mx += K, mn += K, dsum += K * siz;</span><br><span class="line">        add = add + K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">multiply</span><span class="params">(ll K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        squ = (squ * <span class="built_in">sqr</span>(K)) % MOD, sum </span><br><span class="line">            = (sum * (K % MOD)) % MOD, dsum *= K;</span><br><span class="line">mx *= K, mn *= K;</span><br><span class="line"><span class="keyword">if</span> (K &lt; <span class="number">0</span>) <span class="built_in">swap</span>(mx, mn);</span><br><span class="line">        mul = mul * K, add = add * K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(ll K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        squ = (<span class="built_in">sqr</span>(K) * siz) % MOD, sum = ((K % MOD) * siz) % MOD;</span><br><span class="line">        mx = mn = K, dsum = K * siz;</span><br><span class="line">        cov = K, mul = <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cov != <span class="number">-1</span>) lson-&gt;<span class="built_in">cover</span>(cov), rson-&gt;<span class="built_in">cover</span>(cov), cov = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mul != <span class="number">1</span>) lson-&gt;<span class="built_in">multiply</span>(mul), rson-&gt;<span class="built_in">multiply</span>(mul), mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (add) lson-&gt;<span class="built_in">plus</span>(add), rson-&gt;<span class="built_in">plus</span>(add), add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) sum = begin[l] % MOD, squ = <span class="built_in">sqr</span>(begin[l]), </span><br><span class="line">        mx = begin[l], mn = begin[l], dsum = begin[l];</span><br><span class="line">        <span class="keyword">else</span> lson = <span class="keyword">new</span> <span class="built_in">sgt</span>(l, mid), rson = <span class="keyword">new</span> <span class="built_in">sgt</span>(mid + <span class="number">1</span>, r), </span><br><span class="line">        lson-&gt;<span class="built_in">build</span>(), rson-&gt;<span class="built_in">build</span>(), <span class="built_in">push_up</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, ll K, <span class="type">char</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == L &amp;&amp; r == R)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;p&#x27;</span>) <span class="built_in">plus</span>(K);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;m&#x27;</span>) <span class="built_in">multiply</span>(K);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;c&#x27;</span>) <span class="built_in">cover</span>(K);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_down</span>();</span><br><span class="line">            <span class="keyword">if</span> (R &lt;= mid) lson-&gt;<span class="built_in">modify</span>(L, R, K, t);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid) rson-&gt;<span class="built_in">modify</span>(L, R, K, t);</span><br><span class="line">            <span class="keyword">else</span> lson-&gt;<span class="built_in">modify</span>(L, mid, K, t), rson-&gt;<span class="built_in">modify</span>(mid + <span class="number">1</span>, R, K, t);</span><br><span class="line">            <span class="built_in">push_up</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">nod <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == L &amp;&amp; r == R) <span class="keyword">return</span> <span class="built_in">nod</span>(sum, mx, mn, squ, dsum);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">push_down</span>();</span><br><span class="line">            <span class="keyword">if</span> (R &lt;= mid) <span class="keyword">return</span> lson-&gt;<span class="built_in">query</span>(L, R);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L &gt; mid) <span class="keyword">return</span> rson-&gt;<span class="built_in">query</span>(L, R);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nod ls = lson-&gt;<span class="built_in">query</span>(L, mid), rs = rson-&gt;<span class="built_in">query</span>(mid + <span class="number">1</span>, R);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">nod</span>((ls.sum + rs.sum) % MOD, <span class="built_in">max</span>(ls.mx, rs.mx), </span><br><span class="line">                           <span class="built_in">min</span>(ls.mn, rs.mn), (ls.squ + rs.squ) % MOD, ls.dsum + rs.dsum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*hed;</span><br><span class="line"><span class="comment">// 线段树主体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">read</span>(), M = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; ++i) begin[i] = <span class="built_in">read</span>();</span><br><span class="line">    hed = <span class="keyword">new</span> <span class="built_in">sgt</span>(<span class="number">1</span>, N), hed-&gt;<span class="built_in">build</span>();</span><br><span class="line">    ll opt, p1, p2, p3, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        opt = <span class="built_in">read</span>(), p1 = <span class="built_in">read</span>(), p2 = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (hed-&gt;<span class="built_in">query</span>(p1, p2).sum % MOD + MOD) % MOD);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, hed-&gt;<span class="built_in">query</span>(p1, p2).mx);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, hed-&gt;<span class="built_in">query</span>(p1, p2).mn);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">4</span>) hed-&gt;<span class="built_in">modify</span>(p1, p2, <span class="built_in">read</span>(), <span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">5</span>) t = hed-&gt;<span class="built_in">query</span>(p1, p1).mx, t = t ^ p2, hed-&gt;<span class="built_in">modify</span>(p1, p1, t, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, hed-&gt;<span class="built_in">query</span>(p1, p2).dsum / (<span class="type">double</span>)(p2 - p1 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">7</span>) hed-&gt;<span class="built_in">modify</span>(p1, p2, <span class="number">-1</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">8</span>) hed-&gt;<span class="built_in">modify</span>(p1, p2, <span class="built_in">read</span>(), <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (hed-&gt;<span class="built_in">query</span>(p1, p2).squ % MOD + MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现方式：指针；动态申请内存；普通线段树</p><p>注意事项：区间和/区间平方和 被模了；区间最大值/最小值 没模。建议每次操作的参数不要超过long long的取值范围，并保证最大值在long long范围内。（如果想让它们被模可自行更改）</p><h3 id="这颗线段树的使用方法"><a href="#这颗线段树的使用方法" class="headerlink" title="这颗线段树的使用方法"></a>这颗线段树的使用方法</h3><ol><li>在使用之前（最开头）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_to_begin</span>();</span><br><span class="line">hed = <span class="keyword">new</span> <span class="built_in">sgt</span>(<span class="number">1</span>, N);</span><br><span class="line">hed-&gt;<span class="built_in">build</span>();</span><br></pre></td></tr></table></figure><p>其中read_to_begin();要将初始序列读入begin<strong>数组</strong></p><ol><li>使用时</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hed-&gt;<span class="built_in">modify</span>(l, r, k, <span class="string">&#x27;p&#x27;</span>); <span class="comment">//区间加</span></span><br><span class="line">hed-&gt;<span class="built_in">modify</span>(l, r, k, <span class="string">&#x27;m&#x27;</span>); <span class="comment">//区间乘</span></span><br><span class="line">hed-&gt;<span class="built_in">modify</span>(l, r, k, <span class="string">&#x27;c&#x27;</span>); <span class="comment">//区间赋值</span></span><br></pre></td></tr></table></figure><p>其中l, r表示一个闭区间[l,r]，k表示参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hed-&gt;<span class="built_in">query</span>(l, r);</span><br></pre></td></tr></table></figure><p>返回一个nod形变量，如果这个返回值是t，那么</p><ul><li>t.sum是区间和（模了）</li><li>t.mx是区间最大值（没模）</li><li>t.mn是区间最小值（没模）</li><li>t.squ是区间平方和（模了）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-自定义类加载器</title>
      <link href="/2019/05/10/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2019/05/10/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>jvm自定义类加载器</p><span id="more"></span><h1 id="JDK加载类流程"><a href="#JDK加载类流程" class="headerlink" title="JDK加载类流程"></a>JDK加载类流程</h1><p>参考：<a href="https://juejin.im/post/5a1fad585188252ae93ab953">https://juejin.im/post/5a1fad585188252ae93ab953</a></p><h2 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.检查类是否已经加载过</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name 类的二进制名字     </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 类对象（Class&lt;?&gt;），如果没有加载该类，则返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.1.如果没有加载过，先调用父类加载器去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 2.2.如果没有加载过，且没有父类加载器，就用BootstrapClassLoader去加载</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//3. 如果父类加载器没有加载到，调用findClass去加载</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面代码可以明显看出，<code>loadClass(String, boolean)</code>函数即实现了双亲委派模型！整个大致过程如下：</p><ol><li>检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用<code>parent.loadClass(name, false);</code>）.或者是调用<code>bootstrap</code>类加载器来加载。</li><li>如果父加载器及<code>bootstrap</code>类加载器都没有找到指定的类，那么调用当前类加载器的<strong><code>findClass</code></strong>方法来完成类加载。默认的<code>findclass</code>毛都不干，直接抛出<code>ClassNotFound</code>异常，所以我们自定义类加载器就要覆盖这个方法了。</li><li><strong>可以猜测:<code>ApplicationClassLoader</code>的<code>findClass</code>是去<code>classpath</code>下去加载，<code>ExtentionClassLoader</code>是去<code>java_home/lib/ext</code>目录下去加载。实际上就是<code>findClass</code>方法不一样罢了</strong>。</li></ol><hr><p><code>loadClass</code>在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的<code>findClass</code>函数，因此我们必须要在<code>loadClass</code>这个函数里面实现将一个指定类名称转换为Class对象。</p><p>根据JavaDoc</p><blockquote><p>一些类可能并不是来自一个文件，它们可能来自于其他来源，比如网络或者由应用本身构建出来。在这种情况下，defineClass方法会将一个字节数组转换成class类的一个实例，这个新定义的实例是可以通过Class.newInstance去创建。</p></blockquote><p>于是我们可以运用<code>defineClass</code>去创建</p><p><img src="/2019/05/10/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/1.png" alt></p><h2 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节数组转换为类Class的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b 组成类数据的字节数组</span></span><br><span class="line"><span class="comment"> *        off 数据起始位置</span></span><br><span class="line"><span class="comment"> *        len 数组长度</span></span><br><span class="line"><span class="comment"> * @ return 从指定的类数据创建的Class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 从数据创建的Class对象，以及可选的ProtectionDomain</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, off, len, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将字节数组转换为类别类的实例，其中可选的是ProtectionDomain</span></span><br><span class="line"><span class="comment">  * 如果域是null，则默认的域名将被作为文件规定分配给类defineClass(String, byte[], int, int)</span></span><br><span class="line"><span class="comment">  * 在类可以使用之前，必须解决域名问题</span></span><br><span class="line"><span class="comment">  * 包中定义的第一个类决定了该包中定义的所有后续类必须包含的精确的证书集</span></span><br><span class="line"><span class="comment">  * 一套类的证书是从类ProtectionDomain中的CodeSource获得的</span></span><br><span class="line"><span class="comment">  * 添加到该包中的任何类必须包含相同的证书集， 否则将抛出SecurityException</span></span><br><span class="line"><span class="comment">  * 请注意，如果name为null ，则不执行此检查</span></span><br><span class="line"><span class="comment">  * 你应该总是传递你所定义的类的binary name以及字节。 这确保你所定义的类确实是你认为的类。</span></span><br><span class="line"><span class="comment">  * 指定name不能以“java.”开始，因为在所有的类“java.*包只能由引导类装载程序来限定。</span></span><br><span class="line"><span class="comment">  * 如果name不是null，它必须等于binary name类的由字节数组指定” b “，否则将抛出一个NoClassDefFoundError</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> name 预期的类二进制名字，如果不知道则为null</span></span><br><span class="line"><span class="comment">  *       b    构成类数据的字节数组</span></span><br><span class="line"><span class="comment">  *       off  字节数组起始位置</span></span><br><span class="line"><span class="comment">  *       len  字节数组长度</span></span><br><span class="line"><span class="comment">  *       protectionDomain 该类的ProtectionDomain（保护域（保护域定义了授予一段特定代码的所有权限）） </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> 从传入的数据中创建的类对象，可选ProtectionDomain </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len,</span><br><span class="line">                                         ProtectionDomain protectionDomain)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> defineClassSourceLocation(protectionDomain);</span><br><span class="line">        Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">        postDefineClass(c, protectionDomain);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找具有指定二进制名称的类。此方法应由遵循委托模型的类加载器实现覆盖以加载类，</span></span><br><span class="line"><span class="comment"> * 并且在检查所请求类的父类加载器  之后将由loadClass方法调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 类的二进制名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@retrun</span> 生成的class对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findClass默认是空的,所以得重写这个方法.</p><h2 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h2><p>其实很简单，继承ClassLoader类，覆盖findClass方法，这个方法的作用就是找到.class文件,转换成字节数组，调用defineClass对象转换成Class对象返回</p><h1 id="简单实现自定义类加载器"><a href="#简单实现自定义类加载器" class="headerlink" title="简单实现自定义类加载器"></a>简单实现自定义类加载器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户自定义类加载器必须继承ClassLoader类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的扩展名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用方法getSystemClassLoader（）返回的ClassLoader作为父类加载器创建新的类加载器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName, ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="comment">//使用指定的父类加载器创建新的类加载器以进行委派</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.loadClassDate(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassDate(String name)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换为磁盘对应的地址</span></span><br><span class="line">            name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(name + <span class="built_in">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建一个自定义类加载器，其父加载器是系统类加载器</span></span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        test(loader1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><p><code>indi.greenhat.jvm.Test@74a14482</code></p><h1 id="简单类加载器修改1"><a href="#简单类加载器修改1" class="headerlink" title="简单类加载器修改1"></a>简单类加载器修改1</h1><p>修改部分已经用标识起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************</span></span><br><span class="line"><span class="comment"> * update</span></span><br><span class="line"><span class="comment"> ************************************/</span></span><br></pre></td></tr></table></figure><p>从标识部分我们可以看出，在<code>findClass</code>和<code>test</code>增加了几句输出语句，为了输出类的加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户自定义类加载器必须继承ClassLoader类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的扩展名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用方法getSystemClassLoader（）返回的ClassLoader作为父类加载器创建新的类加载器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName, ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="comment">//使用指定的父类加载器创建新的类加载器以进行委派</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">/*************************************</span></span><br><span class="line"><span class="comment">         * update</span></span><br><span class="line"><span class="comment">         ************************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;findClass invoked: &quot;</span> + className);</span><br><span class="line">        System.out.println(<span class="string">&quot;class loader name: &quot;</span> + <span class="built_in">this</span>.classLoaderName);</span><br><span class="line">        <span class="comment">/*************************************</span></span><br><span class="line"><span class="comment">         * update</span></span><br><span class="line"><span class="comment">         ************************************/</span></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.loadClassDate(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassDate(String name)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换为磁盘对应的地址</span></span><br><span class="line">            name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(name + <span class="built_in">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object);</span><br><span class="line">        <span class="comment">/*************************************</span></span><br><span class="line"><span class="comment">         * update</span></span><br><span class="line"><span class="comment">         ************************************/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----getClassLoader-----&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">/*************************************</span></span><br><span class="line"><span class="comment">         * update</span></span><br><span class="line"><span class="comment">         ************************************/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        test(loader1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">indi.greenhat.jvm.Test@74a14482</span><br><span class="line">----getClassLoader-----</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>可以看出该类是由系统类加载器加载的，而不是由我们自定义的类加载器加载的。</p><p>为什么呢？因为我们使用了<code>classLoader</code>的<code>super</code>办法，使用方法<code>getSystemClassLoader（）</code>返回的<code>ClassLoader</code>作为父类加载器创建新的类加载器，根据双亲委派机制，会先让双亲去尝试执行，因为要加载的类符合系统类加载器加载要求，所以是系统类加载器加载的。</p><hr><p>所以系统类加载器是类<code>indi.greenhat.jvm.Test</code>的定义类加载器，而系统类加载器和<code>customClassLoader</code>是类<code>indi.greenhat.jvm.Test</code>的初始类加载器</p><blockquote><p>若一个类加载器能够成功加载Test类，那么这个类加载器被称为定义类加载器，所有能够成功返回Class对象引用的类加载器（包括定义类加载器）都被称为初始类加载器</p></blockquote><h1 id="简单类加载器修改2"><a href="#简单类加载器修改2" class="headerlink" title="简单类加载器修改2"></a>简单类加载器修改2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.greenhat.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户自定义类加载器必须继承ClassLoader类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类的扩展名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">fileExtension</span> <span class="operator">=</span> <span class="string">&quot;.class&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPath</span><span class="params">(String path)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用方法getSystemClassLoader（）返回的ClassLoader作为父类加载器创建新的类加载器</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomClassLoader</span><span class="params">(String classLoaderName, ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="comment">//使用指定的父类加载器创建新的类加载器以进行委派</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findClass invoked: &quot;</span> + className);</span><br><span class="line">        System.out.println(<span class="string">&quot;class loader name: &quot;</span> + <span class="built_in">this</span>.classLoaderName);</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="built_in">this</span>.loadClassDate(className);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(className, data, <span class="number">0</span>, data.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassDate(String name)&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//转换为磁盘对应的地址</span></span><br><span class="line">            name = name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.path+ name + <span class="built_in">this</span>.fileExtension));</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>((ch = is.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        loader1.setPath(<span class="string">&quot;/home/cc/IdeaProjects/test/out/production/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;----getClassLoader-----&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader2&quot;</span>);</span><br><span class="line">        loader2.setPath(<span class="string">&quot;/home/cc/IdeaProjects/test/out/production/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> clazz2.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;----getClassLoader-----&quot;</span>);</span><br><span class="line">        System.out.println(clazz2.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">indi.greenhat.jvm.Test@74a14482</span><br><span class="line"><span class="number">356573597</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line"></span><br><span class="line">indi.greenhat.jvm.Test@677327b6</span><br><span class="line"><span class="number">356573597</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">sun.misc.Launcher$AppClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><p>可以看到，我们定义的两个加载器是一样并且是由系统类加载器加载的。前面所讲，如果该类被加载过了，那么就不会重新加载了。</p><hr><p>接着稍作修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        loader1.setPath(<span class="string">&quot;/home/cc/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;----getClassLoader-----&quot;</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="type">CustomClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br><span class="line">        loader2.setPath(<span class="string">&quot;/home/cc/test/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">&quot;indi.greenhat.jvm.Test&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        System.out.println(clazz2.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;----getClassLoader-----&quot;</span>);</span><br><span class="line">        System.out.println(clazz2.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: indi.greenhat.jvm.Test</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">loader</span> name: loader1</span><br><span class="line">indi.greenhat.jvm.Test@677327b6</span><br><span class="line"><span class="number">21685669</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">indi.greenhat.jvm.CustomClassLoader@74a14482</span><br><span class="line"></span><br><span class="line">findClass invoked: indi.greenhat.jvm.Test</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">loader</span> name: loader1</span><br><span class="line">indi.greenhat.jvm.Test@135fbaa4</span><br><span class="line"><span class="number">1173230247</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">indi.greenhat.jvm.CustomClassLoader@7f31245a</span><br></pre></td></tr></table></figure><p>这一次我们把<code>Test.class</code>移动到<code>/home/cc/test/indi/greenhat/jvm</code>下面，然后尝试去该目录下加载<code>Test.class</code>，我们发现，此时类加载器是我们自定义的类加载器，因为该类不是项目目录下的，所以不能由系统类加载器加载，并且发现类加载器的<code>hashCode值不一样</code>，为什么呢？</p><p>这时候就涉及到了类的命名空间。</p><blockquote><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成</li><li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会会出现类的完整名字（包括类的包名）相同的两个类</li></ul></blockquote><p>因为new的两个加载器属于不同的命名空间，所以<code>hashCode</code>的值不一样。</p><hr><p>（项目没有Test.class前提）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CustomClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader1&quot;</span>);</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将loader1作为loader2的父加载器</span></span><br><span class="line"><span class="type">CustomClassLoader</span> <span class="variable">loader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomClassLoader</span>(<span class="string">&quot;loader2&quot;</span>， loader1);</span><br></pre></td></tr></table></figure><p>结果会输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findClass invoked: indi.greenhat.jvm.Test</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">loader</span> name: loader1</span><br><span class="line">indi.greenhat.jvm.Test@677327b6</span><br><span class="line"><span class="number">21685669</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">indi.greenhat.jvm.CustomClassLoader@74a14482</span><br><span class="line"></span><br><span class="line">indi.greenhat.jvm.Test@7f31245a</span><br><span class="line"><span class="number">21685669</span></span><br><span class="line">----getClassLoader-----</span><br><span class="line">indi.greenhat.jvm.CustomClassLoader@74a14482</span><br></pre></td></tr></table></figure><p>加载<code>Test</code>的是<code>loader1</code>，所以会执行<code>findClass</code>里面两个输出语句。<code>loader1</code>与<code>laoder2</code>在同一命名空间，又因为<code>loader1</code>已经加载过了，所以第二次输出的就是直接是<code>laoder1</code>已经加载过的结果</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>容斥与抽屉定理</title>
      <link href="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/"/>
      <url>/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>容斥与抽屉定理</p><span id="more"></span><h1 id="容斥定理"><a href="#容斥定理" class="headerlink" title="容斥定理"></a>容斥定理</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>参考：百度百科</p><p>在计数时，必须注意没有重复，没有遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</p><ul><li><p>两个集合的容斥关系公式：A∪B =|A∪B| = |A|+|B| - |A∩B |(∩：重合的部分）</p></li><li><p>三个集合的容斥关系公式：|A∪B∪C| = |A|+|B|+|C| - |A∩B| - |B∩C| - |C∩A| + |A∩B∩C|</p></li></ul><p>例如三个集合的关系：</p><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/1.png" alt></p><p>(图里面的A+B+C划红色部分应该是划去{2,3,4,2,1,2}，即划去A∩B，B∩C，A∩C)</p><ul><li>一般情况：</li></ul><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/2.png" alt></p><h2 id="51nod1284"><a href="#51nod1284" class="headerlink" title="51nod1284"></a><a href="https://www.51nod.com/Challenge/Problem.html#!#problemId=1284">51nod1284</a></h2><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/3.png" alt></p><p>容斥定理，先求反面，即1-N有多少是2 3 5 7的倍数，然后再用总数减去反面的数量即为所求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnt = A2+A3+A5+A7-(A23+A25+A27+A35+A37+A57)+(A235+A237+A257+A357)-A2357</span><br></pre></td></tr></table></figure><p>A2表示被2整除的个数  即N/2  A23为即被2又被3整除的个数即N/6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15ms</span></span><br><span class="line"><span class="comment">1912KB </span></span><br><span class="line"><span class="comment">c++11</span></span><br><span class="line"><span class="comment">2019/5/7 8:10:44</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    ll cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//A2+A3+A5+A7</span></span><br><span class="line">    cnt += (n/<span class="number">2</span> + n/<span class="number">3</span> + n/<span class="number">5</span> + n/<span class="number">7</span>); </span><br><span class="line">    <span class="comment">//A23+A25+A27+A35+A37+A57</span></span><br><span class="line">    cnt -= (n/<span class="number">6</span> + n/<span class="number">10</span> + n/<span class="number">14</span> + n/<span class="number">15</span> + n/<span class="number">21</span> + n/<span class="number">35</span>); </span><br><span class="line">    <span class="comment">//A235+A237+A257+A357</span></span><br><span class="line">    cnt += (n/<span class="number">30</span> + n/<span class="number">42</span> + n/<span class="number">70</span> + n/<span class="number">105</span>);</span><br><span class="line">    <span class="comment">//A2357</span></span><br><span class="line">    cnt -= (n/<span class="number">210</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n - cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="电灯泡"><a href="#电灯泡" class="headerlink" title="电灯泡"></a><a href="http://120.78.128.11/Problem.jsp?pid=2332">电灯泡</a></h2><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/4.png" alt></p><p>因为最后求的是亮的个数。那么我们只需要关心a和a的倍数，b和b的倍数，c和c的倍数，其他数没有的电灯泡没有被点亮，所以就不用处理</p><p>点亮三次情况如下：</p><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/5.png" alt></p><p>那么最终变成了求被染色的面积</p><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/6.png" alt></p><p>我们根据容斥定理可以尝试去推理求法，首先结果里面没有2，而2又是a∩b的结果，所以可以尝试去掉2个a∩b，如此类推，推出答案为<code>a+b+c-2ab-2bc-2ac+4abc（ab,bc,ac代表的是这两个数的倍数）</code>，或者也可以根据图形关系结合容斥定理来求结果的表达式。</p><hr><p>那么倍数的数量如何求？</p><p>假设求1-10里面3的倍数有几个，自然可以用到10/3</p><p>如果是2个数呢？</p><p>假设求1-50里面3,5的倍数有几个，那么可以直接50/(3*5)=3：{15,30,45}</p><p>那么求4,6呢，还能50/(4*6)=2吗？</p><p>我们知道1-50中，4,6的倍数有{12,24,36,48}，明显不对</p><p>因为4,6不是互质，所以结果应该是<code>50*gcd(4,6)/(4*6)</code></p><p>因为本题目的a，b，c都是互质，所以就不用考虑这种情况</p><p>然后，因为给出的数的范围较大，所以我们可以将*变为/</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0MS6348KB2082019-05-07 17:18:01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="type">int</span> ans = n/a+n/b+n/c - <span class="number">2</span>*(n/a/b + n/b/c + n/a/c) + <span class="number">4</span>*(n/a/b/c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽屉定理"><a href="#抽屉定理" class="headerlink" title="抽屉定理"></a>抽屉定理</h1><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><p>参考：百度百科</p><p>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。<br>抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。”<br>抽屉原理有时也被称为鸽巢原理。它是组合数学中一个重要的原理。</p><h2 id="第一抽屉定理"><a href="#第一抽屉定理" class="headerlink" title="第一抽屉定理"></a>第一抽屉定理</h2><ul><li><p>原理1： 把多于n+1个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。</p></li><li><p>原理2 ：把多于(mn+1，n不为0)个的物体放到n个抽屉里，则至少有一个抽屉里有不少于（m+1）的物体。</p></li><li><p>原理3 ：把无穷多件物体放入n个抽屉，则至少有一个抽屉里有无穷个物体。</p></li></ul><h2 id="第二抽屉定理"><a href="#第二抽屉定理" class="headerlink" title="第二抽屉定理"></a>第二抽屉定理</h2><p>把(mn-1)个物体放入n个抽屉中，其中必有一个抽屉中至多有(m-1)个物体(例如，将3×5-1=14个物体放入5个抽屉中，则必定有一个抽屉中的物体数少于等于3-1=2)</p><h2 id="最差原则"><a href="#最差原则" class="headerlink" title="最差原则"></a>最差原则</h2><p>最差原则，即考虑所有可能情况中，最不利于某件事情发生的情况。</p><p>例如，有300人到招聘会求职，其中软件设计有100人，市场营销有80人，财务管理有70人，人力资源管理有50人。那么至少有多少人找到工作才能保证一定有70人找的工作专业相同呢？</p><p>此时我们考虑的最差情况为：软件设计、市场营销和财务管理各录取69人，人力资源管理的50人全部录取，则此时再录取1人就能保证有70人找到的工作专业相同。</p><p>（人力资源管理全部录取，其他各录取69，再多1人就可以保证有70人工作专业相同，因为这1个人一定是软件设计，财务管理，市场营销的，不会是人力资源管理的，所以再加一个人就可以保证了）</p><p>因此至少需要69*3+50+1=258人。</p><h2 id="Nyoj417死神来了"><a href="#Nyoj417死神来了" class="headerlink" title="Nyoj417死神来了"></a><a href="http://nyoj.top/problem/417">Nyoj417死神来了</a></h2><p><img src="/2019/05/06/%E5%AE%B9%E6%96%A5%E4%B8%8E%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/nyoj417.png" alt></p><p>假如存在倍数关系，有倍数关系的当为一组。</p><ul><li><p>当n为偶数，最多有n/2组分组(按照2的倍数关系分组)</p></li><li><p>假如是奇数，最多有n/2+1组分组</p></li></ul><p>统一写为p=n/2+(n&amp;1)组</p><p>（n&amp;1：n为奇数时结果为1，n为偶数结果为0）</p><p>例如：</p><p>当n=20时，可分组为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A1 = &#123;1, 2, 4，8, 16&#125;</span><br><span class="line">A2 = &#123;3, 6, 12&#125;</span><br><span class="line">A3 = &#123;5, 10, 20&#125;</span><br><span class="line">A4 = &#123;15&#125;</span><br><span class="line">A5 = &#123;7, 14&#125;</span><br><span class="line">A6 = &#123;9，18&#125;</span><br><span class="line">A7 = &#123;11&#125;</span><br><span class="line">A8 = &#123;13&#125;</span><br><span class="line">A9 = &#123;17&#125;</span><br><span class="line">A10 = &#123;19&#125; </span><br><span class="line">共十组</span><br></pre></td></tr></table></figure><p>存在最坏情况，我们取{19, 17, 13, 11, 18, 14, 15, 20, 12, 16}，也就是取每一组最后一个元素，这样就不存在任意一个数是另外一个数的倍数，所以m至少得取11，即m&gt;n/2。</p><p><strong>取11时，比取10时多一个数，那么就可能至少有2个数出现在同一个倍数集合中，因为取10时是所有组中都取一个数,。正好对应了抽屉定理，无论怎么放至少会有一个抽屉里面至少放两个苹果。</strong></p><p>当n=21时，加一个分组A11={21}，那么m得取12，即m&gt;(n/2+1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 ms 1156 KB</span></span><br><span class="line"><span class="comment">2019-05-06 21:34:12</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        n = n/<span class="number">2</span>+(n&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(m &gt; n)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 容斥定理 </tag>
            
            <tag> 抽屉定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-ClassLoder部分文档解读</title>
      <link href="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-ClassLoder%E9%83%A8%E5%88%86%E6%96%87%E6%A1%A3%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-ClassLoder%E9%83%A8%E5%88%86%E6%96%87%E6%A1%A3%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>ClassLoder部分文档解读</p><span id="more"></span><h1 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span></span><br><span class="line"><span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.</span><br><span class="line"></span><br><span class="line">一个类加载器是一个对象，负责加载类。类ClassLoader是一个抽象类。给定了一个类的二进制名字，ClassLoader应该尝试去定位或者生成构成了类定义的数据。一种典型的策略是将给定的二进制名字转为文件名，然后从文件系统中读取这个文件名里面的class信息。</span><br></pre></td></tr></table></figure><blockquote><p>Binary names</p><p>Any class name provided as a String parameter to method in ClassLoader must be a binary name as definded by <em>The Java Language Specification</em></p><p>Examples of valid class name include:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;java.lang.String&quot;</span></span><br><span class="line"><span class="string">&quot;javax.swing.JSpinner$DefaultEditor&quot;</span></span><br><span class="line"><span class="string">&quot;java.security.KeyStore$Builder$FileBuilder$1&quot;</span></span><br><span class="line"><span class="string">&quot;java.net.URLClassLoader$3$1&quot;</span></span><br></pre></td></tr></table></figure></blockquote><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Every Class object contains a reference to the ClassLoader that defined it.</span><br><span class="line">Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</span><br><span class="line">Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.</span><br><span class="line"></span><br><span class="line">每一个class对象都会包含着定义这个class对象的ClassLoader的引用。</span><br><span class="line">针对于数组类的class对象，并不是由类加载器创建的，而是由java在运行时需要的时候自动创建的。对于一个数组类的类加载器来说，其Class.getClassLoader的返回值与这个数组中元素类型的etClassLoader的返回值是一样的。如果数组当中的元素类型是原生类型，那么这个数组类是没有加载器的。</span><br><span class="line">应用实现了ClassLoader的子类是为了扩展java虚拟机动态加载类的方式</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//string类型由根加载器加载，所以返回null</span></span><br><span class="line">        System.out.println(strings.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">        Main[] mains = <span class="keyword">new</span> <span class="title class_">Main</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//Main类型由系统类加载器加载，所以返回sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(mains.getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//原生类型没有类加载器</span></span><br><span class="line">        System.out.println(ints.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">null </span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class loaders may typically be used by security managers to indicate security domains.</span><br><span class="line">Class loaders may typically be used by security managers to indicate security domains.</span><br><span class="line">The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine&#x27;s built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.</span><br><span class="line"></span><br><span class="line">类加载器典型情况下可以被安全管理器使用来去标识的安全域问题。</span><br><span class="line">类加载器使用了一种委派模型来去寻找类和资源。ClassLoader的每一个实例都会有与之关联的双亲。当被请求去寻找一个类或资源的时候，在自己寻找前，ClassLoader的实例就会将对于类或资源的寻找委托给父ClassLoader。虚拟机内建的类加载器称之为启动类加载器，本身没有双亲，但是它可以作为类加载器的双亲。</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable.</span><br><span class="line">In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).</span><br><span class="line"></span><br><span class="line">我们将支持并行的类加载器称之为parallel capable class loaders，它被要求在它们的类初始化期间通过ClassLoader.registerAsParallelCapable方法将自身注册上。注意，ClassLoader默认注册为parallel capable。然而它们的子类如果也是并行的，仍然需要注册。</span><br><span class="line">在委派模式不是严格的层次化环境下，类加载器需要并行，否则类加载会导致死锁，因为加载器的锁在加载过程中是一直持有的。</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.</span><br><span class="line">However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.</span><br><span class="line"></span><br><span class="line">通常情况下，java虚拟机会从本地的文件系统以一种平台相关性加载类，比如在Unix，虚拟机会从由CLASSPATH变量所定义的目录下去加载类。</span><br><span class="line">然而，一些类可能并不是来自一个文件，它们可能来自于其他来源，比如网络或者由应用本身构建出来。在这种情况下，defineClass方法会将一个字节数组转换成class类的一个实例，这个新定义的实例是可以通过Class.newInstance去创建。</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.</span><br><span class="line">For example, an application could create a network class loader to download class files from a server. Sample code might look like:</span><br><span class="line">     ClassLoader loader = new NetworkClassLoader(host, port);</span><br><span class="line">     Object main = loader.loadClass(&quot;Main&quot;, true).newInstance();</span><br><span class="line">          . . .</span><br><span class="line">The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:</span><br><span class="line">       class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">           String host;</span><br><span class="line">           int port;</span><br><span class="line">  </span><br><span class="line">           public Class findClass(String name) &#123;</span><br><span class="line">               byte[] b = loadClassData(name);</span><br><span class="line">               return defineClass(name, b, 0, b.length);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           private byte[] loadClassData(String name) &#123;</span><br><span class="line">               // load the class data from the connection</span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">由类加载器所创建的对象的方法或构造方法可能会引用其他的类。为了确定所引用的类，java虚拟机会调用最初创建这个类的loadClass方法去加载它所引用的其他的类。</span><br><span class="line">比如说，一个应用可以创建一个网络类加载器，从服务器上加载类：</span><br><span class="line">     ClassLoader loader = new NetworkClassLoader(host, port);</span><br><span class="line">     Object main = loader.loadClass(&quot;Main&quot;, true).newInstance();</span><br><span class="line">          . . .</span><br><span class="line">网络类加载器子类必须定义网络加载类的方法findClass和loadClassData 。 一旦下载构成类的字节，它应该使用方法defineClass创建一个类实例:</span><br><span class="line">       class NetworkClassLoader extends ClassLoader &#123;</span><br><span class="line">           String host;</span><br><span class="line">           int port;</span><br><span class="line">  </span><br><span class="line">           public Class findClass(String name) &#123;</span><br><span class="line">               byte[] b = loadClassData(name);</span><br><span class="line">               return defineClass(name, b, 0, b.length);</span><br><span class="line">           &#125;</span><br><span class="line">  </span><br><span class="line">           private byte[] loadClassData(String name) &#123;</span><br><span class="line">               // load the class data from the connection</span><br><span class="line">                . . .</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-类加载器双亲委托派制2</title>
      <link href="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/"/>
      <url>/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/</url>
      
        <content type="html"><![CDATA[<p>继续学习jvm类加载器双亲委派机制</p><span id="more"></span><h1 id="循环获得ClassLoader"><a href="#循环获得ClassLoader" class="headerlink" title="循环获得ClassLoader"></a>循环获得ClassLoader</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != classLoader)&#123;</span><br><span class="line">            <span class="comment">//获取加载器的父亲</span></span><br><span class="line">            classLoader = classLoader.getParent(); </span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$ExtClassLoader@74a14482</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="getSystemClassLoader"><a href="#getSystemClassLoader" class="headerlink" title="getSystemClassLoader"></a>getSystemClassLoader</h2><p><img src="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/1.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回用于委派的系统类加载器。 </span></span><br><span class="line"><span class="comment"> * 这是新的ClassLoader实例的默认委派父项， 通常是用于启动应用程序的类加载器。</span></span><br><span class="line"><span class="comment"> * 该方法首先在运行时的启动顺序中早期被调用</span></span><br><span class="line"><span class="comment"> * 此时它将创建系统类加载器并将其设置为调用Thread的上下文类加载器</span></span><br><span class="line"><span class="comment"> * 默认的系统类加载器是此类的实现相关实例</span></span><br><span class="line"><span class="comment"> * 如果在首次调用此方法时定义系统属性&quot;java.system.class.loader&quot;</span></span><br><span class="line"><span class="comment"> * 那么该属性的值将被视为将作为系统类  加载器返回的类的名称</span></span><br><span class="line"><span class="comment"> * 类使用默认的系统类加载器加载，必须定义一个公共构造函数，其被用作代理父ClassLoader类型的单个参数</span></span><br><span class="line"><span class="comment"> * 然后使用该构造函数创建一个实例，并使用默认的系统类加载器作为参数</span></span><br><span class="line"><span class="comment"> * 所生成的类加载器被定义为系统类加载器。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title function_">getSystemClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initSystemClassLoader"><a href="#initSystemClassLoader" class="headerlink" title="initSystemClassLoader()"></a>initSystemClassLoader()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">initSystemClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//sclSet:设定好系统类加载器了的话该值为true</span></span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="comment">//scl:系统类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//递归调用异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;recursive invocation&quot;</span>);</span><br><span class="line">        sun.misc.<span class="type">Launcher</span> <span class="variable">l</span> <span class="operator">=</span> sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">oops</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//通过Launch类的getClassLoader()获得应用类加载器</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scl = AccessController.doPrivileged(</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 处理用户自定义了java.system.class.loader系统属性的情况</span></span><br><span class="line"><span class="comment">                     * 有可能是默认的AppClassLoader，也有可能是用户自定义的</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SystemClassLoaderAction</span>(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//系统类加载器设置完毕</span></span><br><span class="line">        sclSet = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SystemClassLoaderAction"><a href="#SystemClassLoaderAction" class="headerlink" title="SystemClassLoaderAction"></a>SystemClassLoaderAction</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SystemClassLoaderAction</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;ClassLoader&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//自定义类加载器系统属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cls</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.system.class.loader&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="literal">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">sys</span> <span class="operator">=</span> (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; parent &#125;);</span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        <span class="keyword">return</span> sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="class-forName"><a href="#class-forName" class="headerlink" title="class.forName"></a>class.forName</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回一个给定类或者接口的一个Class对象，如果没有给定classloader，那么会使用根类加载器，</span></span><br><span class="line"><span class="comment"> * 给定了类或者接口的完全限定名，那么这个方法将尝试去定位，加载和链接类或接口，</span></span><br><span class="line"><span class="comment"> * 如果initalize这个参数传了true，那么给定的类如果之前没有被初始化过，那么会被初始化。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 所需类的完全限定名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialize 是否初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt; caller = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取到调用forName这个方法的Class对象</span></span><br><span class="line">            caller = Reflection.getCallerClass();</span><br><span class="line">            <span class="keyword">if</span> (sun.misc.VM.isSystemDomainLoader(loader)) &#123;</span><br><span class="line">            <span class="comment">//获取到调用forName这个方法的Class对象的类加载器</span></span><br><span class="line">                <span class="type">ClassLoader</span> <span class="variable">ccl</span> <span class="operator">=</span> ClassLoader.getClassLoader(caller);</span><br><span class="line">                <span class="keyword">if</span> (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123;</span><br><span class="line">                    sm.checkPermission(</span><br><span class="line">                        SecurityConstants.GET_CLASSLOADER_PERMISSION);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//forName0:native方法</span></span><br><span class="line">        <span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="getParent"><a href="#getParent" class="headerlink" title="getParent"></a>getParent</h2><p><img src="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/2.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回父类加载器进行委派</span></span><br><span class="line"><span class="comment"> * 一些实现可以使用null来表示根类加载器</span></span><br><span class="line"><span class="comment"> * 如果此类加载器的父级是根类加载器，则此方法将返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Check access to the parent class loader</span></span><br><span class="line">        <span class="comment">// If the caller&#x27;s class loader is same as this class loader,</span></span><br><span class="line">        <span class="comment">// permission check is performed.</span></span><br><span class="line">        checkClassLoaderPermission(parent, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获得指定class文件的资源"><a href="#获得指定class文件的资源" class="headerlink" title="获得指定class文件的资源"></a>获得指定class文件的资源</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//获取当前线程上下文的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;Main.class&quot;</span>;</span><br><span class="line">        <span class="comment">//获取给定名称的所有资源</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = classLoader.getResources(res);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历输出所有资源</span></span><br><span class="line">        <span class="keyword">while</span>(urls.hasMoreElements())&#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">file:/home/cc/IdeaProjects/test/out/production/test/Main.class</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="getContextClassLoader"><a href="#getContextClassLoader" class="headerlink" title="getContextClassLoader()"></a>getContextClassLoader()</h2><p><img src="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/3.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> * 返回此Thread的上下文ClassLoader</span></span><br><span class="line"><span class="comment"> * 上下文ClassLoader由线程的创建者提供，以便在加载类和资源时在此线程中运行的代码使用</span></span><br><span class="line"><span class="comment"> * 默认是父线程的ClassLoader上下文</span></span><br><span class="line"><span class="comment"> * 原始线程的上下文ClassLoader通常设置为用于加载应用程序的类加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> ClassLoader <span class="title function_">getContextClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (contextClassLoader == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                               Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getResources"><a href="#getResources" class="headerlink" title="getResources()"></a>getResources()</h2><p><img src="/2019/05/04/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%B4%BE%E5%88%B62/4.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找具有给定名称的所有资源</span></span><br><span class="line"><span class="comment"> * 资源是可以通过独立于代码位置的方式由类代码访问的一些数据（图像，音频，文本等）</span></span><br><span class="line"><span class="comment"> * 资源的名称是标识资源的/分隔路径名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title function_">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> <span class="title class_">Enumeration</span>&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">    &#125;</span><br><span class="line">    tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompoundEnumeration</span>&lt;&gt;(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取ClassLoader的途径"><a href="#获取ClassLoader的途径" class="headerlink" title="获取ClassLoader的途径"></a>获取ClassLoader的途径</h1><ol><li>获取当前类的ClassLoader</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class&lt;?&gt; clazz</span><br><span class="line">clazz.getClassLoader();</span><br></pre></td></tr></table></figure><ol><li>获取当前线程上下文的ClassLoader</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread.getContextClassLoader();</span><br></pre></td></tr></table></figure><ol><li>获得系统的ClassLoader</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure><ol><li>获得调用者的ClassLoader</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
            <tag> 双亲委派机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-java虚拟机类加载2</title>
      <link href="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD2/"/>
      <url>/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD2/</url>
      
        <content type="html"><![CDATA[<p>继续学习jvm类的加载</p><span id="more"></span><p><img src="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD2/1.jpg" alt></p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><ol><li><p>类一定是由类加载器加载但是</p></li><li><p>类的加载的最终产品是位于内存中的class对象</p></li><li><p>class对象封装了类在方法区内的数据结构，并且向java程序员提供了访问方法区内的数据结构的接口</p></li><li><strong>类加载器并不需要等到某个类被“首次主动使用”时再加载它</strong></li></ol><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><ol><li><p>jvm规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了class文件缺失或存在错误，类加载器必须在<strong>程序首次主动</strong>使用该类时才报告错误<strong>（LinkageError错误）</strong></p></li><li><p>如果这个类一直没有被程序主动使用，那么<strong>类加载器就不会报告这个错误</strong></p></li></ol><h2 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h2><p>类加载器用来把类加载到java虚拟机中。从jdk1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好保证java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序要求加载loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身记载Sample类</p><p>有两种类型的类加载器</p><h3 id="Java虚拟机自带的加载器"><a href="#Java虚拟机自带的加载器" class="headerlink" title="Java虚拟机自带的加载器"></a>Java虚拟机自带的加载器</h3><ol><li>根类加载器（Bootstrap）</li><li>扩展类加载器（Extension）</li><li>系统（应用）类加载器（System）</li></ol><h3 id="用户自定义的类加载器"><a href="#用户自定义的类加载器" class="headerlink" title="用户自定义的类加载器"></a>用户自定义的类加载器</h3><ol><li><code>java.lang.ClassLoader</code>的子类</li><li>用户可以定义类的加载方式</li></ol><h3 id="详细介绍三种类加载器"><a href="#详细介绍三种类加载器" class="headerlink" title="详细介绍三种类加载器"></a>详细介绍三种类加载器</h3><p>Java虚拟机自带了以下几加载器．</p><ol><li>根(Bootstrap)类加载器：该加载器没有父加载器，它负责加载虚拟机的核心类库．如<code>java.lang.*</code>等。<br>根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。根类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一剖分，它并没有继承<code>java.lang.ClassLoader</code>类。</li><li>扩展(Extension）类加器：它的父加载器为根类加载器。它从<code>java.ext.dirs</code>系属性所指定的目录中加类厍，或者从JDK的安装目录<code>jre\lib\ext</code>子目录（扩展目录）下加载类库，如果把用户创建的JAR文件放在这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是<code>java.lang.ClassLoader</code>类的子类。</li><li>系统(System)类加载器：也称为应用类加载器．它的父加载器为扩展类加<br>载器。它从环境变量<code>classpath</code>或者系统属性<code>java.class.path</code>所指定的目录中加<br>载类，它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java<br>类，是<code>java.lang.ClassLoader</code>类的子类。</li></ol><h2 id="简略加载过程"><a href="#简略加载过程" class="headerlink" title="简略加载过程"></a>简略加载过程</h2><p>参考：<a href="https://javacodes.cn/464.html">https://javacodes.cn/464.html</a></p><p><img src="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD2/2.png" alt></p><ul><li>如果一个类加载器收到了类加载的请求，它不会先自己尝试处理这个请求，而是委派给它的父类加载器，所有的请求最终都会传送到顶层的启动类加载器</li><li>只有当父类反馈自己无法完成该请求（它的搜索范围中没有找到所需的类，即抛出<code>ClassNotFoundException</code>）时，子加载器才会尝试自己加载。</li></ul><h1 id="类的验证"><a href="#类的验证" class="headerlink" title="类的验证"></a>类的验证</h1><p>类被加载后，就进入连接阶段。连接就是将已经读入到内存的类的二进制数据集合并到虚拟机的运行时环境去。</p><h2 id="类验证部分内容"><a href="#类验证部分内容" class="headerlink" title="类验证部分内容"></a>类验证部分内容</h2><ol><li>类的文件结构检查</li><li>语义检查</li><li>字节码验证</li><li>二进制兼容性的验证</li></ol><h1 id="类的准备"><a href="#类的准备" class="headerlink" title="类的准备"></a>类的准备</h1><p>在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于下面的Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> b;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h1><p>在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：</p><ol><li>在静态变量的声明处进行初始化</li><li>在静态代码块中进行初始化。</li></ol><p>例如在下面代码中，静态变量a和b都被显式初始化，而静态变量c没有被显式初始化，它将保持默认值0.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//在静态变量的声明处进行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        b = <span class="number">2</span>; <span class="comment">//在静态代码块中进行初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量的声明语句中，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行它们。例如当以下Sample雷欧被初始化后，它的静态变量a的取值为4.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sample</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line">    <span class="keyword">static</span>&#123; a = <span class="number">2</span>; &#125;</span><br><span class="line">    <span class="keyword">static</span>&#123; a = <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Main</span><span class="params">(Stringa args[])</span>&#123;</span><br><span class="line">        System.out.println(a); <span class="comment">//打印4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h2><ol><li>假设这个类还没有被加载和连接，那就先进行加载和连接</li><li>假设类存在直接父类，并且这个父类还没有好被初始化，那就先初始化直接父类</li><li>假设类中存在初始化语句，那就依次执行这些初始化语句</li></ol><h2 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h2><ol><li><p>创建类的实例</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如Class.forName(“com.test.test”)）</p></li><li><p>初始化一个类的子类</p></li><li><p>java虚拟机启动时被标明为启动类的类</p></li><li><p>jdk1.7开始提供动态语言支持：</p><p><code>java.lang.invoke.MethodHandle</code>实例的解析结果<code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code>句柄对应的类没有初始化，则初始化</p></li></ol><p>除了上述7种情形，其他使用java类的方式都被看做是被动使用，不会导致的类的初始化</p><p>（调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化）</p><h2 id="接口初始化"><a href="#接口初始化" class="headerlink" title="接口初始化"></a>接口初始化</h2><p>当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-类加载器双亲委托派制</title>
      <link href="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>jvm类加载器双亲委派机制</p><span id="more"></span><p>并不是所有的jvm虚拟机都使用这个机制，只是大部分，比如还有使用osgi的。</p><p>双亲委任模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。在Java的世界中大部分的类加载器都遵循者模型</p><h1 id="类加载器的双亲委派机制"><a href="#类加载器的双亲委派机制" class="headerlink" title="类加载器的双亲委派机制"></a>类加载器的双亲委派机制</h1><p>在双亲委派机制中，各个加载器按照父子关系形成了树形结构（逻辑意义），除了根类加载器之外，其余的类加载器都有且有一个父加载器</p><p><img src="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/1.png" alt></p><p>根类加载器和扩展类加载器只能加载指定路径的里面的类，而系统类加载器一般可以加载我们工程中所定义的类</p><ul><li><p>根类加载器：由c++实现，不是<code>ClassLoader</code>子类</p></li><li><p>扩展类加载器：由<code>sun.misc.Launcher$ExtClassLoader</code>实现</p></li></ul><p>（代表ExtClassLoader是sun.misc.Launcher的一个内部类）</p><ul><li>系统类加载器：由<code>sun.misc.Launcher$AppClassLoader</code>实现</li></ul><h1 id="过程实例"><a href="#过程实例" class="headerlink" title="过程实例"></a>过程实例</h1><p><img src="/2019/05/03/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/2.png" alt></p><p>Loder1与Loader2是用户自定义的类加载器，两者之间又形成了父子关系</p><ol><li><p>Loder1想要加载我们编写的Sample类，根据类加载器的双亲委派机制，并不是由Loader1直接加载到虚拟机当中，而是把加载任务委派给Loader1的父亲系统类加载器，系统类加载器再将任务委派给扩展类加载器，同理，扩展类加载器将任务最终委派给根类加载器</p></li><li><p>根类加载器尝试去加载编写的Sample类，根类加载器不能加载Sample类，然后把加载任务返回给扩展类加载器，扩展类加载器也不能加载Sample类，同样返回给系统类加载器，最终加载成功，接着把流程返回给Loader1，加载过程结束。</p></li></ol><ul><li>如果一个类加载器收到了类加载的请求，它不会先自己尝试处理这个请求，而是委派给它的父类加载器，所有的请求最终都会传送到顶层的启动类加载器</li><li>只有当父类反馈自己无法完成该请求（它的搜索范围中没有找到所需的类，即抛出<code>ClassNotFoundException</code>）时，子加载器才会尝试自己加载。</li></ul><h1 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line">        <span class="comment">/* public ClassLoader getClassLoader()</span></span><br><span class="line"><span class="comment">         * 返回类的类加载器</span></span><br><span class="line"><span class="comment">         * 一些实现可能使用null来表示根类加载器。</span></span><br><span class="line"><span class="comment">         * 如果此类由根类加载器加载，则此方法将在此类实现中返回null。</span></span><br><span class="line"><span class="comment">         * 如果此对象表示原始类型或空值，则返回null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz2 = Class.forName(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">        System.out.println(clazz2.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出：</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//18b4aac2是它的hash code</span></span><br></pre></td></tr></table></figure><p>可以看到Main是由系统类加载器加载的</p><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ol><li>可以确保Java核心库的类型安全：所有的Java应用都至少会引用<code>java.lang.Object</code>类，也就是说在运行期，<code>java.lang.Object</code>这个类会被加载到Java虚拟机中；如果个加载过程是由Java应用自己类加载器所完成的，那么很可能就会在JVM中存在多个版本的<code>java.lang.Object</code>，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）<br>借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了Java应用所使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。</li><li>可以确保Java核心类库所提供的类不会被定义的类所替代。</li><li>不同的类加载器可以为相同名称(<code>binaryname</code>)的类创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器来加载他们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。</li></ol><h1 id="破坏"><a href="#破坏" class="headerlink" title="破坏"></a>破坏</h1><p>参考：<a href="https://juejin.im/post/5a59f2296fb9a01ca871eb8c">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a></p><p>到目前为止，双亲委派模型有过3次大规模的“被破坏”的情况。</p><h2 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h2><p>在双亲委派模型出现之前——-即JDK1.2发布之前。</p><h2 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h2><p>是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，<strong>如果基础类调用会用户的代码</strong>怎么办呢？</p><p>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？</p><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。</p><p>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，<strong>JDBC</strong>，JCE，JAXB，JBI等。</p><h2 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h2><p>为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 双亲委派机制 </tag>
            
            <tag> 类的记载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2019/04/29/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2019/04/29/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>单调栈及poj2559</p><span id="more"></span><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>什么是单调栈？顾名思义，单调栈首先是一个栈，并且栈内的元素的大小按照他们所在栈内的位置，满足一定的单调性。</p><p>比如有一数组{1,3,232,23,24,3324,-1}，维护其单调递减栈，数组左边为栈顶</p><p>首先，栈为空，入栈[1]</p><p>到下一个元素3，因为3&gt;1，所以入栈，此时栈[3,1]</p><p>接着下一个元素232，因为232&gt;3，所以入栈，此时栈[232,3,1]</p><p>接着下一个元素23，因为232&lt;23，所以232出栈，此时栈[3,1]，因为3&lt;23，所以入栈，此时栈[23,3,1]</p><p>接着下一个元素3324，因为3324&gt;23，所以入栈，此时栈[3324,23,3,1]</p><p>接着下一个元素-1，因为3324&gt;-1，所以出栈，此时栈[23,3,1]，因为23&gt;-1，所以出栈，此时栈[3,1]，因为3&gt;-1，出栈，此时栈[1]，因为1&gt;-1，出栈，此时栈为空，将-1入栈，此时栈[-1]</p><h1 id="模板题—poj2559"><a href="#模板题—poj2559" class="headerlink" title="模板题—poj2559"></a><a href="http://poj.org/problem?id=2559">模板题—poj2559</a></h1><p><img src="/2019/04/29/%E5%8D%95%E8%B0%83%E6%A0%88/timu.png" alt></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>参考：<a href="https://www.zybuluo.com/Chilling/note/633014">https://www.zybuluo.com/Chilling/note/633014</a></p><p>题意：给出几个连续的宽为1的木板的高度，求木板构成矩形的最大面积。</p><p>将木板的长和宽（h，w）压入栈中，若下一个木板的高度大于等于当前栈顶的，那么依次弹出栈中的木板，并且累加他们的宽度，更新最大面积，贪心选择当前最高矩形能连续的位置</p><p>举例：</p><p>(x，y)为一结构体，x表示矩形的高，y为矩形的宽。<br>给出的例子：2，1，4，5，1，3，3，数组左边为栈顶</p><ol><li>入栈： <code>(2,1)</code></li><li>下一个高度为1，但是栈顶高度为2，大于1，说明高度为2的矩形不能延续到当前矩形，那么删除(2，1)，累加宽度，并且更新最大面积2，（1，2）入栈；<code>(1,2)</code></li><li><p>(4，1)入栈：<code>(4,1)(1,2)</code></p></li><li><p>(5，1)入栈：<code>(5,1)(4,1)(1,2)</code></p></li><li><p>下一个高度为1，但是栈顶高度为5，大于1，那么删除(5，1)，更新最大矩形面积为5，把1累加到下一个元素，得到(4，2)，仍然大于1，删除(4，2)，更新最大矩形面积为8，把2累加到下一个元素，得到(1，4)，面积为4小于8，不必更新，删除(1，4)，把4累加到当前准备进栈的元素，(1，5)进栈</p></li><li>(3，1)进栈：<code>(3,1)(1,5)</code></li><li>下一个高度为3，但是栈顶高度也为3，删除(3，1)不必更新，把1累加到当前准备进栈的元素，(3，2)进栈: <code>(3,2)(1,5)</code></li><li>栈非空时，依次出栈；首先(3，2)出栈，不必更新，把2累加到下一个元素，当前栈为(1，7)，(1，7)出栈，不必更新。<br>栈空，结束。<br>最后的答案就是8</li></ol><p><img src="/2019/04/29/%E5%8D%95%E8%B0%83%E6%A0%88/1.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c++: 2812K375MS</span></span><br><span class="line"><span class="comment">2019-04-29 20:57:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    LL h,w; <span class="comment">//矩形的高，宽</span></span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i].h);</span><br><span class="line">            a[i].w = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;node&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL temp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//栈不为空&amp;&amp;栈顶的值&gt;=当前元素的值，出栈已经更新面积值</span></span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().h &gt;= a[i].h) </span><br><span class="line">            &#123;</span><br><span class="line">                LL x = q.<span class="built_in">top</span>().h*(q.<span class="built_in">top</span>().w+temp); <span class="comment">//计算面积</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans,x);</span><br><span class="line">                temp += q.<span class="built_in">top</span>().w; <span class="comment">//叠加宽</span></span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node next;</span><br><span class="line">            next.h = a[i].h;</span><br><span class="line">            next.w = <span class="number">1</span>+temp;</span><br><span class="line">            q.<span class="built_in">push</span>(next); <span class="comment">//元素进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">                LL temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) <span class="comment">//遍历完所有元素，但是栈还有元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            LL x = q.<span class="built_in">top</span>().h*(q.<span class="built_in">top</span>().w+temp);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,x);</span><br><span class="line">            temp += q.<span class="built_in">top</span>().w;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调队列</title>
      <link href="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>单调队列及其优化dp</p><span id="more"></span><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p><strong><a href="http://poj.org/problem?id=2823">poj2823—Sliding Window</a></strong></p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/timu.png" alt></p><p>大意：给你一个长度为N的数组，一个长为K的滑动的窗体从最左移至最右端，你只能见到窗口的K个数，每次窗体向右移动一位，你的任务是找出窗体每个时刻中的最大值与最小值</p><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列能够进行排序，窗口往右一位，就把一个元素放到队列里面，然后每次取队首元素，如果队首元素的id在这个框的范围内的话，那么就取队首，如果不是的话那么就出队，找下一个队首元素，时间复杂度为O(nlogn)</p><h2 id="对优先队列改良—单调队列O-n"><a href="#对优先队列改良—单调队列O-n" class="headerlink" title="对优先队列改良—单调队列O(n)"></a>对优先队列改良—单调队列O(n)</h2><p><strong>基本思想：同样维护队首元素作为答案，去掉多余的元素（维护单调性）</strong></p><p>因为是求最大值，所以维护一个单调递减队列，其队首就是最大值，就是我们想要的答案</p><div class="table-container"><table><thead><tr><th></th><th>L</th><th>L+1</th><th>……</th><th>R-1</th><th>R</th></tr></thead><tbody><tr><td>编号</td><td>A[L]</td><td>A[L+1]</td><td>……</td><td>A[R-1]</td><td>A[R]</td></tr><tr><td>值</td><td>B[L]</td><td>B[L+1]</td><td>……</td><td>B[R-1]</td><td>B[R+1]</td></tr></tbody></table></div><p>上面单调<strong>递减</strong>队列满足：</p><p><code>A[i+1]&gt;A[i]&gt;A[i-1] &amp;&amp; B[i-1]&gt;B[i]&gt;B[i+1]（R&gt;i&gt;L）</code></p><p>单调队列里面的每一个元素一般用一个二元组(id, val)来表示，每次从队尾入队，删除队尾的无用元素，保证编号递增，值递减</p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/1.png" alt></p><p>如上图，当有一元素A要入队时，为了保证队中的单调性，需要删除队尾两个元素，A才能入队，单调性得到了保证，删除队尾的那两个元素，就是上面说的“无用元素”</p><hr><p>下面举例是怎么工作的，刚开始只有[1,1]，所以二元组的值为(1,1)，接着扩大区间，第二个元素元素准备入队，此时3要比-1大，所以去掉队尾元素，然后判断队首元素id属不属于当前区间，是的话就取队首为最大值，否则去掉队首，直到满足条件。如果准备入队的元素小于队尾的元素，直接入队，然后判断队首是不是属于当前区间，接着取最大值，不是则去队首。</p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/2.png" alt></p><p><strong>每个元素都只会进队和出队一次，故时间复杂度为O(n)</strong></p><p><strong>本质作用：在运行的过程中能够快速需求前k个或后k个中的最值</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考：<a href="http://zory.coding.me/posts/e1c7.html">http://zory.coding.me/posts/e1c7.html</a></p><p>单调队列可以用STL的deque实现，也可以手写数组实现。</p><p>两种实现效率比较：数组优于deque</p><p><strong>因为系统自带容器不方便而且不易调试，同时，每个数只会进去一次，所以，数组绝对不会爆，空间也是S（N），优于堆或线段树等数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++: 5604K5360MS</span></span><br><span class="line"><span class="comment">2019-04-28 21:18:27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos, val; <span class="comment">//位置与值的二元组</span></span><br><span class="line">&#125;q1[MAXN], q2[MAXN];</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Front = <span class="number">1</span>, Back = <span class="number">0</span>; <span class="comment">//队首与队尾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//队不为空&amp;&amp;队尾元素大于要进队的元素</span></span><br><span class="line">        <span class="keyword">while</span>(Back &gt;= Front &amp;&amp; q1[Back].val &gt;= arr[i]) </span><br><span class="line">            Back--; <span class="comment">//出队</span></span><br><span class="line">        <span class="comment">//因为那个while循环在刚好满足的条件退出，所以得进一步处理下一个不满足要求的</span></span><br><span class="line">        Back++;</span><br><span class="line">        q1[Back].val = arr[i]; <span class="comment">//进队</span></span><br><span class="line">        q1[Back].pos = i;</span><br><span class="line">        <span class="keyword">while</span>(Back &gt;= Front &amp;&amp; q1[Front].pos + m - <span class="number">1</span> &lt; i) <span class="comment">//判断队首在不在当前区间</span></span><br><span class="line">            Front++; <span class="comment">//去队首</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q1[Front].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetMin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Front = <span class="number">1</span>, Back = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(Back &gt;= Front &amp;&amp; q2[Back].val &lt;= arr[i])</span><br><span class="line">            Back--;</span><br><span class="line">        Back++;</span><br><span class="line">        q2[Back].val = arr[i];</span><br><span class="line">        q2[Back].pos = i;</span><br><span class="line">        <span class="keyword">while</span>(Back &gt;= Front &amp;&amp; q2[Front].pos + m - <span class="number">1</span> &lt; i)</span><br><span class="line">            Front++;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= m)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q2[Front].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="built_in">GetMax</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">GetMin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列优化dp"><a href="#单调队列优化dp" class="headerlink" title="单调队列优化dp"></a>单调队列优化dp</h2><p>形如的dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i] = <span class="built_in">min</span>(f[j] | Low[i] &lt;= j &lt;= Up[i]) + a[i]</span><br></pre></td></tr></table></figure><p>Low和Up是关于i的单调不下降函数（因为是求min，队首为最小值）</p><p>例如下面举例<code>Low[i] &lt;= j &lt;= Up[i]</code>为阴影，那么求i+1的时候，阴影的左右端点不能往左移动，这样才能用单调队列求解，因为单调队列一直都是从头处理到尾，如果返回的时间复杂度就可能不是O(logn)了</p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/3.png" alt></p><h2 id="单调队列优化多重背包实例"><a href="#单调队列优化多重背包实例" class="headerlink" title="单调队列优化多重背包实例"></a>单调队列优化多重背包实例</h2><p><strong><a href="http://codevs.cn/problem/5429/">Codevs5249</a></strong></p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/timu2.png" alt></p><p><img src="/2019/04/26/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/timu1.png" alt></p><p>参考：<a href="https://blog.csdn.net/ylsoi/article/details/80238116">https://blog.csdn.net/ylsoi/article/details/80238116</a></p><p>题意：</p><p>你有一个容量为M的背包，和N种物品。<br>每种物品都有三个属性，vi，wi，与ci，分别表示这种物品的体积、价值和件数。<br>你的任务是，从这些所给物品中，选出若干件，其体积之和不能超过背包容量，并且使所选物品的权值的和最大。</p><p>解析：</p><p>朴素的方法当然是先枚举物品再枚举体积最后再枚举个数，但是这样的时间复杂度太高，接受不了，所以可以考虑用单调队列优化DP。发现单调队列维护的区间一定是一段连续的区间，但是由于v[i]的限制，如果还按照原来的顺序枚举，这样我们的决策点将不满足连续，而是离散的，所以我们要想办法解决这个问题才可以用单调队列优化。发现在模v[i]的同一个剩余类下的所有体积的决策点都是连续的（虽然看起来是离散，但是是连续的离散），可以用单调队列维护，所以我们先按照剩余类分类，对于每一个剩余类用一个单调队列维护，这样时间复杂度就只有O(nm)了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 971 ms</span></span><br><span class="line"><span class="comment"> 2019-04-28 22:33:41</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N=<span class="number">1e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c,w,num,n,m,i,j,k,head,tail;</span><br><span class="line"><span class="type">int</span> a[N],b[N],f[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;c, &amp;w, &amp;num);</span><br><span class="line">        <span class="keyword">if</span>(m/c&lt;num) <span class="comment">//取最小值 </span></span><br><span class="line">            num=m/c;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;c;k++) <span class="comment">//分成c份 </span></span><br><span class="line">        &#123;</span><br><span class="line">            head=tail=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=(m-k)/c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=j;</span><br><span class="line">                <span class="type">int</span> y=f[j*c+k]-j*w; <span class="comment">//将f[j*c+k]-j*w入队 </span></span><br><span class="line">                <span class="keyword">while</span>(head&lt;tail &amp;&amp; y&gt;=b[tail<span class="number">-1</span>])</span><br><span class="line">                    tail--;</span><br><span class="line">                a[tail]=x; <span class="comment">//记录下标 </span></span><br><span class="line">                b[tail++]=y; <span class="comment">//记录dp值 </span></span><br><span class="line">                <span class="keyword">while</span>(a[head]&lt;j-num) <span class="comment">//如果超出了范围 </span></span><br><span class="line">                    head++;</span><br><span class="line">                f[j*c+k]=b[head]+j*w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[m]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> dp优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-接口初始化规则</title>
      <link href="/2019/04/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99/"/>
      <url>/2019/04/26/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>接口初始化规则</p><span id="more"></span><h1 id="接口初始化规则"><a href="#接口初始化规则" class="headerlink" title="接口初始化规则"></a>接口初始化规则</h1><p>当java虚拟机初始化一个类时，要求它的所有父类都已经初始化，但是这条规则不适用于接口</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化</p><h1 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CC&quot;</span>); <span class="comment">//每次创建对象时都会输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ouput:</span></span><br><span class="line"><span class="comment">CC</span></span><br><span class="line"><span class="comment">c()</span></span><br><span class="line"><span class="comment">CC</span></span><br><span class="line"><span class="comment">c()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CC&quot;</span>); <span class="comment">//创建对象时只会输出一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;c()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ouput:</span></span><br><span class="line"><span class="comment">CC</span></span><br><span class="line"><span class="comment">c()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Mychild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyParent5 invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span>  <span class="title class_">Mychild5</span> <span class="keyword">extends</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出5，并没有<code>MyParent5 invoked</code></p><h1 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h1><p>把接口改成类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Mychild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyParent5 invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mychild5</span> <span class="keyword">extends</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则两个都会输出</p><p>如果变b变为final的话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Mychild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyParent5 invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Mychild5</span> <span class="keyword">extends</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正好验证了之前学的结论，b已经被放到常量池中，这时候与<code>Mychild5</code>和<code>MyParent5</code>都没有关系，即使删掉这两者<code>.class</code>文件都可以运行</p><h1 id="样例3"><a href="#样例3" class="headerlink" title="样例3"></a>样例3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Mychild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyGrandpa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyGrandpa invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent5</span> <span class="keyword">extends</span> <span class="title class_">MyGrandpa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyParent5 invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mychild5</span> <span class="keyword">extends</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只输出5</p><p>因为输出b并不会导致MyParent5的初始化，更不会导致接口的初始化。</p><p>改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Mychild5.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyGrandpa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyGrandpa invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent5</span> <span class="keyword">extends</span> <span class="title class_">MyGrandpa</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyParent5 invoked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mychild5</span> <span class="keyword">extends</span> <span class="title class_">MyParent5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则三者都会输出</p><p>其加载顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Loaded MyGrandpa from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br><span class="line">[Loaded MyParent5 from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br><span class="line">[Loaded Mychild5 from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 接口初始化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RMQ之ST表实现</title>
      <link href="/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>区间最值查询</p><span id="more"></span><p>参考：<a href="https://blog.csdn.net/qq_41311604/article/details/79900893">https://blog.csdn.net/qq_41311604/article/details/79900893</a></p><p><a href="https://www.cnblogs.com/YSFAC/p/7189571.html"></a></p><h1 id="RMQ"><a href="#RMQ" class="headerlink" title="RMQ"></a>RMQ</h1><p><strong>RMQ</strong><code>（Range Minimum/Maximum Query）</code>，<strong>即区间最值查询</strong>，这是一种在线算法，所谓在线算法，是指用户每次输入一个查询，便马上处理一个查询。RMQ算法一般用较长时间做预处理，时间复杂度为O(nlogn)，然后可以在O(1)的时间内处理每次查询。</p><hr><h2 id="求dp"><a href="#求dp" class="headerlink" title="求dp"></a>求dp</h2><p>现假设有一数组arr={1,3,6,7,4,2,5}；</p><p>设<code>dp[i][j]</code>表示从第i位开始连续2^j个数中的最小值。</p><p>例如<code>dp[2][1]</code>表示从第二位开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），即3，6中的最小值，所以<code>dp[2][1] = 3</code>;</p><p>那么怎么求<code>dp[2][1]</code>呢？</p><ol><li><p>当i=2，j=3时，求dp<code>[2][3]</code></p><p><img src="/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/1.png" alt></p><p>因为2^3=8，代表从2开始有8个数，所以范围为[2,9]<br>然后我们可以将其按照类似二分的思想将其拆分为两部分<br>所以中间mid=(2+9)/2=5</p><ul><li>左区间[2,5]：有4个数，其对应<code>dp[2][2]</code></li><li>右区间[6,9]：有4个数，其对应<code>dp[6][2]</code></li></ul></li><li><p>推广到普遍情况</p><p><img src="/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/2.png" alt></p><p>对照上面例子，因为平分，所以每个区间都可以分到一半的数(因为j是2的次方)，所以j肯定是j-1，<code>2^(j-1)</code>代表除以<code>2^j/2</code>，接着i就是很常见的位置关系了<br>左区间：<code>dp[i][j-1]</code><br>右区间：<code>dp[i+(2^j)/2][j-1]</code></p></li></ol><p>所以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp [i][j - <span class="number">1</span>], dp [i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先更新每两个元素中的最小值，然后通过每两个元素的最小值获得每4个元素中的最小值，依次类推更新所有长度的最小值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rmq_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=N; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = arr[i];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= N; j++) <span class="comment">//2^j不超过N</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= N; i++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询dp"><a href="#查询dp" class="headerlink" title="查询dp"></a>查询dp</h2><p>得到了dp数组，那么怎么得到区间[l,r]最小值呢？我们只需要对每个二分区间进行取min就行了，首先我们得到这个区间是2的几次方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/3.png" alt></p><p>然后2^k取到前面那些数的最小值，还没有覆盖整个区间，所以我们可以从后面再取最小值，最后再两者取最小就行了。</p><p>所以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RMQ[l,r] = <span class="built_in">min</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmq</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">log2</span>(r-l<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(dp[l][k],dp[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="poj3264—Balanced-Lineup"><a href="#poj3264—Balanced-Lineup" class="headerlink" title="poj3264—Balanced Lineup"></a><a href="http://poj.org/problem?id=3264">poj3264—Balanced Lineup</a></h1><p><img src="/2019/04/25/RMQ%E4%B9%8BST%E8%A1%A8%E5%AE%9E%E7%8E%B0/timu.png" alt></p><p>题意：有N头奶牛，按1-n编号，并给出他们的高度，有q次询问，求每次询问的一段编号区间内最高的牛和最矮的牛的身高差</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">G++: 8172K3579MS c++: 7964K1813MS  </span></span><br><span class="line"><span class="comment">(微软的C++比开源的G++，快了将近一)</span></span><br><span class="line"><span class="comment">2019-04-26 19:40:00</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E5</span>;</span><br><span class="line"><span class="type">int</span> maxn[MAXN][<span class="number">20</span>], minn[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> n, q, num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RMQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span> &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minn[i][j]=<span class="built_in">min</span>(minn[i][j<span class="number">-1</span>], minn[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">            maxn[i][j]=<span class="built_in">max</span>(maxn[i][j<span class="number">-1</span>], maxn[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RMQ_MAX</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//log2()报错的话可以用log的换底公式</span></span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(<span class="built_in">double</span>(R-L<span class="number">+1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(maxn[L][k],maxn[R-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RMQ_MIN</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(<span class="built_in">double</span>(R-L<span class="number">+1</span>))/<span class="built_in">log</span>(<span class="number">2.0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(minn[L][k],minn[R-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">        maxn[i][<span class="number">0</span>] = minn[i][<span class="number">0</span>] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RMQ</span>();</span><br><span class="line">    <span class="type">int</span> L, R;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="keyword">if</span>(L &gt; R)</span><br><span class="line">            <span class="built_in">swap</span>(L, R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">RMQ_MAX</span>(L, R) - <span class="built_in">RMQ_MIN</span>(L, R));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RMQ </tag>
            
            <tag> ST表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-编译期常量与运行期常量的区别及数组创建本质分析</title>
      <link href="/2019/04/25/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/"/>
      <url>/2019/04/25/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>编译期常量与运行期常量的区别及数组创建本质分析</p><span id="more"></span><h1 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(MyParent3.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParent3 code block&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">MyParent3 code block</span></span><br><span class="line"><span class="comment">0e7ed916-96de-4805-865d-1b2e703482ec</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，这时程序运行时，会导致主动使用这个常量所在的类，显然会导致这个的类的初始化。</strong></p><h1 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        MyParent4[] myParent4s = <span class="keyword">new</span> <span class="title class_">MyParent4</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent4</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParent3 code block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序并没有输出，那么为什么呢</p><p>对于数组实例来说，其类型是由JVM在运行期动态生成的，并没有主动使用这个类，所以不会导致类的初始化</p><p>接着我们可以看这个的类的类型以及它的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(myParent4s.getClass());</span><br><span class="line">System.out.println(myParent4s.getClass().getSuperclass());</span><br></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class [LMyParent4;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br></pre></td></tr></table></figure><p>说明这个动态生成的类型表现为<code>[LMyParent4</code>这种形式。动态生成的类型，其父类是<code>Object</code></p><p>对于数组来说，<code>JavaDoc</code>经常将构成数组的元素为<code>Component</code>，实际上就是将数组降低一个维度后的类型。</p><p>那么二维数组又是什么形式呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyParent4[][] myParent4s1 = <span class="keyword">new</span> <span class="title class_">MyParent4</span>[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">System.out.println(myParent4s1.getClass());</span><br><span class="line">System.out.println(myParent4s1.getClass().getSuperclass());</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class [[LMyParent4;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Object</span><br></pre></td></tr></table></figure><p>上面是引用类型的数组，那么原始类型数组的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(ints.getClass());</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(chars.getClass());</span><br><span class="line"></span><br><span class="line">Boolean[] bools = <span class="keyword">new</span> <span class="title class_">Boolean</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(bools.getClass());</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class [I</span><br><span class="line">class [C</span><br><span class="line">class [Ljava.lang.Boolean;</span><br></pre></td></tr></table></figure><h1 id="反编译样例2"><a href="#反编译样例2" class="headerlink" title="反编译样例2"></a>反编译样例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        MyParent4[] myParent4s = <span class="keyword">new</span> <span class="title class_">MyParent4</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent4</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyParent3 code block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/25/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/1.png" alt></p><ul><li>anewarray：表示创建一个引用类型的（如类，接口，数组）数组，并将其引用值压入栈顶</li><li>newarray：表示创建一个指定的原始类型（如int， float）的数组并将其引用值压入栈顶</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 常量本质 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树入门</title>
      <link href="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/"/>
      <url>/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>线段树入门</p><span id="more"></span><h1 id="数据结构—线段树（segment-tree）"><a href="#数据结构—线段树（segment-tree）" class="headerlink" title="数据结构—线段树（segment tree）"></a>数据结构—线段树（segment tree）</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>给定一个数组，数组长度可能非常大。现在我们需要对数组里面的数据反反复复进行两个操作</p><ul><li>求出某一个区间里面所有元素之和，(query操作)</li><li>修改某个元素的值，(update操作)</li></ul><h3 id="暴力解决和前缀和"><a href="#暴力解决和前缀和" class="headerlink" title="暴力解决和前缀和"></a>暴力解决和前缀和</h3><p>对区间[L,R]（长度为n）取和，并且更新一个元素i的值，采用暴力解决方法<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/1.png" alt></p><p>可得</p><ul><li>query(L,R)时间复杂度为O(n)</li><li>update(i)时间复杂度为O(1)</li></ul><p>如果区间范围很大，再加上多次操作，暴力取和明显会超时，可以采用前缀和方式优化查询<br>sum_arr[0]=arr[0]<br>sum_arr[1]=arr[0]+arr[1]<br>sum_arr[2]=arr[0]+arr[1]+arr[2]<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/2.png" alt><br>这样，假如我们想得到区间[2,4]的和，我们可以用sum_arr[4]-sum_arr[1]计算到</p><ul><li>query(L,R)时间复杂度减小为O(1)</li><li>因为改变一个值后，要同时更新后面的sum_arr数组，所以update(i)时间复杂度增大为O(n)</li></ul><p>如果用线段树的话，我们可以将查询和更新的的时间复杂度都变为O(logn)</p><div class="table-container"><table><thead><tr><th>方法</th><th>query</th><th>update</th></tr></thead><tbody><tr><td>暴力</td><td>O(n)</td><td>O(1)</td></tr><tr><td>前缀和</td><td>O(1)</td><td>O(n)</td></tr><tr><td>线段树</td><td>O(logn)</td><td>O(logn)</td></tr></tbody></table></div><h2 id="线段树简介"><a href="#线段树简介" class="headerlink" title="线段树简介"></a>线段树简介</h2><p>线段树是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。使用线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logn)。是一种可以在很短的时间内对某个区间进行操作的数据结构。</p><p>可用于：<br>单点修改、区间修改、区间查询（如：区间求和，求区间最大值，求区间最小值……）</p><h2 id="线段树构建"><a href="#线段树构建" class="headerlink" title="线段树构建"></a>线段树构建</h2><div class="table-container"><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>数组元素</td><td>1</td><td>3</td><td>5</td><td>7</td><td>9</td></tr></tbody></table></div><p>树根保存的是区间[1-6]中元素的和，其左孩子保存区间[1-3]所有元素的和，右孩子则是[4-6]<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/3.png" alt><br>它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。<br>其划分区间方法类似于二分</p><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/4.png" alt></p><p>然后给每个叶子结点赋值</p><div class="table-container"><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>数组元素</td><td>1</td><td>3</td><td>5</td><td>7</td><td>9</td></tr></tbody></table></div><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/5.png" alt></p><p>接着由孩子结点构成双亲结点</p><div class="table-container"><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>数组元素</td><td>1</td><td>3</td><td>5</td><td>7</td><td>9</td></tr></tbody></table></div><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/6.png" alt></p><h2 id="回到原题"><a href="#回到原题" class="headerlink" title="回到原题"></a>回到原题</h2><p>如何找到[2-5]这个区间的和<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/7.png" alt><br><strong>根节点记录的是[1-6]的和，可以把[3-6]分成两半，左边找的是[3],右边是[4-6]，右边可以直接得到[4-6]的和为27，而[3]可以通过[1-3]得到和为5，最终结果为27+5=32。</strong><br>这样子可以省掉很多搜索的时间，最坏情况是把整棵树都搜索一遍，时间复杂度为O(logn)</p><p>那么如何更新呢，假如我们想把第5个元素由9变成5<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/8.png" alt><br><strong>我们先找到9那个结点，然后把其值变为6，接着顺着一条路从下往上一直更新。</strong><br>同样，更新的时间复杂度也是O(logn)</p><h2 id="线段树的实现"><a href="#线段树的实现" class="headerlink" title="线段树的实现"></a>线段树的实现</h2><p>由于线段树是用二叉树结构储存的，而且是近乎完全二叉树的，所以我使用了数组tree来存储<br><strong>数组下标从1开始，同时添加虚结点使其变成完全二叉树</strong><br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/9.png" alt></p><div class="table-container"><table><thead><tr><th>数组下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>数组元素</td><td>36</td><td>9</td><td>27</td><td>4</td><td>5</td></tr></tbody></table></div><p>树的结点的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value; <span class="comment">//节点对应区间的权值（不唯一，也可以代表区间最大值等）</span></span><br><span class="line">    <span class="type">int</span> left, right; <span class="comment">//区间[left, right]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> tree[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> father[<span class="number">100</span>]; <span class="comment">//记录某个点的序号，方便查找对应的数组下标</span></span><br></pre></td></tr></table></figure><h3 id="建树"><a href="#建树" class="headerlink" title="建树"></a>建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Build_tree</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//为区间[left, right]建立一个以top为祖先的线段树，top为根节点下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Build_tree</span><span class="params">(<span class="type">int</span> top, <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[top].left = left; <span class="comment">//写入第index个结点的左区间</span></span><br><span class="line">    tree[top].right = right; <span class="comment">//写入第index个结点的右区间</span></span><br><span class="line">    tree[top].value = <span class="number">0</span>; <span class="comment">//每个区间的值初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left == right)<span class="comment">//区间长度为0时，赋值并且结束递归</span></span><br><span class="line">    &#123;</span><br><span class="line">    tree[top].value = arr[left];</span><br><span class="line">        father[left] = top;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (right + left) / <span class="number">2</span>; <span class="comment">//取区间中点</span></span><br><span class="line">    <span class="type">int</span> left_node = top * <span class="number">2</span>; <span class="comment">//左孩子下标</span></span><br><span class="line">    <span class="type">int</span> right_node = top * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">//右孩子下标</span></span><br><span class="line">    <span class="built_in">Build_tree</span>(left_node, left, mid);  <span class="comment">//往左孩子方向继续建立线段树</span></span><br><span class="line">    <span class="built_in">Build_tree</span>(right_node, mid + <span class="number">1</span>, right);  <span class="comment">//往右孩子方向继续建立线段树</span></span><br><span class="line">    <span class="comment">//更新结点值为左右孩子的和</span></span><br><span class="line">    tree[top].value = tree[left_node].value + tree[right_node].value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新数组的第5个元素的值为6，直接在树里面更新该结点的值后，然后从父结点往上更新，直到更新到了根结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[father[<span class="number">5</span>]].value = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">Update</span>(father[<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">(<span class="type">int</span> index)</span><span class="comment">//index为要修改那个点的数组下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> father_node = index / <span class="number">2</span>; <span class="comment">//父结点下标</span></span><br><span class="line">    <span class="type">int</span> left_node = father_node * <span class="number">2</span>;   <span class="comment">//左孩子下标</span></span><br><span class="line">    <span class="type">int</span> right_node = father_node * <span class="number">2</span> + <span class="number">1</span>;   <span class="comment">//右孩子下标</span></span><br><span class="line">    tree[father_node].value = tree[left_node].value + tree[right_node].value; <span class="comment">//更新值</span></span><br><span class="line">    <span class="keyword">if</span>(father_node == <span class="number">1</span>) <span class="comment">//找到树的根结点，终止退出</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">Update</span>(father_node); <span class="comment">//递归更新，由父结点往上找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="查询-L-R-区间"><a href="#查询-L-R-区间" class="headerlink" title="查询[L,R]区间"></a>查询[L,R]区间</h3><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/6.png" alt><br>先查询左子树：</p><ol><li>如果满足条件3 &gt;= L,则要查询的区间有涉及左子树，例如查询[1,2]，[2,4]<ul><li>如果满足3 &gt;= R,则要查询的区间完全在左子树，例如[1,2]，这时候要查询的区间不变</li><li>如果不满足3 &gt;= R,则要查询的区间不完全在左子树，例如[2,4]，这时候就需要查询在左子树那边的区间，所以要查询[2,3]</li></ul></li></ol><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/6.png" alt="90%"><br>同理再查询右子树：</p><ol><li>如果满足条件R &gt;= 4,则要查询的区间有涉及右子树，例如查询[4,6]，[2,5]<ul><li>如果满足L &gt;= 4,则要查询的区间完全在右子树，例如[4,6]，这时候要查询的区间不变</li><li>如果不满足L &gt;= 4,则要查询的区间不完全在右子树，例如[2,5]，这时候就需要查询在右子树那边的区间，所以要查询[4,5]</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从index开始查询，所以index一般为树的根结点,查询的区间是[L,R]，结果保留在ans里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[index].left == L &amp;&amp; tree[index].right == R)&#123; <span class="comment">//找到了一个完全重合的区间</span></span><br><span class="line">        ans += tree[index].value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left_node = index*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= tree[left_node].right)&#123; <span class="comment">//左区间有涉及</span></span><br><span class="line">    <span class="keyword">if</span>(R &lt;= tree[left_node].right) <span class="comment">//全包含于左区间，查询区间不变</span></span><br><span class="line">        <span class="built_in">Query</span>(left_node, L, R, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//半包含于左区间，则查询区间拆分，左端点不变，右端点变为左孩子的右区间端点</span></span><br><span class="line">        <span class="built_in">Query</span>(left_node, L, tree[left_node].right, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> right_node = left_node + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R &gt;= tree[right_node].left)&#123; <span class="comment">//右区间有涉及</span></span><br><span class="line">    <span class="keyword">if</span>(L &gt;= tree[right_node].left) <span class="comment">//全包含于右区间，查询区间不变</span></span><br><span class="line">        <span class="built_in">Query</span>(right_node, L, R, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//半包含于左区间，则查询区间拆分，与上同理</span></span><br><span class="line">        <span class="built_in">Query</span>(right_node, tree[right_node].left, R, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/10.PNG" alt></p><h2 id="模板题HDU1754"><a href="#模板题HDU1754" class="headerlink" title="模板题HDU1754"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754">模板题HDU1754</a></h2><p><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/timu.png" alt></p><p>936MS    8336K（注意，线段树需要空间比较大，数组开小可能会wa或者TLE，一般为4n）<br><img src="/2019/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%85%A5%E9%97%A8/11.PNG" alt></p><h2 id="线段树部分优化"><a href="#线段树部分优化" class="headerlink" title="线段树部分优化"></a>线段树部分优化</h2><ol><li><code>a*2</code>可以用<code>a&lt;&lt;1</code>代替，<code>a/2</code>可以用<code>a&gt;&gt;1</code>代替。（位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快）</li><li>因为下标为a的节点的左儿子下标为<code>a*2</code>，右儿子下标为<code>a*2+1</code>，所以可以</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入一些编译预处理指令可以提高编程效率，加快编译速度</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LS(a) (a &lt;&lt; 1)</span></span><br><span class="line"><span class="comment">// a&lt;&lt;1 等同于 a*2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RS(a) (a &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="comment">// a&lt;&lt;1|1 等同于 a*2+1</span></span><br></pre></td></tr></table></figure><h2 id="线段树进阶"><a href="#线段树进阶" class="headerlink" title="线段树进阶"></a>线段树进阶</h2><ol><li>Lazy标记—用于同时更新一段区间的值：<a href="http://poj.org/problem?id=3468">poj3468 A Simple Problem with Integers</a></li><li>线段树离散化（节约空间）—<a href="http://poj.org/problem?id=2528">poj2528 Mayor’s posters</a></li><li>线段树应用：扫描线问题（求多个矩形互相覆盖后的面积）：<a href="http://poj.org/problem?id=1151">poj1151 Atlantis</a></li><li>可持久化（保留整个操作的历史）—主席树</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-常量的本质含义以及反编译出现的部分助记符</title>
      <link href="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/"/>
      <url>/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>常量的本质含义以及反编译出现的部分助记符</p><span id="more"></span><h1 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Mychild1.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        out.println(<span class="string">&quot;Myparent1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mychild1</span> <span class="keyword">extends</span> <span class="title class_">MyParent1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;welcome&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mychild1 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态字段来说，只有定义了该字段的类才会被初始化，当一个类在初始化时，要求其父类全部都已经初始化完毕了。所以上述代码只会输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Myparent1 static block</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>并没有<code>welcome</code>以及<code>Mychild1 static block</code></p><p>但是子类<code>Mychild1</code>有没有被加载呢，可以使用虚拟机参数去查看</p><p><code>-XX:+TraceClassLoading</code></p><p>然后运行，可以看到子类被加载了，(这个有没有加载并没有规范)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[Loaded sun.net.NetHooks$Provider from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">[Loaded sun.net.sdp.SdpProvider from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">[Loaded MyParent1 from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br><span class="line">[Loaded Mychild1 from file:/home/cc/IdeaProjects/test/out/production/test/]</span><br><span class="line">[Loaded java.net.Socket$<span class="number">2</span> from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">Myparent1 <span class="keyword">static</span> block</span><br><span class="line">hello world</span><br><span class="line">[Loaded java.net.SocketInputStream from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">[Loaded sun.nio.cs.US_ASCII$Decoder from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line">[Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-<span class="number">8</span>-oracle/jre/lib/rt.jar]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="虚拟机参数一般形式"><a href="#虚拟机参数一般形式" class="headerlink" title="虚拟机参数一般形式"></a>虚拟机参数一般形式</h1><p><code>-XX:+&lt;option&gt;</code>：表示开启option选项</p><p><code>-XX:-&lt;option&gt;</code>：表示关闭option选项</p><p><code>`-XX:&lt;option&gt;=value</code>：表示将option选项的值设置为value</p><h1 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(MyParent2.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Myparent2 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output: hello world</span></span><br></pre></td></tr></table></figure><p>为什么输出没有<code>Myparent2 static block</code>呢？</p><p><strong>常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此并不会触发定义常量的类的初始化</strong></p><p><strong>注意：这里指的是将常量放到了<code>Main</code>的常量池中，之后<code>Main</code>与<code>MyParent2</code>就没有任何关系了.</strong></p><p>甚至可以将<code>MyParent2</code>的class文件删除</p><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/1.png" alt></p><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/2.png" alt></p><h1 id="对样例2反编译"><a href="#对样例2反编译" class="headerlink" title="对样例2反编译"></a>对样例2反编译</h1><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/3.png" alt></p><p>对样例2反编译后我们可以看到一些助记符以及code那里的一些构造方法,下面看一些助记符(操作码)</p><ul><li><p>gestatic：得到out这个对象,本身out这个对象是一个静态成员变量</p></li><li><p>ldc：表示将int，float或是String类型的常量值从常量池中推送至栈顶（栈顶表示等会立即要用的）</p></li></ul><p>将代码改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(MyParent2.S);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyParent2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">short</span> <span class="variable">S</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Myparent2 static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反编译</p><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/4.png" alt></p><p>可以看到其他的相同，出现一个新的名叫<code>bipush</code>的助记符</p><ul><li>bipush：表示将单字节(-128~127)的常量值推送到栈顶</li></ul><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">128</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/5.png" alt></p><ul><li>sipush：表示将一个短整型的常量值(-32768~32767)推送到栈顶</li></ul><p>改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/6.png" alt></p><ul><li>iconst_1：表示将int型1推送至栈顶(<code>iconst_m1~iconst_5</code>)</li></ul><h1 id="助记符"><a href="#助记符" class="headerlink" title="助记符"></a>助记符</h1><p>助记符在<code>jt.jar</code>包有相关的类实现</p><p>比如<code>ICONST</code>，在包<code>com.sun.org.apache.bcel.internal.generic</code>里面</p><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/7.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICONST</span> <span class="keyword">extends</span> <span class="title class_">Instruction</span></span><br><span class="line">  <span class="keyword">implements</span> <span class="title class_">ConstantPushInstruction</span>, TypedInstruction &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Empty constructor needed for the Class.newInstance() statement in</span></span><br><span class="line"><span class="comment">   * Instruction.readInstruction(). Not to be used otherwise.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ICONST() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ICONST</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(com.sun.org.apache.bcel.internal.Constants.ICONST_0, (<span class="type">short</span>)<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((i &gt;= -<span class="number">1</span>) &amp;&amp; (i &lt;= <span class="number">5</span>))</span><br><span class="line">      opcode = (<span class="type">short</span>)(com.sun.org.apache.bcel.internal.Constants.ICONST_0 + i); <span class="comment">// Even works for i == -1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassGenException</span>(<span class="string">&quot;ICONST can be used only for value between -1 and 5: &quot;</span> +</span><br><span class="line">                                  i);</span><br><span class="line">    value = i;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到，它<code>icosnt</code>只有[-1,5]</p><p>再比如<code>sipush</code></p><p><img src="/2019/04/23/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%90%AB%E4%B9%89%E4%BB%A5%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0%E7%9A%84%E9%83%A8%E5%88%86%E5%8A%A9%E8%AE%B0%E7%AC%A6/8.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SIPUSH</span> <span class="keyword">extends</span> <span class="title class_">Instruction</span> <span class="keyword">implements</span> <span class="title class_">ConstantPushInstruction</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">short</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Empty constructor needed for the Class.newInstance() statement in</span></span><br><span class="line"><span class="comment">   * Instruction.readInstruction(). Not to be used otherwise.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  SIPUSH() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SIPUSH</span><span class="params">(<span class="type">short</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(com.sun.org.apache.bcel.internal.Constants.SIPUSH, (<span class="type">short</span>)<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 常量本质 </tag>
            
            <tag> 助记符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019中山大学程序设计竞赛-重现赛-补两道水题</title>
      <link href="/2019/04/20/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B-%E8%A1%A5%E4%B8%A4%E9%81%93%E6%B0%B4%E9%A2%98/"/>
      <url>/2019/04/20/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B-%E8%A1%A5%E4%B8%A4%E9%81%93%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>HDU6512 —Triangle &amp;&amp; HDU6518—Clumsy Keke</p><span id="more"></span><h1 id="HDU6518—Clumsy-Keke"><a href="#HDU6518—Clumsy-Keke" class="headerlink" title="HDU6518—Clumsy Keke"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6518">HDU6518—Clumsy Keke</a></h1><p><img src="/2019/04/20/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B-%E8%A1%A5%E4%B8%A4%E9%81%93%E6%B0%B4%E9%A2%98/timu1.png" alt></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目大意：</p><p>给出一个三维图形的x，y，z轴的长度，然后分别给出正视图，侧视图，俯视图，视图的表示方法是在一个大方格里面，用0代表空白，用1代表阴影，这样就可以表示一个图形了，然后求出这个三维图形是由多少小正方体组成的。</p><p>我们可以运用逆向思维，首先构建一个完整的图形，然后减去没有出现的，最终剩下来的就是拥有的，然后再统计下有几个就是我们要求的答案了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-04-20 00:21:25</span></span><br><span class="line"><span class="comment">46MS  2184K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span>;</span><br><span class="line"><span class="type">bool</span> Map[MAXN][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(Map, <span class="literal">false</span>, <span class="built_in">sizeof</span>(Map));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= y; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">                <span class="keyword">if</span>(input == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= z; k++)</span><br><span class="line">                        Map[i][j][k] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= z; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">                <span class="keyword">if</span>(input == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= x; k++)</span><br><span class="line">                        Map[k][i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= z; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= x; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">                <span class="keyword">if</span>(input == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= y; k++)</span><br><span class="line">                        Map[j][k][i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= y; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= z; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Map[i][j][k] == <span class="literal">false</span>)</span><br><span class="line">                        ans++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HDU6512-Triangle"><a href="#HDU6512-Triangle" class="headerlink" title="HDU6512-Triangle"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6512">HDU6512-Triangle</a></h1><p><img src="/2019/04/20/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E9%87%8D%E7%8E%B0%E8%B5%9B-%E8%A1%A5%E4%B8%A4%E9%81%93%E6%B0%B4%E9%A2%98/timu2.png" alt></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>题目大意：</p><p>给出n个数，问你能不能从中选中三个数构成三角形</p><p>（根据范围，直接算肯定T）</p><p>因为两边之和一定要大于第三边，因此当数列满足，排序后，较小两边相加都小于等于下一条边，这种序列即斐波那契数列，甚至比斐波那契数列更容易增大的数列。</p><p>反过来想想，既然构造一个超长的不能满足构成三角形的数列必须最低限度是构造一个斐波那契数列，那么这个数列长度能否构造得很长？不行，因为斐波那契数列到第51个就超过<code>5^1e6</code>了。<br>因为数列中所有值都小于5^1e6，因此任何区间大于50的长度，必定存在能构造出三角形的三边，150以内的，直接区间排序后暴力查找是否存在能构成三边的三角形即可。</p><p>参考：<a href="https://blog.csdn.net/kuronekonano/article/details/79701126">https://blog.csdn.net/kuronekonano/article/details/79701126</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-04-19 21:24:51</span></span><br><span class="line"><span class="comment">1513MS1384K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5</span>*<span class="number">1E6</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a ,b ,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">50</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">            <span class="built_in">sort</span>(arr, arr + n);</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = arr[i];</span><br><span class="line">                <span class="type">int</span> b = arr[i<span class="number">-1</span>];</span><br><span class="line">                <span class="type">int</span> c = arr[i<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">if</span>((a+b&gt;c &amp;&amp; a+c&gt;b &amp;&amp; b+c&gt;a))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 斐波那契 </tag>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些STL知识填坑</title>
      <link href="/2019/04/19/%E4%B8%80%E4%BA%9BSTL%E7%9F%A5%E8%AF%86%E5%A1%AB%E5%9D%91/"/>
      <url>/2019/04/19/%E4%B8%80%E4%BA%9BSTL%E7%9F%A5%E8%AF%86%E5%A1%AB%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>一些STL知识填坑</p><span id="more"></span><p>参考：<a href="https://oi-wiki.org">https://oi-wiki.org</a></p><h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a>nth_element</h2><p>作用是找到选定区间内第 大的数，并将所有比它小的数与比它大的数分别置于两侧，返回它的地址。原理是未完成的快速排序，时间复杂度：期望 O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">nth_element</span>(a, a<span class="number">+5</span>, a<span class="number">+9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">   cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;输出第五大的数： &quot;</span>&lt;&lt;a[<span class="number">4</span>]&lt;&lt;endl; <span class="comment">//注意下标是从0开始计数的</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">2 1 4 3 5 6 8 7 9</span></span><br><span class="line"><span class="comment">输出第五大的数： 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="stable-sort"><a href="#stable-sort" class="headerlink" title="stable_sort"></a>stable_sort</h2><p>稳定的O(nlogn)排序，即保证相等元素排序后的相对位置与原序列相同。</p><h2 id="partial-sort"><a href="#partial-sort" class="headerlink" title="partial_sort"></a>partial_sort</h2><p>将序列中前k小元素按顺序置于前k个位置，后面的元素不保证顺序。时间复杂度：O(nlogk)</p><p><img src="/2019/04/19/%E4%B8%80%E4%BA%9BSTL%E7%9F%A5%E8%AF%86%E5%A1%AB%E5%9D%91/patial_sort.PNG" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">partial_sort</span>(a, a<span class="number">+3</span>, a<span class="number">+9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">   cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output：</span></span><br><span class="line"><span class="comment">1 2 3 5 4 6 8 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> nth_element </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EXBSGS算法</title>
      <link href="/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>EXBSGS</p><span id="more"></span><p>$a^{x} \equiv b(\bmod p)$</p><p>BSGS只能求解p为素数的情况，EXBSGS可以完美解决这个问题，其基本思路就是通过转换，然后可以运用BSGS算法来求解，最终还是基于BSGS基础</p><h1 id="EXBSGS"><a href="#EXBSGS" class="headerlink" title="EXBSGS"></a>EXBSGS</h1><p>参考：<a href="https://www.cnblogs.com/TheRoadToTheGold/p/8478697.html">https://www.cnblogs.com/TheRoadToTheGold/p/8478697.html</a></p><p><a href="https://blog.csdn.net/a_bright_ch/article/details/83513731">https://blog.csdn.net/a_bright_ch/article/details/83513731</a></p><p><a href="https://www.cnblogs.com/lajioj/p/9529255.html">https://www.cnblogs.com/lajioj/p/9529255.html</a></p><p>求解$a^{x} \equiv b(\bmod p)$（P不一定是质数）的最小非负正整数解</p><p><strong>先放三个同余定理</strong></p><ul><li>定理1：</li></ul><p><img src="/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/gongshi1.png" alt></p><ul><li>定理2：</li></ul><p><img src="/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/gongshi2.png" alt></p><ul><li>定理3：</li></ul><p><img src="/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/gongshi3.png" alt></p><p><strong>求解</strong></p><ol><li><p>如果b==1，那么x=0，算法结束</p></li><li><p>若gcd(a, p) != 1，令d=gcd(a, p)，若d不能整除b，则无解，算法结束，否则继续</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如当x=1，a=4，p=8，b=3时，代入公式有4 mod 8和3 mod 8，此时d = gcd(a, p) = 4，</span><br><span class="line">说明a与p有因子为4，但是d不能整除b，说明b中没有共同因子，同样mod同一个数，没有共同因子，那么说明方程无解</span><br></pre></td></tr></table></figure></li><li><p>把一个a提取出来，$a^{x} \equiv b(\bmod p)$变成$a*a^{x-1} \equiv b(\bmod p)$</p><p>同时除以d得$a^{x-1} * \frac{a}{d} \equiv \frac{b}{d}\left(\bmod \frac{p}{d}\right)$</p></li><li><p>持续第三步除法，直到$\operatorname{gcd}\left(\mathrm{a}, \frac{p}{\prod<em>{i-1}^{k} d</em>{i}}\right)=1$</p><p>此时有$a^{x-k} * \frac{a^{k}}{\prod<em>{i-1}^{k} d</em>{i}} \equiv \frac{b}{\prod<em>{i-1}^{k} d</em>{i}}\left(\bmod \frac{p}{\prod<em>{i-1}^{k} d</em>{i}}\right)$</p></li><li><p>枚举 0&lt;x&lt;k，若有解，输出x，算法结束</p></li><li><p>对于x&gt;=k</p><p>$a=a^{x-k}$, $b=\frac{b}{\prod<em>{i-1}^{k} d</em>{i}}$ , $p= \frac{p}{\prod<em>{i-1}^{k} d</em>{i}}$</p><p>A，P 互素</p><p>直接BSGS求$\frac{a^{k}}{\prod<em>{i-1}^{k} d</em>{i}}*a^{x} \equiv b ( \  mod\ p)$，所得结果+k即可</p></li></ol><h1 id="模板题http-poj-org-problem-id-3243"><a href="#模板题http-poj-org-problem-id-3243" class="headerlink" title="模板题http://poj.org/problem?id=3243"></a>模板题<a href="http://poj.org/problem?id=3243">http://poj.org/problem?id=3243</a></h1><p><img src="/2019/04/19/EXBSGS%E7%AE%97%E6%B3%95/timu.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hash版，省时间耗空间</span></span><br><span class="line"><span class="comment">2208K63MS</span></span><br><span class="line"><span class="comment">2019-04-19 15:36:08</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL N = <span class="number">40000</span>, Max = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="type">bool</span> bk;</span><br><span class="line">LL X, Z, K, len;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">70000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">LL d, id, next;</span><br><span class="line">&#125;Hash[<span class="number">2</span> * Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">LL tx, ty;</span><br><span class="line">LL d = <span class="built_in">exgcd</span>(b, a%b, tx, ty);</span><br><span class="line">x = ty; y = tx - (a / b)*ty;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(LL d, LL id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL t = d&amp;Max;</span><br><span class="line"><span class="keyword">if</span> (!vis[t]) &#123;</span><br><span class="line">vis[t] = <span class="number">1</span>;</span><br><span class="line">Hash[t].d = d, Hash[t].id = id, Hash[t].next = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (; Hash[t].next != <span class="number">-1</span>; t = Hash[t].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Hash[t].d == d) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Hash[t].next = ++len;</span><br><span class="line">Hash[len].d = d; Hash[len].id = id; Hash[len].next = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">find</span><span class="params">(LL d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL t = d&amp;Max;</span><br><span class="line"><span class="keyword">if</span> (!vis[t]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; t != <span class="number">-1</span>; t = Hash[t].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Hash[t].d == d) <span class="keyword">return</span> Hash[t].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">BSGS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL t, g, x, y, pm, a, b, c, m, k, sum, am;</span><br><span class="line">a = X; b = K; c = Z; k = <span class="number">1</span>; sum = <span class="number">0</span>; t = <span class="number">1</span> % c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (t == b) <span class="keyword">return</span> i;</span><br><span class="line">t = t*a%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((g = <span class="built_in">exgcd</span>(X, c, x, y)) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = (k*X / g) % c;</span><br><span class="line">c /= g;</span><br><span class="line"><span class="keyword">if</span> (b%g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">b /= g;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">m = (LL)(<span class="built_in">ceil</span>((<span class="type">double</span>)<span class="built_in">sqrt</span>((<span class="type">double</span>)c)));</span><br><span class="line"><span class="built_in">ins</span>(k, <span class="number">0</span>);</span><br><span class="line">t = k; pm = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">t = t*a%c, pm = pm*a%c;</span><br><span class="line"><span class="built_in">ins</span>(t, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exgcd</span>(pm, c, x, y);</span><br><span class="line">am = x%c + c;</span><br><span class="line">t = b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">x = <span class="built_in">find</span>(t);</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">-1</span>) <span class="keyword">return</span> i*m + x + sum;</span><br><span class="line">t = t*am%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;X, &amp;Z, &amp;K) != EOF &amp;&amp; Z &amp;&amp; X &amp;&amp; K)&#123;</span><br><span class="line">K %= Z; len = Max;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">LL ans = <span class="built_in">BSGS</span>();</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">二分版，耗时间省空间</span></span><br><span class="line"><span class="comment">1108K313MS</span></span><br><span class="line"><span class="comment">2019-04-19 15:41:10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40000</span>;</span><br><span class="line"><span class="type">bool</span> bk;</span><br><span class="line">LL X, Z, K, a, b, c, m, k, sum, am, bl;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">LL d, id;</span><br><span class="line">&#125;bit[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.d != y.d) <span class="keyword">return</span> x.d&lt;y.d;</span><br><span class="line"><span class="keyword">return</span> x.id&lt;y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL u, LL v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(v, u%v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">find</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = bl;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (bit[mid].d == x) <span class="keyword">return</span> bit[mid].id;</span><br><span class="line"><span class="keyword">if</span> (bit[mid].d&gt;x) r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (bit[mid].d&lt;x) l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exgcd</span><span class="params">(LL u, LL v, LL &amp;x, LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="number">0</span>) &#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">LL tx, ty;</span><br><span class="line"><span class="built_in">exgcd</span>(v, u%v, tx, ty);</span><br><span class="line">x = ty; y = tx - (u / v)*ty;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">BSGS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL t, g, x, y, pm;</span><br><span class="line">a = X; b = K; c = Z; k = <span class="number">1</span>; sum = <span class="number">0</span>; bk = <span class="number">1</span>; bl = <span class="number">0</span>; t = <span class="number">1</span> % c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)&#123;<span class="comment">//避免a的负数次方</span></span><br><span class="line"><span class="keyword">if</span> (t == b) <span class="keyword">return</span> i;</span><br><span class="line">t = t*a%c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((g = <span class="built_in">gcd</span>(X, c)) != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = (k*X / g) % c;<span class="comment">//k记得要mod，否则溢出</span></span><br><span class="line">c /= g;</span><br><span class="line"><span class="keyword">if</span> (b%g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">b /= g;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">m = (LL)(<span class="built_in">ceil</span>((<span class="type">double</span>)<span class="built_in">sqrt</span>((<span class="type">double</span>)c)));<span class="comment">//要约分之后再求m</span></span><br><span class="line">p[<span class="number">0</span>].d = k%c;</span><br><span class="line">p[<span class="number">0</span>].id = <span class="number">0</span>;</span><br><span class="line">pm = <span class="number">1</span>;<span class="comment">//pm是不用*k的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">p[i].d = p[i - <span class="number">1</span>].d*a%c, pm = pm*a%c, p[i].id = i;</span><br><span class="line"><span class="built_in">sort</span>(p, p + <span class="number">1</span> + m, cmp);</span><br><span class="line">bit[<span class="number">0</span>] = p[<span class="number">0</span>]; bl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].d != p[i - <span class="number">1</span>].d) bit[++bl] = p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exgcd</span>(pm, c, x, y);</span><br><span class="line">am = (x%c + c);<span class="comment">//避免am=0</span></span><br><span class="line"></span><br><span class="line">t = b;</span><br><span class="line">x = <span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bl; i++)</span><br><span class="line">&#123;</span><br><span class="line">t *= am; t %= c;</span><br><span class="line">x = <span class="built_in">find</span>(t);</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> i*m + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;X, &amp;Z, &amp;K) &amp;&amp; X &amp;&amp; Z &amp;&amp; K)&#123;</span><br><span class="line"><span class="keyword">if</span> (!X &amp;&amp; !Z &amp;&amp; !K) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">K %= Z;</span><br><span class="line">LL ans = <span class="built_in">BSGS</span>();</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans + sum);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No Solution\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> EXBSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BSGS算法</title>
      <link href="/2019/04/18/BSGS%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/18/BSGS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>BSGS</p><span id="more"></span><h1 id="BSGS-baby-step-gaint-step"><a href="#BSGS-baby-step-gaint-step" class="headerlink" title="BSGS(baby-step gaint-step)"></a>BSGS(baby-step gaint-step)</h1><p>该算法是指类似于$a^{x} \equiv b(\bmod p$)的方程，已知a，b，p，求x的算法</p><p><strong>原始的BSGS只能解决p为质数的情况</strong></p><p>由费马小定理$a^{p-1} \equiv 1(\bmod p)$（a，p互质）</p><p>同时拆开上面两式得</p><p>$a^{p-1} (\bmod p)= 1(\bmod p)$</p><p>$a^{x} (\bmod p)= b(\bmod p)$</p><p>b最小取值1，而当$x=p-1$时正好为$b=1$，所以当b增大时，x须小于p-1，才能让b大于1，综合得</p><p><strong>解x满足$0 \leq x&lt;p$</strong></p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><p>设$m=\lceil\sqrt{p}\rceil$（根号p向上取整），$x=Am-B(0 \leq A,B &lt; m)$</p><p>则由$a^{x} \equiv b(\bmod p)$有$a^{Am- B} \equiv b(\bmod p)$</p><p>即$\frac{a^{Am}}{a^{B}}\equiv b(\bmod p)$</p><p>即$a^{Am }  \equiv b a^{B}(\bmod p)$</p><p>我们已知的是a，b，所以我们可以先算出等式右边的$ba^{B}$的所有取值，用hash/map存下来，然后逐一计算$a^{Am}$，枚举A，寻找是否有与之相等的$ba^{B}$，从而我们可以得到所有的$x=A\lceil\sqrt{p}\rceil- B$</p><p>注意到$A,B &lt;\lceil\sqrt{p}\rceil$，所以时间复杂度为$O(\sqrt{p})$，用 map 的话会多一个 log</p><h2 id="模板题—http-poj-org-problem-id-2417"><a href="#模板题—http-poj-org-problem-id-2417" class="headerlink" title="模板题—http://poj.org/problem?id=2417"></a>模板题—<a href="http://poj.org/problem?id=2417">http://poj.org/problem?id=2417</a></h2><p><img src="/2019/04/18/BSGS%E7%AE%97%E6%B3%95/timu.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">892K32MS</span></span><br><span class="line"><span class="comment">2019-04-19 00:13:27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 76543</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hs[MOD], head[MOD], next[MOD], id[MOD], top;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = x % MOD;</span><br><span class="line">    hs[top] = x;</span><br><span class="line">    id[top] = y;</span><br><span class="line">    next[top] = head[k];</span><br><span class="line">    head[k] = top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = x % MOD;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[k]; i != <span class="number">-1</span>; i = next[i])</span><br><span class="line">        <span class="keyword">if</span> (hs[i] == x)</span><br><span class="line">            <span class="keyword">return</span> id[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSGS</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">sqrt</span>(n * <span class="number">1.0</span>), j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">1</span>, p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++, p = p * a % n)</span><br><span class="line">        <span class="built_in">insert</span>(p * b % n, i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = m; ; i += m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((j = <span class="built_in">find</span>(x = x * p % n)) != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">BSGS</span>(a, b, n);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no solution\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机笔记-java虚拟机类加载</title>
      <link href="/2019/04/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/04/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>学习自周志明老师的《深入理解Java虚拟机》第二版</p><span id="more"></span><p>同时参考：<a href="http://www.cnblogs.com/plxx/p/4528688.html">http://www.cnblogs.com/plxx/p/4528688.html</a></p><h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验,转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制</strong></p><p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在<strong>程序运行期间完成</strong>的，这种策略虽然会令类加载时稍微增加一些性能开销，但是<strong>会为Java应用程序提供高度的灵活性</strong></p><p>Java里天生可以扩展的语言特性就是依赖<strong>运行期动态加载和动态连接</strong>这个特点实现的，比如</p><ul><li>编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类</li><li>用户可以通过Java预定义的和自定义类加载器，让 一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部 分，这种组装应用程序的方式目前已广泛应用于Java程序之中。从最基础的<code>Applet</code>、<code>JSP</code>到相 对复杂的<code>OSGi</code>技术</li></ul><blockquote><p>OSGi(Open Service Gateway  Initiative)技术是Java动态化模块化系统的一系列规范。OSGi一方面指维护OSGi规范的OSGI官方联盟，另一方面指的是该组织维护的基于Java语言的服务（业务）规范。简单来说，OSGi可以认为是Java平台的模块层。</p><p>OSGi服务平台向Java提供服务，这些服务使Java成为软件集成和软件开发的首选环境。Java提供在多个平台支持产品的可移植性。OSGi技术提供允许应用程序使用精炼、可重用和可协作的组件构建的标准化原语，这些组件能够组装进一个应用和部署中。</p></blockquote><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类从被加载到虚拟机内存中开始，直到卸载出内存为止，它的整个生命周期包括了： <strong>加载、验证、准备、解析、初始化、使用和卸载</strong> 这7个阶段。其中， <strong>验证、准备和解析这三个部分统称为连接（linking）</strong> 。</p><p><img src="/2019/04/17/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD/jiazai.jpg" alt></p><h1 id="类进行初始化的情况"><a href="#类进行初始化的情况" class="headerlink" title="类进行初始化的情况"></a>类进行初始化的情况</h1><p>什么情况下需要开始类加载过程的第一个阶段:”加载”。虚拟机规范中并没强行约束，这点可以交给虚拟机的的具体实现自由把握，但是对于<strong>初始化阶段虚拟机规范是严格规定了有且只有5种情况，如果类未初始化会对类进行初始化</strong>。</p><p><strong>初始化不等同于赋值，所以是先进行初始化然后再进行赋值的</strong></p><ol><li><p>使用new关键字<strong>实例化对象的</strong>时、<strong>读取或设置一个类的静态字段</strong>（被final修饰、已在编译期把结果放入常 量池的静态字段除外）的时候，以及<strong>调用一个类的静态方法</strong>的时候。</p><p><em>因为编译器把他们当作值(value)而不是域(field)来对待。如果你的代码中用到了常变 量(constant<br>variable)，编译器并不会生成字节码来从对象中载入域的值，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变 final域的值那么每一块用到那个域的代码都需要重新编译。</em></p></li><li><p><strong>反射</strong> 如( <code>Class.forName(&quot;com.xxx.Test&quot;)</code> )</p></li><li>当初始化一个类时，发现<strong>其父类还未初始化，则先出触发父类的初始化</strong></li><li>虚拟机启动时，<strong>用户需要指定一个要执行的主类（包含main()办法的那个类），虚拟机会先初始化这个主类</strong></li><li>JDK1.7的动态语言支持，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后解析结果<code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要将其初始化。</li></ol><p>这五种场景中的行为对一个类进行<strong>主动引用</strong>，除此之外，所有引用类的方式都不会触发初始化，称为<strong>被动引用</strong></p><p>所有java虚拟机实现必须在每个类或接口被java程序<strong>“首次使用”</strong>时才初始化他们</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>1. 通过子类引用父类的静态字段，不会导致子类初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperCalss</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;super class init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperCalss</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subclass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output： super class init</span></span><br></pre></td></tr></table></figure><p><strong>对于静态字段，只有直接定义这个字段的类才会初始化</strong>，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。<em>至于是否触发子类中定义<strong>加载和验证</strong>，在规范中未明确规定，取决于虚拟机的实现，<code>Sun HotSpot</code>虚拟机会导致子类的加载</em></p><p><strong>2. 使用数组来定义引用类，不会触发该类的初始化</strong></p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SuperCalss[]subClass = <span class="keyword">new</span> <span class="title class_">SuperCalss</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">//执行之后不会有任何的输出。</span></span><br></pre></td></tr></table></figure><p><strong>3. 常量在编译接阶段就会存入调用类的常量池中，本质上没有直接引用定义常量的类，因此不会触发被引用的类的初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Test init!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(Test.s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行之后不会有任何的输出。</span></span><br></pre></td></tr></table></figure><h1 id="接口的加载"><a href="#接口的加载" class="headerlink" title="接口的加载"></a>接口的加载</h1><p>接口的加载过程与类加载过程稍有一些不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息 的，而接口中不能使用“static{}”语句块，但编译器仍然会为接口生成“<code>&lt;clinit&gt;()”</code>类构造 器，<strong>用于初始化接口中所定义的成员变量</strong>。接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始 化过了，但是一个接口在初始化时，<strong>并不要求其父接口全部都完成了初始化</strong>，只有在真正使用到父接口的时候才会初始化</p><h1 id="类加载、连接与初始化"><a href="#类加载、连接与初始化" class="headerlink" title="类加载、连接与初始化"></a>类加载、连接与初始化</h1><p>加载：查找并加载类的二进制数据</p><p>连接：</p><ul><li>验证：确保被加载的类的正确性</li><li>准备：为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong></li><li>解析：把类中的符号引用转换为直接引用</li></ul><p><strong>初始化：为类的静态变量赋予正确的初始值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在java中，一个java类将会编译成一个class文件。在编译时，java类并不知道引用类的实际内存地址，因此只能使用符号引用来代替。比如org.simple.People类引用org.simple.Tool类，在编译时People类并不知道Tool类的实际内存地址，因此只能使用符号org.simple.Tool(假设)来表示Tool类的地址。而在类装载器装载People类时，此时可以通过虚拟机获取Tool类 的实际内存地址，因此便可以既将符号org.simple.Tool替换为Tool类的实际内存地址，即直接引用地址。</span><br></pre></td></tr></table></figure><h1 id="类的加载-1"><a href="#类的加载-1" class="headerlink" title="类的加载"></a>类的加载</h1><p>类的加载指的是将类的<code>.class</code>文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个<code>java.lang.Class</code>对象（规范并未说明CIass对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构</p><h2 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h2><p>加载<code>.class</code>文件的方式</p><ul><li>从本地系统中直接加载</li><li>通过网络下载<code>.class</code>文件，最典型应用是<code>Applet</code></li><li>从zip，jar等归档文件中加载<code>.class</code>文件</li><li>从专有数据库中提取<code>.class</code>文件</li><li>将Java源文件动态编为<code>.class</code>文件，典型场景是JSP应用</li></ul><blockquote><p>Applet是采用Java编程语言编写的小应用程序，该程序可以包含在 HTM页中与在页中包含图像的方式大致相同。</p><p>含有Applet的网页的HTML文件代码中部带有<code>&lt;applet&gt;</code>和<code>&lt;/applet&gt;</code>这样一对标记，当支持Java的网络浏览器遇到这对标记时，就将下载相应的小应用程序代码并在本地计算机上执行该Applet。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 类的加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1024-m子段和的最大值</title>
      <link href="/2019/04/14/HDU1024-m%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2019/04/14/HDU1024-m%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>HDU1024-Max Sum Plus Plus</p><span id="more"></span><h1 id="HDU1024"><a href="#HDU1024" class="headerlink" title="HDU1024"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1024">HDU1024</a></h1><p><img src="/2019/04/14/HDU1024-m%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/timu.png" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>在n个数中选出m组数, 每组数连续且不能相交,使得这m组的和是所有m组数中最大的。</p><p>每组数也可以叫做每一段</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 6 -1 4 -2 3 -2 3</span><br><span class="line">选两组数,当我们选&#123;4,-2,3&#125;,&#123;3&#125;这两组数时可得到最大的和8</span><br></pre></td></tr></table></figure><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>参考：</p><p><a href="https://blog.csdn.net/zuzhiang/article/details/78450380">https://blog.csdn.net/zuzhiang/article/details/78450380</a></p><p><strong><code>定义二维数组dp，dp[i][j]，表示前 j 项所构成 i 子段的最大和，且必须包含着第j项，即以第j项结尾</code></strong></p><p>求<code>dp[i][j]</code>，有两种情况:</p><ul><li><code>dp[i][j] = dp[i][j-1]+a[j]</code>，把第j项融合到第 j-1 项的子段中，子段数没变</li><li><code>dp[i][j] = dp[i-1][t]+a[j]（i-1&lt;= t&lt;j）</code>,把第 j 项作为单独的一个子段，然后找一下i-1个子段时，最大的和，然后加上a[ j ] ，字段数由i-1变成i</li></ul><p>然后比较上面两种情况，取最大的。即</p><p><code>dp[i][j] = max(dp[i][j-1]+a[j], dp[i-1][t]+a[j])</code></p><p><img src="/2019/04/14/HDU1024-m%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/1.png" alt="HDU1024-m子段和的最大值/1.png"></p><p>如图，要求<code>dp[3][6]</code>，只需比较他左边的那个，和上面那一行圈起来的之中最大的数，再加上a[ j ] 即为<code>dp[3][6]</code> 的值。</p><p><strong>优化</strong></p><ol><li><p>每确定一个<code>dp[ i ][ j ]</code>，只需用到本行和上一行，所以不用开二维数组也可以，省内存。类似于01背包。所以可以开两个一维数组，pre和dp，pre记录上一行，dp记录当前行</p></li><li><p>对上一行红圈中的数字找最大值时，可以在每次计算dp之前，同时记录下j前面的最大元素。避免一次循环来查找。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">468MS9596K</span></span><br><span class="line"><span class="comment">2019-04-15 18:37:21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN], pre[MAXN], arr[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span> ,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = -INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j<span class="number">-1</span>], pre[j<span class="number">-1</span>])+arr[j];</span><br><span class="line">                pre[j<span class="number">-1</span>] = tmp;</span><br><span class="line">                tmp = <span class="built_in">max</span>(tmp, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hdu-1231最大连续子序列和-dp-记录位置</title>
      <link href="/2019/04/14/hdu-1231%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C-dp-%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/"/>
      <url>/2019/04/14/hdu-1231%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C-dp-%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>HDU1231最大连续子序列</p><span id="more"></span><h1 id="HDU1231"><a href="#HDU1231" class="headerlink" title="HDU1231"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1231">HDU1231</a></h1><p><img src="/2019/04/14/hdu-1231%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C-dp-%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/timu.png" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><strong><em>（转移方程好求，但是栽在了求位置上面，后来才想起是后往前推。）</em></strong></p><p><strong>转移方程</strong></p><p>dp[i]表示以i结尾的最大连续子序列的和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态转移方程：dp[i] = max(dp[i - 1] + num[i],num[i]) </span><br></pre></td></tr></table></figure><p><strong>记录位置</strong></p><p>根据转移方程求最大值，这样就能找到最大连续子序列的最后一个元素，然后根据这个位置再向前找起始位置即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-04-14 11:46:05</span></span><br><span class="line"><span class="comment">124MS1628K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="comment">//输入的数据全是负数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0 %d %d\n&quot;</span>, arr[<span class="number">1</span>], arr[n]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> MAX = -INF; <span class="comment">//记录最大值</span></span><br><span class="line">        <span class="type">int</span> End, Begin; <span class="comment">//结尾以及开始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+arr[i], arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                MAX = dp[i];</span><br><span class="line">                End = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = End; i &gt;= <span class="number">1</span>; i--) <span class="comment">//从末尾开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp -= arr[i];</span><br><span class="line">            <span class="keyword">if</span>(tmp == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                Begin = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, MAX, arr[Begin], arr[End]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 最大连续子序列和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1217-Arbitrage-Flody变形</title>
      <link href="/2019/04/14/HDU1217-Arbitrage-Flody%E5%8F%98%E5%BD%A2/"/>
      <url>/2019/04/14/HDU1217-Arbitrage-Flody%E5%8F%98%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<p>HDU1217-Arbitrage</p><span id="more"></span><h1 id="HDU1217"><a href="#HDU1217" class="headerlink" title="HDU1217"></a><a href="acm.hdu.edu.cn/showproblem.php?pid=1217">HDU1217</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)</span><br></pre></td></tr></table></figure><p><strong>Problem Description</strong></p><p>Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 <em> 10.0 </em> 0.21 = 1.05 US dollars, making a profit of 5 percent. </p><p>Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not.</p><hr><p><strong>Input</strong></p><p>The input file will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;=n&lt;=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.</p><p>Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n. </p><hr><p><strong>Output</strong></p><p>For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”.</p><hr><p><strong>Sample Input</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">USDollar</span><br><span class="line">BritishPound</span><br><span class="line">FrenchFranc</span><br><span class="line">3</span><br><span class="line">USDollar 0.5 BritishPound</span><br><span class="line">BritishPound 10.0 FrenchFranc</span><br><span class="line">FrenchFranc 0.21 USDollar</span><br><span class="line"></span><br><span class="line">3</span><br><span class="line">USDollar</span><br><span class="line">BritishPound</span><br><span class="line">FrenchFranc</span><br><span class="line">6</span><br><span class="line">USDollar 0.5 BritishPound</span><br><span class="line">USDollar 4.9 FrenchFranc</span><br><span class="line">BritishPound 10.0 FrenchFranc</span><br><span class="line">BritishPound 1.99 USDollar</span><br><span class="line">FrenchFranc 0.09 BritishPound</span><br><span class="line">FrenchFranc 0.19 USDollar</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Case 1: Yes</span><br><span class="line">Case 2: No</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>参考：<a href="https://blog.csdn.net/wyxeainn/article/details/69157966">https://blog.csdn.net/wyxeainn/article/details/69157966</a></p><p><strong>题目意思：给出n中货币，和m个货币间的汇率，让求解是否存在一种货币，先将这种货币兑换为其他货币，再从其他货币兑换回自己。所获得的钱更多。这样就可以通过货币兑换赚取利润。如果存在这样的货币就输出Yes,如果怎样兑换都会赔本，就输出No.</strong></p><p>先开辟一个二维数组，arr,<code>arr[i][j]</code>存放i可以兑换成多少j。因此如果存在一种货币k，货币i兑换成货币k,再从货币k兑换成货币j,所得到j货币的数量比从货币i直接兑换成货币j的大。则要更新<code>arr[i][j]</code>要的是i兑换成j的最大j数。其思想与求最短路Flody算法的思想是相同的。所以可以借助Flody算法（这种思想）的模板去解决这个问题。</p><p>要解决的问题，如何将字符串对应成整型的节点下标？ 可以采用stl的map实现字符串与下标的一一映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> arr[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Flody</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//如果货币i兑换成k再兑换成j，比i直接兑换成j所得j货币更多，更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][k]*arr[k][j] &gt; arr[i][j])</span><br><span class="line">                    arr[i][j] = arr[i][k]*arr[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">100</span>], str1[<span class="number">100</span>], str2[<span class="number">100</span>];</span><br><span class="line">    <span class="type">double</span> num;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t) != EOF &amp;&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        map&lt;string, <span class="type">int</span>&gt;Map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">            Map[name] = i; <span class="comment">//用map来处理货币对应的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][i] = <span class="number">1.0</span>; <span class="comment">//自身兑换自身的汇率为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>; j &lt;= t; j++)</span><br><span class="line">                arr[i][j] = arr[j][i] = <span class="number">0.0</span>; <span class="comment">//0代表两种货币不能兑换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%lf%s&quot;</span>, str1, &amp;num, str2);</span><br><span class="line">            arr[Map[str1]][Map[str2]] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Flody</span>(t);</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= t; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果第i种货币经过来回兑换后，比原来钱多了，则就可以通过这样的方式赚到钱</span></span><br><span class="line">            <span class="keyword">if</span>(arr[k][k] &gt; <span class="number">1.0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Case %d: Yes\n&quot;</span>,++index);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; t)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case %d: No\n&quot;</span>,++index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU1518-Square-DFS</title>
      <link href="/2019/04/12/HDU1518-Square-DFS/"/>
      <url>/2019/04/12/HDU1518-Square-DFS/</url>
      
        <content type="html"><![CDATA[<p>HDU1518—-Square</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1518">HDU1518</a></p><p><img src="/2019/04/12/HDU1518-Square-DFS/timu.png" alt></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>参考：<a href="https://blog.csdn.net/guodongxiaren/article/details/23126997">https://blog.csdn.net/guodongxiaren/article/details/23126997</a></p><p>题意就是好多棍子，看能不能拼成正方形。主要注意的有几点：</p><ul><li>所有棍子都要用到，不能剩余</li><li>输入已经保证大于4根棍子了。所以无需判断可能小于3根棍子的情况</li><li>棍长的总数首先要是4的倍数，才能进行。否则直接输出 “no”</li><li>当前面前提满足以后，再满足3 根棍子拼好，就完工了。最后一根一定能拼好。</li></ul><p>解法就是运用dfs方法不断尝试，当一个结果不符合题意时，就回溯到上一个结果。</p><p>此外，我们还可以提前对数据进行排序，将数据从大到小排序，以提高查找速率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">421MS1320K</span></span><br><span class="line"><span class="comment">2019-04-12 22:40:37</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN  =<span class="number">1E5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN]; <span class="comment">//存储木棍长度</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN]; <span class="comment">//代表此木棍有没有被用过</span></span><br><span class="line"><span class="type">int</span> one, n, t; <span class="comment">//one:正方形一条边长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//num:已经边的个数，pos:现在遍历的第几根棍子，res:要凑成目标长度剩余的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos, <span class="type">int</span> res)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">3</span>) <span class="comment">//3条边拼好就能保证都拼好</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == res) <span class="comment">//拼好了一条边，所以递归下一个棍子要拼的状态</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(num<span class="number">+1</span>, <span class="number">0</span>, one))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果第i根棍子的长度小于目前所需的。那么也把它加上</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &lt; res) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(num, i<span class="number">+1</span>, res-arr[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*前面如果满足的话，就会返回true。而不执行这一句</span></span><br><span class="line"><span class="comment">         *如果能走到这句，那么就是说前面的情况都不成功，</span></span><br><span class="line"><span class="comment">         *也就是说这根棍子不能凑近去，所以要推翻加入这根棍子的方案</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">            cnt += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        one = cnt / <span class="number">4</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">sort</span>(arr, arr+n, cmp);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,one))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客283H-Dij-链式向前星-快速幂</title>
      <link href="/2019/03/28/%E7%89%9B%E5%AE%A2283H-Dij-%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F-%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2019/03/28/%E7%89%9B%E5%AE%A2283H-Dij-%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F-%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>Dijkstra—链式向前星—快速幂<br><span id="more"></span></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="https://ac.nowcoder.com/acm/contest/283/H">牛客283H-图论一顿套模版</a></p><p><img src="/2019/03/28/%E7%89%9B%E5%AE%A2283H-Dij-%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F-%E5%BF%AB%E9%80%9F%E5%B9%82/timu1.png" alt></p><p><img src="/2019/03/28/%E7%89%9B%E5%AE%A2283H-Dij-%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F-%E5%BF%AB%E9%80%9F%E5%B9%82/timu2.png" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>题目求的是乘积，但是又因为<strong>W一定是2的整数次幂。</strong>所以我们可以将乘法换为加法，<code>2^x * 2^y = 2^(x+y)</code></p><p>只要我们求出<code>x+y</code>的最小值，那么对应其答案也是最小值。算<code>2^x</code>可以运用快速幂解决</p><p>所以总体上我们可以用<code>dij+优先队列优化+链式向前星+快速幂解决</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行时间(ms)使用内存(KB)代码长度使用语言提交时间</span></span><br><span class="line"><span class="comment">62   4188     1543    C++       2019-03-28 10:53:59</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">//链式向前星存图</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// to：表示这条边的另外一个顶点，next：指向下一条边的数组下标，值为-1表示没有下一条边</span></span><br><span class="line"><span class="type">int</span> to, next; </span><br><span class="line">    <span class="comment">//val：表示第i条边的值</span></span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> <span class="comment">//优先队列节点，pos表示顶点位置，cost表示从起点到该点需要的最优路径长度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos, cost;</span><br><span class="line"><span class="built_in">Node</span>()&#123;&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> pos, <span class="type">int</span> cost):<span class="built_in">pos</span>(pos),<span class="built_in">cost</span>(cost)&#123;&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node &amp; a, <span class="type">const</span> Node &amp; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head[i]：表示顶点i的第一条边的数组下标，-1表示顶点i没有边</span></span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="comment">//vis[i]：第i个点是否被访问</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line">Edge edge[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod_pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">ans = ans*x%MOD;</span><br><span class="line">x = x*x%MOD;</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> e1, <span class="type">int</span> e2, <span class="type">int</span> id, <span class="type">int</span> val)</span> <span class="comment">//链式向前星建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[id].to = e2;</span><br><span class="line">edge[id].next = head[e1];</span><br><span class="line">head[e1] = id;</span><br><span class="line">edge[id].val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">Node p;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">Node</span>(s, <span class="number">0</span>));</span><br><span class="line">Edge e;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">p = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[p.pos])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">vis[p.pos] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = head[p.pos]; k != <span class="number">-1</span>; k = edge[k].next)</span><br><span class="line">&#123;</span><br><span class="line">    e = edge[k];</span><br><span class="line"><span class="keyword">if</span>(dis[e.to] &gt; dis[p.pos] + e.val)</span><br><span class="line">&#123;</span><br><span class="line">dis[e.to] = dis[p.pos] + e.val;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">Node</span>(e.to, dis[e.to]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">dis[i] = INF;</span><br><span class="line"><span class="type">int</span> e1, e2, val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;e1, &amp;e2, &amp;val);</span><br><span class="line"><span class="built_in">addEdge</span>(e1, e2, i,<span class="built_in">log2</span>(val)); <span class="comment">//取出2的几次幂后再存入图</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dijkstra</span>();</span><br><span class="line"><span class="keyword">if</span>(dis[t] == INF)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">mod_pow</span>(<span class="number">2</span>,dis[t]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> dijkstra </tag>
            
            <tag> 链式向前星 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之存图方式</title>
      <link href="/2019/03/26/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/03/26/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>邻接矩阵，邻接表，链式向前星</p><span id="more"></span><p>参考：</p><p><a href="http://jzqt.github.io/2015/07/21/ACM%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/">ACM图论之存图方式</a></p><h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>邻接矩阵是三种存图方式中最简单也最为暴力的一种存图方式了。</p><h2 id="存图思想"><a href="#存图思想" class="headerlink" title="存图思想"></a>存图思想</h2><p>使用一个矩阵来描述一个图，对于矩阵的第i行第j列的值，表示编号为i的顶点到编号为j的顶点的权值</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于邻接矩阵来说，它的代码实现都十分简单，二维数组就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1e3</span>;</span><br><span class="line"><span class="comment">//邻接矩阵,Map[i][j]:顶点i到顶点j的权值</span></span><br><span class="line"><span class="type">int</span> Map[MAXV][MAXV];</span><br><span class="line"><span class="built_in">memset</span>(Map, <span class="number">0</span>, <span class="built_in">sizeof</span>(Map));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="comment">// 新增顶点`i`到顶点`j`的边，权值为`w`</span></span><br><span class="line">Map[i][j] = w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除边</span></span><br><span class="line"><span class="comment">// 删除顶点`i`到顶点`j`的边</span></span><br><span class="line">Map[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询边</span></span><br><span class="line"><span class="comment">// 查询顶点`i`到顶点`j`的边权</span></span><br><span class="line"></span><br><span class="line">Map[i][j];</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>使用邻接矩阵来进行建图存图有以下优点</p><ul><li><strong>简单易学</strong></li></ul><p>这个肯定不用多说，哪怕是没学过线性代数的童鞋也很容易理解这样的存图方式。</p><ul><li><strong>代码易写，简单好操作</strong></li></ul><p>上面的代码实现已经展示了要定义这个数据结构以及实现初始化，增加删除边等操作有多么的简单。</p><ul><li><strong>对已确定的边进行操作，效率高</strong></li></ul><p>确定边（已知两顶点编号）要进行增加或删除边（或者说更改边权）以及查询边权等操作，时间复杂度为O(1)。</p><ul><li><strong>易处理重边</strong></li></ul><p>你可以随时覆盖掉重边，可以自己实现存储最新的边，权值最大的边或权值最小的边等。<br>当然，如果你非要使用邻接矩阵存图还要存重边也不是不可以。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>邻接矩阵存图虽然简单优雅，但是它的一些缺点却几乎是致命的。</p><ul><li><strong>过高的空间复杂度</strong></li></ul><p>对于顶点数V，邻接矩阵存图的空间复杂度高达<code>O(V^2)</code>，顶点数上了一万可以不用考虑这种存图方式了。<br>对于稀疏图来说，邻接矩阵存图内存浪费太严重，这也是邻接矩阵存图在ACM题目中十分罕见的根本原因。</p><ul><li><strong>对于不确定边的查询效率一般</strong></li></ul><p>比如，我找个编号为1出发的第一条边我还要一条条边判断是否存在（权值是否为0）</p><h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>邻接表在三种常用的存图方式中属于较为中庸和普遍的存图方式了，缺点不致命，优点不明显。</p><h2 id="存图思想-1"><a href="#存图思想-1" class="headerlink" title="存图思想"></a>存图思想</h2><p><strong>邻接矩阵</strong>对于每个顶点使用<strong>定长的数组</strong>来存储以该点出发的边的情况。第i个数组的第j个值存储的是从顶点i到顶点j的边的权值。</p><p>而<strong>邻接表</strong>则是对于每个顶点使用<strong>不定长的链表</strong>来存储以该点出发的边的情况。<strong>因此对于第i个链表的第j个值实际上存储的是从编号为i的顶点出发的第j条边的情况</strong>。</p><p><strong>一般来说，如果有边权的话，邻接表的链表存储的是一个结构体，这个结构体存储该边的终点以及边权</strong></p><p><img src="/2019/03/26/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E5%AD%98%E5%9B%BE%E6%96%B9%E5%BC%8F/links&amp;matrix.png" alt></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>在ACM题目中，动态的数据结构一般是不被推荐的，因为动态开辟内存比较消耗时间，且写起来复杂容易出错。<br>大部分情况我们使用<strong>C++STL里的vector</strong>作为链表来实现图的邻接表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector实现的邻接表的定义</span></span><br><span class="line"><span class="comment">// 不考虑边权，存储类型为int型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[V];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表的初始化操作</span></span><br><span class="line"><span class="comment">// 将起点为`i`的边链表全部清空</span></span><br><span class="line">e[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="comment">// 新增顶点`i`到顶点`j`的边</span></span><br><span class="line">e[i].<span class="built_in">push_back</span>(j);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询边</span></span><br><span class="line">e[i][<span class="number">0</span>];    <span class="comment">// 查询以`i`为起点的第一条边i-&gt;e[i][0]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;(<span class="type">int</span>)e[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e[i][j] == k) &#123;     <span class="comment">// 查询边`i-&gt;k`</span></span><br><span class="line">        <span class="comment">// do something.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>较为简单易学</strong></li></ul><p>相比邻接矩阵，无非是数组转链表加上存储值的意义不同而已，不需要转太大的弯。</p><ul><li><strong>代码易写，不复杂</strong></li></ul><p>代码实现已经演示过了，较简单，不容易写错。</p><ul><li><strong>内存利用率较高</strong></li></ul><p>对于顶点数V与边数E，空间复杂度为O(V+E)。能较好处理稀疏图的存储。</p><ul><li><strong>对不确定边的操作方便效率也不错</strong></li></ul><p>比如，要遍历从某点出发的所有边，不会像邻接矩阵一样可能会遍历到不存在的边。</p><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li><strong>重边不好处理</strong></li></ul><p>判重比较麻烦，还要遍历已有的边，不能直接判断。<br>一般情况下使用邻接表存图是会存储重边的，不会做重边的判断。<br>所以如果要解决重边的影响一般不在存边的情况下做文章。</p><ul><li><strong>对确定边的操作效率不高</strong></li></ul><p>比如对于给定i-&gt;j的边要进行查询或修改等操作只有通过遍历这种方式找到了。</p><h1 id="链式向前星"><a href="#链式向前星" class="headerlink" title="链式向前星"></a>链式向前星</h1><p>链式前向星是前向星的升级版，因为它可以完美代替前向星，所以就跳过前向星的学习，直接学习链式前向星。</p><h2 id="存图思想-2"><a href="#存图思想-2" class="headerlink" title="存图思想"></a>存图思想</h2><p>链式前向星的本质其实就是用数组模拟链表的邻接表。</p><p>这种存图方式的数据结构主要是<strong>边集数组</strong>，顾名思义，<strong>图的边是用数组来存储的。</strong><br>当然想要完美表示图结构，光有一个边集数组还不够，还要有一个数组存储指向<strong>每一个点的第一条边的“指针”。</strong><br>而每一条边都需要存储接下来一条边的“指针”，这样就能够像类似邻接表一样方便遍历每一个点的所有边了</p><p>可参考:</p><p><a href="https://blog.csdn.net/acdreamers/article/details/16902023">https://blog.csdn.net/acdreamers/article/details/16902023</a></p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">1E5</span>;</span><br><span class="line"><span class="comment">// 最大边数</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXE = <span class="number">1E5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构体的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;         <span class="comment">// 表示这条边的另外一个顶点</span></span><br><span class="line">    <span class="type">int</span> next;       <span class="comment">// 指向下一条边的数组下标，值为-1表示没有下一条边</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head[i] 表示顶点i的第一条边的数组下标，-1表示顶点i没有边</span></span><br><span class="line"><span class="type">int</span> head[V];</span><br><span class="line">Edge edge[E];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式前向星初始化，只需要初始化顶点数组就可以了</span></span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边的方式</span></span><br><span class="line"><span class="comment">// 新增边 a -&gt; b，该边的数组下标为`id`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddEdge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[id].to = b;</span><br><span class="line">    edge[id].next = head[a];    <span class="comment">// 新增的边要成为顶点`a`的第一条边，而不是最后一条边</span></span><br><span class="line">    head[a] = id;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=head[a]; i!=<span class="number">-1</span>; i=e[i].next) &#123;</span><br><span class="line">    <span class="comment">// e[i] 就是你当前遍历的边 a -&gt; e[i].to</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li><strong>内存利用率高</strong></li></ul><p>相比vector实现的邻接表而言，可以准确开辟最多边数的内存，不像vector实现的邻接表有爆内存的风险。</p><ul><li><strong>对不确定边的操作方便效率也不错</strong></li></ul><p>这点和邻接表一样，不会遍历到不存在的边。</p><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ul><li><strong>难于理解，代码较复杂</strong></li></ul><p>这种存图方式相对于邻接表来说比较难理解，代码虽然不是很复杂但是不熟练的话写起来也不是方便。</p><ul><li><strong>重边不好处理</strong></li></ul><p>这点与邻接表一样，只有通过遍历判重。</p><ul><li><strong>对确定边的操作效率不高</strong></li></ul><p>也与邻接表一样，不能通过两点马上确定边，只能遍历查找。</p><h1 id="链式向前星与邻接表"><a href="#链式向前星与邻接表" class="headerlink" title="链式向前星与邻接表"></a>链式向前星与邻接表</h1><p><strong>邻接表</strong></p><p><strong>优点：</strong></p><ol><li><p>写起来比链式前向星快（大概</p></li><li><p>每个顶点的出边都是用vector存储的，方便执行一些STL中的函数（比如排序）</p></li></ol><p><strong>缺点:</strong></p><ol><li>STL会略慢一些</li><li>浪费空间，由于vector申请空间的方式是两倍扩容，遇到卡空间的题目的时候会跪</li><li>数组可以random access的优点在图问题中通常没有什么卵用，但是数组不能O(1)删除元素的缺点在某些应用场合下非常致命</li></ol><p>然后把上面的取个反大概也就是链式前向星的特点了…</p><p><strong>所以在没有删边操作的情况下，以写的爽的角度来看的话应该是邻接表这种方式更爽一点，遇到需求删边操作或者对时间空间要求比较高的问题用链式前向星比较稳妥</strong></p><p>参考：<br><a href="https://www.zhihu.com/question/59676094/answer/178637763">https://www.zhihu.com/question/59676094/answer/178637763</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于<strong>邻接矩阵存图</strong>来说，由于<strong>内存消耗的局限性</strong>，它的适用范围比较狭窄，几乎只能在简单图论题目中见到。</p><p><strong>邻接表存图</strong>是最为常见的一种，绝大部分采用<code>C++STL中的vector</code>实现，一般情况下大部分图论题目都能使用该存图方式。</p><p>但是<strong>链式前向星</strong>其实是一种较好替代邻接表来存图的数据结构，在邻接表存图不能使用时可以使用，几乎可以用于全部图论题目。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 邻接矩阵 </tag>
            
            <tag> 邻接表 </tag>
            
            <tag> 链式向前星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图着色问题</title>
      <link href="/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>洛谷P2819图的m着色问题, POJ 1129 Channel Allocation</p><span id="more"></span><h1 id="模板题—洛谷P2819图的m着色问题"><a href="#模板题—洛谷P2819图的m着色问题" class="headerlink" title="模板题—洛谷P2819图的m着色问题"></a><a href="https://www.luogu.org/problemnew/show/P2819">模板题—洛谷P2819图的m着色问题</a></h1><p><img src="/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/timu1.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码 C++11，0.77KB</span></span><br><span class="line"><span class="comment">提交时间 2019-04-04 15:54:31</span></span><br><span class="line"><span class="comment">耗时/内存</span></span><br><span class="line"><span class="comment">277ms, 888KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">bool</span> gra[MAXN][MAXN] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//判断两个点是否连通</span></span><br><span class="line"><span class="type">int</span> color[MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">//存每个点已经涂成的颜色,值为0则是没有被涂色</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m, e1, e2, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当两个图连通且颜色一样就冲突</span></span><br><span class="line">        <span class="keyword">if</span>(gra[i][num] == <span class="literal">true</span> &amp;&amp; color[i] == color[num])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; n) <span class="comment">//搜完所有顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="comment">//遍历所有颜色</span></span><br><span class="line">    &#123;</span><br><span class="line">        color[num] = i; <span class="comment">//给第num个顶点上第i个颜色</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(num))</span><br><span class="line">            <span class="built_in">dfs</span>(num<span class="number">+1</span>); <span class="comment">//涂下一个</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            color[num] = <span class="number">0</span>; <span class="comment">//如果冲突,则回溯,也就是清除涂色状态回到上一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;e1, &amp;e2);</span><br><span class="line">        gra[e1][e2] = <span class="literal">true</span>;</span><br><span class="line">        gra[e2][e1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); <span class="comment">//从第一个点开始</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="POJ1129"><a href="#POJ1129" class="headerlink" title="POJ1129"></a><a href="http://poj.org/problem?id=1129">POJ1129</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/timu2.png" alt></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>参考:<a href="https://blog.csdn.net/lyy289065406/article/details/6647986">https://blog.csdn.net/lyy289065406/article/details/6647986</a></p><p>题意:</p><p>当一个广播电台在一个非常大的地区，广播站会用中继器来转播信号以使得每一个接收器都能接收到一个强烈的信号。然而，每个中继器必须慎重选择使用，使相邻的中继器不互相干扰。如果相邻的中继器使用不同的频道，那么就不会相互干扰。</p><p>由于无线电频道是一有限的，一个给定的网络所需的中继频道数目应减至最低。编写一个程序，读取一个中继网络，然后求出需要的最低的不同频道数。</p><p><strong>即一个有N个节点的无向图，要求对每个节点进行染色，使得相邻两个节点颜色都不同，问最少需要多少种颜色？</strong></p><h3 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-04-04 16:54:23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">bool</span> gra[MAXN][MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> color[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> Find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(gra[i][num] == <span class="literal">true</span> &amp;&amp; color[i] == color[num])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> cnt)</span> <span class="comment">//当前搜索到下标为id的点，此时总共用的颜色数为cnt</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Find)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        Find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        color[num] = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(num))</span><br><span class="line">            <span class="built_in">dfs</span>(num<span class="number">+1</span>, cnt);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            color[num] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!Find) <span class="comment">//当用cnt种颜色无法完成时，则增加一种颜色进行着色</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="built_in">dfs</span>(num, cnt<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[MAXN];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">memset</span>(gra, <span class="literal">false</span>, <span class="built_in">sizeof</span>(gra));</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="type">int</span> e1 = s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; s[j] != <span class="string">&#x27;\0&#x27;</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> e2 = s[j]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                gra[e1][e2] = gra[e2][e1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        Find = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;1 channel needed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%d channels needed.\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四色定理剪枝"><a href="#四色定理剪枝" class="headerlink" title="四色定理剪枝"></a>四色定理剪枝</h3><p><strong>四色问题</strong>的内容是:任何一张地图只用四种颜色就能使具有共同边界的国家着上不同的颜色。”也就是说在不引起混淆的情况下一张地图只需四种颜色来标记就行。</p><p><img src="/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/sise.jpeg" alt></p><p><strong>四色定理的“相邻”是指两块多边形地区“至少一条边重合”才为之相邻</strong></p><p><strong>“至少一条边重合”同时也隐含了“任意边（线段）不正规相交</strong></p><p>本题的相邻是“两点有边连接，但任意两边不交叉（正规相交）”，这种“相邻”其实就是四色定理的“相邻”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">bool</span> gra[MAXN][MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> color[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> Find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(gra[i][num] == <span class="literal">true</span> &amp;&amp; color[i] == color[num])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Find)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        Find = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        color[num] = i;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(num))</span><br><span class="line">            <span class="built_in">dfs</span>(num<span class="number">+1</span>, cnt);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            color[num] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!Find)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span>(cnt<span class="number">+1</span> == <span class="number">4</span>) <span class="comment">//四色定理</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">dfs</span>(num, cnt<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[MAXN];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="built_in">memset</span>(gra, <span class="literal">false</span>, <span class="built_in">sizeof</span>(gra));</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            <span class="type">int</span> e1 = s[<span class="number">0</span>]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; s[j] != <span class="string">&#x27;\0&#x27;</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> e2 = s[j]-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">                gra[e1][e2] = gra[e2][e1] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        Find = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;1 channel needed.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;%d channels needed.\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="蓝桥杯历届试题分考场"><a href="#蓝桥杯历届试题分考场" class="headerlink" title="蓝桥杯历届试题分考场"></a><a href="http://lx.lanqiao.cn/problem.page?gpid=T457">蓝桥杯历届试题分考场</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><img src="/2019/03/23/%E5%9B%BE%E7%9D%80%E8%89%B2%E9%97%AE%E9%A2%98/timu3.png" alt></p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>此题是一道经典的图的染色问题，等同于：对图经行染色，且相邻的顶点不能染同样的颜色，问至少需要多少种不同的颜色<br>参考:<a href="https://www.cnblogs.com/looeyWei/p/10439834.html">https://www.cnblogs.com/looeyWei/p/10439834.html</a><br><a href="https://blog.csdn.net/memeda1141/article/details/80301201">https://blog.csdn.net/memeda1141/article/details/80301201</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">bool</span> gra[MAXN][MAXN] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//gra[i][j]=1表示i和j认识，否则不认识</span></span><br><span class="line"><span class="type">int</span> room[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">//room[i][j]=x 表示第i个房间第j个人是编号为x的学生</span></span><br><span class="line"><span class="type">int</span> room_num[MAXN] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//room_num[i]=k  表示第i个房间有k个人</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, e1, e2, ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> cnt)</span> <span class="comment">//num表示当前学生的编号，cnt表示用掉房间的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= ans) <span class="comment">//如果当前用掉房间的数量大于历史用掉的最小数量，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; n) <span class="comment">//如果学生已经安排完了，取最优值，并返回 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; cnt)</span><br><span class="line">            ans = cnt;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) <span class="comment">//遍历所有房间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len = room_num[i]; <span class="comment">//第i个房间的有多少人</span></span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j++) <span class="comment">//遍历当前房间的所有学生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!gra[num][room[i][j]]) <span class="comment">//如果学生num与学生room[i][j]没有关联，k++;</span></span><br><span class="line">                k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == len)  <span class="comment">//如果num与当前房间所有的人都没有关联</span></span><br><span class="line">        &#123;</span><br><span class="line">            room[i][++room_num[i]] = num; <span class="comment">//那么就把num放进这个房间里</span></span><br><span class="line">            <span class="built_in">dfs</span>(num<span class="number">+1</span>, cnt); <span class="comment">//当前学生已经被安排，dfs安排下一个学生</span></span><br><span class="line">            room_num[i]--; <span class="comment">//递归返回之后把这个同学在从这个教室分走，分到下几个教室看看</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果全部教室都存在num认识的同学，那么就把这个同学新开个教室</span></span><br><span class="line">    room[cnt<span class="number">+1</span>][++room_num[cnt<span class="number">+1</span>]] = num; </span><br><span class="line">    <span class="built_in">dfs</span>(num<span class="number">+1</span>, cnt<span class="number">+1</span>); <span class="comment">//递归下一个同学并且当前的教室数目+1</span></span><br><span class="line">    room_num[cnt<span class="number">+1</span>]--; <span class="comment">//返回后移除这个同学看下上一个同学有没有其他的选择</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;e1, &amp;e2);</span><br><span class="line">        gra[e1][e2] = gra[e2][e1] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 四色定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L2-016-dfs</title>
      <link href="/2019/03/17/L2-016-dfs/"/>
      <url>/2019/03/17/L2-016-dfs/</url>
      
        <content type="html"><![CDATA[<p>L2-016 愿天下有情人都是失散多年的兄妹</p><span id="more"></span><h1 id="L2-016-愿天下有情人都是失散多年的兄妹"><a href="#L2-016-愿天下有情人都是失散多年的兄妹" class="headerlink" title="L2-016 愿天下有情人都是失散多年的兄妹"></a><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805061769609216">L2-016 愿天下有情人都是失散多年的兄妹</a></h1><p><img src="/2019/03/17/L2-016-dfs/timu.png" alt></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>找到并标记两人的5代以内祖先，如果发现已标记过的祖先，就说明两人有共同祖先</p><h2 id="存储和查找"><a href="#存储和查找" class="headerlink" title="存储和查找"></a>存储和查找</h2><p>输入的数据包含一个人的ID、性别和父母的ID，为了方便可以就用一个结构体来存储数据，声明一个结构体数组，</p><p>其数组下标代表这个人的id，结构体属性有父母id。另外开辟一个数组空间来保存性别，一个数组空间保存标记信息。</p><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><p><strong>测试数据里面可能会判断某个人的父亲，或者母亲和某个人是否能结婚，所以也要标记父母的性别</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="comment">//sex[i]:编号为i的人的性别，vis[i]：编号为i的人是否已经标记，flag：判断两人是否可行</span></span><br><span class="line"><span class="type">int</span> sex[MAXN], vis[MAXN], flag;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//fa:父亲id，ma：母亲id，初始化为-1</span></span><br><span class="line">    <span class="type">int</span> fa = <span class="number">-1</span>, ma = <span class="number">-1</span>;</span><br><span class="line">&#125;stru[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//超过五代，或者父母不可考</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">4</span> || n == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//如果已经被标记过，说明有在五代内有共同亲属，则不能结婚</span></span><br><span class="line">    <span class="keyword">if</span>(vis[n])</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[n] = <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//进行dfs查找五代内的信息</span></span><br><span class="line">    <span class="built_in">dfs</span>(stru[n].fa, num<span class="number">+1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(stru[n].ma, num<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="type">int</span> id, fa, ma;</span><br><span class="line">    <span class="type">char</span> se;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %c %d %d&quot;</span>, &amp;id, &amp;se, &amp;fa, &amp;ma);</span><br><span class="line">        sex[id] = (<span class="type">int</span>)se;</span><br><span class="line">        stru[id].fa = fa;</span><br><span class="line">        stru[id].ma = ma;</span><br><span class="line">        sex[fa] = (<span class="type">int</span>)<span class="string">&#x27;M&#x27;</span>;</span><br><span class="line">sex[ma] = (<span class="type">int</span>)<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> m, id1, id2;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;id1, &amp;id2);</span><br><span class="line">        <span class="keyword">if</span>(sex[id1] == sex[id2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Never Mind\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(id1, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(id2, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关于DFS"><a href="#关于DFS" class="headerlink" title="关于DFS"></a>关于DFS</h2><p><strong>dfs会一直遍历父节点，直到遇到父节点的值为-1或者已经超过五代，这时候会回溯回去遍历母亲节点。</strong></p><p><img src="/2019/03/17/L2-016-dfs/dfs1.png" alt></p><p><strong>此时，return后，会回溯到19这个节点，接着访问19的母亲节点</strong></p><p><img src="/2019/03/17/L2-016-dfs/dfs2.png" alt></p><p><strong>接着如此循环，直到遇到结束条件</strong></p><p><img src="/2019/03/17/L2-016-dfs/dfs3.png" alt></p><p><strong>…</strong></p><hr><p><strong>遍历完第一个人的关系图后，我们再遍历第二个人的，如果在遍历第二个人的关系图时发现在遍历第一个人的时候已经标记过了而且没有超过五代，这时候就可以判断不能结婚，否则可以结婚</strong></p>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FZU-1649-PrimeNumberOrNot-大素数判断</title>
      <link href="/2019/03/16/FZU-1649-PrimeNumberOrNot-%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/"/>
      <url>/2019/03/16/FZU-1649-PrimeNumberOrNot-%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>FZU-1649-PrimeNumberOrNot-大素数判断<br><span id="more"></span></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="FZU-1649"><a href="#FZU-1649" class="headerlink" title="FZU-1649"></a><a href="http://acm.fzu.edu.cn/problem.php?pid=1649">FZU-1649</a></h2><p><img src="/2019/03/16/FZU-1649-PrimeNumberOrNot-%E5%A4%A7%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/timu.png" alt></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>普通素数筛法不能用于大数。此时只能用别的算法——米勒-拉宾素数测试</p><p>我们知道对于某个素数P,由费马定理得</p><script type="math/tex; mode=display">a^p \ mod \ p \equiv a</script><p>于是就有了希望使用这个来判断某个p是否是素数</p><hr><p><strong>但$a^p \ mod \ p \equiv a$不是<code>p是素数</code>的充分条件</strong></p><p><strong><em>存在有名但是极端稀少的Carmichael数，它们不是素数但是满足费马小定理，比如561, 1105, 1729, 2465, 2821,6601, 8911, 10585, 15841, 29341…。</em></strong></p><p>所以如果我们只是随机的从<code>1</code>和<code>p-1</code>之间（这里p是一个待判断的正整数）取一个数a计算$a^p \ mod \ p \equiv a$的值，如果该值不是a，那么我们100%肯定p不是素数。但<strong>如果$a^p \ mod \ p \equiv a$的值是a，p可能是素数也可能不是。</strong></p><hr><p>费马小定理的一个特殊情况，如果n是一个素数，那么<code>phi(n)=n-1</code>，而任意不大于n的数a都与n互质，于是费马小定理的推论为：</p><script type="math/tex; mode=display">a^{n-1}=1\ mod\ n\ (当n为素数，而a为任意整数时)</script><p>即一个数字n为素数的必要条件是对于任意<code>a&lt;n</code>，都有$a^{n-1}\ mod\ n = 1$</p><hr><p>但是这是必要条件，根据计算，如果n为任意数字，单独任取一个<code>a&lt;n</code>，当$a^{n-1}\ mod\ n = 1$成立时，<strong>有<code>25%</code>可能性n为合数</strong></p><p><strong>所以我们可以通过多次随机选择不同的a，如果上面测试都被通过，我们就可以说n有很大的可能是素数。这种算法<code>`是米勒-拉宾素数测试</code>。</strong></p><hr><p>注意:</p><p>在计算$a^{n-1}\ mod\ n$的时候，n可能很大，所以$a^{n-1}$可能越界，就需要用快速幂取模，但a很大的时候<code>a*a</code>也可能越界，就需要用快速乘法（基于快速幂）</p><p>参考：<a href="https://blog.csdn.net/qq_40889820/article/details/82145736"><a href="https://blog.csdn.net/qq_40889820/article/details/82145736">https://blog.csdn.net/qq_40889820/article/details/82145736</a></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1046ms</span></span><br><span class="line"><span class="comment">2019-03-16 16:46:15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> random(a, b) (rand()%(b-a+1)+a)  <span class="comment">//取得在[a,b]间的随机数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll MOD)</span> <span class="comment">//快速乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (ll)((ld)a / MOD * b) * MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n, ll mod)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = <span class="built_in">mul</span>(ans, x, mod);</span><br><span class="line">        x = <span class="built_in">mul</span>(x, x, mod);</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a = <span class="built_in">random</span>(<span class="number">1</span>, n<span class="number">-1</span>); <span class="comment">//取得在[1,n-1]的随机数</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mod_pow</span>(a, n<span class="number">-1</span>, n) != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll num;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">is_prime</span>(num))</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;It is a prime number.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;It is not a prime number.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 米勒-拉宾素数测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces-236B-求因子个数</title>
      <link href="/2019/03/15/CodeForces-236B-%E6%B1%82%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0/"/>
      <url>/2019/03/15/CodeForces-236B-%E6%B1%82%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>CodeForces-236B-求因子个数<br><span id="more"></span></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="CodeForces-236B"><a href="#CodeForces-236B" class="headerlink" title="CodeForces-236B"></a><a href="http://codeforces.com/problemset/problem/236/B">CodeForces-236B</a></h2><p><img src="/2019/03/15/CodeForces-236B-%E6%B1%82%E5%9B%A0%E5%AD%90%E4%B8%AA%E6%95%B0/timu.jpg" alt></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>先算出<code>q=i*j*k</code>，然后算q的因子的个数，最后把这个因子和加起来<code>mod</code>上一个数</p><p>记录下求解因子个数的办法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-03-15 15:00:35</span></span><br><span class="line"><span class="comment">92ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1073741824</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) <span class="comment">//初始化，每一个数最少有两个因子，１和它本身</span></span><br><span class="line">arr[i] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i*j得到一个数，代表这个数有因i和j，如果i,j相等,因子个数+1,否则+2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i*i &lt; MAXN; i++)　</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i; j*i &lt; MAXN; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i != j)</span><br><span class="line">arr[i*j] += <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">arr[i*j] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= c; k++)</span><br><span class="line">&#123;</span><br><span class="line">ans += arr[i*j*k];</span><br><span class="line"><span class="keyword">if</span>(ans &gt; MOD)</span><br><span class="line">ans %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
            <tag> 因子 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA-L2-025-分而治之-vector-思维</title>
      <link href="/2019/03/06/PTA-L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B-vector-%E6%80%9D%E7%BB%B4/"/>
      <url>/2019/03/06/PTA-L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B-vector-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>L2-025-分而治之<br><span id="more"></span></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805056195379200">L2-025</a></p><p><img src="/2019/03/06/PTA-L2-025-%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B-vector-%E6%80%9D%E7%BB%B4/timu.jpg" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><strong>图问题！！</strong></p><p>刚开始是想存储在vector里面，然后如果摧毁i的话，就把对应的<code>vector&lt;i&gt;</code>清空，还有查询别的vector，如果有i的话，则去掉，然后提交了一发，过了两个test，TLE了两个（很明显暴力超时，而且暴力不对）</p><p>附上TLE代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019/3/6 20:42:45</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[<span class="number">11000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, e1, e2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">v</span>(n<span class="number">+10</span>);</span><br><span class="line">    v.<span class="built_in">reserve</span>(m<span class="number">+10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; e1 &gt;&gt; e2;</span><br><span class="line">        v[e1].<span class="built_in">push_back</span>(e2);</span><br><span class="line">        v[e2].<span class="built_in">push_back</span>(e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num, in1, in2;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">vec</span>(v);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        cin &gt;&gt; in1;</span><br><span class="line">        <span class="keyword">while</span>(in1--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; in2;</span><br><span class="line">            vis[in2] = <span class="number">1</span>;</span><br><span class="line">            vec[in2].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt;::iterator findInput = <span class="built_in">find</span>(vec[j].<span class="built_in">begin</span>(), vec[j].<span class="built_in">end</span>(), in2);</span><br><span class="line">                <span class="keyword">if</span>(findInput != vec[j].<span class="built_in">end</span>())</span><br><span class="line">                    vec[j].<span class="built_in">erase</span>(findInput);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">find</span>(vec[j].<span class="built_in">begin</span>(), vec[j].<span class="built_in">end</span>(), j) != vec[j].<span class="built_in">end</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!vec[j].<span class="built_in">empty</span>())</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(flag)</span><br><span class="line">               &#123;</span><br><span class="line">                   cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面代码问题在于查找和删除这个过程，其实完全没有必要这种做</strong></p><p>因为是摧毁，所以一条路摧毁一个城市就可以把这条路给毁了，<strong>所以我们只需要判断所有的孤立的城市是否哦满足条件即可，孤立的城市 = 没被摧毁且没有连接到别的城市</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019/3/6 21:07:37</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[<span class="number">11000</span>];  <span class="comment">//vis[i]:代表第i座城市是否被摧毁</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">11000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//查询所有孤立的点是否满足条件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//孤立的城市 = 没被摧毁且没有连接到别的城市</span></span><br><span class="line">            <span class="comment">//v[i][j]代表一个城市，v[i][j]代表i连通的某个城市的值</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i] &amp;&amp; vis[v[i][j]] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m, e1, e2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; e1 &gt;&gt; e2;</span><br><span class="line">        v[e1].<span class="built_in">push_back</span>(e2);</span><br><span class="line">        v[e2].<span class="built_in">push_back</span>(e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num, in1, in2;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        cin &gt;&gt; in1;</span><br><span class="line">        <span class="keyword">while</span>(in1--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; in2;</span><br><span class="line">            vis[in2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fun</span>(n))</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PTA-L2-028-vector-思维</title>
      <link href="/2019/03/06/PTA-L2-028-vector-%E6%80%9D%E7%BB%B4/"/>
      <url>/2019/03/06/PTA-L2-028-vector-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p>L2-028 秀恩爱分得快 </p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>链接：<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805054698012672">L2-028</a></p><p><img src="/2019/03/06/PTA-L2-028-vector-%E6%80%9D%E7%BB%B4/timu.png" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>分别求出a，b与编号为i(i&gt;0)的人的亲密度va[i]，vb[i]，还有va，vb的最大值MAXA，MAXB然后进行判断</p><ul><li>如果MAXA对应的人是b而且MAXB对应的人是a，那么输出a，b即可</li><li>否则，分别按要求输出MAXA对应的人的编号，MAXB对应的人的编号</li></ul><p>对于va，vb我们可以用个double数组存储，因为编号有正有负，所以得进行绝对值处理，所以得有另外一个数组g进行标记性别，<strong>同时需要注意到0这个点，因为会有+0，-0出现，所以得以字符串的形式输入</strong></p><p>存储输入的数据，因为每行的个数都不一样，所以可以开辟一个较大的二维数组，或者用vector，这里选用vector</p><p>参考：<a href="https://blog.csdn.net/qq1013459920/article/details/86772096">https://blog.csdn.net/qq1013459920/article/details/86772096</a></p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//va[i]:a编号为i(i&gt;0)的人的亲密度,vb[i]同理</span></span><br><span class="line"><span class="type">double</span> va[<span class="number">1100</span>] = &#123;<span class="number">0.0</span>&#125;, vb[<span class="number">1100</span>] = &#123;<span class="number">0.0</span>&#125;;</span><br><span class="line"><span class="comment">//g[i]==true:编号为i的为女性</span></span><br><span class="line"><span class="type">bool</span> g[<span class="number">1100</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="comment">//以字符串的形式读入，将读入的字符串变为整型，同时取绝对值，并且标记性别</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> input = <span class="number">0</span>, sign = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> a = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span> ((a&lt;<span class="string">&#x27;0&#x27;</span> || a&gt;<span class="string">&#x27;9&#x27;</span>) &amp;&amp; a != <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">a = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">sign = <span class="number">1</span>;</span><br><span class="line">a = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (a &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; a &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">input = input * <span class="number">10</span> + a - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">a = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">g[input] = sign;</span><br><span class="line"><span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, input1;</span><br><span class="line">    <span class="type">char</span> input2[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;<span class="built_in">photos</span>(n); <span class="comment">//存储输入的数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;input1);</span><br><span class="line">        photos[i].<span class="built_in">resize</span>(input1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; input1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果读进去字符串再转化的话，可能会超时</span></span><br><span class="line">            photos[i][j] =  <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">double</span> MAXA = <span class="number">0.0</span>, MAXB = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//是否在一行数据中找得到a</span></span><br><span class="line">        <span class="type">bool</span> findA = <span class="built_in">find</span>(photos[i].<span class="built_in">begin</span>(), photos[i].<span class="built_in">end</span>(), a) != photos[i].<span class="built_in">end</span>();</span><br><span class="line">        <span class="type">bool</span> findB = <span class="built_in">find</span>(photos[i].<span class="built_in">begin</span>(), photos[i].<span class="built_in">end</span>(), b) != photos[i].<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">if</span>(findA || findB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; photos[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(findA &amp;&amp; g[a] != g[photos[i][j]])</span><br><span class="line">                &#123;</span><br><span class="line">                    va[photos[i][j]] += (<span class="type">double</span>)<span class="number">1.0</span>/photos[i].<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span>(va[photos[i][j]] &gt; MAXA)</span><br><span class="line">                        MAXA = va[photos[i][j]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(findB &amp;&amp; g[b] != g[photos[i][j]])</span><br><span class="line">                &#123;</span><br><span class="line">                    vb[photos[i][j]] += (<span class="type">double</span>)<span class="number">1.0</span>/photos[i].<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">if</span>(vb[photos[i][j]] &gt; MAXB)</span><br><span class="line">                        MAXB = vb[photos[i][j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(MAXA == va[b] &amp;&amp; MAXB == vb[a])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s%d %s%d\n&quot;</span>, g[a] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, a, g[b] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, b);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(va[i] == MAXA)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s%d %s%d\n&quot;</span>, g[a] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, a, g[i] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vb[i] == MAXB)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s%d %s%d\n&quot;</span>, g[b] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, b, g[i] ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chroot方法恢复grub信息</title>
      <link href="/2019/02/27/chroot%E6%96%B9%E6%B3%95%E6%81%A2%E5%A4%8Dgrub%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/02/27/chroot%E6%96%B9%E6%B3%95%E6%81%A2%E5%A4%8Dgrub%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>利用Live CD的另外一个方法解决grub rescue方法</p><span id="more"></span><p>开机缺引导日常进grub rescue，除了<code>set set prefix</code>的办法外，还可以利用Live CD进行<code>update-grub</code>命令</p><p>从Linux LIve CD启动后，能够通过<code>update-grub chroo</code>t到<code>grub</code>分区来解决这个问题</p><p><img src="/2019/02/27/chroot%E6%96%B9%E6%B3%95%E6%81%A2%E5%A4%8Dgrub%E4%BF%A1%E6%81%AF/grub-rescue.png" alt></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>参考：<a href="https://askubuntu.com/questions/254491/failed-to-get-canonical-path-of-cow">https://askubuntu.com/questions/254491/failed-to-get-canonical-path-of-cow</a></p><p><em>评论区还有个更好的解决方案，如果这个不行，可以试试那一个</em></p><p>（<code>/dev/sda1</code>用你在grub上安装的任何分区替换下面。所有命令都是root。）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/chrootdir</span><br><span class="line">mount /dev/sda1 /mnt/chrootdir</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分别用proc dev sys etc bin sbin var usr lib lib64 tmp替代<span class="variable">$dir</span>后执行命令</span></span><br><span class="line">mkdir /mnt/chrootdir/$dir</span><br><span class="line">mount --bind /$dir /mnt/chrootdir/$dir</span><br><span class="line"></span><br><span class="line">chroot /mnt/chrootdir</span><br><span class="line">update-grub2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">update-grub</span></span><br></pre></td></tr></table></figure><p>如果缺引导，可以进live cd联网安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt</span><br><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">cd /mnt</span><br><span class="line">ls -l</span><br><span class="line"></span><br><span class="line">grub-install --recheck --root-directory=/mnt /dev/sda</span><br></pre></td></tr></table></figure><h1 id="记记"><a href="#记记" class="headerlink" title="记记"></a>记记</h1><h2 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h2><p>chroot是在unix系统的一个操作，针对正在运作的软件进程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由chroot设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。chroot这一特殊表达可能指chroot系统调用或chroot前端程序</p><p>—-<a href="https://zh.wikipedia.org/zh-hans/Chroot">chroot - 维基百科，自由的百科全书</a></p><h2 id="—bind"><a href="#—bind" class="headerlink" title="—bind"></a>—bind</h2><p>bind的意思是，把其他地方的子树再进行挂载，也就是说可以把文件系统中的某一个部分进行挂载。</p><p>这个特性是从linux2.4.0开始的。<br>或者更简介的说,就是<strong>挂载一个已有的文件夹</strong></p><p>—-<a href="https://xionchen.github.io/2016/08/25/linux-bind-mount/">bind mount 的用法</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>L2-001紧急救援-dijkstra变形-记录路径</title>
      <link href="/2019/02/22/L2-001%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4-dijkstra%E5%8F%98%E5%BD%A2-%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/02/22/L2-001%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4-dijkstra%E5%8F%98%E5%BD%A2-%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<p>L2-001紧急救援</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805073643683840">L2-001紧急救援</a></p><p><img src="/2019/02/22/L2-001%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4-dijkstra%E5%8F%98%E5%BD%A2-%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84/timu.png" alt></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019/2/22 17:08:10</span></span><br><span class="line"><span class="comment">56ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"><span class="type">int</span> edge[MAXN][MAXN]; </span><br><span class="line"><span class="type">int</span> vis[MAXN] = &#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN]; <span class="comment">//存每个点救援人员数量</span></span><br><span class="line"><span class="type">int</span> path[MAXN]; <span class="comment">//存储路径，path[i]:表示最短路径的前一个结点，最后递归打印路径即可</span></span><br><span class="line"><span class="type">int</span> totWeight[MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">//totWeight[i]:代表从起点到点i所能召集的最多救援队的数量</span></span><br><span class="line"><span class="type">int</span> totPath[MAXN]; <span class="comment">//totPath[i]:起始到点i的最短路径数目</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num_e, num_v, beg, en, MIN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_v; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] = edge[beg][i];</span><br><span class="line">        path[i] = beg;</span><br><span class="line">        <span class="keyword">if</span>(i != beg)</span><br><span class="line">            totWeight[i] = num[beg] + num[i];</span><br><span class="line">        totPath[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">vis[beg] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_v; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        MIN = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_v; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; MIN &gt; dis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                MIN = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_v; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[k] + edge[k][j] &lt; dis[j]) <span class="comment">//松弛时各数组的更新</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dis[j] = dis[k] + edge[k][j];</span><br><span class="line">                    path[j] = k;</span><br><span class="line">                    totPath[j] = totPath[k];</span><br><span class="line">                    totWeight[j] = totWeight[k] + num[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dis[k] + edge[k][j] == dis[j]) <span class="comment">//相等时的更新</span></span><br><span class="line">                &#123;</span><br><span class="line">                    totPath[j] += totPath[k]; <span class="comment">//应该是二者最短路径的和</span></span><br><span class="line">                     <span class="comment">//追求最短路的前提下尽可能地增加队员数目</span></span><br><span class="line">                    <span class="keyword">if</span>(totWeight[k] + num[j] &gt; totWeight[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        totWeight[j] = totWeight[k] + num[j];</span><br><span class="line">                        path[j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(<span class="type">int</span> en)</span> <span class="comment">//输出路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(en == beg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; en;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printPath</span>(path[en]);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; en;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; num_v &gt;&gt; num_e &gt;&gt; beg &gt;&gt; en;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_v; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; num_v; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                edge[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                edge[i][j] = edge[j][i] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_v; i++)</span><br><span class="line">        cin &gt;&gt; num[i];</span><br><span class="line">    <span class="type">int</span> e1, e2, val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_e; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; val;</span><br><span class="line">        edge[e1][e2] = edge[e2][e1] = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dijkstra</span>(beg);</span><br><span class="line">    cout &lt;&lt; totPath[en] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; totWeight[en] &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printPath</span>(en);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.voidcn.com/article/p-vibveive-tk.html">http://www.voidcn.com/article/p-vibveive-tk.html</a></p><p><a href="https://blog.csdn.net/wbb1997/article/details/79119608">https://blog.csdn.net/wbb1997/article/details/79119608</a></p><p><a href="https://www.liuchuo.net/archives/2362">https://www.liuchuo.net/archives/2362</a></p>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之最小生成树</title>
      <link href="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>prim算法，kruskal算法，POJ1251入门题目</p><span id="more"></span><p>参考：<a href="https://blog.csdn.net/qq_40306845/article/details/81540626">https://blog.csdn.net/qq_40306845/article/details/81540626</a></p><h1 id="模板题目"><a href="#模板题目" class="headerlink" title="模板题目"></a>模板题目</h1><p><strong><a href="http://poj.org/problem?id=1251">poj1251—Jungle Roads</a></strong><img src="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/timu.png" alt></p><p>题意：给你n个点，右n-1条边，每个边都有一个权值，让你求出最小生成树</p><p><em>题目说明不含重复边</em></p><h2 id="prime"><a href="#prime" class="headerlink" title="prime"></a>prime</h2><ul><li>先任意选择一条边（一般直接选择第一条），连接与其相连权值最小的点，然后两个点成为一个集合体。</li><li>找这个不在这个集合体里 但是与集合体相连的权值最小的点 与集合体相连，并把该点归入集合体。</li><li>重复上一条操作，直到集合体归入了所有的点</li></ul><p><strong>时间复杂度</strong></p><p>记顶点数v，边数e</p><p>邻接矩阵:O(v2)                 邻接表:O(elog2v)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span>;</span><br><span class="line"><span class="type">int</span> mp[MAXN][MAXN]; <span class="comment">////邻接矩阵</span></span><br><span class="line"><span class="type">int</span> vis[MAXN], ans[MAXN]; </span><br><span class="line"><span class="comment">//vis[i]:判断第i个顶点有没有走过</span></span><br><span class="line"><span class="comment">//ans[i]:当指定一个点n时，n到第i个点的距离，n的范围是全部点，所以ans是变化的</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//初始化第一个点</span></span><br><span class="line">    &#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        ans[i] = mp[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">//第一个点已经走过</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//遍历所有的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> MIN = INF, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//遍历第i个点旁边所有的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; ans[j] &lt; MIN) <span class="comment">//没有走过&amp;&amp;求出ans[]最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                MIN = ans[j];</span><br><span class="line">                pos = j; <span class="comment">//记录最小位置，即(i, pos)这个点值最小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(MIN == INF) <span class="comment">//没有找到</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vis[pos] = <span class="number">1</span>;</span><br><span class="line">        sum += MIN; <span class="comment">//权值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="comment">//第一个点走完后，重新初始化下一个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*当前点没有走过&amp;&amp;防止走回去，假如(1,2)已经走过了，</span></span><br><span class="line"><span class="comment">             *如果不加这个条件，可能初始化2这个点的时候，会把（2,1）加进去</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[k] &amp;&amp; mp[pos][k] &lt; ans[k]) </span><br><span class="line">                ans[k] = mp[pos][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, k;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp, INF, <span class="built_in">sizeof</span>(mp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; c1 &gt;&gt; m;</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; c2 &gt;&gt; k;</span><br><span class="line">                mp[c1-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>][c2-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>] = mp[c2-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>][c1-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">prime</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="kruskal"><a href="#kruskal" class="headerlink" title="kruskal"></a>kruskal</h2><ul><li>先选择一条权值最小的边，把这条边相连的两个点归成一个集合。</li><li>再找下一个权值最小的边，但是边相连的两个点不能属于同一个集合，把这条边相连的两个点（这里也可以是集合）归成一个集合</li><li>重复上一条操作，直到最后只有一个集合体且归入所有的点。</li></ul><p><strong>时间复杂度</strong></p><p>elog2e  （e为图中的边数）</p><hr><p><code>prime</code>与<code>kruskal</code>区别：</p><ol><li>集合的个数：<code>prime</code>算法自始自终只有一个集合，而<code>kruskal</code>算法可以有多个集合，所以<code>kruskal</code>算法要用到并查集。</li><li>选取的方式：<code>prime</code>算法先是任意选取，再根据选取已有的基础上选取权值最小且不在集合的点（取点）。<code>kruskal</code>算法则是每次以权值最小的边来选取，可以有多个集合（取边）。</li><li>稠密图用prim比kcuskal快的不止一下，稀疏图kruskal更快。</li></ol><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[MAXN]; <span class="comment">//并查集使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">&#125;mp[MAXN*MAXN]; <span class="comment">//储存边的信息，包括起点/终点/权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> <span class="comment">//排序函数，边按照权值从小到大排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val &lt; y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findFather</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//并查集寻找祖先</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> vis[x] = <span class="built_in">findFather</span>(vis[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>; <span class="comment">//cnt:计算加入的边数</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span> ,<span class="built_in">sizeof</span>(vis)); </span><br><span class="line">    <span class="built_in">sort</span>(mp, mp + len, cmp); <span class="comment">//因为kruskal是靠从边的最小依次查找的，所以直接排序方便查找</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findFather</span>(mp[i].a);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findFather</span>(mp[i].b);</span><br><span class="line">        <span class="keyword">if</span>(x != y) <span class="comment">//如果两个点所属的集合不同就和并</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[x] = y;</span><br><span class="line">            ans += mp[i].val;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt != n - <span class="number">1</span>) <span class="comment">//图不连通</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m, k;</span><br><span class="line">    <span class="type">char</span> c1, c2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; c1 &gt;&gt; m;</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; c2 &gt;&gt; k;</span><br><span class="line">                mp[len].a = c1-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>;</span><br><span class="line">                mp[len].b = c2-<span class="string">&#x27;A&#x27;</span><span class="number">+1</span>;</span><br><span class="line">                mp[len].val = k;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">kruskal</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="POJ1751—Highways"><a href="#POJ1751—Highways" class="headerlink" title="POJ1751—Highways"></a><a href="http://poj.org/problem?id=1751">POJ1751—Highways</a></h1><p><img src="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/2.png" alt></p><p>参考：</p><p><a href="https://blog.csdn.net/mengxiang000000/article/details/51338700">POJ 1751 Highways【最小生成树+输出路径】 - mengxiang000000 - CSDN博客</a></p><p>题意：给你n个村庄的坐标x，y，建立高速公路，并且已经给你了m条已经建好公路的村庄，让你输出还要建立的公路，并且输出该公路的两端的村庄编号，输出可以任意顺序；</p><p>此题就是求最小生成树+路径输出就行了，但是我们要处理已经联通了的村庄。怎么处理呢？</p><p>我们假设不相连的节点的权值为无穷大，</p><p>如果我们直接把两个已经联通的点的值更新为无穷大的话，明显不行</p><p><img src="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/3.png" alt></p><p>如上图，红色部分即已经联通了，如果我们直接把这2条路径更新为无穷大，就会变为不联通的情况，详细可看去掉红色部分的图。</p><p>我们可以将红色部分的值变为0，然后如果判断到了权值为0，那么就不用输出路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Problem: 1751User: heigua</span></span><br><span class="line"><span class="comment">Memory: 4160KTime: 125MS</span></span><br><span class="line"><span class="comment">Language: C++Result: Accepted</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">int</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN], ans[MAXN];</span><br><span class="line"><span class="type">int</span> path[MAXN]; <span class="comment">//记录前驱，用于输出路径</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">//顶点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Dist</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1.0</span>*(a.x-b.x)*(a.x-b.x)<span class="number">+1.0</span>*(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        path[i] = <span class="number">1</span>;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        ans[i] = mp[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> MIN = INF, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; ans[j] &lt; MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                MIN = ans[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(MIN != INF &amp;&amp; MIN != <span class="number">0</span>) <span class="comment">//判断为0</span></span><br><span class="line">            cout &lt;&lt; path[pos] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(MIN == INF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vis[pos] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[k] &amp;&amp; mp[pos][k] &lt; ans[k])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[k] = mp[pos][k];</span><br><span class="line">                path[k] = pos;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mp, INF, <span class="built_in">sizeof</span>(mp));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mp[i][j] = mp[j][i] = <span class="built_in">Dist</span>(p[i], p[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        mp[a][b] = mp[b][a] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">prime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
            <tag> prim </tag>
            
            <tag> kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论之最短路</title>
      <link href="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>Floyd，Dijkstra， Spfa</p><span id="more"></span><ul><li>Dijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)</li><li>BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)</li><li><p>SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，SPFA的最坏情况应该是O(VE).</p></li><li><p>Floyd：每对节点之间的最短路径</p></li></ul><p>（E为边个数，V为顶点个数）</p><hr><p><img src="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF/duibi.png" alt></p><p>其中N表示点数，M表示边数</p><p>Floyd 算法虽然总体上时间复杂度较高，但可以处理带负权边的图（但不能有负权回路），并且均摊到每一点对上，在所有的算法中还是属于比较优秀的算法。另外，floyd算法较小的编码复杂度也是一大优势，所以，如果要求的是所有点对间的最短路径，或者如果数据范围较小，则floyd算法比较合适。</p><p>Dijkstra算法最大的弊端就是他无法处理带有负权边以及负权回路的图，但是Dijkstra算法具有良好的可扩展性，扩展后可以适应很多问题。另外用堆优化的Dijkstra算法的时间复杂度可以达到O（M log N）。当边有负权，甚至存在负权回路时，需要使用Bellman-ford 算法或者队列优化的Bellman-ford算法，因此我们选择最短路径法时，根据实际的需求和每一种算法的特性，选择合适的算法来使用。</p><p>参考：<a href="https://blog.csdn.net/yuewenyao/article/details/81023035">https://blog.csdn.net/yuewenyao/article/details/81023035</a></p><hr><h1 id="Floyd-多源最短路"><a href="#Floyd-多源最短路" class="headerlink" title="Floyd(多源最短路)"></a>Floyd(多源最短路)</h1><p>Floyd算法用于求每一对顶点之间的最短路径，3个for循环就可以。时间复杂度O(v^3) 。v为图顶点个数</p><p>模板题：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">HDU2544-最短路</a></p><p><img src="/2019/02/19/%E5%9B%BE%E8%AE%BA%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF/floyd.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-02-20 01:02:20</span></span><br><span class="line"><span class="comment">62MS</span></span><br><span class="line"><span class="comment">1844K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n, m, e1, e2, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[j][i] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; v;</span><br><span class="line">            dp[e1][e2] = dp[e2][e1] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">floyd</span>();</span><br><span class="line">        cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dijkstra-单源最短路"><a href="#Dijkstra-单源最短路" class="headerlink" title="Dijkstra(单源最短路)"></a>Dijkstra(单源最短路)</h1><p>不采用最小优先队列，时间复杂度是O(v^2)，v为图顶点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-02-20 02:53:21</span></span><br><span class="line"><span class="comment">46MS</span></span><br><span class="line"><span class="comment">1848K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, e1, e2, v, MIN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        dis[i] = dp[beg][i];</span><br><span class="line">    &#125;</span><br><span class="line">    vis[beg] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        MIN = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//寻找开始点到其他点最小值及位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; MIN &gt; dis[j])</span><br><span class="line">            &#123;</span><br><span class="line">                MIN = dis[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//三点合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; dis[k] + dp[k][j] &lt; dis[j])</span><br><span class="line">                dis[j] = dis[k] + dp[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[j][i] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; v;</span><br><span class="line">            dp[e1][e2] = dp[e2][e1] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>(<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h1><p>邻接表，队列优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-02-21 00:59:10</span></span><br><span class="line"><span class="comment">46MS</span></span><br><span class="line"><span class="comment">1980K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0X3F3F3F3F</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, next, cost;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, e1, e2, v, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[len].to = to;</span><br><span class="line">    edge[len].cost = cost;</span><br><span class="line">    edge[len].next = head[from];</span><br><span class="line">    head[from] = len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[beg] = <span class="number">0</span>;</span><br><span class="line">    vis[beg] = <span class="number">1</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(beg);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">-1</span>; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = edge[i].to;</span><br><span class="line">            <span class="type">int</span> c = edge[i].cost;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + c)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + c;</span><br><span class="line">                <span class="keyword">if</span>(vis[v] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span> , <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(dis, INF, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; v;</span><br><span class="line">            <span class="built_in">add</span>(e1, e2, v);</span><br><span class="line">            <span class="built_in">add</span>(e2, e1, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(dis[n] == INF)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; dis[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> dijkstra </tag>
            
            <tag> floyd </tag>
            
            <tag> spfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配上模拟的vector</title>
      <link href="/2019/02/17/%E9%85%8D%E4%B8%8A%E6%A8%A1%E6%8B%9F%E7%9A%84vector/"/>
      <url>/2019/02/17/%E9%85%8D%E4%B8%8A%E6%A8%A1%E6%8B%9F%E7%9A%84vector/</url>
      
        <content type="html"><![CDATA[<p>天梯赛练习L1-049 天梯赛座位分配</p><span id="more"></span><h1 id="L1-049-天梯赛座位分配"><a href="#L1-049-天梯赛座位分配" class="headerlink" title="L1-049 天梯赛座位分配"></a><a href="https://pintia.cn/problem-sets/994805046380707840/problems/type/7">L1-049 天梯赛座位分配</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>题目描述</strong></p><p>天梯赛每年有大量参赛队员，要保证同一所学校的所有队员都不能相邻，分配座位就成为一件比较麻烦的事情。为此我们制定如下策略：假设某赛场有 N 所学校参赛，第 i 所学校有 M[i] 支队伍，每队 10 位参赛选手。令每校选手排成一列纵队，第 i+1 队的选手排在第 i 队选手之后。从第 1 所学校开始，各校的第 1 位队员顺次入座，然后是各校的第 2 位队员…… 以此类推。如果最后只剩下 1 所学校的队伍还没有分配座位，则需要安排他们的队员隔位就坐。本题就要求你编写程序，自动为各校生成队员的座位号，从 1 开始编号。</p><p><strong>输入格式</strong></p><p>输入在一行中给出参赛的高校数 N （不超过100的正整数）；第二行给出 N 个不超过10的正整数，其中第 i 个数对应第 i 所高校的参赛队伍数，数字间以空格分隔。</p><p><strong>输出格式</strong></p><p>从第 1 所高校的第 1 支队伍开始，顺次输出队员的座位号。每队占一行，座位号间以 1 个空格分隔，行首尾不得有多余空格。另外，每所高校的第一行按“#X”输出该校的编号X，从 1 开始。</p><p><strong>样例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">1 4 7 10 13 16 19 22 25 28</span><br><span class="line">31 34 37 40 43 46 49 52 55 58</span><br><span class="line">61 63 65 67 69 71 73 75 77 79</span><br><span class="line">#2</span><br><span class="line">2 5 8 11 14 17 20 23 26 29</span><br><span class="line">32 35 38 41 44 47 50 53 56 59</span><br><span class="line">62 64 66 68 70 72 74 76 78 80</span><br><span class="line">82 84 86 88 90 92 94 96 98 100</span><br><span class="line">#3</span><br><span class="line">3 6 9 12 15 18 21 24 27 30</span><br><span class="line">33 36 39 42 45 48 51 54 57 60</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>让每个学校的学生排成一排，为每一个座位安排学生。<br>每把椅子依次从每个学校面前走过，如果这个学校还有学生没被安排座位，那就安排，安排方案为：<br>如果此座位前一个不是本校学生，那么抓一个此校学生做在这把椅子上，并标记这把椅子被此校学生坐了，<br>如果此座位前一个是本校学生，那此位置空着，抓一个此校学生做在这把椅子的后一把上，并标记这把椅子的后一把被此校学生坐了。</p><p>参考：<a href="https://www.liuchuo.net/archives/5082">https://www.liuchuo.net/archives/5082</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019/2/17 17:20:008 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E4</span>;</span><br><span class="line"><span class="type">int</span> sc[MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">//一个学校的队伍里面的人数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vec[MAXN]; <span class="comment">//第i个座位上做的是哪个学校的学生。</span></span><br><span class="line"><span class="type">int</span> vis[MAXN] = &#123;<span class="number">0</span>&#125;; <span class="comment">//这个座位有没有坐过了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; sc[i];</span><br><span class="line">        sc[i] *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>, num = <span class="number">0</span>; <span class="comment">//index:学校的序号，num:当前已经排完的学校的数量</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>() &lt; sc[i]) <span class="comment">//这个学校的队伍还没有排完</span></span><br><span class="line">            &#123;</span><br><span class="line">                vec[i].<span class="built_in">push_back</span>(index); <span class="comment">//放到专属的vector里面</span></span><br><span class="line">                <span class="keyword">if</span>(num == n<span class="number">-1</span>) <span class="comment">//只有一个队伍</span></span><br><span class="line">                    index += <span class="number">2</span>; <span class="comment">//得隔空排</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(vec[i].<span class="built_in">size</span>() == sc[i] &amp;&amp; vis[i] == <span class="number">0</span>) <span class="comment">//已经排完</span></span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                num++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;#&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j != <span class="number">0</span> &amp;&amp; (j<span class="number">+1</span>) % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                cout &lt;&lt; vec[i][j] &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; vec[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> STL </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟除法</title>
      <link href="/2019/02/17/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/"/>
      <url>/2019/02/17/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>天梯赛练习L1-046. 整除光棍</p><span id="more"></span><h1 id="L1-046-整除光棍"><a href="#L1-046-整除光棍" class="headerlink" title="L1-046 整除光棍"></a><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805084284633088">L1-046 整除光棍</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制: 400 ms</span><br><span class="line">内存限制: 64 MB</span><br><span class="line">代码长度限制: 16 KB</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数<code>x</code>，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字<code>s</code>，表示<code>x</code>乘以<code>s</code>是一个光棍，第二个数字<code>n</code>是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。</p><p>提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除<code>x</code>为止。但难点在于，<code>s</code>可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。</p><p><strong>输入格式</strong></p><p>输入在一行中给出一个不以5结尾的正奇数x(&lt;1000)​。</p><p><strong>输出格式</strong></p><p>在一行中输出相应的最小的<code>s</code>和<code>n</code>，其间以1个空格分隔。</p><p><strong>样例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3584229390681 15</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>模拟除法应用</p><p>然后模拟除法的话</p><p><img src="/2019/02/17/%E6%A8%A1%E6%8B%9F%E9%99%A4%E6%B3%95/moni.png" alt></p><p>我们先构造出比x大的最小光棍数，然后判断能不能整除于x，不能的话就继续往这个光棍数后面加1.</p><p>流程：</p><ul><li>光棍数能整除于x<ul><li>输出答案</li></ul></li><li>不能整除<ul><li>先算出目前光棍数除以x的值</li><li>然后在后面加上1，然后继续循环判断</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019/2/17 14:29:184 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>, len = <span class="number">1</span>; <span class="comment">//num为光棍数，len为光棍数长度</span></span><br><span class="line">    <span class="keyword">while</span>(num &lt; n) <span class="comment">//先构造出比x大的最小光棍数</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = num*<span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num % n == <span class="number">0</span>) <span class="comment">//能整除于x，就是答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num / n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; len;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//不能的话就进位</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; num / n; </span><br><span class="line">            num %= n; <span class="comment">//取得余数</span></span><br><span class="line">            num = num*<span class="number">10</span> + <span class="number">1</span>; <span class="comment">//往余数后面+1</span></span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch安装配置笔记</title>
      <link href="/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>整理一下，方便以后安装Arch Linux</p><span id="more"></span><p>刻录u盘略过。。。</p><h1 id="检测是否是UEFI启动"><a href="#检测是否是UEFI启动" class="headerlink" title="检测是否是UEFI启动"></a>检测是否是UEFI启动</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/firmware/efi/efivars</span><br></pre></td></tr></table></figure><ul><li>文件不存在说明不是以UEFI启动</li></ul><h1 id="连接WIFI"><a href="#连接WIFI" class="headerlink" title="连接WIFI"></a>连接WIFI</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wifi-menu</span><br></pre></td></tr></table></figure><p>然后可以检测连接是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 www.baidu.com</span><br></pre></td></tr></table></figure><h1 id="更新系统时间"><a href="#更新系统时间" class="headerlink" title="更新系统时间"></a>更新系统时间</h1><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp true</span><br></pre></td></tr></table></figure><h2 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure><p>原因</p><ul><li><p>系统时间不对可能造成<code>ssl</code>连接失败导致安装出错</p></li><li><p>验证软件包签名，确定公钥过期没过期</p></li><li><code>https</code>证书，也要验过期时间</li></ul><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="检测分区情况"><a href="#检测分区情况" class="headerlink" title="检测分区情况"></a>检测分区情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h2 id="分区-1"><a href="#分区-1" class="headerlink" title="分区"></a>分区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sdx</span><br></pre></td></tr></table></figure><p><img src="/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/fenqu.png" alt></p><h2 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h2><ul><li>格式化成<code>ext4</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sdX2</span><br></pre></td></tr></table></figure><ul><li>格式<code>swap</code>分区并激活</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sdX3</span><br><span class="line">swapon /dev/sdX3</span><br></pre></td></tr></table></figure><ul><li>格式化<code>efi</code>分区</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs -t vfat /dev/sdX4</span><br></pre></td></tr></table></figure><h2 id="挂载分区"><a href="#挂载分区" class="headerlink" title="挂载分区"></a>挂载分区</h2><ul><li>首先将根分区 <a href="https://wiki.archlinux.org/index.php/Mount">挂载</a> 到 <code>/mnt</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdX2 /mnt</span><br></pre></td></tr></table></figure><p>（多个分区的情况下可选）</p><ul><li>挂载<code>home</code>分区</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mnt/home</span><br><span class="line">mount /dev/sdx3 /mnt/home</span><br></pre></td></tr></table></figure><ul><li>挂载<code>boot</code>分区(uefi)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/boot/efi</span><br><span class="line">mount /dev/sdx4 /mnt/boot/efi</span><br></pre></td></tr></table></figure><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="选择镜像源"><a href="#选择镜像源" class="headerlink" title="选择镜像源"></a>选择镜像源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>在列表中越前的镜像在下载软件包时有越高的优先权，将清华源复制到第一行</p><h2 id="安装基本系统"><a href="#安装基本系统" class="headerlink" title="安装基本系统"></a>安装基本系统</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel</span><br></pre></td></tr></table></figure><h1 id="配置系统"><a href="#配置系统" class="headerlink" title="配置系统"></a>配置系统</h1><h2 id="Fstab"><a href="#Fstab" class="headerlink" title="Fstab"></a>Fstab</h2><p>用以下命令生成 <a href="https://wiki.archlinux.org/index.php/Fstab">fstab</a> 文件 (用 <code>-U</code> 或 <code>-L</code> 选项设置UUID 或卷标)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h2 id="Chroot"><a href="#Chroot" class="headerlink" title="Chroot"></a>Chroot</h2><p><a href="https://wiki.archlinux.org/index.php/Change_root">Change root</a> 到新安装的系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>设置时区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>硬件时间设置，默认为<code>UTC</code>时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hwclock --systohc </span><br></pre></td></tr></table></figure><h2 id="本地化"><a href="#本地化" class="headerlink" title="本地化"></a>本地化</h2><p><code>/etc/locale.gen</code> 是一个仅包含注释文档的文本文件。指定您需要的本地化类型，只需移除对应行前面的注释符号（<code>＃</code>）即可，建议选择带 <code>UTF-8</code> 的项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># nano /etc/locale.gen</span><br><span class="line">en_US.UTF-8 UTF-8</span><br><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_TW.UTF-8 UTF-8</span><br></pre></td></tr></table></figure><p>接着执行以生成 locale 讯息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locale-gen</span><br><span class="line">echo LANG=en_US.UTF-8 &gt; /etc/locale.conf</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>设置主机名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo cc &gt; /etc/hostname</span><br></pre></td></tr></table></figure><p>添加对应的信息到<code>host</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># nano /etc/hosts</span><br><span class="line">127.0.0.1localhost</span><br><span class="line">::1localhost</span><br><span class="line">127.0.1.1myhostname.localdomainmyhostname</span><br></pre></td></tr></table></figure><h2 id="Root密码"><a href="#Root密码" class="headerlink" title="Root密码"></a>Root密码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h2 id="安装引导"><a href="#安装引导" class="headerlink" title="安装引导"></a>安装引导</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#后面两个包多系统的情况下可以选装</span><br><span class="line">pacman -S grub efibootmgr ntfs-3g os-prober</span><br></pre></td></tr></table></figure><ul><li>非uefi</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=i386-pc /dev/sdx </span><br><span class="line">#/dev/sdx 是已经完成分区的磁盘，grub 将安装到它上面。</span><br></pre></td></tr></table></figure><ul><li>uefi</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=grub</span><br><span class="line"># 注意要挂载/boot/efi，见上面挂载boot分区那步</span><br></pre></td></tr></table></figure><p>生成主配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="安装微码"><a href="#安装微码" class="headerlink" title="安装微码"></a>安装微码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S amd-ucode</span><br></pre></td></tr></table></figure><h2 id="无线连接"><a href="#无线连接" class="headerlink" title="无线连接"></a>无线连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S iw wpa_supplicant dialog</span><br></pre></td></tr></table></figure><h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit #返回安装环境</span><br><span class="line">umount -R /mnt</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="配置新系统"><a href="#配置新系统" class="headerlink" title="配置新系统"></a>配置新系统</h1><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -G wheel cc</span><br><span class="line">passwd cc</span><br></pre></td></tr></table></figure><p>设置权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/sudoers</span><br><span class="line">在 root ALL=(ALL) ALL 下面添加</span><br><span class="line">用户名 ALL=(ALL) ALL</span><br><span class="line">为你刚才创建的用户 添加sudo权限</span><br></pre></td></tr></table></figure><h2 id="添加archcn源"><a href="#添加archcn源" class="headerlink" title="添加archcn源"></a>添加archcn源</h2><p>在 <code>/etc/pacman.conf</code> 文件末尾添加两行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>然后请安装 <code>archlinuxcn-keyring</code> 包以导入<code>GPG key</code>。</p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S git make cmake openssh gcc g++ gdb vim wget sshpass net-tools ntfs-3g</span><br></pre></td></tr></table></figure><h2 id="linux-lts内核"><a href="#linux-lts内核" class="headerlink" title="linux-lts内核"></a>linux-lts内核</h2><p>更换为lts内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S linux-lts</span><br></pre></td></tr></table></figure><p>卸载原内核</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -Q | grep linux</span></span><br><span class="line">archlinux-appstream-data 20190424-1</span><br><span class="line">archlinux-keyring 20190123-2</span><br><span class="line">archlinuxcn-keyring 20190422-1</span><br><span class="line">libutil-linux 2.33.2-1</span><br><span class="line">linux 5.0.10.arch1-1</span><br><span class="line">linux-api-headers 5.0.7-1</span><br><span class="line">linux-firmware 20190424.4b6cf2b-1</span><br><span class="line">linux-lts 4.19.37-1</span><br><span class="line">util-linux 2.33.2-1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -R linux</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> <span class="built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</span></span><br></pre></td></tr></table></figure><h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><p><img src="/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/3.png" alt></p><ol><li><p>安装<code>xorg</code></p><p><code>Xorg</code>是<code>Linux</code>下的一个著名的开源图形服务，我们的桌面环境需要<code>Xorg</code>的支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg-server xorg-xinit</span><br></pre></td></tr></table></figure></li><li><p>桌面环境</p><ul><li><p><code>xfce</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure></li><li><p><code>KDE(Plasma)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma kde-applications</span><br></pre></td></tr></table></figure><p>更多:<a href="https://wiki.archlinux.org/index.php/Desktop_environment_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">archwiki</a></p></li></ul></li><li><p>桌面管理器</p><p>安装好了桌面环境包以后，我们需要安装一个图形化的桌面管理器来帮助我们登录并且选择我们使用的桌面环境，这里我推荐使用<code>sddm</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S sddm</span><br></pre></td></tr></table></figure></li><li><p>开机自启<code>sddm</code>服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable sddm</span><br></pre></td></tr></table></figure></li></ol><h2 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h2><p>Arch拥有一个强大的用户库AUR即Arch User Repository，为我们提供了官方包之外的各种软件包，一些闭源的软件包也可以在上面找到，可以说AUR极大地丰富了软件包的种类与数量，并可以配合yay这样的工具为用户省下大量安装、更新软件包的时间。</p><p>yay实际上也是一个软件包，我们可以把它看成是对pacman的包装，它兼容pacman的所有操作，最大的不同是我们可以用它方便地安装与管理AUR中的包，下面的许多软件包都是在AUR库中的，也都是使用AUR来安装的。</p><p><strong>安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S yay</span><br></pre></td></tr></table></figure><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置zsh为默认shell</span></span><br><span class="line">sudo chsh -s /bin/zsh username</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装oh-my-zsh</span></span><br><span class="line">yay -S oh-my-zsh-git</span><br></pre></td></tr></table></figure><hr><p><strong>修改zsh提示为英文</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br><span class="line"></span><br><span class="line">LANGUAGE=&quot;en&quot;</span><br></pre></td></tr></table></figure><p><strong>插件</strong></p><ul><li>zsh-autosuggestions</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><ul><li><code>zsh-syntax-highlighting</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ul><li>配置<code>~/.zshrc</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( zsh-autosuggestions zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><hr><h2 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h2><ul><li>安装networkmanager</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S networkmanager</span><br></pre></td></tr></table></figure><ul><li>设置开机自启并启用</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable NetworkManager</span><br><span class="line">systemctl start NetworkManager</span><br></pre></td></tr></table></figure><ul><li><p>安装前端插件</p><ul><li><p>GTK3+前端小程序，工作在Xorg环境下，带有一个系统托盘。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S network-manager-applet</span><br></pre></td></tr></table></figure></li><li><p>kde可以只安装plasma-nm，然后通过 面板的选项 &gt; 添加部件 &gt; 网络 来把它添加到KDE的任务栏上。</p></li></ul></li></ul><h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p><strong>搜狗输入法</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S fcitx fcitx-im fcitx-sogoupinyin fcitx-configtool zenity</span><br></pre></td></tr></table></figure><p>装完以后需要修改<code>~/.xprofile</code>文件，在文件开头加入三行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br><span class="line">export GTK_IM_MODULE=&quot;fcitx&quot;</span><br><span class="line">export QT_IM_MODULE=&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><p>可以解决一些软件无法调出fcitx的问题。</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ol><li>安装字体</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S ttf-dejavu ttf-monaco noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra otf-fira-code</span><br></pre></td></tr></table></figure><ol><li><p>选择</p><ul><li>字体: <code>noto fonts cjk</code>,</li><li>等宽字体: <code>Fira Code</code>或者<code>monaco</code></li></ul></li><li><p>配置文件</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.config/fontconfig/fonts.conf</span></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="line">&lt;!DOCTYPE fontconfig SYSTEM &#x27;fonts.dtd&#x27;&gt;</span><br><span class="line">&lt;fontconfig&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;serif&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Serif&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Serif CJK SC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Serif CJK TC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Serif CJK JP&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Serif CJK KR&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;sans-serif&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK SC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK TC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK JP&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK KR&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;sans-sans&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK SC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK TC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK JP&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK KR&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;tahoma&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK SC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;monospace&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Fira Code&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans CJK SC&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Emoji&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;Noto Sans Mono&lt;/family&gt;</span><br><span class="line">            &lt;family&gt;DejaVu Sans Mono&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;emoji&lt;/family&gt;</span><br><span class="line">        &lt;default&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/default&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;Apple Color Emoji&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">        &lt;default&gt;</span><br><span class="line">            &lt;family&gt;sans-serif&lt;/family&gt;</span><br><span class="line">        &lt;/default&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;alias&gt;</span><br><span class="line">        &lt;family&gt;Segoe UI Emoji&lt;/family&gt;</span><br><span class="line">        &lt;prefer&gt;</span><br><span class="line">            &lt;family&gt;Noto Color Emoji&lt;/family&gt;</span><br><span class="line">        &lt;/prefer&gt;</span><br><span class="line">        &lt;default&gt;</span><br><span class="line">            &lt;family&gt;sans-serif&lt;/family&gt;</span><br><span class="line">        &lt;/default&gt;</span><br><span class="line">    &lt;/alias&gt;</span><br><span class="line">    &lt;match target=&quot;font&quot;&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;antialias&quot;&gt;</span><br><span class="line">            &lt;bool&gt;true&lt;/bool&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;rgba&quot;&gt;</span><br><span class="line">            &lt;const&gt;rgb&lt;/const&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot;&gt;</span><br><span class="line">            &lt;bool&gt;false&lt;/bool&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot;&gt;</span><br><span class="line">            &lt;const&gt;hintnone&lt;/const&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">    &lt;/match&gt;</span><br><span class="line">    &lt;dir&gt;~/.fonts&lt;/dir&gt;</span><br><span class="line">    &lt;match target=&quot;font&quot;&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot;&gt;</span><br><span class="line">            &lt;bool&gt;false&lt;/bool&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">    &lt;/match&gt;</span><br><span class="line">    &lt;match target=&quot;font&quot;&gt;</span><br><span class="line">        &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot;&gt;</span><br><span class="line">            &lt;const&gt;hintnone&lt;/const&gt;</span><br><span class="line">        &lt;/edit&gt;</span><br><span class="line">    &lt;/match&gt;</span><br><span class="line">&lt;/fontconfig&gt;</span><br></pre></td></tr></table></figure><p>参考:</p><p><a href="https://wiki.archlinux.org/index.php/Localization/Simplified_Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">Localization/Simplified Chinese</a>)</p><p><a href="https://wiki.archlinux.org/index.php/Font_Configuration/Chinese_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87">Font Configuration/Chinese</a>)</p><p><a href="https://blog.firerain.me/article/14">Arch Linux字体渲染(fontconfig)-fonts.conf参考</a></p><h2 id="synaps"><a href="#synaps" class="headerlink" title="synaps"></a>synaps</h2><p>Synapse是一个快速的软件启动器，可以方便地查找安装的软件，设置快捷键使用再也不用找软件入口了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S synapse</span><br></pre></td></tr></table></figure><h2 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h2><ul><li>删除自带的<code>klipper</code>（kde）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /usr/share/plasma/plasmoids/org.kde.plasma.clipboard</span><br></pre></td></tr></table></figure><ul><li>安装<code>copyq</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S copyq</span><br></pre></td></tr></table></figure><h2 id="xournal"><a href="#xournal" class="headerlink" title="xournal"></a>xournal</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S xournal</span><br></pre></td></tr></table></figure><h2 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S virtualbox virtualbox-ext-vnc virtualbox-guest-iso virtualbox-host-modules-arch</span><br></pre></td></tr></table></figure><p>再去官网下载Oracle VM VirtualBox Extension Pack ，在设置中导入使用。安装windows的过程不在这里讲解，记得安装之后在windows内安装扩展客户端软件即可。</p><h2 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S timeshifts</span><br><span class="line">systemctl enable --now cronie.service</span><br></pre></td></tr></table></figure><h2 id="声卡"><a href="#声卡" class="headerlink" title="声卡"></a>声卡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pacman -S alsa-utils pulseaudio pulseaudio-bluetooth</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">前端</span></span><br><span class="line">pacman -S pavucontrol</span><br></pre></td></tr></table></figure><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S bluez bluez-utils</span><br><span class="line">sudo systemctl start bluetooth.service</span><br><span class="line">sudo systemctl enable bluetooth.service</span><br></pre></td></tr></table></figure><p>图形界面使用<code>blueman</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S blueman</span><br></pre></td></tr></table></figure><p>为了消除登录时蓝牙请求权限，创建<code>/etc/polkit-1/rules.d/81-blueman.rules</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">polkit.addRule(function(action, subject) &#123;</span><br><span class="line">  if (action.id == &quot;org.blueman.rfkill.setstate&quot; &amp;&amp; subject.local &amp;&amp; subject.active &amp;&amp; subject.isInGroup(&quot;wheel&quot;)) &#123;</span><br><span class="line">      return polkit.Result.YES;</span><br><span class="line">  &#125;</span><br><span class="line">  if (action.id == &quot;org.blueman.network.setup&quot; &amp;&amp; subject.local &amp;&amp; subject.active &amp;&amp; subject.isInGroup(&quot;wheel&quot;)) &#123;</span><br><span class="line">      return polkit.Result.YES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="文本工具"><a href="#文本工具" class="headerlink" title="文本工具"></a>文本工具</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S foxitreader typora visual-studio-code-bin mousepad</span><br></pre></td></tr></table></figure><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S codeblocks</span><br></pre></td></tr></table></figure><h2 id="互联网工具"><a href="#互联网工具" class="headerlink" title="互联网工具"></a>互联网工具</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S firefox chromium filezilla teamviewer</span><br></pre></td></tr></table></figure><p><strong>teamviewer not ready</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start teamviewerd</span><br><span class="line">sudo systemctl enable teamviewerd</span><br></pre></td></tr></table></figure><h2 id="图形软件"><a href="#图形软件" class="headerlink" title="图形软件"></a>图形软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S flameshot nomacs</span><br></pre></td></tr></table></figure><h2 id="jdk8"><a href="#jdk8" class="headerlink" title="jdk8"></a>jdk8</h2><ol><li><p>到<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a>下载jdk8</p></li><li><p>解压并且配置环境变量</p></li></ol><h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p><a href="https://wiki.archlinux.org/index.php/Xorg">Xorg - ArchWiki</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xf86-video-amdgpu mesa</span><br></pre></td></tr></table></figure><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p><img src="/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/1.png" alt></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主题Materia KDE</span></span><br><span class="line">pacman -S materia-kde kvantum-theme-materia</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">图标papirus</span></span><br><span class="line">pacman -S papirus-icon-theme</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标</span></span><br><span class="line">yay -S capitaine-cursors</span><br></pre></td></tr></table></figure><p>对应的介绍</p><ul><li><p><a href="https://github.com/PapirusDevelopmentTeam/materia-kde">Materia KDE</a></p></li><li><p><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme">papirus</a></p></li><li><a href="https://github.com/keeferrourke/capitaine-cursors">mac—capitaine-cursors</a></li></ul><h2 id="KDE系部分软件"><a href="#KDE系部分软件" class="headerlink" title="KDE系部分软件"></a>KDE系部分软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S dolphin dolphin-plugins konsole ark</span><br></pre></td></tr></table></figure><ul><li>Simple System Monitor</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载https://github.com/dhabyx/plasma-simpleMonitor/releases</span></span><br><span class="line">plasmapkg2 -i plasma-simpleMonitor-0.6.plasmoid</span><br></pre></td></tr></table></figure><ul><li>桌面添加网络监视器</li></ul><p><img src="/2019/02/15/Arch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/4.png" alt></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ul><li><code>systemd-backlight@backlight:acpi_video0.service failed</code></li></ul><p>添加backlight文件夹下的文件名到grub文件,然后禁止上面的service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /sys/class/backlight/</span></span><br><span class="line">radeon_bl0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> vim /etc/default/grub</span></span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet acpi_backlight=radeon_bl0&quot;</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> grub-mkconfig -o /boot/grub/grub.cfg</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> systemctl mask systemd-backlight@backlight:acpi_video0.service</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -S docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure><h2 id="划词翻译"><a href="#划词翻译" class="headerlink" title="划词翻译"></a>划词翻译</h2><p>参考：<a href="https://blog.einverne.info/post/2018/08/goldendict.html">https://blog.einverne.info/post/2018/08/goldendict.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S goldendict</span><br></pre></td></tr></table></figure><ul><li>有道的源</li></ul><p><code>http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</code></p><ul><li>Chinese Wikipedia</li></ul><p><code>https://zh.wikipedia.org/w</code></p><ul><li>Chinese Wiktionary</li></ul><p><code>https://zh.wiktionary.org/w</code></p><h2 id="16进制查看器"><a href="#16进制查看器" class="headerlink" title="16进制查看器"></a>16进制查看器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacmam -S ghex   #查看功能</span><br><span class="line">pacman -S okteta #修改功能</span><br></pre></td></tr></table></figure><h2 id="离线文档管理"><a href="#离线文档管理" class="headerlink" title="离线文档管理"></a>离线文档管理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zeal</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第三方源：https://zealusercontributions.now.sh/</span></span><br></pre></td></tr></table></figure><h2 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S python-pip</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制的应用</title>
      <link href="/2019/02/15/%E8%BF%9B%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/02/15/%E8%BF%9B%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="天梯赛练习L1-050-倒数第N个字符串"><a href="#天梯赛练习L1-050-倒数第N个字符串" class="headerlink" title="天梯赛练习L1-050 倒数第N个字符串"></a><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805080346181632">天梯赛练习L1-050 倒数第N个字符串</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制: 400 ms</span><br><span class="line">内存限制: 64 MB</span><br><span class="line">代码长度限制: 16 KB</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为<code>&#123; aaa, aab, aac, ..., aaz, aba, abb, ..., abz, ..., zzz &#125;</code>。这个序列的倒数第27个字符串就是<code>zyz</code>。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。</p><p><strong>输入</strong></p><p>输入在一行中给出两个正整数 $L(2 ≤ L ≤ 6)$和$N (N≤10^5)$。</p><p><strong>输出</strong></p><p>在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 7417</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pat</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>Ｌ个字符就是Ｌ位的26进制数，告诉我们n是倒数的位置，那么我们求一下正着数的位置，然后将求得的10进制数字转化为26进制（每位26进制用小写的26个字符表示），这样求得的字符串就是外面需要的字符串。</p><p>如何求正数呢？</p><p>用总数减去倒数的就是正数了，因a到z有26步，所以Ｌ位共有$26^L$个</p><p>参考：</p><p>[<a href="https://www.cnblogs.com/yinbiao/p/8685712.html(https://www.cnblogs.com/yinbiao/p/8685712.html">https://www.cnblogs.com/yinbiao/p/8685712.html(https://www.cnblogs.com/yinbiao/p/8685712.html</a>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间2019/2/16 00:55:43</span></span><br><span class="line"><span class="comment">耗时　4 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">pow</span>(<span class="number">26</span>, n) - m;</span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        s += num%<span class="number">26</span>+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        num /= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>() &lt; n) <span class="comment">////位数不够时，补充到L位为止</span></span><br><span class="line">        s += <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="“a”-N"><a href="#“a”-N" class="headerlink" title=" “a”+N"></a><a href="http://fzcoj.hustoj.com/problem.php?id=4491"> “a”+N</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间限制: 2 Sec  </span><br><span class="line">内存限制: 128 MB</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>在C语言中，“a”加上一个数的结果是一个整数。<br>例如：“a”+6=97+6=103<br>但是老陈觉得这样很无聊，所以他改变了这个加的定义：加N的结果是当前字符串按字典序的顺序之后第N个字符串。<br>例如：”az”+4的结果就是”az”之后第四个字符串。(“az”，”ba”，”bb”，”bc”，”bd”)，所以”az”+4=”bd”。<br>现在请你编写程序实现它。</p><p><strong>输入</strong></p><p>第一行包含一个正整数T，代表数据组数。(1≤T≤1000)<br>接下来T行，每行一个测试数据。每个测试数据包含一个字符串s和一个正整数X。(字符串长度不大于10^4且保证非空，1 ≤ X ≤ 10^13)</p><p><strong>输出</strong></p><p>对于每组测试数据，输出s+X的结果。 </p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">a 10</span><br><span class="line">abcd 5</span><br><span class="line">zzz 3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k</span><br><span class="line">abci</span><br><span class="line">aaac</span><br></pre></td></tr></table></figure><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>刚开始一看就知道是26进制题目,所以下意识得想先把字符串转成十进制,然后再相加,最后再转成26进制.emmm这个很明显是错误的,因为字符串长度比较长,一转十进制的话,早就爆范围了.那怎么解决呢?</p><p>能不能不转换直接相加呢,这样就可以避免了这个问题?直接相加的话我们考虑下每个字母需要变成什么,那么就需要知道每个位对应要相加的数,同时要处理下进位,所以最终我们可以像处理大数加法那样,去处理进位.</p><p>首先我们先把数加到第一位上面,然后判断有没有进位,如果有那么就加到下一位,同时第一位也要减去对应的数,如此循环直到不需要进位.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Time:436 ms</span></span><br><span class="line"><span class="comment">Memory:1088 kb</span></span><br><span class="line"><span class="comment">2019-04-08 22:48:52 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll arr[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %lld&quot;</span>, s, &amp;n);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="comment">//将字母变成数字存储,同时翻转容易存储</span></span><br><span class="line">            arr[i] = s[len<span class="number">-1</span>-i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        ll next = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        arr[<span class="number">0</span>] += n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            next = arr[i] / <span class="number">26</span>; <span class="comment">//需要进的位</span></span><br><span class="line">            arr[i] %= <span class="number">26</span>; <span class="comment">//减去已经进位的</span></span><br><span class="line">            <span class="keyword">if</span>(next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == len<span class="number">-1</span>) <span class="comment">//处理完成但是还有进位,就加在首部</span></span><br><span class="line">                &#123;</span><br><span class="line">                    arr[i<span class="number">+1</span>] = next<span class="number">-1</span>;</span><br><span class="line">                    len++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    arr[i<span class="number">+1</span>] += next; <span class="comment">//后一位加上进位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="string">&#x27;a&#x27;</span> + arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rinne Loves Math</title>
      <link href="/2019/02/12/Rinne-Loves-Math/"/>
      <url>/2019/02/12/Rinne-Loves-Math/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/370/J">牛客70j-Rinne Loves Math</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ 1秒，其他语言2秒</span><br><span class="line">空间限制：C/C++ 262144K，其他语言524288K</span><br><span class="line">64bit IO Format: %lld</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>给了你形如$\sqrt{n}$的式子中的 n，让你输出化简后的结果 $a\sqrt{b}$ 中的 a,b，如果这样的式子在<strong>实数</strong>范围内没有意义，输出 -1。</p><p><strong>输入描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数 T,表示数据组数。</span><br><span class="line">接下来 T 行，每行一个整数 x 表示根号下的数。</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一共 T 行，每行两个数表示化简后的答案 a,b</span><br></pre></td></tr></table></figure><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">20</span><br><span class="line">25</span><br><span class="line">-2005</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 5</span><br><span class="line">5 1</span><br><span class="line">-1</span><br><span class="line">1 11</span><br></pre></td></tr></table></figure><p><em>说明</em></p><p>20=4×5<br>25=5×5<br>实数范围内$ \sqrt{n} $中 n 小于 0 没有意义。<br>11 是个质数。</p><p><strong>备注</strong></p><p>$T≤100, 0&lt;|x|≤10^7$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>比较水的模拟题，但是比赛时想错了，想得有点麻烦了，以为只除4和9就行了，emmm，不过还好最后做出来了。既然是化简，那么肯定是平方，所以逆序遍历$x\in[0,sqrt(n)]$，如果有n%(x*x)==0就代表可以化简出x，为什么是逆序，因为要求最简，所以可能得除以最大（之前就是没想到这个emmm）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-02-12 10:21:33 语言：C++14 代码长度：520 运行时间： 20 ms 占用内存：632K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t, n;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">sqrt</span>(n); i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n % (i*i) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n/i/i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区间或和</title>
      <link href="/2019/02/06/%E5%8C%BA%E9%97%B4%E6%88%96%E5%92%8C/"/>
      <url>/2019/02/06/%E5%8C%BA%E9%97%B4%E6%88%96%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/332/G">牛客332G-区间或和</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ 1秒，其他语言2秒</span><br><span class="line">空间限制：C/C++ 262144K，其他语言524288K</span><br><span class="line">64bit IO Format: %lld</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>求$a|(a+1)|(a+2)|…|(b-1)|b$。 </p><p>其中|表示<a href="https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E6%88%96">按位或</a></p><p><strong>输出描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每组输入，输出一个数a|(a+1)|(a+2)|...|(b-1)|b。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">99 109</span><br><span class="line">68 77</span><br><span class="line">55 66</span><br><span class="line">34 43</span><br><span class="line">1111234 1114321</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">79</span><br><span class="line">127</span><br><span class="line">47</span><br><span class="line">1179647</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>输入不超过10000行，$0≤a,b≤10^{18}，a≤b$</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>如果 a=b ，那么答案 =a ；</p><p>否则 a≠b ，</p><p>考虑a和b的二进制表示从高到低第一个不同的位i，</p><p>必定b的第i位=1，a的第i位=0。</p><p>那么可以断定，对于答案的二进制表示，</p><p>(1) 比第i位更高的那些位一定跟a相同。</p><p>(2) 第i位及比第i位更低的那些位一定为1。</p><p>(1)是显然的，(2)是由于把a中比第i位更低的那些位都置为1得到的数一定在区间[a,b]中</p><p>参考：</p><p><a href="https://ac.nowcoder.com/discuss/153349?type=101&amp;order=0&amp;pos=8&amp;page=1">https://ac.nowcoder.com/discuss/153349?type=101&amp;order=0&amp;pos=8&amp;page=1</a></p><p><strong><em>举个例子</em></strong></p><ol><li><p>[2300，2323]：</p><p>2300： <strong>100</strong>011111100</p><p>2323:    <strong>100</strong>100010011</p><p>总的结果就是2559：  <strong>100</strong>111111111 </p></li><li><p>[787，2323]：</p><p>787：      001100010011</p><p>2323:     100100010011</p><p>而这个 我们注意到前面段是没有相同，那也就是可变化范围就是那整段了。</p><p>所以答案就是：4095：111111111111</p></li></ol><p>参考：</p><p><a href="http://keyblog.cn/article-67.html">http://keyblog.cn/article-67.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-02-09 18:48:22 语言：C++14 代码长度：797 运行时间： 29 ms 占用内存：868K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll MOD = <span class="number">1e9</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0xffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ll a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        ll cnt = <span class="number">0</span>; <span class="comment">//统计从高位数起，a,b有多少位不一样</span></span><br><span class="line">        <span class="comment">//统计不同的个数，当a，b相同时退出循环，此时a，b的值都为与b相同的部分</span></span><br><span class="line">        <span class="keyword">while</span>(a != b)</span><br><span class="line">            cnt++, a &gt;&gt;= <span class="number">1</span>, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将b左移cnt位，同时每左移一次，再b右边加个1(二进制)，这样就变成，相同部分相同，其他部分都是1</span></span><br><span class="line">        <span class="keyword">while</span>(cnt--)</span><br><span class="line">                b = (b &lt;&lt; <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出题</title>
      <link href="/2019/02/05/%E5%87%BA%E9%A2%98/"/>
      <url>/2019/02/05/%E5%87%BA%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/332/A">牛客323A-出题</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ 1秒，其他语言2秒</span><br><span class="line">空间限制：C/C++ 32768K，其他语言65536K</span><br><span class="line">64bit IO Format: %lld</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>小B准备出模拟赛。<br> 她把题目按难度分为四等，分值分别为6,7,8,9。<br> 已知小B共出了m道题，共n分。<br> 求小B最少出了多少道6分题。    </p><p><strong>输入描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个正整数n,m</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一个数，表示答案。</span><br><span class="line">若无解，输出&quot;jgzjgzjgz&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>示例3</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jgzjgzjgz</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$n,m\leq10^{12}$</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然，有解的充要条件为 $6m≤n≤9m$ 。</p><p>若有解：</p><p>设有 $x(0≤x≤m)$ 道6分题，则剩下的$m-x$题共$n-6x$分，</p><p>则剩下的题有解的充要条件为$7(m−x)≤n−6x≤9(m−x)$ ，</p><p>解得 $7m−n≤x≤(9m−n)/3$。</p><p>因此答案为$max(0,7m-n)$。</p><p>参考：</p><p><a href="https://ac.nowcoder.com/discuss/153349?type=101&amp;order=1&amp;pos=7&amp;page=1">https://ac.nowcoder.com/discuss/153349?type=101&amp;order=1&amp;pos=7&amp;page=1</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-02-06 00:09:06 语言：C++ 代码长度：335 运行时间： 7 ms 占用内存：604K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = m*<span class="number">7</span>-n;</span><br><span class="line">    <span class="keyword">if</span>(ans &lt; <span class="number">0</span>)</span><br><span class="line">        ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m*<span class="number">6</span> &gt; n || n &gt; <span class="number">9</span>*m)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;jgzjgzjgz&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">     cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Applese-涂颜色</title>
      <link href="/2019/02/05/Applese-%E6%B6%82%E9%A2%9C%E8%89%B2/"/>
      <url>/2019/02/05/Applese-%E6%B6%82%E9%A2%9C%E8%89%B2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/330/E">牛客 -330E Applese 涂颜色</a></p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ 1秒，其他语言2秒</span><br><span class="line">空间限制：C/C++ 32768K，其他语言65536K</span><br><span class="line">64bit IO Format: %lld</span><br></pre></td></tr></table></figure><p><strong>题目描述</strong></p><p>精通程序设计的 Applese 叕写了一个游戏。<br>在这个游戏中，有一个 n 行 m 列的方阵。现在它要为这个方阵涂上黑白两种颜色。规定左右相邻两格的颜色不能相同。请你帮它统计一下有多少种涂色的方法。由于答案很大，你需要将答案对 $10^9+7$取模。</p><p><strong>输入描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅一行两个正整数 n, m，表示方阵的大小。</span><br></pre></td></tr></table></figure><p><strong>输出描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个正整数，表示方案数对10^9+7取模。</span><br></pre></td></tr></table></figure><p><strong>示例1</strong></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>示例2</strong><br>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>备注</strong></p><p>$1\leq n,m\leq10^{100000}$</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一个比较显然的结论是，对于每一列，有$2^n$种涂色方法。<br>我们可以发现，当确定了第一列之后，由于左右相邻不能同色，所以后面每一列的涂色方案也随之确定。因此答案就是 $2^n$</p><p>首先n的数字范围非常大，10的10万次方，所以数据一定是用字符串读进去的，其次，因为 n 很大，循环n次肯定超时。所以得降幂，费马小定理或者欧拉降幂都可以。</p><p><strong>费马小定理</strong></p><p>费马小定理：对于素数 $m$ 任意不是 $m$ 的倍数的 $b$，都有：$b^{m-1}\equiv1\  mod \ m$ </p><ol><li><p>先决条件成立：$10^9+7$是素数，$gcd(10^9+7, \ 2)=1$</p></li><li><p>处理：</p><p>因$b^{m-1}=1$，故我们只需要算出除去1的部分有多少就行了，于是有</p><p>$2^{n}=2^{n\%(m-1)}$ (m为$10^9+7$)</p><p>这样n就减少了，但是$10^9+7$还是很大，要用到快速幂取模</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-02-05 14:59:46 语言：C++ 代码长度：565 运行时间： 4 ms 占用内存：864K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n)</span> <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            ans = ans * x % MOD;</span><br><span class="line">        x = x*x % MOD;</span><br><span class="line">        n &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    ll p = <span class="number">0</span>;</span><br><span class="line">    ll len = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      p = (p*<span class="number">10</span> + s1[i] - <span class="string">&#x27;0&#x27;</span>) % (MOD - <span class="number">1</span>); <span class="comment">//将读入的字符变成整数，并且这个过程中取模</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">mod_pow</span>(<span class="number">2</span>, p) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>欧拉降幂</strong></p><script type="math/tex; mode=display">A^Bmod\ C=A^{ B\ mod\varphi(C)+\varphi(C) }mod\ C</script><p>故有</p><p>$2^nmod\ m=2^{n\ mod\ \varphi(m)+\varphi(m)}\ mod\ m$</p><p>所以</p><ol><li>先求出$ \varphi(m)$</li><li>再用快速幂求出$2^n$</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-02-05 16:38:55 语言：C++ 代码长度：855 运行时间： 8 ms 占用内存：916K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n)</span> <span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            ans = ans * x % MOD;</span><br><span class="line">        x = x*x % MOD;</span><br><span class="line">        n &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">euler</span><span class="params">(ll n)</span> <span class="comment">//求phi</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = n;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n%i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res =res/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    ll p = <span class="built_in">euler</span>(MOD);</span><br><span class="line">    ll len = s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">      ans = (ans*<span class="number">10</span> + s1[i] - <span class="string">&#x27;0&#x27;</span>) % p; <span class="comment">//算出n mod phi(m),phi：欧拉函数</span></span><br><span class="line">    ans += p; <span class="comment">//算出n mod phi(m) + phi(m)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">mod_pow</span>(<span class="number">2</span>, ans) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 欧拉降幂 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 费马小定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2019/02/04/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2019/02/04/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>欧拉函数公式，性质，模板</p><span id="more"></span><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目。例如φ(8)=4，因为1,3,5,7均和8互质。</p><h3 id="欧拉函数公式"><a href="#欧拉函数公式" class="headerlink" title="欧拉函数公式"></a>欧拉函数公式</h3><script type="math/tex; mode=display">euler(x) =x\times(1-\frac{1}{p_1})\times(1-\frac{1}{p_2})\times......\times(1-\frac{1}{p_n})</script><p><em>(其中p1, p2……pn为x的所有质因数，x是不为0的整数)</em></p><p><img src="/2019/02/04/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/ohiexample.png" alt></p><p><strong>注意：</strong></p><p><code>φ(1) = 1</code>（唯一和1互质的数(小于等于1)就是1本身）。 (注意：每种质因数只一个。比如 <script type="math/tex">12 = 2\times2\times3</script> 那么 <script type="math/tex">φ(12) = 12\times (1-\frac{1}{2}) \times (1-\frac{1}{3})=4  )</script></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>当n为质数时，$φ(n)=n-1$。</li><li>当$n=p^k$时（p是素数），$φ(n)=φ(p^k )=p^k-p^{k-1}=(p-1)p^{k-1}$</li><li>若n,m互质，$φ(nm)=φ(n)φ(m)=(n-1)(m-1)$</li><li>若n是奇数，则$φ(2n)=φ(n)$</li></ol><p><strong>特殊性质</strong></p><ol><li>当a与n互质时(n&gt;2)有:$a^{φ(n)}\  mod\ n=1$ (恒等于)此公式即 <strong>欧拉定理</strong></li><li>当a与n互质且n为质数时(即:gcd(a,n)=1)则上式有:$ a^{(n-1)}\ mod \ n=1$(恒等于)此公式即 <strong>费马小定理</strong></li></ol><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>小于n且与n互质的数的和：</p><script type="math/tex; mode=display">\frac{φ(n)∗n}2  (n>1)</script><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>求$7^{222}$的个位数。</strong></p><p>因为7和10互质，且$φ(10)=4$</p><p>所以$7^4  mod 10=1$</p><p>所以$7^{222}  mod 10=7^{4∗55}∗7^2  mod 10=7^2  mod 10=9$</p><p>即$7^{222}  mod 10=7^{222\%4}  mod 10=7^2  mod 10=9$</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>参考：</p><p><a href="https://www.cnblogs.com/wkfvawl/p/9317125.html">https://www.cnblogs.com/wkfvawl/p/9317125.html</a></p><h5 id="直接求小于n-且与n互质的个数（欧拉函数模板）"><a href="#直接求小于n-且与n互质的个数（欧拉函数模板）" class="headerlink" title="直接求小于n,且与n互质的个数（欧拉函数模板）"></a>直接求小于n,且与n互质的个数（欧拉函数模板）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">eular</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,ret=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret=ret/i*(i<span class="number">-1</span>);<span class="comment">//这里先使用除法是为了防止溢出，ret=ret*(1-1/p(1))</span></span><br><span class="line">            <span class="comment">//为了完全消除我们已经除完了刚才得到的那个i因子,确保下一个得到的i是n的素因子</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)<span class="comment">//可能还剩下一个素因子没有除 </span></span><br><span class="line">    &#123;</span><br><span class="line">        ret=ret/n*(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="筛选模板-求-1-n-之间每个数的质因数的个数"><a href="#筛选模板-求-1-n-之间每个数的质因数的个数" class="headerlink" title="筛选模板:求[1,n]之间每个数的质因数的个数"></a>筛选模板:求[1,n]之间每个数的质因数的个数</h5><p>如果我们要求的数比较多，如果一个一个求那么很容易就超时，所以我们自然而然就想到——打表。</p><p>如果我们依照上述思想，来个最朴素的打表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> size 1000001</span></span><br><span class="line"><span class="type">int</span> euler[size];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!euler[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;size; j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!euler[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    euler[j]=j;</span><br><span class="line">                &#125;</span><br><span class="line">                euler[j]=euler[j]/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法是为了防止中间数据的溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="欧拉降幂"><a href="#欧拉降幂" class="headerlink" title="欧拉降幂"></a>欧拉降幂</h1><script type="math/tex; mode=display">A^Bmod\ C=A^{ Bmod\varphi(C)+\varphi(C) }mod\ C</script><p>$\varphi()$为欧拉函数</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 欧拉降幂 </tag>
            
            <tag> 欧拉函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模运算</title>
      <link href="/2019/02/03/%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
      <url>/2019/02/03/%E6%A8%A1%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>模运算</p><span id="more"></span><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p><strong>一些基本规则</strong></p><p>加法：</p><p>$(a+b)\mod n=(a \mod n+b \mod n)\mod n$</p><p>减法：</p><p>$(a-b)\mod n=(a \mod n-b \mod n)\mod n$</p><p>乘法：</p><p>$(a∗b)\mod n=(a \mod n∗b \mod n)\mod n$</p><p>幂：</p><p>$a^b \mod n=(a \mod n)^b  mod \ n$</p><p><strong><em>注意！除法不成立。</em></strong></p><p>那么，如何计算$(a/b)\ mod\  n$?</p><p>我们可以通过将除b转换成乘b的逆元来解决，即$(a∗b^{-1} )\mod n$ </p><h1 id="求-a-b-mod-m"><a href="#求-a-b-mod-m" class="headerlink" title="求$(a/b)\ mod\ m $"></a>求$(a/b)\ mod\ m $</h1><h3 id="逆元定义"><a href="#逆元定义" class="headerlink" title="逆元定义"></a>逆元定义</h3><p>对于正整数$a$和$m$，如果有$ax\equiv 1(\ mod\ m)$，那么把这个同余方程中的$x$最小正整数解叫做$a$模$m$的逆元。</p><p><strong>逆元的存在性质：当$a$与$m$互素的时候，逆元才存在解，如果不互素则无解（这里说的都是整数解）</strong></p><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>逆元一般用扩展欧几里得算法来求得，如果$m$为素数，那么还可以根据费马小定理得到逆元为$a^{m-2}\ mod\ m$。（都要求$a$和$m$互质）</p><hr><h4 id="费马小定理求解（m为素数是费马小定理的前置条件）"><a href="#费马小定理求解（m为素数是费马小定理的前置条件）" class="headerlink" title="费马小定理求解（m为素数是费马小定理的前置条件）"></a>费马小定理求解（m为素数是费马小定理的前置条件）</h4><p>费马小定理：对于素数 $m$ 任意不是 $m$ 的倍数的 $b$，都有：$b^{m-1}\equiv1\  mod \ m$</p><p>于是有$ b* b^{m-2}\equiv1\ mod \ m $</p><p>于是有</p><script type="math/tex; mode=display">a/b=a/b*(b * b ^ {m-2})=a*b ^ {m-2}\ mod\ m</script><h4 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h4><p>利用费马小定理只能求出m为素数的情况下的乘法逆元，所以还是需要采用扩展欧几里德算法来计算普遍情况下的乘法逆元的情况。</p><p>当 a 与 b 互素时有$ gcd （ a ， b ） = 1 $；</p><p>即得：<script type="math/tex">a*x + b*y = 1</script></p><p>$a * x ≡ 1 （ mod b ）；$</p><p>由于 a 与 b 互素，同余式两边可以同除 a ，得：</p><p>$1 * x ≡ 1 / a （mod b）$；</p><p>因此 $x$ 是 $a \ mod\  b$ 的逆元；</p><script type="math/tex; mode=display">a*x + b*y = 1</script><p><strong>求得$x$即为$a\%b$的逆元$(ax\%b \equiv 1)$；$ y$即为$b\%a$的逆元$(by\%a \equiv 1)$。</strong></p><p><strong>所以</strong></p><p>用扩展欧几里得算法求得一组$x0,y0$和$gcd$;检查$gcd$是否为1<br>$gcd$不为1说明逆元不存在，若为1,调整$x0$到0~m-1的范围中即可。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此算法即可求出gcd(a,b)，也可求出x和y。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span>       <span class="comment">//扩展欧几里得 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">ex_gcd</span>(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod_reverse</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span><span class="comment">//ax=1(mod n) 求a的逆元x </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d,x,y;</span><br><span class="line">    d=<span class="built_in">ex_gcd</span>(a,n,x,y);</span><br><span class="line">    <span class="keyword">if</span>(d==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (x%n+n)%n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><p>费马小定理和扩展欧几里得算法求逆元是有局限性的，它们都会要求<img src="https://img-blog.csdn.net/20140613102654328" alt="img">与<img src="https://img-blog.csdn.net/20140613102712781" alt="img">互素。实际上我们还有一</p><p>种通用的求逆元方法，适合所有情况。公式如下</p><p>$ans=a*b^{-1}\ mod\ m=a\ mod\ (mb)/b$</p><p>参考：</p><p><a href="http://www.cnblogs.com/cenariusxz/p/4323872.html">http://www.cnblogs.com/cenariusxz/p/4323872.html</a></p><p><a href="https://blog.csdn.net/liangzhaoyang1/article/details/56514028">https://blog.csdn.net/liangzhaoyang1/article/details/56514028</a></p><p><a href="https://blog.csdn.net/greenary/article/details/79343176">https://blog.csdn.net/greenary/article/details/79343176</a></p><p><a href="https://blog.csdn.net/acdreamers/article/details/8220787">https://blog.csdn.net/acdreamers/article/details/8220787</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 费马小定理 </tag>
            
            <tag> 模运算 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 逆元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛快速幂</title>
      <link href="/2019/02/03/%E7%B4%A0%E6%95%B0%E7%AD%9B%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2019/02/03/%E7%B4%A0%E6%95%B0%E7%AD%9B%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>素数筛快速幂</p><span id="more"></span><h1 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h1><h2 id="埃氏筛法—-求解n以内的素数个数"><a href="#埃氏筛法—-求解n以内的素数个数" class="headerlink" title="埃氏筛法—-求解n以内的素数个数"></a>埃氏筛法—-求解n以内的素数个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prime[MAXN]; <span class="comment">//第i个素数的值</span></span><br><span class="line"><span class="type">bool</span> is_prime[MAXN]; <span class="comment">//is_prime[i]为true时表示i是素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回n以内素数的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//代表素数个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[p++] = i; <span class="comment">//每有一个素数，p就++，然后prime存的就是素数的值，然后进行筛选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//prime[p - 1]代表n以内最大的素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法比较好理解，初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数(注意上面的i*i ,  比 i*2 要快点 )，把这些合数都筛掉，即算法名字的由来。</p><p>但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。比如10，在i=2的时候，k=2*15筛了一次；在i=5，k=5*6 的时候又筛了一次。所以，也就有了快速线性筛法。</p><h2 id="快速线性筛法"><a href="#快速线性筛法" class="headerlink" title="快速线性筛法"></a>快速线性筛法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line"><span class="type">const</span> <span class="type">long</span> N = <span class="number">200000</span>;   </span><br><span class="line"><span class="type">long</span> prime[N] = &#123;<span class="number">0</span>&#125;,num_prime = <span class="number">0</span>;    </span><br><span class="line"><span class="type">int</span> isNotPrime[N] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">long</span> i = <span class="number">2</span> ; i &lt; N ; i ++)       </span><br><span class="line">       &#123;            </span><br><span class="line"><span class="keyword">if</span>(!isNotPrime[i])               </span><br><span class="line"> prime[num_prime++]=i;  </span><br><span class="line"><span class="comment">//关键处1        </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> j = <span class="number">0</span> ; j &lt; num_prime &amp;&amp; i * prime[j] &lt;  N ; j ++)</span><br><span class="line">    &#123;               </span><br><span class="line">      isNotPrime[i * prime[j]] = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">if</span>( !(i % prime[j] ) )  <span class="comment">//关键处2                  </span></span><br><span class="line"><span class="keyword">break</span>;           </span><br><span class="line">&#125;    </span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h2><p><img src="/2019/02/03/%E7%B4%A0%E6%95%B0%E7%AD%9B%E5%BF%AB%E9%80%9F%E5%B9%82/duibi.jpg" alt></p><p>由上述数据不难看出，快速线性筛法的效率基本比普通筛法求素数的效率高一倍，说明这的确是一种比较可靠的关于求素数优化的算法~！</p><p>参考:</p><p><a href="https://blog.csdn.net/dinosoft/article/details/5829550">https://blog.csdn.net/dinosoft/article/details/5829550</a></p><p><a href="https://zhuanlan.zhihu.com/p/42609585">https://zhuanlan.zhihu.com/p/42609585</a></p><h1 id="快速幂，快速乘"><a href="#快速幂，快速乘" class="headerlink" title="快速幂，快速乘"></a>快速幂，快速乘</h1><p>参考：<a href="https://blog.xehoth.cc/DurationPlan-modPow/#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E5%B9%82">https://blog.xehoth.cc/DurationPlan-modPow/#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E5%B9%82</a></p><h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>普通快速幂在面对大量数据或单个够大数据时效率很低，这个时候我们就需要十进制快速幂，而如果模数是 <code>long long</code> 以内的数，我们可以用快速幂思想 <em>O</em>(log n)O(log n) 完成快速乘，但我们其实可以 <em>O</em>(1)完成。</p><p>利用 <code>long double</code>，而 <code>long double</code>的精度其实只有 19 位，直接乘是不行的，我们可以先除再乘，这样就不会出现精度问题，而前面直接计算 <em>a</em>×<em>b</em>，再减去后面的部分，即使前面 <em>a</em>×<em>b</em> 爆负，它还会再爆一遍变为正的，保证了答案的正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (ll)((ld)a / MOD * b) * MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制快速幂"><a href="#二进制快速幂" class="headerlink" title="二进制快速幂"></a>二进制快速幂</h3><p><strong>基本代码，都懂</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n, ll mod)</span> <span class="comment">//x^n % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) <span class="comment">//遍历所有二进制位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="comment">//对应n的二进制位是不是1</span></span><br><span class="line">            ans = ans * x % mod; <span class="comment">//乘上x^(2^i)</span></span><br><span class="line">        x = x * x % mod;  <span class="comment">//x平方</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>蜜汁优化版本（参考ext/numeric.h的power函数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="title">optimizedModPow</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ~b &amp; <span class="number">1</span>; b &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a));</span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> ret = a;</span><br><span class="line">    <span class="keyword">for</span> (b &gt;&gt;= <span class="number">1</span>; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a), (b &amp; <span class="number">1</span>) ? ret = <span class="built_in">mul</span>(a, ret) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//balabala--看不懂系列！！</span></span><br></pre></td></tr></table></figure><h3 id="十进制快速幂"><a href="#十进制快速幂" class="headerlink" title="十进制快速幂"></a>十进制快速幂</h3><p>说白了就是拆成十进制数</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
            <tag> 快速乘 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 素数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧几里得</title>
      <link href="/2019/02/03/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2019/02/03/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>gcd, lcm, exgcd</p><span id="more"></span><h1 id="欧几里得—最大公约数"><a href="#欧几里得—最大公约数" class="headerlink" title="欧几里得—最大公约数"></a>欧几里得—最大公约数</h1><h3 id="gcd（a-b-gcd-b-a-mod-b"><a href="#gcd（a-b-gcd-b-a-mod-b" class="headerlink" title="gcd（a, b) = gcd(b, a mod b)"></a>gcd（a, b) = gcd(b, a mod b)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % )b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一波应用：<a href="https://www.cnblogs.com/kimsimple/p/6680820.html">线段上格点个数—-挑战编程—-欧几里得</a></p><h3 id="algorithm库的std-gcd函数"><a href="#algorithm库的std-gcd函数" class="headerlink" title="algorithm库的std::_gcd函数"></a>algorithm库的std::_gcd函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt;__gcd(a, b); <span class="comment">//两个&#x27;_&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out：4   //g++-4.8 </span></span><br></pre></td></tr></table></figure><h3 id="最小公倍数-LCM-和最大公约数-GCD"><a href="#最小公倍数-LCM-和最大公约数-GCD" class="headerlink" title="最小公倍数(LCM)和最大公约数(GCD)"></a>最小公倍数(LCM)和最大公约数(GCD)</h3><p><code>lcm(a, b) = (a*b)/gcd(a,b)</code></p><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p>基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。</p><p>当 gcd （ a ， b ）= d 时，求绝对值和最小的 x ， y 使得 x <em> a + y </em> b = d 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此算法即可求出gcd(a,b)，也可求出x和y。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> gcd </tag>
            
            <tag> lcm </tag>
            
            <tag> exgcd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客--applese的回文串</title>
      <link href="/2019/01/30/%E7%89%9B%E5%AE%A2--applese%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2019/01/30/%E7%89%9B%E5%AE%A2--applese%E7%9A%84%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>判断一个字符串在任意位置(包括最前面和最后面)插入一个字符后能不能构成一个回文串</p> <span id="more"></span><p><a href="https://ac.nowcoder.com/acm/contest/330/I">Applese 的回文串</a></p><p><strong>解析</strong></p><p>TAG：思维，想法</p><p>可以认为插入和删除是等价的操作。想到这一点，这题就会好做很多。<br>如果这个串本身就是回文串，答案一定是Yes。<br>否则我们只需要考虑串中对称的位置不相等的两个字符，分别尝试把它们删掉后判断一下是不是回文的就行了。</p><p>参考自：<a href="https://ac.nowcoder.com/discuss/153012?type=101">https://ac.nowcoder.com/discuss/153012?type=101</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-01-30 12:03:32 语言：C++ 代码长度：695 运行时间： 4 ms 占用内存：996K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断对称位置的字符是否相等，相等返回-1，不是返回不相等的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">0</span>; i &lt; len ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[len - <span class="number">1</span> - i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> diff = <span class="built_in">check</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(diff == <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        string tmp = s;</span><br><span class="line">        <span class="comment">//删除掉不相等的那个字符，s1是删掉左边的，s2的删掉右边的</span></span><br><span class="line">        string s1 = s.<span class="built_in">erase</span>(diff, <span class="number">1</span>); </span><br><span class="line">        string s2 = tmp.<span class="built_in">erase</span>(tmp.<span class="built_in">size</span>() - <span class="number">1</span> - diff, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(s1) == <span class="number">-1</span> || <span class="built_in">check</span>(s2) == <span class="number">-1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回文串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常wa于模拟题</title>
      <link href="/2019/01/29/%E6%97%A5%E5%B8%B8wa%E4%BA%8E%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
      <url>/2019/01/29/%E6%97%A5%E5%B8%B8wa%E4%BA%8E%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>牛客—<a href="https://ac.nowcoder.com/acm/contest/330/C">Applese 走迷宫</a></p><span id="more"></span><p>模拟题，就是给出个m×n矩阵，从(0,0)开始，输出一种方案能够不重复得走完所有的点并且回到起点，没有的话输出-1。</p><p>掉了两个坑：</p><ul><li>特殊情况：1行2列或2行1列，没有考虑这个也可以回到原点，以为只要是<code>m==1||n==1</code>就不能走了</li><li>没有考虑到别的走法，以至于以为<code>m%2==0</code>就不能走了</li></ul><p>有一个还需要的优化的地方就是代码逻辑。</p><p><strong>解析</strong></p><p>主要是两种情况，当<code>n%2==0</code>时，可以按照下面这种走法输出方案</p><p><img src="/2019/01/29/%E6%97%A5%E5%B8%B8wa%E4%BA%8E%E6%A8%A1%E6%8B%9F%E9%A2%98/one.png" alt></p><p>当<code>n%2!=0&amp;&amp;m%2==0</code>时，可以按照下面这种走法输出方案</p><p><img src="/2019/01/29/%E6%97%A5%E5%B8%B8wa%E4%BA%8E%E6%A8%A1%E6%8B%9F%E9%A2%98/two.png" alt></p><p>其他情况都没有方案，输出-1</p><p>代码逻辑方面，有一部分都是一样的输出，所以可重复利用，如红色部分。所以可精简代码。</p><p><img src="/2019/01/29/%E6%97%A5%E5%B8%B8wa%E4%BA%8E%E6%A8%A1%E6%8B%9F%E9%A2%98/code.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">提交时间：2019-01-29 19:41:29 语言：C++ 代码长度：1360 运行时间： 5 ms 占用内存：504K </span></span><br><span class="line"><span class="comment">运行状态：答案正确</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;RL&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;DU&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">         <span class="comment">//重复利用部分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">          <span class="comment">//  </span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;U&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;D&quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;R&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;U&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;U&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;L&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平衡三进制</title>
      <link href="/2019/01/28/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/"/>
      <url>/2019/01/28/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>平衡三进制</p> <span id="more"></span><p><a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/9370144?fr=aladdin">平衡三进制—百度百科</a></p><p>一道简单平衡三进制题目:</p><p><a href="https://ac.nowcoder.com/acm/contest/327/C">牛客—处女座的砝码</a></p><p>参考:<a href="https://blog.csdn.net/Sherry_Yue/article/details/86658533">https://blog.csdn.net/Sherry_Yue/article/details/86658533</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//submit time:2019-01-28 22:26:07</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> n, res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">3</span> * cnt + <span class="number">1</span>;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><code>long long与 long double</code></p><p>按道理来说，<code>long double</code> 比<code>double</code>和<code>long long</code>要表示的范围要大，但是依据情况而定，在本机64位机测试上测试:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) = <span class="number">16</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) = <span class="number">8</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">double</span>) = <span class="number">8</span>    </span><br></pre></td></tr></table></figure><hr><p>更多了解:</p><p><a href="http://poj.org/problem?id=1702">poj1702—Eva’s Balance</a></p><p><a href="https://blog.csdn.net/yeruby/article/details/47047385">https://blog.csdn.net/yeruby/article/details/47047385</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡三进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论</title>
      <link href="/2019/01/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
      <url>/2019/01/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>博弈论</p> <span id="more"></span><h1 id="博弈论两道题"><a href="#博弈论两道题" class="headerlink" title="博弈论两道题"></a>博弈论两道题</h1><h2 id="牛客—处女座和小姐姐"><a href="#牛客—处女座和小姐姐" class="headerlink" title="牛客—处女座和小姐姐"></a><a href="https://ac.nowcoder.com/acm/contest/329/E">牛客—处女座和小姐姐</a></h2><p>分析：</p><p>作者：儒生雄才1<br>链接：<a href="https://ac.nowcoder.com/discuss/152781?type=101&amp;order=0&amp;pos=1&amp;page=1">https://ac.nowcoder.com/discuss/152781?type=101&amp;order=0&amp;pos=1&amp;page=1</a><br>来源：牛客网</p><p>显然处女座十分牛逼，因此输出“cnznb”即可<br> 咳咳……至于正确的做法。首先因为每次在右边砍掉一个头就相当于在左边会多出来一个头，所以可以把每𝑛次操作看作一轮，每轮的操作都是从01串右边向左边对每个位置在原位依次进行操作。我们考虑这种做法，从右到左我们首先看到1就把他变成0，0的话让他随机，直到第一次出现有0变成了1的情况。如果没有出现这种情况那么这个串已经符合了要求，如果有0变成1发生，那么在这之后的1我们都继续变成1。这样一轮结束之后，这个01串所表示的二进制数的的大小一定是严格增加了的（因为虽然你可能把一些1变成了0但是有一个高位的0变成了1）而这个二进制数的大小是有限的，因此在有限步内一定可以把这串数变成全0串。</p><h2 id="HDU6312—GAME"><a href="#HDU6312—GAME" class="headerlink" title="HDU6312—GAME"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6312">HDU6312—GAME</a></h2><p>参考：</p><p><a href="https://blog.csdn.net/qq_37025443/article/details/81214403">https://blog.csdn.net/qq_37025443/article/details/81214403</a></p><p><em>上面两大题都是输出一个结果，无论输入的是什么。这只是博弈论之一，博弈论还有其他的内容</em></p><h1 id="博弈论常见类型"><a href="#博弈论常见类型" class="headerlink" title="博弈论常见类型"></a>博弈论常见类型</h1><p>参考:<a href="https://blog.csdn.net/lgdblue/article/details/15809893">https://blog.csdn.net/lgdblue/article/details/15809893</a></p><h2 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h2><ol><li><p>问题模型：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个，最后取光者得胜。</p></li><li><p>解决思路：当n=m+1时，由于一次最多只能取m个，所以无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜，<code>所以当一方面对的局势是n%(m+1)=0时，其面临的是必败的局势</code>。所以当n=（m+1)*r+s，（r为任意自然数，s≤m)时,如果先取者要拿走s个物品，如果后取者拿走x（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。</p></li><li><p>变形：条件不变，改为最后取光的人输。</p></li><li><p>结论：当一方面对的局势是n%(m+1)=0时，其面临的是必败的局势</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体来说，当m大于等于n时肯定是先手赢，所以这是必胜点，而m = n+1就是必败点了，因为这时你至少加1，至多加n，达不到n+1，而后手肯定能补满到n+1，如果m是（n+1）的倍数，那么也是必败点；因为后手只是每次保持m是（n+1）的倍数，最后一轮，肯定又出现n+1的必败点。相反m不是（n+1）的倍数，那么就是必胜点，因为我们只要加价让剩余价格是（n+1）的倍数，就可以到达必败点</span><br></pre></td></tr></table></figure><h3 id="HDU2188—悼念512汶川大地震遇难同胞——选拔志愿者"><a href="#HDU2188—悼念512汶川大地震遇难同胞——选拔志愿者" class="headerlink" title="HDU2188—悼念512汶川大地震遇难同胞——选拔志愿者"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2188">HDU2188—悼念512汶川大地震遇难同胞——选拔志愿者</a></h3><p>巴什博弈应用题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Submit Time2019-01-27 15:25:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n ,m;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(n % (m + <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Rabbit&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Grass&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU2149—Public-Sale"><a href="#HDU2149—Public-Sale" class="headerlink" title="HDU2149—Public Sale"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2149">HDU2149—Public Sale</a></h3><p>参考:<a href="http://blog.sina.com.cn/s/blog_a16dd6d101013lha.html">http://blog.sina.com.cn/s/blog_a16dd6d101013lha.html</a></p><p>结果可以分三种情况：</p><ol><li>当n&gt;=m，即先手第一次可以加的价格大于等于田地的成本价，此时可以加的价格依次为m~n；②</li><li>当m%(n+1)==0时，后手必赢，即此时输出“none”；</li><li>当m%(n+1)!=0时，题目要求输出第一次报价，枚举每一种可能的出价，只要能使结果满足m%(n+1) == 0， 就是一次合理的出价</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Submit Time2019-01-27 16:06:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n ,m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; m &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m % (n + <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;none&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ans[<span class="number">10000</span>];</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//第二种情况或者保持给对手留下（m+1）的倍数，就能最后获胜</span></span><br><span class="line">                <span class="keyword">if</span>(m-i&lt;=<span class="number">0</span> || (m-i)%(n<span class="number">+1</span>)==<span class="number">0</span>) </span><br><span class="line">                    ans[num++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意题目输出要求，不能多余空格，不然报PE</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num<span class="number">-1</span>; i++)</span><br><span class="line">                cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cout &lt;&lt; ans[num - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="威佐夫博奕"><a href="#威佐夫博奕" class="headerlink" title="威佐夫博奕"></a>威佐夫博奕</h2><p>问题模型：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。</p><p>证明可参考：</p><p><a href="https://blog.csdn.net/qq_41311604/article/details/79980882">https://blog.csdn.net/qq_41311604/article/details/79980882</a></p><h3 id="HDU1527—取石子游戏"><a href="#HDU1527—取石子游戏" class="headerlink" title="HDU1527—取石子游戏"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1527">HDU1527—取石子游戏</a></h3><p>裸威佐夫博奕题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Submit Time2019-01-27 18:08:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> MIN = n;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)</span><br><span class="line">            MIN = m;</span><br><span class="line">        <span class="type">double</span> r = (<span class="built_in">sqrt</span>(<span class="number">5.0</span>)<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> num = (<span class="type">int</span>)(<span class="built_in">abs</span>(n - m) * r);</span><br><span class="line">        <span class="keyword">if</span>(num == MIN)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斐波那契博弈-Fibonacci-Nim"><a href="#斐波那契博弈-Fibonacci-Nim" class="headerlink" title="斐波那契博弈(Fibonacci Nim)"></a>斐波那契博弈(Fibonacci Nim)</h1><p>参考:<a href="https://blog.csdn.net/dgq8211/article/details/7602807">https://blog.csdn.net/dgq8211/article/details/7602807 </a></p><p>有一堆个数为n(n&gt;=2)的石子，游戏双方轮流取石子，规则如下：</p><ol><li><p>先手不能在第一次把所有的石子取完，至少取1颗；</p></li><li><p>之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。</p></li></ol><p>约定取走最后一个石子的人为赢家，求必败态。</p><p>结论：当n为Fibonacci数的时候，必败。</p><p><code>f[i]：1,2,3,5,8,13,21,34,55,89……</code></p><h3 id="HDU2516—取石子游戏"><a href="#HDU2516—取石子游戏" class="headerlink" title="HDU2516—取石子游戏"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2516">HDU2516—取石子游戏</a></h3><p>斐波那契博弈裸题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Submit Time2019-01-27 18:18:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E2</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;MAXN;i++)</span><br><span class="line">        f[i] = f[i<span class="number">-1</span>] + f[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n == f[i])</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Second win&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;First win&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尼姆博弈"><a href="#尼姆博弈" class="headerlink" title="尼姆博弈"></a>尼姆博弈</h2><p>问题模型：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜</p><p>可参考:<a href="https://blog.csdn.net/tianweidadada/article/details/80091063">https://blog.csdn.net/tianweidadada/article/details/80091063</a></p><h3 id="HDU1847—Good-Luck-in-CET-4-Everybody"><a href="#HDU1847—Good-Luck-in-CET-4-Everybody" class="headerlink" title="HDU1847—Good Luck in CET-4 Everybody!"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1847">HDU1847—Good Luck in CET-4 Everybody!</a></h3><p>裸尼姆博弈题</p><p>参考:<a href="https://blog.csdn.net/a1214034447/article/details/78872034">https://blog.csdn.net/a1214034447/article/details/78872034</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *Submit Time2019-01-27 18:33:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cici&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Kiki&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平组合博弈（Impartial-Combinatori-Games）"><a href="#公平组合博弈（Impartial-Combinatori-Games）" class="headerlink" title="公平组合博弈（Impartial Combinatori Games）"></a>公平组合博弈（Impartial Combinatori Games）</h2><p>问题模型：</p><ol><li><p>两人参与。</p></li><li><p>游戏局面的状态集合是有限。</p></li><li><p>对于同一个局面，两个游戏者的可操作集合完全相同</p></li><li><p>游戏者轮流进行游戏。</p></li><li><p>当无法进行操作时游戏结束，此时不能进行操作的一方算输。</p></li><li><p>无论游戏如何进行，总可以在有限步数之内结束。</p></li></ol><h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>可参考:<a href="https://blog.csdn.net/qq_40774175/article/details/80526991">https://blog.csdn.net/qq_40774175/article/details/80526991</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件测试testCast</title>
      <link href="/2019/01/25/%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95testCast/"/>
      <url>/2019/01/25/%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95testCast/</url>
      
        <content type="html"><![CDATA[<p>采用文件读写办法进行样例测试以及生成各种测试用例</p> <span id="more"></span><p>写OJ调试的时候如果输入数据比较多，每次调试手动输入会很麻烦，把测试数据写到文件里用文件输入会比较方便。<em>本次主要用<code>freopen</code>进行文件读取</em></p><h1 id="freopen"><a href="#freopen" class="headerlink" title="freopen"></a>freopen</h1><p>参考</p><p><a href="https://blog.csdn.net/u013480600/article/details/18372341">https://blog.csdn.net/u013480600/article/details/18372341</a></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>首先必须知道调取<code>freopen</code>必须用到头文件<code>cstdio</code> 或者 <code>stdio.h</code></p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE * <span class="title">freopen</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> * filename, <span class="type">const</span> <span class="type">char</span> * mode, FILE * stream )</span></span>;</span><br><span class="line"><span class="comment">//filename: 要打开的文件名</span></span><br><span class="line"><span class="comment">//mode: 文件打开的模式，和fopen中的模式(r/w)相同</span></span><br><span class="line"><span class="comment">//stream: 文件指针，通常使用标准流文件(stdin/stdout/stderr)</span></span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><em>因为文件指针使用的是标准流文件，因此我们可以不定义文件指针</em></p><ol><li><p>使用<code>freopen()</code>函数以只读方式r(read)打开测试样例文件<code>in.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br></pre></td></tr></table></figure><p>以写入方式w(write)打开输出文件<code>out.txt</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br></pre></td></tr></table></figure></li><li><p>不再需要修改输入和输出，而是维持代码的原样就可以了。因为freopen()函数重定向了标准流，使其指向前面指定的文件。</p></li><li>使用<code>fclose</code>关闭输入文件和输出文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fclose</span>(stdin);</span><br><span class="line"><span class="built_in">fclose</span>(stdout);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>最好使用扩展名为<code>.txt</code>，因为它最稳定</li><li><p>注意文件的路径</p></li><li><p>一定要用<code>fcolse</code>关闭,否则下次继续读取或写入数据的时候很有可能出错.</p></li><li><p><code>in.txt</code>必须已经创建，<code>out.txt</code>不需要，无则—-系统会自动创建，有则—-原来文件中的内容会被全部更新。</p></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="comment">/* 中间按原样写代码，什么都不用修改 */</span>  </span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试样例生成"><a href="#测试样例生成" class="headerlink" title="测试样例生成"></a>测试样例生成</h1><p>工具：</p><p><a href="https://github.com/luogu-dev/cyaron">https://github.com/luogu-dev/cyaron</a></p><p>该文件需要python环境，详细看<code>README.md</code></p><p>一个生成样例python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> cyaron <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = IO(<span class="string">&quot;test.in&quot;</span>) </span><br><span class="line"><span class="comment">#生成20个</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">    <span class="comment">#生成一个4到6个字母之间的单词，只有&#x27;a&#x27;,&#x27;b&#x27;组成的字符串，a的可能性是90%，b的可能性是10%</span></span><br><span class="line">    <span class="built_in">str</span> = String.random((<span class="number">4</span>,<span class="number">6</span>), charset=<span class="string">&quot;aaaaaaaaab&quot;</span>)</span><br><span class="line">    io.input_writeln(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><h1 id="文件对比"><a href="#文件对比" class="headerlink" title="文件对比"></a>文件对比</h1><p>有时候需要对比一下找出一些错误，例如：</p><p>已知测试样例文件<code>testcase.txt</code>，正确代码输出文件<code>true.txt</code>，测试代码输出文件<code>test.txt</code></p><p><strong>在linux下</strong>可以使用<code>diff</code>命令对比</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span>(选项)(参数)</span><br></pre></td></tr></table></figure><ul><li><strong>选项</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-&lt;行数&gt;：指定要显示多少行的文本。此参数必须与-c或-u参数一并使用；</span><br><span class="line">-a或——text：diff预设只会逐行比较文本文件；</span><br><span class="line">-b或--ignore-space-change：不检查空格字符的不同；</span><br><span class="line">-B或--ignore-blank-lines：不检查空白行；</span><br><span class="line">-c：显示全部内容，并标出不同之处；</span><br><span class="line">-C&lt;行数&gt;或--context&lt;行数&gt;：与执行“-c-&lt;行数&gt;”指令相同；</span><br><span class="line">-d或——minimal：使用不同的演算法，以小的单位来做比较；</span><br><span class="line">-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt;：此参数的输出格式可用于前置处理器巨集；</span><br><span class="line">-e或——ed：此参数的输出格式可用于ed的script文件；</span><br><span class="line">-f或-forward-ed：输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处；</span><br><span class="line">-H或--speed-large-files：比较大文件时，可加快速度；</span><br><span class="line">-l&lt;字符或字符串&gt;或--ignore-matching-lines&lt;字符或字符串&gt;：若两个文件在某几行有所不同，而之际航同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异；</span><br><span class="line">-i或--ignore-case：不检查大小写的不同；</span><br><span class="line">-l或——paginate：将结果交由pr程序来分页；</span><br><span class="line">-n或——rcs：将比较结果以RCS的格式来显示；</span><br><span class="line">-N或--new-file：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录，文件A 若使用-N参数，则diff会将文件A 与一个空白的文件比较；</span><br><span class="line">-p：若比较的文件为C语言的程序码文件时，显示差异所在的函数名称；</span><br><span class="line">-P或--unidirectional-new-file：与-N类似，但只有当第二个目录包含了第一个目录所没有的文件时，才会将这个文件与空白的文件做比较；</span><br><span class="line">-q或--brief：仅显示有无差异，不显示详细的信息；</span><br><span class="line">-r或——recursive：比较子目录中的文件；</span><br><span class="line">-s或--report-identical-files：若没有发现任何差异，仍然显示信息；</span><br><span class="line">-S&lt;文件&gt;或--starting-file&lt;文件&gt;：在比较目录时，从指定的文件开始比较；</span><br><span class="line">-t或--expand-tabs：在输出时，将tab字符展开；</span><br><span class="line">-T或--initial-tab：在每行前面加上tab字符以便对齐；</span><br><span class="line">-u，-U&lt;列数&gt;或--unified=&lt;列数&gt;：以合并的方式来显示文件内容的不同；</span><br><span class="line">-v或——version：显示版本信息；</span><br><span class="line">-w或--ignore-all-space：忽略全部的空格字符；</span><br><span class="line">-W&lt;宽度&gt;或--width&lt;宽度&gt;：在使用-y参数时，指定栏宽；</span><br><span class="line">-x&lt;文件名或目录&gt;或--exclude&lt;文件名或目录&gt;：不比较选项中所指定的文件或目录；</span><br><span class="line">-X&lt;文件&gt;或--exclude-from&lt;文件&gt;；您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件；</span><br><span class="line">-y或--side-by-side：以并列的方式显示文件的异同之处；</span><br><span class="line">--help：显示帮助；</span><br><span class="line">--left-column：在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容；</span><br><span class="line">--suppress-common-lines：在使用-y参数时，仅显示不同之处。</span><br></pre></td></tr></table></figure><ul><li><strong>参数</strong><ul><li>文件1：指定要比较的第一个文件；</li><li>文件2：指定要比较的第二个文件。</li></ul></li></ul><p>例如上例：</p><p><code>diff test.txt true.txt -y</code></p><p><img src="/2019/01/25/%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95testCast/diff.png" alt></p><p>然后就可以知道哪个测试样例出错了。</p><p>其他系统可以自行查找工具。</p><h2 id="多次对比"><a href="#多次对比" class="headerlink" title="多次对比"></a>多次对比</h2><p>有时候可能一次测试的样例不错，我们需要不断生成测试样例，但是如果一次性生成过多会造成查找以及对比麻烦，所以一次性最好不要生成太多测试样例。</p><p>最好办法是多次生成不同的测试样例。</p><p>举例，有下列文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生成测试样例规则：ceate.py</span><br><span class="line">测试样例：testcase.txt</span><br><span class="line">测试代码：test.cpp</span><br><span class="line">正确代码: true.cpp</span><br><span class="line">测试代码输出：test.txt</span><br><span class="line">正确代码: true.txt</span><br></pre></td></tr></table></figure><ol><li>我们可以先生成测试样例<code>testcase.txt</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ceate.py</span><br></pre></td></tr></table></figure><ol><li>编译两个cpp文件</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="literal">-o</span> true true.cpp</span><br><span class="line">g++ <span class="literal">-o</span> test test.cpp</span><br></pre></td></tr></table></figure><ol><li>运行文件</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./true</span><br><span class="line">./test</span><br></pre></td></tr></table></figure><p>​    这样就就生成了两个输出文件，一个是正确的<code>true.txt</code>，一个测试的<code>test.txt</code>，然后我们就可以使用<code>dif</code>工具对比。接着，再次进行生成测试样例并且测试</p><ol><li>再次生成测试样例</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ceate.py</span><br></pre></td></tr></table></figure><ol><li>这次我们只需要</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./true</span><br><span class="line">./test</span><br></pre></td></tr></table></figure><p>​    就可以重新运行并且生成新的输出文件，然后就再对比，如此循环</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n1配置</title>
      <link href="/2018/11/24/n1%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/24/n1%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>某讯日常倒闭</p><span id="more"></span><h1 id="清空data"><a href="#清空data" class="headerlink" title="清空data"></a>清空<code>data</code></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/data</span><br></pre></td></tr></table></figure><h1 id="开启WiFi"><a href="#开启WiFi" class="headerlink" title="开启WiFi"></a>开启<code>WiFi</code></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe dhd &amp;&amp; echo dhd &gt;&gt; /etc/modules</span><br></pre></td></tr></table></figure><h1 id="配置Sakura-Frp"><a href="#配置Sakura-Frp" class="headerlink" title="配置Sakura Frp"></a>配置<code>Sakura Frp</code></h1><p>配置<code>frp</code>内网穿透，今天卡在开机自启这里了，后来查了下<code>linux</code>启动顺序才知道错处</p><p>参考：</p><p><a href="http://blog.51cto.com/net881004/2073150">centos 6和centos 7启动顺序</a></p><p><a href="https://blog.csdn.net/fireroll/article/details/15503463">linux添加开机自启动脚本示例详解</a>‘</p><p><a href="Linux 将 Sakura Frp 设置为服务，开机自动启动">Linux 将 Sakura Frp 设置为服务，开机自动启动</a></p><p><strong>1. 获取<code>Sakura Frp arm</code>版并且解压</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://s1.tcotp.cn/cdn/SakuraFrpClient-2.3/Sakura_frpc_linux_arm.tar.gz </span><br><span class="line">tar -xvf Sakura_frpc_linux_arm.tar.gz</span><br></pre></td></tr></table></figure><p><strong>2. 在<code>/etc/init.d</code>目录下放个启动无线网卡的脚本<code>dhd</code>并且赋予权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/dhd</span><br></pre></td></tr></table></figure><p><code>dhd</code>内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">modprobe dhd</span><br></pre></td></tr></table></figure><p>如果开机不能启动话<br><code>ln -s /etc/init.d/dhd /etc/rc.d/rc3.d/S70dhd</code><br>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x dhd</span><br></pre></td></tr></table></figure><p><strong>3. 然后在<code>/etc/systemd/system</code>目录下放关于<code>frp</code>的<code>service</code>文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/sakurafrp.service</span><br></pre></td></tr></table></figure><p>其内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Sakura Frp Client</span><br><span class="line">Wants=network-online.target</span><br><span class="line">After=network-online.target</span><br><span class="line">[Service]</span><br><span class="line">User=root</span><br><span class="line">WorkingDirectory=/root #你的客户端储存位置</span><br><span class="line">LimitNOFILE=4096</span><br><span class="line">PIDFile=/var/run/sakurafrp/client.pid</span><br><span class="line">ExecStart=/root/Sakura_frpc_linux_arm --su=test --sp=test --sid=2 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行命令su:用户名，sp:密码,sid:节点序号</span></span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitInterval=600</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>接着重新加载<code>service</code>文件还有设置开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start sakurafrp</span><br><span class="line">systemctl enable sakurafrp</span><br></pre></td></tr></table></figure><h1 id="配置frp"><a href="#配置frp" class="headerlink" title="配置frp"></a>配置frp</h1><p>配置文件：<code>frps.ini</code>和<code>frpc.ini</code></p><ol><li><p>将<code>frps</code>及<code>frps.ini</code> 放到具有公网 IP 的机器上</p></li><li><p>将 <code>frpc</code>及<code>frpc.ini</code>放到处于内网环境的机器上</p></li></ol><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><strong>1. 获取<a href="https://github.com/fatedier/frp">frp</a></strong><br><strong>2. 解压然后设置<code>frps.ini</code></strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">common</span>]</span><br><span class="line"><span class="comment"># 用于接收 frpc 连接的端口</span></span><br><span class="line">bind_port = <span class="number">7000</span></span><br></pre></td></tr></table></figure><p><strong>3. 启动</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps <span class="literal">-c</span> ./frps.ini</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps <span class="literal">-c</span> ./frps.ini &amp;</span><br></pre></td></tr></table></figure><br><strong>4. 设置开机自启</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/frps.service</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">Unit</span>]</span><br><span class="line">Description=frps daemon</span><br><span class="line"></span><br><span class="line">[<span class="type">Service</span>]</span><br><span class="line"><span class="built_in">Type</span>=simple</span><br><span class="line">ExecStart=/root/frp/frps <span class="literal">-c</span> /root/frp/frps.ini</span><br><span class="line"></span><br><span class="line">[<span class="type">Install</span>]</span><br><span class="line">WantedBy=multi<span class="literal">-user</span>.target</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon<span class="literal">-reload</span></span><br><span class="line">systemctl <span class="built_in">start</span> frps</span><br><span class="line">systecmtl enable frps</span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><strong>1. 获取<code>frp</code></strong><br><strong>2. 配置<code>frpc.ini</code></strong></p><ul><li>ftp</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一键脚本</span></span><br><span class="line">wget -c https://www.2dan.cc/download/ftp.sh</span><br><span class="line">sh ftp.sh</span><br></pre></td></tr></table></figure><p>使用被动模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/etc/proftpd.conf</span><br><span class="line">PassivePortRange         20000 20005</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.wenrouge.com/post/1483">http://www.wenrouge.com/post/1483</a></p><ul><li>其他</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">common</span>]</span><br><span class="line">server_addr = ip</span><br><span class="line">server_port = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line">[<span class="type">ssh</span>]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">local_port = <span class="number">22</span></span><br><span class="line">remote_port = <span class="number">7022</span></span><br><span class="line"></span><br><span class="line">[<span class="type">range</span>:<span class="type">ftp</span>]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">local_port = <span class="number">21</span>,<span class="number">20000</span><span class="literal">-20005</span></span><br><span class="line">remote_port = <span class="number">21</span>,<span class="number">20000</span><span class="literal">-20005</span></span><br><span class="line"></span><br><span class="line">[<span class="type">rdp</span>]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line">local_port = <span class="number">3389</span></span><br><span class="line">remote_port = <span class="number">3389</span></span><br></pre></td></tr></table></figure><p><strong>3. 连接</strong><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc <span class="literal">-c</span> ./frpc.ini</span><br></pre></td></tr></table></figure></p><p>或者</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frpc <span class="literal">-c</span> ./frpc.ini &amp;</span><br></pre></td></tr></table></figure><p><strong>4. 开机自启</strong></p><p>设置盒子的开启网卡为</p><p><code>ln -s /etc/init.d/dhd /etc/rc.d/rc3.d/S70dhd</code></p><p>然后</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim　/etc/init.d/frp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">nohup /root/frp/frpc -c ./root/frp/frpc.ini &amp;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln <span class="literal">-s</span> /etc/init.d/frp /etc/rc.d/rc3.d/S99frp</span><br></pre></td></tr></table></figure><p><strong>备用方案</strong><br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim /etc/rc.local</span></span><br><span class="line"><span class="built_in">sleep</span> <span class="number">20</span></span><br><span class="line">nohup /root/frp/frpc <span class="literal">-c</span> ./root/frp/frpc.ini &amp;</span><br><span class="line">nohup ./v2ray/v2ray &amp;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> n1 </tag>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数模板</title>
      <link href="/2018/11/22/%E5%A4%A7%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2018/11/22/%E5%A4%A7%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>大数四则运算模板</p> <span id="more"></span><p>参考：</p><p><a href="https://www.xuebuyuan.com/1860973.html">https://www.xuebuyuan.com/1860973.html</a></p><h1 id="大数加法"><a href="#大数加法" class="headerlink" title="大数加法"></a>大数加法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> ia[MAXN];</span><br><span class="line"><span class="type">int</span> ib[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sa, sb;</span><br><span class="line">    cin &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">    <span class="type">int</span> la = sa.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = sb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ml = la &gt; lb ? la : lb;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">        ia[i] = sa[la - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++)</span><br><span class="line">        ib[i] = sb[lb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ml; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = (ia[i] + ib[i] + next) % <span class="number">10</span>;</span><br><span class="line">        next = (ia[i] + ib[i] + next) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(next &gt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = ml - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大数减法"><a href="#大数减法" class="headerlink" title="大数减法"></a>大数减法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span>;</span><br><span class="line"><span class="type">int</span> ia[MAXN];</span><br><span class="line"><span class="type">int</span> ib[MAXN];</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sa, sb;</span><br><span class="line">    cin &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">    <span class="keyword">if</span>(sa == sb)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> la = sa.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = sb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//默认取sa大于sb，如果sb大于sa，那么需要交换，并且在输出结果前面加上-</span></span><br><span class="line">    <span class="keyword">if</span>(lb &gt; la || (la == lb &amp;&amp; sb &gt; sa))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(sa, sb);</span><br><span class="line">        <span class="built_in">swap</span>(la, lb);</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">        ia[i] = sa[la - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++)</span><br><span class="line">        ib[i] = sb[lb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ia[i] -= ib[i];</span><br><span class="line">        <span class="keyword">if</span>(ia[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ia[i] += <span class="number">10</span>;</span><br><span class="line">            ia[i + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j = la - <span class="number">1</span>;;</span><br><span class="line">    <span class="keyword">while</span>(ia[j] == <span class="number">0</span>)</span><br><span class="line">        j--;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(;j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ia[j]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大数乘法"><a href="#大数乘法" class="headerlink" title="大数乘法"></a>大数乘法</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/1542849793970.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> ia[MAXN];</span><br><span class="line"><span class="type">int</span> ib[MAXN];</span><br><span class="line"><span class="type">int</span> ic[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string sa, sb;</span><br><span class="line">    cin &gt;&gt; sa &gt;&gt; sb;</span><br><span class="line">    <span class="type">int</span> la = sa.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = sb.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(ia, <span class="number">0</span>, <span class="built_in">sizeof</span>(ia));</span><br><span class="line">    <span class="built_in">memset</span>(ib, <span class="number">0</span>, <span class="built_in">sizeof</span>(ib));</span><br><span class="line">    <span class="comment">//默认取sa大于sb，如果sb大于sa，那么需要交换，因为涉及到后面的2×la，方便处理</span></span><br><span class="line">    <span class="keyword">if</span>(lb &gt; la || (lb == la &amp;&amp; lb &gt; la))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(sa, sb);</span><br><span class="line">        <span class="built_in">swap</span>(la, lb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">        ia[i] = sa[la - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++)</span><br><span class="line">        ib[i] = sb[lb - i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; la; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ic[i + j] = ic[i + j] + ia[j] * ib[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * la; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ic[i] &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ic[i + <span class="number">1</span>] = ic[i + <span class="number">1</span>] + ic[i] / <span class="number">10</span>;</span><br><span class="line">            ic[i] = ic[i] % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span> * la;</span><br><span class="line">    <span class="keyword">while</span>(ic[j] == <span class="number">0</span>)</span><br><span class="line">        j--;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        cout &lt;&lt; ic[j];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大数除法"><a href="#大数除法" class="headerlink" title="大数除法"></a>大数除法</h1><p>参考：<br><a href="http://www.cnblogs.com/wuqianling/p/5387099.html">http://www.cnblogs.com/wuqianling/p/5387099.html</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数sub功能： </span></span><br><span class="line"><span class="comment">用长度为len1的大整数num1减去长度为len2的大整数num2 </span></span><br><span class="line"><span class="comment">结果存在num1中，返回值代表结果的长度 </span></span><br><span class="line"><span class="comment">不够减：返回-1 ， 正好够：返回0</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> *num1, <span class="type">int</span> len1, <span class="type">int</span> *num2, <span class="type">int</span> len2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1 == len2) <span class="comment">//两数字位数相同时，对比哪个数大</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num1[i] &gt; num2[i]) <span class="comment">//num1大，满足条件</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num1[i] &lt; num2[i]) <span class="comment">//当n2大于n1时，此时不够减，返回－1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len1 - <span class="number">1</span>; i++) <span class="comment">//减法操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        num1[i] -= num2[i];</span><br><span class="line">        <span class="keyword">if</span>(num1[i] &lt; <span class="number">0</span>) <span class="comment">//需要借位</span></span><br><span class="line">        &#123;</span><br><span class="line">            num1[i] += <span class="number">10</span>;</span><br><span class="line">            num1[i + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len1 - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--) <span class="comment">//去除前导0，查找结果最高位。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num1[i])</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//两数相等时返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大数除法---结果不包括小数点 </span></span><br><span class="line"><span class="comment">num1 / num2  </span></span><br><span class="line"><span class="comment">ans:结果数组,商，存放计算的结果，</span></span><br><span class="line"><span class="comment">即：num1/num2=ans</span></span><br><span class="line"><span class="comment">返回数组ans的有效长度，即商的位数 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">division</span><span class="params">(<span class="type">char</span>* num1, <span class="type">char</span>* num2, <span class="type">char</span>* ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">strlen</span>(num1);</span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(num2);</span><br><span class="line">    <span class="type">int</span> num_a[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num_b[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num_c[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++) <span class="comment">//将字符数字每个数字处理为int，然后倒序存在另外一个数组</span></span><br><span class="line">        num_a[i] = num1[len1 - i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">        num_b[i] = num2[len2 - i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len1 &lt; len2) <span class="comment">//如果被除数小于除数，直接返回-1，表示结果为0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dvalue = len1 - len2; <span class="comment">//两大数相差位数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进行扩展，不是一个个减，而是以其10的倍数减，刚开始扩展到与被除数相等的位数，即相当于乘以10的x次方</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= dvalue)</span><br><span class="line">            num_b[i] = num_b[i - dvalue];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num_b[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    len2 = len1;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//进行减法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= dvalue; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//num_b + i代表不断尝试10的x次方,因为其后面为0,故相当于乘以10的x次方</span></span><br><span class="line">        <span class="keyword">while</span>((n = <span class="built_in">sub</span>(num_a, len1, num_b + i, len2 - i)) &gt;= <span class="number">0</span>) <span class="comment">//不断尝试将除数扩大来减</span></span><br><span class="line">        &#123;</span><br><span class="line">            len1 = n;</span><br><span class="line">            num_c[dvalue - i]++; </span><br><span class="line">            <span class="comment">//对应的结果位数++，刚开始加的位数很大，比如百位，然后除数逐渐减少，对应的就会加在十位个位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="comment">//跳过高位0，获取商的位数</span></span><br><span class="line">    <span class="keyword">for</span>(j = MAXN - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num_c[j] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">-1</span>; <span class="comment">//商的位数</span></span><br><span class="line">    <span class="keyword">if</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">        len = j + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//因为得到的结果是倒序的，故倒序将结果复制到ans数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; j &gt;= <span class="number">0</span>; i++, j--)</span><br><span class="line">        ans[i] = num_c[j];</span><br><span class="line">    ans[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> num1[MAXN] = <span class="string">&quot;1234567899876543210&quot;</span>;</span><br><span class="line">    <span class="type">char</span> num2[MAXN] = <span class="string">&quot;20160415123025&quot;</span>;</span><br><span class="line">    <span class="type">char</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">division</span>(num1, num2, ans);</span><br><span class="line">    <span class="keyword">if</span>(len &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            cout &lt;&lt; ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串常见算法--kmp，E-kmp，manacher，ac自动机</title>
      <link href="/2018/10/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-kmp%EF%BC%8CE-kmp%EF%BC%8Cmancher%EF%BC%8Cac%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2018/10/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-kmp%EF%BC%8CE-kmp%EF%BC%8Cmancher%EF%BC%8Cac%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>kmp，E-kmp，manacher，ac自动机</p> <span id="more"></span><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p><a href="http://t.cn/EZlzRyg">http://t.cn/EZlzRyg</a></p><h1 id="Manacher—最长回文串O-N"><a href="#Manacher—最长回文串O-N" class="headerlink" title="Manacher—最长回文串O(N)"></a>Manacher—最长回文串O(N)</h1><h2 id="关于求最长回文串办法"><a href="#关于求最长回文串办法" class="headerlink" title="关于求最长回文串办法"></a>关于求最长回文串办法</h2><p><a href="https://www.jianshu.com/p/c82cada7e5b0">四种方法求最长回文串</a></p><p>但是上面几种都不是最快的，最快的是Manacher（马拉车）算法，算法复杂度是O(N)</p><h2 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h2><p><a href="https://www.cnblogs.com/grandyang/p/4475985.html">https://www.cnblogs.com/grandyang/p/4475985.html</a></p><p><a href="https://www.cnblogs.com/z360/p/6375514.html">https://www.cnblogs.com/z360/p/6375514.html</a></p><p><a href="https://segmentfault.com/a/1190000008484167">https://segmentfault.com/a/1190000008484167</a></p><p><a href="https://www.bilibili.com/video/av4829276?from=search&amp;seid=9253656566579281943">https://www.bilibili.com/video/av4829276?from=search&amp;seid=9253656566579281943</a></p><p><a href="https://www.bilibili.com/video/av20495920?from=search&amp;seid=9253656566579281943">https://www.bilibili.com/video/av20495920?from=search&amp;seid=9253656566579281943</a></p><h3 id="模板题—HDU-3068-最长回文"><a href="#模板题—HDU-3068-最长回文" class="headerlink" title="模板题—HDU-3068(最长回文)"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068">模板题—HDU-3068(最长回文)</a></h3><p>注意，此题别的算法O(NlogN)都会超时，所以只能用马拉车的O(N)算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Exe.Time:1154MS</span></span><br><span class="line"><span class="comment">Exe.Memory:3328K</span></span><br><span class="line"><span class="comment">Submit Time:2018-10-27 19:10:19</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span>;</span><br><span class="line"><span class="type">int</span> p[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function">string <span class="title">Manacher</span><span class="params">(string s)</span> <span class="comment">//返回一个字符串，该字符串为形参s的最长回文串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t = <span class="string">&quot;$#&quot;</span>; <span class="comment">//字符串开头增加一个特殊字符&#x27;$&#x27;，防止越界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) <span class="comment">//扩展原来的字符串，使之字符个数为奇数(不包括字符&#x27;$&#x27;)</span></span><br><span class="line">    &#123;</span><br><span class="line">        t += s[i];</span><br><span class="line">        t += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mx即为当前计算回文串最右边字符的最大值</span></span><br><span class="line">    <span class="comment">//id为能延伸到最右端的位置的那个回文子串的中心点位置</span></span><br><span class="line">    <span class="comment">//maxLen：最长的长度</span></span><br><span class="line">    <span class="comment">//maxCenter：最长回文中心</span></span><br><span class="line">    <span class="type">int</span> mx = <span class="number">0</span>, id = <span class="number">0</span>, maxLen = <span class="number">0</span>, maxCenter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; t.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = mx &gt; i ? <span class="built_in">min</span>(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>; <span class="comment">//取min是为了防止超过mx</span></span><br><span class="line">        <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i]; </span><br><span class="line">        <span class="comment">/*暴力从某一个点从左右扩展，注意此时p[i]的取值，</span></span><br><span class="line"><span class="comment">         *例如当mx&lt;i时，p[i]=1， 那么说此时最长回文是自己，然后拓展匹配</span></span><br><span class="line"><span class="comment">         *不需边界判断，因为左有&#x27;$&#x27;,右有&#x27;\0&#x27;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *我们每走一步 i，都要和 mx 比较</span></span><br><span class="line"><span class="comment">         *我们希望 mx 尽可能的远，这样才能更有机会执行 if (i &lt; mx)这句代码，从而提高效率</span></span><br><span class="line"><span class="comment">         *即不断更新值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (mx &lt; i + p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            mx = i + p[i];</span><br><span class="line">            id = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            maxLen = p[i];</span><br><span class="line">            maxCenter = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>((maxCenter - maxLen) / <span class="number">2</span>, maxLen - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//最长子串的长度是半径减1，起始位置是中间位置减去半径再除以2。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">Manacher</span>(s).<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">//输出最长回文长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基于URL网络编程--获取网页HTML</title>
      <link href="/2018/09/30/java%E5%9F%BA%E4%BA%8EURL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5HTML/"/>
      <url>/2018/09/30/java%E5%9F%BA%E4%BA%8EURL%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5HTML/</url>
      
        <content type="html"><![CDATA[<p>JAVA URL编程</p><span id="more"></span><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>创建一个URL。</li><li>获取URLConnection对象。</li><li>在URLConnection上设置输出功能。</li><li>从连接获取输入或输出流。</li><li>读取输入流或写入输出流。</li><li>关闭输入流或输出流。</li></ol><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="创建一个URL"><a href="#创建一个URL" class="headerlink" title="创建一个URL"></a>创建一个URL</h2><h3 id="URL在程序中的表示"><a href="#URL在程序中的表示" class="headerlink" title="URL在程序中的表示"></a>URL在程序中的表示</h3><p>在Java中定义了一个URL类，该类可以封装URL信息，创建一个URL对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="URL构造办法"><a href="#URL构造办法" class="headerlink" title="URL构造办法"></a>URL构造办法</h3><p>常用的传一个网址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URL(String spec)</span><br><span class="line"><span class="comment">//从 String表示形成一个 URL对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">myURL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://example.com/&quot;</span>);</span><br></pre></td></tr></table></figure><p>还有根据协议，端口等等进行创建的。</p><h3 id="使用URL对象"><a href="#使用URL对象" class="headerlink" title="使用URL对象"></a>使用URL对象</h3><p>创建完成URL对象后，可以像使用普通的类对象一样去调用URL类的各种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getHost</span><span class="params">( )</span></span><br><span class="line"><span class="comment">//返回URL的主机名</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getPort</span><span class="params">( )</span></span><br><span class="line"><span class="comment">//返回URL的端口号, 如果没有设置端口号返回值为-1）。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getFile</span><span class="params">( )</span></span><br><span class="line"><span class="comment">//返回URL的文件名及路径。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getRef</span><span class="params">( )</span></span><br><span class="line"><span class="comment">//返回URL的标记    </span></span><br></pre></td></tr></table></figure><p>等等</p><h2 id="获取URLConnection对象"><a href="#获取URLConnection对象" class="headerlink" title="获取URLConnection对象"></a>获取URLConnection对象</h2><h3 id="URL与URLConnection"><a href="#URL与URLConnection" class="headerlink" title="URL与URLConnection"></a>URL与URLConnection</h3><ul><li>概念</li></ul><p>​        URL类将URL地址封装成对象，提供了解析URL地址的方法，如获取uri部分、host部分、端口等。</p><p>​         URLConnection则是URL对象和Socket连接给结合起来了，使得可以更轻松地获取发起URL请求的连接套接字。</p><ul><li>两者关系</li></ul><p>​         通过URL的openConnection()方法可以获取URLConnection对象，这个对象是面对这个URL的连接。</p><p>​        也就是说，这个对象其实是一个已连接套接字，它不仅具有解析http响应报文的功能，还具有套接字的相关功能(例如获取输入流、输出流等)。</p><ul><li>仅就解析对象来说，URL对象解析的是URL地址，可以看作是解析http请求报文(如getPort(),getFile()等)，而URLConnection则解析的是http响应报文(如getLastModified(),getHeaderFields()等)。</li></ul><h3 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.net.URLConnection</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">URLConnection</span> <span class="keyword">extends</span> <span class="title class_">Object</span></span><br></pre></td></tr></table></figure><p>可以由URL获得URLConnection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URLConnection(URL url)</span><br><span class="line"><span class="comment">//构造与指定URL的URL连接。</span></span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> url.openConnection();<span class="comment">//获取URLConnection对象</span></span><br></pre></td></tr></table></figure><h2 id="获取网络输入流"><a href="#获取网络输入流" class="headerlink" title="获取网络输入流"></a>获取网络输入流</h2><p>防止读取超时可以设置一波连接超时时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setConnectTimeout(<span class="type">int</span> timeout)</span><br><span class="line"><span class="comment">//设置打开与此URLConnection引用的资源的通信链接时使用的指定超时值（以毫秒为单位）。</span></span><br><span class="line">conn.setConnectTimeout(<span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">//conn：URLConnection对象</span></span><br></pre></td></tr></table></figure><p>获取网络输入流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> conn.getInputStream();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战程序设计竞赛---poj2431(贪心+优先队列)</title>
      <link href="/2018/09/29/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-poj2431-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2018/09/29/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-poj2431-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>贪心，优先队列</p><span id="more"></span><p><strong>题目链接：</strong><a href="http://poj.org/problem?id=2431">http://poj.org/problem?id=2431</a></p><p><strong>题目大意：</strong></p><p>一辆卡车，初始时，距离终点L，油量为P，在起点到终点途中有n个加油站，每个加油站油量有限，而卡车的油箱容量无限，卡车在行车途中，每走一个单位的距离消耗一个单位的油量，给定n个加油站距离终点的距离以及油存储量。问卡车是否能到达终点，如果可达，最少需要加多少次油，否则输出-1.</p><p><strong>题目思路：</strong></p><p>采用贪心的思想，卡车当然在不加油的情况下走的越远越好了，而当它没油时，我们再判断卡车在经过的途中的加油站，哪个加油站加的油最多，选油量最多的，这样后面加油次数也越少，然后又继续行驶，当它又没油了的时候，继续选它从起点到该点所经过的加油站油量最多的加油。</p><p>做法先将加油站到终点的距离由远到近排下序，这样离起点就是由近到远。就是每经过一个加油站就将该加油站的油量压入优先队列中，然后每次没油的时候，去队首元素加油即可。</p><p>参考：<a href="https://www.cnblogs.com/zjl192628928/p/9414201.html">https://www.cnblogs.com/zjl192628928/p/9414201.html</a></p><p><em>为什么这样做呢，经过加油站后还可以加油？其实不是这样的，只是预先模拟汽车到达那个加油站的情况，并不是汽车真正到达那个加油站，这样才能预算沿途究竟在哪个加油站加油最好。之前纠结这个有点久2333，后来就想想这个只是预想汽车到达那个加油站，并没有真正到达</em></p><p><strong>Code</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Submit Time:2018-09-29 12:18:22</span></span><br><span class="line"><span class="comment">Time:172MS</span></span><br><span class="line"><span class="comment">Memory:300K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span>;</span><br><span class="line"><span class="comment">//代表一个加油站，x代表距离终点位置，y代表能加的油量</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;stru[MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x1, node x2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x<span class="number">1.</span>x &lt; x<span class="number">2.</span>x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> p, l, n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; stru[i].x &gt;&gt; stru[i].y;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为给的是距离终点的距离，不是距离起点，所以得算出距离起点的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        stru[i].x = p - stru[i].x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将终点也看是一个加油站，避免一些特殊情况，比如</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    3 1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    stru[n].x = p;</span><br><span class="line">    stru[n].y = <span class="number">0</span>;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">sort</span>(stru, stru + n, cmp); <span class="comment">//因为题目不一定按顺序输入，所以得手动排序，将离起点最近的放在前面</span></span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt;pq;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, pos = <span class="number">0</span>, tank = l; <span class="comment">//ans:加油次数，pos：现在所在位置，tank：油箱中的汽油量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//模拟经过所有加油站</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = stru[i].x - pos; <span class="comment">//到下一个加油站需要的路程</span></span><br><span class="line">        <span class="keyword">while</span>(tank - d &lt; <span class="number">0</span>) <span class="comment">//到不了了，需要在沿途加油</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">empty</span>()) <span class="comment">//没有加油站可以加油，输入-1，代表到达不了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tank += pq.<span class="built_in">top</span>(); <span class="comment">//否则找个加油站，加最多的油，正好优先队列第一个元素就是最大值</span></span><br><span class="line">            pq.<span class="built_in">pop</span>(); </span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tank -= d; <span class="comment">//如果到达的了这个加油站，说明油够，不需要加，那么只需要减去到达这个加油站的油量就行了</span></span><br><span class="line">        pos = stru[i].x; <span class="comment">//位置更新为这个加油站</span></span><br><span class="line">        pq.<span class="built_in">push</span>(stru[i].y); </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 挑战程序设计 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOC学习python爬虫之中国大学排名</title>
      <link href="/2018/09/25/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8B%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D/"/>
      <url>/2018/09/25/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8B%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>定向爬虫</p><span id="more"></span><h1 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6.png"></p><p><strong>还得确定排名信息是不是写在HTML里面</strong></p><h1 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A62.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A63.png"></p><h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A64.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getHTMLTest</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r = requests.get(url)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding = r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fillUnivList</span>(<span class="params">ulist, html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr, bs4.element.Tag):</span><br><span class="line">            tds = tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string, tds[<span class="number">1</span>].string, tds[<span class="number">2</span>].string, tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printUnivLIst</span>(<span class="params">ulist, num</span>):</span><br><span class="line">    tplt = <span class="string">&quot;&#123;0:^10&#125;\t&#123;1:^10&#125;\t&#123;2:&#123;4&#125;^10&#125;\t&#123;3:^10&#125;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(tplt.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>, <span class="string">&quot;学校名称&quot;</span>, <span class="string">&quot;地区&quot;</span>, <span class="string">&quot;分数&quot;</span>, <span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u = ulist[i]</span><br><span class="line">        <span class="built_in">print</span>(tplt.<span class="built_in">format</span>(u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], u[<span class="number">3</span>], <span class="built_in">chr</span>(<span class="number">12288</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    uinfo = []</span><br><span class="line">    url = <span class="string">&#x27;http://www.zuihaodaxue.cn/zuihaodaxuepaiming2018.html&#x27;</span></span><br><span class="line">    html = getHTMLTest(url)</span><br><span class="line">    fillUnivList(uinfo, html)</span><br><span class="line">    printUnivLIst(uinfo, <span class="number">20</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E5%8F%96%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A65.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOC学习python爬虫之beautifulsoup</title>
      <link href="/2018/09/24/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8Bbeautifulsoup/"/>
      <url>/2018/09/24/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8Bbeautifulsoup/</url>
      
        <content type="html"><![CDATA[<p>beautifulsoup4</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br><span class="line"><span class="comment">#python 3.6 deepin15.7</span></span><br></pre></td></tr></table></figure><h1 id="bs4理解以及引用"><a href="#bs4理解以及引用" class="headerlink" title="bs4理解以及引用"></a>bs4理解以及引用</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E7%90%86%E8%A7%A3.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E7%B1%BB.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs4%E5%BC%95%E7%94%A8%60.png"></p><h1 id="bs类基本元素"><a href="#bs类基本元素" class="headerlink" title="bs类基本元素"></a>bs类基本元素</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0.png"></p><h2 id="Name属性"><a href="#Name属性" class="headerlink" title="Name属性"></a>Name属性</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A02.png"></p><h2 id="Attribus属性"><a href="#Attribus属性" class="headerlink" title="Attribus属性"></a>Attribus属性</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A03.png"></p><h2 id="NavigableString属性"><a href="#NavigableString属性" class="headerlink" title="NavigableString属性"></a>NavigableString属性</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A04.png"></p><h1 id="Comment属性"><a href="#Comment属性" class="headerlink" title="Comment属性"></a>Comment属性</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A05.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/pythob-bs%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A06.png"></p><h1 id="HTML基本格式以及遍历"><a href="#HTML基本格式以及遍历" class="headerlink" title="HTML基本格式以及遍历"></a>HTML基本格式以及遍历</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html2.png"></p><h2 id="下行遍历"><a href="#下行遍历" class="headerlink" title="下行遍历"></a>下行遍历</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html3.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/pythob-html4.png"></p><h2 id="上行遍历"><a href="#上行遍历" class="headerlink" title="上行遍历"></a>上行遍历</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html5.png"></p><h2 id="平行遍历"><a href="#平行遍历" class="headerlink" title="平行遍历"></a>平行遍历</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html6.png"></p><p>迭代类型：只能放在循环里面</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html7.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-html8.png"></p><h1 id="pretiffy"><a href="#pretiffy" class="headerlink" title="pretiffy()"></a>pretiffy()</h1><p>美化代码</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-prettify.png"></p><h1 id="find-all"><a href="#find-all" class="headerlink" title="find_all"></a>find_all</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all.png"></p><h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all2.png"></p><h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all3.png"></p><h2 id="recursive"><a href="#recursive" class="headerlink" title="recursive"></a>recursive</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all4.png"></p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all5.png"></p><h2 id="拓展办法"><a href="#拓展办法" class="headerlink" title="拓展办法"></a>拓展办法</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-find_all6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> beautifulsoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOC学习python爬虫之简单实战</title>
      <link href="/2018/09/24/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/"/>
      <url>/2018/09/24/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E4%B9%8B%E7%AE%80%E5%8D%95%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>简单抓取京东，亚马逊，搜索引擎信息，ip归属地查询</p><span id="more"></span><h1 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h1><p>无意外，status_code返回202</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E4%BA%AC%E4%B8%9C.png"></p><h1 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h1><p>status_code返回503。模拟一波head</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E5%A4%A9%E7%8C%AB.png"></p><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8E%A5%E5%8F%A3.png"></p><p>google:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com/search?q=keyword</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%99%BE%E5%BA%A6.png"></p><h1 id="爬取网页图片并且保存"><a href="#爬取网页图片并且保存" class="headerlink" title="爬取网页图片并且保存"></a>爬取网页图片并且保存</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E5%9B%BE%E7%89%87%E7%88%AC%E5%8F%96.png"></p><h1 id="IP地址归属地自动查询"><a href="#IP地址归属地自动查询" class="headerlink" title="IP地址归属地自动查询"></a>IP地址归属地自动查询</h1><p> <img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-ip.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOC学习python爬虫学习之Requests</title>
      <link href="/2018/09/23/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8BRequests/"/>
      <url>/2018/09/23/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8BRequests/</url>
      
        <content type="html"><![CDATA[<p>Python-Requests库</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests</span><br><span class="line"><span class="comment"># python3 deepin15.6</span></span><br></pre></td></tr></table></figure><h1 id="Requests库的7个主要办法"><a href="#Requests库的7个主要办法" class="headerlink" title="Requests库的7个主要办法"></a>Requests库的7个主要办法</h1><div class="table-container"><table><thead><tr><th>requests.request()</th><th>构造一个请求，支撑以下各方法的基础方法</th></tr></thead><tbody><tr><td>requests.get()</td><td>获取HTML网页的主要方法，对应于HTTP的GET</td></tr><tr><td>requests.head()</td><td>获取HTML网页头信息的方法，对应于HTTP的HEAD</td></tr><tr><td>requests.post()</td><td>向HTML网页提交POST请求的方法，对应于HTTP的POST</td></tr><tr><td>requests.put()</td><td>向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td></tr><tr><td>requests.patch()</td><td>向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td>requests.delete()</td><td>向HTML页面提交删除请求，对应于HTTP的DELETE</td></tr></tbody></table></div><h1 id="request-get"><a href="#request-get" class="headerlink" title="request.get()"></a>request.get()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests2.png"></p><h1 id="requests-head"><a href="#requests-head" class="headerlink" title="requests.head()"></a>requests.head()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-gead.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-head.png"></p><p><em>HEAD获取头部信息，没有html主体，故r.text为空</em>‘</p><h1 id="requests-post"><a href="#requests-post" class="headerlink" title="requests.post()"></a>requests.post()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-post.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-post.png"></p><h1 id="requests-put"><a href="#requests-put" class="headerlink" title="requests.put()"></a>requests.put()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-put.png"></p><h1 id="requests-patch"><a href="#requests-patch" class="headerlink" title="requests.patch()"></a>requests.patch()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-patch.png"></p><h1 id="requests-delete"><a href="#requests-delete" class="headerlink" title="requests.delete()"></a>requests.delete()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-delete.png"></p><h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests3.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-Response.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-response.png"></p><h1 id="Requests库的异常"><a href="#Requests库的异常" class="headerlink" title="Requests库的异常"></a>Requests库的异常</h1><p> <img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests%E5%BC%82%E5%B8%B8.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r.raise_for_status() <span class="comment">#如果不是200，产生异常requests.HTTPError</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python%E7%88%AC%E5%8F%96%E7%BD%91%E9%A1%B5%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6.png"></p><h1 id="Http协议对资源的操作"><a href="#Http协议对资源的操作" class="headerlink" title="Http协议对资源的操作"></a>Http协议对资源的操作</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-http%E5%AF%B9%E5%BF%97%E6%84%BF%E7%9A%84%E6%93%8D%E4%BD%9C.png"></p><h1 id="resquests-request"><a href="#resquests-request" class="headerlink" title="resquests.request()"></a>resquests.request()</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-request.png"></p><p><strong>kwargs参数讲解</strong></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request2.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request3.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request4.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request5.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request6.png"></p><p> <img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request7.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request8.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-requests-request9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> requests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MOOC学习python爬虫学习之入门</title>
      <link href="/2018/09/23/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/23/MOOC%E5%AD%A6%E4%B9%A0python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>入门</p><span id="more"></span><h1 id="几个库"><a href="#几个库" class="headerlink" title="几个库"></a>几个库</h1><p>Requests：自动爬取HTML页面，自动网络请求提交</p><p>robots.txt：网络爬虫排除标准</p><p>Beautiful Soup：解析HTML页面</p><p>Scrapy：爬虫框架</p><p>采用Python 3.x系列版本</p><h1 id="网络爬虫尺寸"><a href="#网络爬虫尺寸" class="headerlink" title="网络爬虫尺寸"></a>网络爬虫尺寸</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/python-%E7%88%AC%E8%99%AB%E5%B0%BA%E5%AF%B8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战程序设计竞赛---POJ3253切木板</title>
      <link href="/2018/09/23/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-POJ3253%E5%88%87%E6%9C%A8%E6%9D%BF/"/>
      <url>/2018/09/23/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-POJ3253%E5%88%87%E6%9C%A8%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>《挑战程序设计竞赛》—贪心法另一例子</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%87%E6%9C%A8%E6%9D%BF.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%87%E6%9C%A8%E6%9D%BF2.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%88%87%E6%9C%A8%E6%9D%BF3.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战程序设计 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战程序设计竞赛---区间问题（选择最多的工作量）贪心</title>
      <link href="/2018/09/23/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%88%E9%80%89%E6%8B%A9%E6%9C%80%E5%A4%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%87%8F%EF%BC%89%E8%B4%AA%E5%BF%83/"/>
      <url>/2018/09/23/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%88%E9%80%89%E6%8B%A9%E6%9C%80%E5%A4%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%87%8F%EF%BC%89%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>《挑战程序设计竞赛》—-贪心</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%982.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%983.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%984png.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战程序设计 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战程序设计--- 任意四个数字为定和</title>
      <link href="/2018/09/22/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BB%BB%E6%84%8F%E5%9B%9B%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B8%BA%E5%AE%9A%E5%92%8C/"/>
      <url>/2018/09/22/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E4%BB%BB%E6%84%8F%E5%9B%9B%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B8%BA%E5%AE%9A%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>《挑战程序设计级竞赛》抽签问题—-任意四个数字为定和</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%98.png"><br><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%982.png"><br><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%983.jpg"><br><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%984.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%985.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%8A%BD%E7%AD%BE%E9%97%AE%E9%A2%986.png"></p><p><em>扩展此类题目可看</em></p><p><a href="https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.03.html">https://wizardforcel.gitbooks.io/the-art-of-programming-by-july/content/02.03.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
            <tag> 挑战程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战程序设计--POJ1852(Ants)思维</title>
      <link href="/2018/09/22/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-POJ1852-Ants-%E6%80%9D%E7%BB%B4/"/>
      <url>/2018/09/22/%E6%8C%91%E6%88%98%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-POJ1852-Ants-%E6%80%9D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<p> 《挑战程序设计竞赛入门》—POJ1852</p><span id="more"></span><p><a href="http://poj.org/problem?id=1852">POJ1852 Ants（思维）</a></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/POJ1852-1.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/POJ1852-2.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/POJ1852-3.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-09-22 09:20:29</span></span><br><span class="line"><span class="comment"> Exe.Time:641MS Exe.Memory：572K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, n;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        <span class="type">int</span> minT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minT = <span class="built_in">max</span>(minT, <span class="built_in">min</span>(arr[i], l - arr[i])); <span class="comment">//求的是所有蚂蚁都下落的时间，所以求的是最大值，保证所有蚂蚁都下落了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxT = <span class="built_in">max</span>(maxT, <span class="built_in">max</span>(arr[i], l - arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; minT &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxT &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
            <tag> 挑战程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC之PreparedStatement对象执行SQL语句</title>
      <link href="/2018/09/18/JDBC%E4%B9%8BPreparedStatement%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/09/18/JDBC%E4%B9%8BPreparedStatement%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<p>实现Statement接口</p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>PreparedStatement实现了Statement接口，使用该接口类型的对象同样可以执行SQL语句。</p><p><strong>特点</strong></p><ul><li>预编译：创建时就包含了一个SQL语句，并送到数据库系统进行编译，下次再执行同样的对象就不用在编译了，节省时间。</li><li>SQL语句可以包含参数：使用采用参数的SQL语句的优点是可以使用相同的语句，并在每次执行它时提供不同的值</li></ul><h1 id="使用代码"><a href="#使用代码" class="headerlink" title="使用代码"></a>使用代码</h1><p><em>假设之前的工作已经做好，con是已经获取到的connection对象</em></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Preparestatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.execuQuery();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(rs.next())</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">&#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Preparestatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;insert into student1 values (?,?,?,?)&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Grade&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Sex&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">4</span>, <span class="string">&quot;Sno&quot;</span>);  </span><br><span class="line"><span class="type">int</span> numInsert=pstmt.executeUpdate(); <span class="comment">//返回插入的数量                                     </span></span><br></pre></td></tr></table></figure><p>setString是定义了字符串中第n个”?“字符的替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setString</span><span class="params">(<span class="type">int</span> parameterIndex, String x)</span> <span class="keyword">throws</span> SQLException</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Preparestatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;update student1 set NAME=?,SEX=?,DEPT=? where NO=?&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Name&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">2</span>, <span class="string">&quot;Grade&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">3</span>, <span class="string">&quot;Sex&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">4</span>, <span class="string">&quot;Sno&quot;</span>);  </span><br><span class="line"><span class="type">int</span> numDelete=pstmt.executeUpdate();</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Preparestatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;delete from student1 where NO=?&quot;</span>);</span><br><span class="line">pstmt.setString(<span class="number">1</span>, <span class="string">&quot;Sno&quot;</span>);</span><br><span class="line"><span class="type">int</span> numDelete=pstmt.executeUpdate();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2018/09/18/JDBC%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/18/JDBC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>java访问数据库技术</p><span id="more"></span><h1 id="JDBC概述以及功能"><a href="#JDBC概述以及功能" class="headerlink" title="JDBC概述以及功能"></a>JDBC概述以及功能</h1><p><strong>概述</strong></p><ul><li>JDBC（Java DataBase Connectivity）是数据库公司开发的一种提供给Java编程者使用的Java API（类库），能够帮助Java程序访问表格数据，主要应用在对关系数据库的访问中。</li><li>在Java程序中，需要JDK中java.sql和javax.sql包中的类和JDBC包中的类配合完成对数据库的访问。</li></ul><p><strong>功能</strong></p><ol><li>连接数据源（数据库）。</li><li>将SQL语句（查询、更新）发送到数据库。</li><li>获取并处理从数据库中返回的结果</li></ol><h1 id="基本代码"><a href="#基本代码" class="headerlink" title="基本代码"></a>基本代码</h1><p><em>省去项目加载驱动包过程，直接代码</em></p><h2 id="加载驱动类"><a href="#加载驱动类" class="headerlink" title="加载驱动类"></a>加载驱动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(driverClass);</span><br></pre></td></tr></table></figure><ul><li><p>Class.forName(xxx.xx.xx)返回的是一个类。<br>Class.forName(xxx.xx.xx)的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></table></figure><p><em>&lt;？&gt;是1.5的新特性，泛型  如果是?表示可以放Object类型以及他的子</em>类</p></li><li><p>driverClass：不同数据库的驱动类不一样</p><ul><li>MySQL的jdbc驱动类是： com.mysql.jdbc.Driver</li><li>Oracle的jdbc驱动类是：oracle.jdbc.driver.OracleDriver</li></ul></li></ul><h2 id="连接数据库，获取Connection对象"><a href="#连接数据库，获取Connection对象" class="headerlink" title="连接数据库，获取Connection对象"></a>连接数据库，获取Connection对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(URL, databaseUserName, databasePassword);</span><br></pre></td></tr></table></figure><ul><li>Connection：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Connection</span> <span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable;</span><br></pre></td></tr></table></figure><ul><li>DriverManager类的静态方法通过数据库URL，可以连接数据库并获得一个Connection对象，方法的后两个参数是连接数据库的用户名和密码。</li></ul><h2 id="获取Statement对象，用于执行SQL语句"><a href="#获取Statement对象，用于执行SQL语句" class="headerlink" title="获取Statement对象，用于执行SQL语句"></a>获取Statement对象，用于执行SQL语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span>  <span class="operator">=</span>  con.creatStatement();</span><br></pre></td></tr></table></figure><ul><li>Statement:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Statement</span> <span class="keyword">extends</span> <span class="title class_">Object</span>;</span><br></pre></td></tr></table></figure><ul><li><p>Statement对象:</p><p>由Connection对象获得Statement对象，Statement对象可以执行SQL语句：</p><ul><li>executeQuery方法执行查询语句</li><li>executeUpdate方法执行更新语句（增，删，改）</li></ul></li></ul><h2 id="执行SQL语句，获取查询结果"><a href="#执行SQL语句，获取查询结果" class="headerlink" title="执行SQL语句，获取查询结果"></a>执行SQL语句，获取查询结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(querySQL);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResultSet executeQuery(String sql) throws SQLException //执行给定的SQL语句，返回单个ResultSet对象</span><br></pre></td></tr></table></figure><p><em>querySQL代表是SQL的查询语句</em></p><ul><li>ResultSet:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultSet</span> <span class="keyword">extends</span> <span class="title class_">Wrapper</span>, AutoCloseable;</span><br></pre></td></tr></table></figure><h2 id="关闭数据库连接，释放资源"><a href="#关闭数据库连接，释放资源" class="headerlink" title="关闭数据库连接，释放资源"></a>关闭数据库连接，释放资源</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();rs = <span class="literal">null</span>;</span><br><span class="line">stmt.close(); stmt = <span class="literal">null</span>;</span><br><span class="line">con.close(); con = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>依次关闭ResultSet、Statement、Connection对象，通过赋值null释放资源。</p><h1 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h1><ol><li><p>ResultSet对象表示数据库查询结果集，可以看成一个数据表，通常通过执行查询数据库来生成。 </p></li><li><p>实现Statement接口的任何对象（包括PreparedStatement，CallableStatement和RowSet）都可以创建一个ResultSet对象。</p></li><li><p>访问ResultSet中的对象：</p><p>可以通过游标访问ResultSet对象中的数据，游标可以看做是指向ResultSet对象中的一行数据的指针。 </p><p>最初，游标位于数据表第一行之前。ResultSet.next()方法将游标移动到下一行。 如果游标位于最后一行之后，此方法返回false，否则返回true。 该方法可以作为while循环的条件，来遍历ResultSet中的所有数据。</p><p><strong>常用默认类型是游标只能前移，只读</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;Name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span><br><span class="line">String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span><br></pre></td></tr></table></figure><p>rs:数据集，即ResultSet对象。<br>​    rs.getInt(int index);<br>​    rs.getInt(String columName);<br>​    可以通过索引或者列名来获得查询结果集中的某一列的值。</p><h1 id="元数据-MetaData"><a href="#元数据-MetaData" class="headerlink" title="元数据(MetaData)"></a>元数据(MetaData)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>元数据：描述数据库或数据表本身属性的数据，例如数据库中的表名，每个表中的列名称，主键，外键，存储过程等。</p><p>所谓的MetaData在英文中的解释为“Data about Data”，直译成中文则为“有关数据的数据”或者“描述数据的数据”，实际上就是描述及解释含义的数据。以Result的MetaData为例，ResultSet是以表格的形式存在，所以getMetaData就包括了数据的字段名称、类型以及数目等表格所必须具备的信息。 </p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>JDBC提供了ResultSetMetaData接口，该接口可以获得数据表的元数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSetMetaData <span class="title function_">getMetaData</span><span class="params">()</span> <span class="comment">//ResultSet接口中定义了一个方法</span></span><br><span class="line"><span class="comment">//该方法返回的对象可以获取表的元数据，例如有多少列，列名是什么等</span></span><br></pre></td></tr></table></figure><h1 id="总结代码"><a href="#总结代码" class="headerlink" title="总结代码"></a>总结代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Statement</span> <span class="variable">stm</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库并且获取Statement对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DB</span><span class="params">(String driverClass, String dataBase, String usrName, String passWord)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(dataBase, usrName, passWord);</span><br><span class="line">            stm = con.createStatement();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryDatabase</span><span class="params">(String querySQL)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            rs = stm.executeQuery(querySQL);</span><br><span class="line">            <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount(); <span class="comment">//获取表的列数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++)</span><br><span class="line">                System.out.print(rsmd.getColumnName(i) + <span class="string">&quot; &quot;</span>); <span class="comment">//输出每一列的列名</span></span><br><span class="line">            System.out.println();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++)</span><br><span class="line">                    System.out.print(rs.getObject(i) + <span class="string">&quot;  &quot;</span>); <span class="comment">//输出每一列内容</span></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改数据库中的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDatabase</span><span class="params">(String updateSQL)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">numUpate</span> <span class="operator">=</span> stm.executeUpdate(updateSQL); <span class="comment">//返回已更新个数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;已更新了&quot;</span> + numUpate + <span class="string">&quot;条记录&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据库中的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDatabase</span><span class="params">(String deleteSQL)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stm.executeUpdate(deleteSQL);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往数据库中添加信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertDatabase</span><span class="params">(String insertSQL)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            stm.executeUpdate(insertSQL);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            rs.close();</span><br><span class="line">            rs = <span class="literal">null</span>;</span><br><span class="line">stmt.close(); </span><br><span class="line">            stmt = <span class="literal">null</span>;</span><br><span class="line">con.close(); </span><br><span class="line">            con = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">schema</span> <span class="operator">=</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">table</span> <span class="operator">=</span> <span class="string">&quot;new_table&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">database</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/&quot;</span> + schema + <span class="string">&quot;?useSSL=false&amp;serverTimezone=GMT%2B8&amp;characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">querySQL</span> <span class="operator">=</span> <span class="string">&quot;select* from &quot;</span> + table;</span><br><span class="line">        <span class="type">String</span> <span class="variable">updateSQL</span> <span class="operator">=</span> <span class="string">&quot;update &quot;</span> + table + <span class="string">&quot; set grade=70 where name=&#x27;小陈&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">deleteSQL</span> <span class="operator">=</span> <span class="string">&quot;delete from &quot;</span> + table + <span class="string">&quot; where name=&#x27;小丽&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insertSQL</span> <span class="operator">=</span> <span class="string">&quot;insert into &quot;</span> + table + <span class="string">&quot; values(&#x27;小白&#x27;, &#x27;男&#x27;, &#x27;98&#x27;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">DB</span> <span class="variable">db</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DB</span>(driverClass, database, username, password);</span><br><span class="line">        System.out.println(<span class="string">&quot;原先的数据库数据为&quot;</span>);</span><br><span class="line">        db.queryDatabase(querySQL);</span><br><span class="line">        System.out.println();</span><br><span class="line">        db.updateDatabase(updateSQL);</span><br><span class="line">        System.out.println(<span class="string">&quot;执行update将小陈成绩变成70&quot;</span>);</span><br><span class="line">        db.queryDatabase(querySQL);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;将名为小丽那一行删除&quot;</span>);</span><br><span class="line">        db.deleteDatabase(deleteSQL);</span><br><span class="line">        db.queryDatabase(querySQL);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;添加名为小白一行&quot;</span>);</span><br><span class="line">        db.insertDatabase(insertSQL);</span><br><span class="line">        db.queryDatabase(querySQL);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--deepin15.7环境下的配置</title>
      <link href="/2018/09/16/mySQL-deepin15-7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/16/mySQL-deepin15-7%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>deepin15.7基于debian9</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/deepin%E4%BF%A1%E6%81%AF.png"></p><p>为了还原最好的配置环境，先把MySQL的遗留配置以及部分依赖卸载干净</p><h1 id="使用APT删除MySQL"><a href="#使用APT删除MySQL" class="headerlink" title="使用APT删除MySQL"></a>使用APT删除MySQL</h1><p>参考：</p><p><a href="https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/index.html#apt-repo-remove">Removing MySQL with APT</a></p><p>要卸载MySQL服务器以及使用MySQL APT存储库安装的相关组件，首先，使用以下命令删除MySQL服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove mysql-server</span><br></pre></td></tr></table></figure><p>强力卸载可以使用以下这条命令（卸载并清除软件包的配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge mysql-server</span><br></pre></td></tr></table></figure><p>然后，删除使用MySQL服务器自动安装的任何其他软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure><p>如果要卸载MySQL其他组件，可以先看看软件包列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep mysql | grep ii</span><br></pre></td></tr></table></figure><p>然后再对应删除</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/mysql%E5%8D%B8%E8%BD%BD.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/mysql%E5%8D%B8%E8%BD%BD2.png"></p><h1 id="全新安装MySQL步骤之之配置软件源-APT"><a href="#全新安装MySQL步骤之之配置软件源-APT" class="headerlink" title="全新安装MySQL步骤之之配置软件源(APT)"></a>全新安装MySQL步骤之之配置软件源(APT)</h1><p>参考：</p><p><a href="https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/index.html#apt-repo-fresh-install">Steps for a Fresh Installation of MySQL</a></p><p>这里导入相关源的信息是用deb包，也可以自己手动编辑对应的源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.mysql.com//mysql-apt-config_0.8.10-1_all.deb</span><br></pre></td></tr></table></figure><p>然后安装对应的deb包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.8.10-1_all.deb</span><br></pre></td></tr></table></figure><p>接着会进入相关的设置</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/mysql-apt-config1.png"></p><p>因为本次配置的环境是debian stretch，所以选择debian stretch</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/mysql-apt-config2.png"></p><p>然后默认ok，然后就完成了apt源的设置</p><p>接着就是常规更新源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>重新配置mysql-apt-config</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure mysql-apt-config</span><br></pre></td></tr></table></figure><h1 id="全新安装MySQL步骤之之安装MySQL-APT"><a href="#全新安装MySQL步骤之之安装MySQL-APT" class="headerlink" title="全新安装MySQL步骤之之安装MySQL(APT)"></a>全新安装MySQL步骤之之安装MySQL(APT)</h1><p>通过以下命令安装MySQL,这将安装MySQL服务器的包，以及客户端和数据库公共文件的包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p><em>然后据说安装新版MySQL(8.0)没有出现设置root的提示框，确实，这次安装我也没有出现，那么就安装后再通过命令行设置</em></p><p>可选安装图形化管理工具workbench</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-workbench </span><br></pre></td></tr></table></figure><h1 id="完成上一步未完成的工作—-设置root密码"><a href="#完成上一步未完成的工作—-设置root密码" class="headerlink" title="完成上一步未完成的工作—-设置root密码"></a>完成上一步未完成的工作—-设置root密码</h1><p>参考：</p><p><a href="https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=168685&amp;highlight=mysql">deepin15.7安装mysql无输入密码提示，导致安装后无法使用mysql</a></p><p>登录Mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -uroot -p</span><br></pre></td></tr></table></figure><p>输入系统密码回车</p><p>然后输入，注意还有<code>;</code>号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use sql;</span><br></pre></td></tr></table></figure><p>回车，接着输入下面的命令,123456是将要设置的密码，然后可以自己更改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string=password(&#x27;123456&#x27;),plugin=&#x27;mysql_native_password&#x27; where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><p>回车，接着输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>回车，已经设置好了密码，输入<code>exit</code>回车退出命令行</p><h1 id="不知道密码登录MySQL"><a href="#不知道密码登录MySQL" class="headerlink" title="不知道密码登录MySQL"></a>不知道密码登录MySQL</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql stop回车</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysqld_safe --skip-grant-tables &amp;回车</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql回车</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> deepin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp</title>
      <link href="/2018/08/15/kmp/"/>
      <url>/2018/08/15/kmp/</url>
      
        <content type="html"><![CDATA[<p><strong>KMP是一个非常实用的字符串匹配算法</strong></p><span id="more"></span><p>推荐网站：</p><p><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html">https://www.cnblogs.com/yjiyjige/p/3263858.html</a> <a href="https://blog.csdn.net/starstar1992/article/details/54913261/">https://blog.csdn.net/starstar1992/article/details/54913261/</a></p><p>视频：</p><p> <a href="https://is.gd/KMP01">KMP字符串匹配算法1—-kmp如何运作</a> </p><p><a href="https://is.gd/KMP02">KMP字符串匹配算法2——代码实现</a></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/KMP1.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/kmp2.png"></p><h1 id="HDU-1711-Number-Sequence"><a href="#HDU-1711-Number-Sequence" class="headerlink" title="HDU - 1711 Number Sequence"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1711">HDU - 1711 Number Sequence</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-16 16:11:34</span></span><br><span class="line"><span class="comment"> Exe.Time:748MS Exe.Memory：5.4MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> type;</span><br><span class="line">type text[MAXN]; <span class="comment">//较长的</span></span><br><span class="line">type pattern[MAXN]; <span class="comment">//较短的</span></span><br><span class="line"><span class="type">int</span> prefix[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prefix</span><span class="params">(<span class="type">int</span> len_pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len_pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || pattern[i] == pattern[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span>(pattern[i] != pattern[j]) <span class="comment">//正常情况</span></span><br><span class="line">                prefix[i] = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//特殊情况，这里即为优化之处。考虑下AAAB, 防止4个A形成012在匹配时多次迭代</span></span><br><span class="line">                prefix[i] = prefix[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = prefix[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">int</span> len_text, <span class="type">int</span> len_pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">get_prefix</span>(len_pattern);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len_text)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || text[i] == pattern[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = prefix[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == len_pattern)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> len_text, len_pattern;</span><br><span class="line">        cin &gt;&gt; len_text &gt;&gt; len_pattern;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_text; i++)</span><br><span class="line">            cin &gt;&gt; text[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len_pattern; i++)</span><br><span class="line">            cin &gt;&gt; pattern[i];</span><br><span class="line">        <span class="built_in">kmp</span>(len_text, len_pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HDU-1358-Period—-求循环节还有次数"><a href="#HDU-1358-Period—-求循环节还有次数" class="headerlink" title="HDU 1358 Period—-求循环节还有次数"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1358">HDU 1358 Period—-求循环节还有次数</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符编号从<span class="number">1</span>开始，那么<span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>)，则i前面的串为一个轮回串，其中轮回子串出现i/(i-next[i])次。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-17 11:42:23</span></span><br><span class="line"><span class="comment"> Exe.Time:171MS Exe.Memory：6308K</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> type;</span><br><span class="line">type pattern[MAXN];</span><br><span class="line"><span class="type">int</span> prefix[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prefix</span><span class="params">(<span class="type">int</span> len_pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len_pattern)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || pattern[i] == pattern[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            prefix[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = prefix[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> len_pattern)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_pattern; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = i - prefix[i];</span><br><span class="line">        <span class="keyword">if</span>(i % tmp == <span class="number">0</span> &amp;&amp; i / tmp &gt; <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i / tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, cas = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; pattern;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; cas++ &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">get_prefix</span>(n);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; prefix[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">solve</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Test:</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">aaa</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">aabaabaabaab</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Output array of prefix(1 &lt;= i &lt;= n):</span></span><br><span class="line"><span class="comment">Test case #1</span></span><br><span class="line"><span class="comment">0 1 2 </span></span><br><span class="line"><span class="comment">Test case #2</span></span><br><span class="line"><span class="comment">0 1 0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KMP </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP</title>
      <link href="/2018/08/02/DP/"/>
      <url>/2018/08/02/DP/</url>
      
        <content type="html"><![CDATA[<p>动态规划</p><span id="more"></span><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>DP入门参考：<a href="https://www.sohu.com/a/153858619_466939">漫画：什么是动态规划？</a></p><p>进阶参考：<a href="https://blog.csdn.net/cc_again/article/details/25866971">【DP专辑】ACM动态规划总结</a></p><p><a href="http://www.cnblogs.com/raichen/p/5772056.html">http://www.cnblogs.com/raichen/p/5772056.html</a></p><p> <strong>动态规划原理</strong></p><p><strong>1-最优子结构</strong></p><p>用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。</p><p><strong>2-重叠子问题</strong></p><p>在斐波拉契数列，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/20170715205029376.png"></p><p><strong>3-无后效性</strong></p><p>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p><h1 id="数塔系列"><a href="#数塔系列" class="headerlink" title="数塔系列"></a>数塔系列</h1><p>首先什么是“数塔类型”？从某一点转向另一点或者说是从某一状态转向另一状态，有多种选择方式（比如这里的9-&gt;12 , 9-&gt;15），从中选取一条能产生最优值的路径。</p><p>参考：</p><p><a href="https://www.cnblogs.com/DiaoCow/archive/2010/04/18/1714859.html">动态规划“数塔”类型题目总结</a></p><h2 id="经典数塔HDU-2048"><a href="#经典数塔HDU-2048" class="headerlink" title="经典数塔HDU[2048]"></a>经典数塔<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2084">HDU[2048]</a></h2><p>数塔问题 ：要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？</p><p>数塔问题的经典解法是从后面算到前面，如果从前面算到后面很麻烦，因为后面一层有很多个数字是由少到多，如果反过来由多到少就简单了</p><p>分析：站在位置9，我们可以选择沿12方向移动，也可以选择沿着15方向移动，现在我们假设“已经求的”沿12方向的最大值x和沿15方向的最大值y，那么站在9的最大值必然是：Max(x,y) + 9。</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/数塔.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 13:05:10</span></span><br><span class="line"><span class="comment"> Exe.Time:171MS Exe.Memory：1848k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">111</span>;</span><br><span class="line"><span class="type">int</span> Map[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Map[i][j] = Map[i][j] + <span class="built_in">max</span>(Map[i + <span class="number">1</span>][j], Map[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; Map[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HDU1176-免费馅饼"><a href="#HDU1176-免费馅饼" class="headerlink" title="HDU1176[免费馅饼]"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1176">HDU1176[免费馅饼]</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第0秒                       5                         （这里的数字指的是第N秒可能到达的位置坐标）</span><br><span class="line"></span><br><span class="line">第1秒                     4 5 6</span><br><span class="line"></span><br><span class="line">第2秒                   3 4 5 6 7</span><br><span class="line"></span><br><span class="line">第3秒                 2 3 4 5 6 7 8</span><br><span class="line"></span><br><span class="line">第4秒               1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">第5秒             0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">第6秒             0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">第7秒 .................  </span><br><span class="line"></span><br><span class="line">可以发现从第5秒开始之后就都是 0 1 2 3 4 5 6 7 8 9 10 </span><br></pre></td></tr></table></figure><p>和“数塔”一样，它也是从某一点出发，有多个选择的问题（往前走一步，呆在原地，往后走一步）从中选择一条最优值路径（获得馅饼最多）。还是按照“数塔”的思考方式，我们可以假设“已经求得”下一个站在位置4获得的最大值x和呆在原地获得的最大值y以及站在位置6获得的最大值z,那么对于起始位置5获得最大值就是Max(x,y,z) ，因此可以得到状态转移方程为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[t][x] += <span class="built_in">max</span>(<span class="built_in">max</span>(dp[t + <span class="number">1</span>][x - <span class="number">1</span>], dp[t + <span class="number">1</span>][x + <span class="number">1</span>]),dp[t + <span class="number">1</span>][x]);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 17:53:03</span></span><br><span class="line"><span class="comment"> Exe.Time:265MS Exe.Memory：10012k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110000</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, Max, t, x;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        Max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; Max) <span class="comment">//记录最大时间，时间是纵坐标，落地点是横坐标</span></span><br><span class="line">                Max = t;</span><br><span class="line">            dp[t][x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(t = Max - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[t][<span class="number">0</span>] += <span class="built_in">max</span>(dp[t<span class="number">+1</span>][<span class="number">0</span>],dp[t<span class="number">+1</span>][<span class="number">1</span>]);<span class="comment">//每行的第一个只有二种选择</span></span><br><span class="line">            <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[t][x] += <span class="built_in">max</span>( <span class="built_in">max</span>(dp[t + <span class="number">1</span>][x - <span class="number">1</span>],dp[t + <span class="number">1</span>][x]),</span><br><span class="line">                                    dp[t + <span class="number">1</span>][x + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[t][<span class="number">10</span>] += <span class="built_in">max</span>(dp[t + <span class="number">1</span>][<span class="number">9</span>], dp[t + <span class="number">1</span>][<span class="number">10</span>]); <span class="comment">//每行的最后一个只有二种选择</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; endl;<span class="comment">//不是dp[1][5]，刚开始吃的不一定在5，有可能在4,6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poj1088-滑雪"><a href="#poj1088-滑雪" class="headerlink" title="poj1088(滑雪)"></a><a href="http://poj.org/problem?id=1088">poj1088(滑雪)</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">依然和“数塔”一样，从某一点出发，面临多个选择（往上，往左，往下，往右）从中选择一条最优值路径（滑雪距离最长）</span><br><span class="line">若对A点求，很显然它的最大值就为： <span class="built_in">Max</span>(上，右，下，左) + <span class="number">1</span></span><br><span class="line">因此对于任意位置[i,j], 其状态转移方程为：m[i][j] = <span class="built_in">Max</span>(m[i<span class="number">-1</span>][j] , m[i][j<span class="number">+1</span>] , m[i<span class="number">+1</span>][j] , m[i][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">由于这道题很难画出它的路径图（起点和终点都不知道）因此很难用“列表格”的方式自底向上求解。</span><br><span class="line"></span><br><span class="line">解题思路：设一与输入数组对应的状态数组 dp，其值代表输入数组中此点的最长滑雪路径。使用广搜填表，最后遍历输出最大值即可    </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 23:04:42</span></span><br><span class="line"><span class="comment"> Exe.Time:79MS Exe.Memory：320k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> row, col; <span class="comment">//二维数组的行与列</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Map[MAX][MAX];</span><br><span class="line"><span class="type">int</span> dp[MAX][MAX]; <span class="comment">// 记录每一个点的最大滑雪长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span> &amp;&amp; i &lt;= row &amp;&amp; j &lt;= col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断右边能不能走，同时要满足右边的数小</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(i, j + <span class="number">1</span>) &amp;&amp; Map[i][j] &gt; Map[i][j + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j + <span class="number">1</span>]) <span class="comment">//如果之前走过，那就比较下是现在的线路的值还是之前的大</span></span><br><span class="line">           Max = Max &gt; dp[i][j + <span class="number">1</span>] ? Max : dp[i][j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//没有走过的话，那就需要BFS一遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i, j + <span class="number">1</span>) ? Max : <span class="built_in">BFS</span>(i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i + <span class="number">1</span>, j) &amp;&amp; Map[i][j] &gt; Map[i + <span class="number">1</span>][j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i + <span class="number">1</span>][j] ? Max : dp[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i + <span class="number">1</span>, j) ? Max : <span class="built_in">BFS</span>(i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i, j - <span class="number">1</span>) &amp;&amp; Map[i][j] &gt; Map[i][j - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i][j - <span class="number">1</span>] ? Max : dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i, j - <span class="number">1</span>) ? Max : <span class="built_in">BFS</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, j) &amp;&amp; Map[i][j] &gt; Map[i - <span class="number">1</span>][j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i - <span class="number">1</span>][j] ? Max : dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i - <span class="number">1</span>, j) ? Max : <span class="built_in">BFS</span>(i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上下左右均不通，该点路径值为 1；</span></span><br><span class="line">    <span class="comment">// 否则取最大路径值加 1</span></span><br><span class="line">    <span class="comment">//将结果记录在dp数组中(记忆化搜索的重点)</span></span><br><span class="line">    <span class="keyword">if</span> (Max == <span class="number">0</span>)</span><br><span class="line">        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = <span class="number">1</span> + Max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; row &gt;&gt; col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="built_in">BFS</span>(i, j);</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; ans)</span><br><span class="line">                    ans = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><p>数位dp是一种计数用的dp，一般就是要统计一个区间内满足一些条件数的个数。</p><p>参考：</p><p><a href="https://blog.csdn.net/wust_zzwh/article/details/52100392">数位dp总结 之 从入门到模板</a></p><p><a href="https://www.bilibili.com/video/av27156563?from=search&amp;seid=3730573967901251511">数位dp记录——bili</a></p><h2 id="HDU3555-Bomb-模板题"><a href="#HDU3555-Bomb-模板题" class="headerlink" title="HDU3555( Bomb )模板题"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3555">HDU3555( Bomb )模板题</a></h2><p>题目大意：在[0,n]的范围内存在多少个数字含有49</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Judge Status : AcceptedLanguage : C++  </span></span><br><span class="line"><span class="comment">Submit Time：2018-08-07 15:54:05</span></span><br><span class="line"><span class="comment">Exe.Time:93MS Exe.Memory：1796k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> digit[<span class="number">20</span>]; <span class="comment">//存位数，最长20位</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>]; <span class="comment">//dp[i][j]表示当前第i位，前一位的数字是否是j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//len:第len个数位，if_num:判断某一位是否到到达约束数位, limit:上一位是否有限制</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="type">bool</span> if_num, <span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，既然是按位枚举，最低位是0，那么len == 0说明这个数我枚举完了</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//两个约束条件,limit防止前面的dp[len][if_num]让条件为真，比如dp[1][1]时，当百位有限制，</span></span><br><span class="line">    <span class="comment">// 而dp[1][1]之前有值了，如果没有limit，就会多算了。</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num]) <span class="comment">//不用去统计49</span></span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>); <span class="comment">//up:如果到了限制那个数位，那么就限制，否则循环0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(if_num &amp;&amp; i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i == <span class="number">4</span>, limit &amp;&amp; i == up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) <span class="comment">//如果没有约束，说明是完整计算的，那么就记忆下，下次直接就可以返回值了</span></span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="comment">//得到位数，存到k里面</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//从最高位开始枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        ll num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="comment">//solve:算的是没有49的个数</span></span><br><span class="line">        cout &lt;&lt; num + <span class="number">1</span> - <span class="built_in">solve</span>(num) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="稍微修改HDU2089-不要62"><a href="#稍微修改HDU2089-不要62" class="headerlink" title="稍微修改HDU2089(不要62)"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2089">稍微修改HDU2089(不要62)</a></h2><p>在HDU3555基础上面多了一个区间，开始的时候是给出最大值m，区间是1～m，现在是区间是n～m，那么只要solve(m) - solve(n - 1)就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-07 18:22:21</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS Exe.Memory：1792k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///标有改的注释是说这里相当于3555那道题变了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> digit[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="type">bool</span> if_num, <span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num]) </span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(if_num &amp;&amp; i == <span class="number">2</span>) <span class="comment">//改</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(if_num ==<span class="number">4</span> || i == <span class="number">4</span>) <span class="comment">//改</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i == <span class="number">6</span>, limit &amp;&amp; i == up); <span class="comment">//改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) </span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) </span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(m) - <span class="built_in">solve</span>(n - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="牛客—区间内数字含有6的个数"><a href="#牛客—区间内数字含有6的个数" class="headerlink" title="牛客—区间内数字含有6的个数"></a><a href="https://ac.nowcoder.com/acm/contest/329/G">牛客—区间内数字含有6的个数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Submit Time 2019-01-27 23:21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> digit[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="type">bool</span> if_num, <span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> if_num;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num])</span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, if_num || i == <span class="number">6</span>, limit &amp;&amp;i == digit[len]);</span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(m) - <span class="built_in">solve</span>(n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LCIS—最长上升公共子序列"><a href="#LCIS—最长上升公共子序列" class="headerlink" title="LCIS—最长上升公共子序列"></a>LCIS—最长上升公共子序列</h1><p>讲解：</p><p><a href="https://www.cnblogs.com/wd-one/p/4470844.html">zoj2432 hdoj1423 最长公共上升子序列（LCIS）</a></p><p><a href="https://www.cnblogs.com/WArobot/p/7479431.html">LCIS 最长公共上升子序列问题DP算法及优化</a></p><h2 id="模板题HDU1423-Greatest-Common-Increasing-Subsequence"><a href="#模板题HDU1423-Greatest-Common-Increasing-Subsequence" class="headerlink" title="模板题HDU1423(Greatest Common Increasing Subsequence)"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1423">模板题HDU1423(Greatest Common Increasing Subsequence)</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-09-07 21:30:12</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS Exe.Memory：5712KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> s1[MAXN], s2[MAXN];</span><br><span class="line"><span class="type">int</span> len1, len2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCIS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp[MAXN][MAXN]  = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> maxdp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[j])</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &gt; s2[j] &amp;&amp; maxdp &lt; dp[i + <span class="number">1</span>][j])</span><br><span class="line">                maxdp = dp[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = maxdp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i + <span class="number">1</span>][j] &gt; ans)</span><br><span class="line">                ans = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; len1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">            cin &gt;&gt; s1[i];</span><br><span class="line">        cin &gt;&gt; len2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">            cin &gt;&gt; s2[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LCIS</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(test)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LIS—最长递增子序列"><a href="#LIS—最长递增子序列" class="headerlink" title="LIS—最长递增子序列"></a>LIS—<strong>最长递增子序列</strong></h1><p>问题描述：找出一个n个数的序列的最长单调递增子序列： 比如<code>A = &#123;5,6,7,1,2,8&#125;</code> 的LIS是<code>5,6,7,8</code></p><h2 id="O-n-2-的复杂度"><a href="#O-n-2-的复杂度" class="headerlink" title="O(n^2)的复杂度"></a><code>O(n^2)</code>的复杂度</h2><p><strong>最优子结构</strong></p><p> 假设<code>LIS[i]</code> 是以<code>arr[i]</code>为末尾的LIS序列的长度。则：</p><p> <code>LIS[i] = &#123;1+Max(LIS(j))&#125;</code>; <code>j&lt;i, arr[j]&lt;arr[i]</code>; </p><p><code>LIS[i] = 1, j&lt;i</code>, 但是不存在<code>arr[j]&lt;arr[i]</code>; </p><p>所以问题转化为计算<code>Max(LIS(j))</code> <code>0&lt;i&lt;n</code></p><p><strong>重叠的子问题</strong></p><p>以<code>arr[i] (1&lt;= i &lt;= n)</code>每个元素结尾的LIS序列的值是 重叠的子问题。 </p><p>所以填表时候就是建立一个数组<code>DP[i]</code>, 记录以<code>arr[i]</code>为序列末尾的LIS长度。</p><p><strong>DP[i]怎么计算？</strong></p><p>遍历所有<code>j&lt;i</code>的元素，检查是否<code>DP[j]+1&gt;DP[i] &amp;&amp; arr[j]&lt;arry[i]</code> 若是，则可以更新<code>DP[i]</code></p><p><strong>图示</strong></p><ul><li>arr[1]到arr[9]存值</li><li>LIS代表此元素到arr[1]的LIS</li><li>LIS来源代表是从哪个继承而来，值为数组下标</li></ul><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/LIS.png"></p><p><strong>HDU1257(最少拦截系统)模板题</strong></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1257">http://acm.hdu.edu.cn/showproblem.php?pid=1257</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 11:16:58</span></span><br><span class="line"><span class="comment"> Exe.Time:62MS Exe.Memory：1844k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dp_len = len + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[dp_len];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[<span class="number">0</span>]) * dp_len); <span class="comment">//创建动态数组并且初始化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// int * dp = new int[dp_len]();</span></span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)  <span class="comment">//找出dp数组中最大的那个值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; MAX)</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://segmentfault.com/a/1190000002641054">算法设计 - LCS 最长公共子序列&amp;&amp;最长公共子串 &amp;&amp;LIS 最长递增子序列</a></p><p><a href="https://blog.csdn.net/u011268787/article/details/78675388">【算法知识总结】最长递增子序列</a></p><p><a href="https://www.bilibili.com/video/av15439338?from=search&amp;seid=17716055664494305815">【算法设计指南】最长递增子序列(微博/微信公众号:@算法时空—bilibili)</a></p><h2 id="nlgn的复杂度"><a href="#nlgn的复杂度" class="headerlink" title="nlgn的复杂度"></a><code>nlgn</code>的复杂度</h2><p>参考：</p><p><a href="https://www.bilibili.com/video/av18339080?from=search&amp;seid=11934838010834623209">HRBU ACM 01背包 LIS 拓扑 凸包—-bilibili——20:41</a></p><p>这个比较难讲，看视频比较好理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 14:27:55</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS Exe.Memory：1884k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp = <span class="keyword">new</span> <span class="type">int</span>[len + <span class="number">10</span>]();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(dp + <span class="number">1</span>, dp + ans + <span class="number">1</span>, arr[i]) - dp; </span><br><span class="line">        <span class="comment">//求最长非递减序列可以将lower_bound变为upper_bound</span></span><br><span class="line">        dp[pos] = arr[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">10</span>]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图示</strong></p><Img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20180803145239.png"><h2 id="LIS变形—有升有降"><a href="#LIS变形—有升有降" class="headerlink" title="LIS变形—有升有降"></a><a href="http://fzcoj.hustoj.com/problem.php?id=4493">LIS变形—有升有降</a></h2><p><img src="/2018/08/02/DP/timu.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Time:54 ms</span></span><br><span class="line"><span class="comment">    Memory:2252 kb</span></span><br><span class="line"><span class="comment">    2019-04-08 16:45:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN], dp[MAXN] = &#123;<span class="number">0</span>&#125;, rdp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">-1</span>] &gt;= arr[i])</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">+1</span>] &gt;= arr[i])</span><br><span class="line">            rdp[i] = rdp[i<span class="number">+1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rdp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">int</span> n1, n2;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line">        <span class="keyword">if</span>(dp[n2] + rdp[n1] &gt;= n2-n1<span class="number">+1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大递增子数组和"><a href="#最大递增子数组和" class="headerlink" title="最大递增子数组和"></a>最大递增子数组和</h2><p>这个是由LIS O(n2)的办法变化而来的，因为O(nlgn)的那个代码的dp数组虽然保存的是一个最长递增序列，但是里面是最小的，不是最大的，所以只能由n2那个办法转变而来</p><p>这个动态规划可以先看前三项</p><ul><li><p>dp[1] = num[1]</p></li><li><p>num[2]如果大于num[1]</p><ul><li><p>dp[2] = dp[1] + num[2]</p></li><li><p>否则dp[2] = num[2]</p></li></ul></li><li>num[3]如果大于num[2]<ul><li>那么dp[3] = dp[2] + num[3]</li></ul></li><li>如果num[3]大于num[1]<ul><li>dp[3] = dp[1] + num[3]</li></ul></li><li>如果num[3]不大于num[2]同时也不大于num[1]<ul><li>dp[3] = num[3]。</li></ul></li></ul><p>说了这么多其实就是一个意思，用之前的每一个数和当前的数比较，比当前数小的就加上dp【之前数】，不然就等于当前数</p><p>参考:<a href="https://blog.csdn.net/yopilipala/article/details/74372746">动态规划：HDU1087-Super Jumping! Jumping! Jumping!（最大上升子序列和）</a></p><p><strong>HDU1087(Super Jumping! Jumping! Jumping!)模板题</strong></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1087">http://acm.hdu.edu.cn/showproblem.php?pid=1087</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 18:38:13</span></span><br><span class="line"><span class="comment"> Exe.Time:31MS Exe.Memory：1828k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dp_len = len + <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> * dp = <span class="keyword">new</span> <span class="type">int</span>[dp_len]();</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="type">int</span> MAX = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j]) <span class="comment">//之前数比当前数小，就加上当前数到之前数的和上面</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], arr[i]);<span class="comment">//之前数都不比当前数小的情况下直接就是当前数</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; MAX)<span class="comment">//记录最大的那个和</span></span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">10</span>]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LCS—最长公共子序列"><a href="#LCS—最长公共子序列" class="headerlink" title="LCS—最长公共子序列"></a>LCS—最长公共子序列</h1><p>找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。而最长公共子序列则并不要求连续。</p><p>cnblogs与belong，最长公共子序列为blog（cnblogs, belong），最长公共子串为lo（cnblogs, belong）这两个问题都是用空间换空间，创建一个二维数组来记录之前的每个状态</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/LCS(%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%89.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/lcs.png"></p><p>解释参考：<a href="https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/79178521">LCS（最长公共子序列）注意：是可以不连续的，区别于最长公共子串</a></p><p><strong><a href="http://poj.org/problem?id=1458">poj1458（Common Subsequence）模板题</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-09 11:45:50</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS Exe.Memory：1036k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXDP = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXS = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXDP][MAXDP];</span><br><span class="line"><span class="type">char</span> s1[MAXS], s2[MAXS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">strlen</span>(s1) - <span class="number">1</span>;<span class="comment">//因为s1,s2是从1开始存的，所以长度要减1</span></span><br><span class="line">    <span class="type">int</span> len2 = <span class="built_in">strlen</span>(s2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt;= len1 ; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0;j &lt;= len2; j++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>, s2[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 <span class="number">+1</span> &gt;&gt; s2 + <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LCS</span>(s1, s2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HDU1503-Advanced-Fruits-还原最长公共子序列、记录路径"><a href="#HDU1503-Advanced-Fruits-还原最长公共子序列、记录路径" class="headerlink" title="HDU1503(Advanced Fruits)还原最长公共子序列、记录路径"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1503">HDU1503(Advanced Fruits)还原最长公共子序列、记录路径</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以用pre[i][j]来记录dp[i][j]状态转移时是从哪种状态转移过来的，一共就三种：dp[i−1][j−1]+1,dp[i−1][j],dp[i][j−1]。然后从dp[len0][len1]开始往前递归，遇到从dp[i−1][j−1]+1状态转移的情况就标记，直到递归到dp[0][]或者dp[][0]结束。</span><br></pre></td></tr></table></figure><p>参考：<a href="https://blog.csdn.net/Ramay7/article/details/52003368">https://blog.csdn.net/Ramay7/article/details/52003368</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-10 11:33:40</span></span><br><span class="line"><span class="comment"> Exe.Time:62MS Exe.Memory：9620k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXDP = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXS = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXDP][MAXDP];</span><br><span class="line"><span class="type">char</span> s1[MAXS], s2[MAXS];</span><br><span class="line"><span class="type">int</span> pre[MAXDP][MAXDP]; <span class="comment">//dfs需要，记录状态</span></span><br><span class="line"><span class="type">int</span> vis[MAXDP];  <span class="comment">//记录第一个串中哪些位置被用掉</span></span><br><span class="line"><span class="type">int</span> len_s1, len_s2; <span class="comment">//s1,s2的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> len1, <span class="type">int</span> len2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[len1][len2] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[len1] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(len1 - <span class="number">1</span>, len2 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre[len1][len2] == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(len1, len2 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">dfs</span>(len1 - <span class="number">1</span>, len2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LCS</span><span class="params">(<span class="type">char</span>* s1, <span class="type">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len_s1 = <span class="built_in">strlen</span>(s1) - <span class="number">1</span>;</span><br><span class="line">    len_s2 = <span class="built_in">strlen</span>(s2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len_s1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len_s2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                pre[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    pre[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    pre[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len_s1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = st; j &lt;= len_s2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; s2[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = st; j &lt;= len_s2; ++j)</span><br><span class="line">        cout &lt;&lt; s2[j];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>, s2[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 <span class="number">+1</span> &gt;&gt; s2 + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in">sizeof</span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">LCS</span>(s1, s2);</span><br><span class="line">        <span class="built_in">dfs</span>(len_s1, len_s2);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poj1080-Human-Gene-Functions-LCS应用"><a href="#poj1080-Human-Gene-Functions-LCS应用" class="headerlink" title="poj1080(Human Gene Functions)LCS应用"></a><a href="http://poj.org/problem?id=1080">poj1080(Human Gene Functions)LCS应用</a></h2><p>题意</p><p>给定两个基因字符串，用A，C，G，T表示其组成成分。若两个基因的长度不一样，可以通过在两个串中分别添加空格使其长度一致。当其长度一样后，分别计算对应位置上的两个字母的分数，并将所有的分数相加便得到两个串的相似度分数。求，两个基因串的最高分数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设dp(i,j)为第一个序列(s1)的前i个数和第二个序列(s2)的前j个数的相似度的最大值。当s1[i-1]==s2[j-1]时，由题目给出的表显然可以得出dp(i,j)=dp(i-1,j-1)+score[s1[i-1]][s2[j-1]];score数组为题目中给出的那个表格。当s1[i-1]!=s2[j-1]时，由普通的LCS显然有dp(i,j)=max(d(i-1,j)+score[s1[i-1]][&#x27;-&#x27;],dp(i,j-1)+score[&#x27;-&#x27;][],d(i-1,j-1)+score[s1[i-1]][s2[j-1]])。于是，两个for就解决问题了。注意初始化数组。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-29 12:43:57</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS Exe.Memory：0.6MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">int</span> dp[LEN][LEN];</span><br><span class="line"><span class="type">int</span> score[LEN][LEN];</span><br><span class="line"><span class="type">char</span> c1[LEN];</span><br><span class="line"><span class="type">char</span> c2[LEN];</span><br><span class="line"><span class="type">int</span> len1, len2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=<span class="number">5</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=<span class="number">-1</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=<span class="number">-2</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=<span class="number">-3</span>;</span><br><span class="line">    score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=<span class="number">-4</span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i + <span class="number">1</span>] = dp[<span class="number">0</span>][i] + score[c1[i]][<span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + score[c2[i]][<span class="string">&#x27; &#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; len1 &gt;&gt; c1;</span><br><span class="line">        cin &gt;&gt; len2 &gt;&gt; c2;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)</span><br><span class="line">                dp[j][i] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[j - <span class="number">1</span>][i - <span class="number">1</span>] + score[c2[j - <span class="number">1</span>]][c1[i - <span class="number">1</span>]], dp[j - <span class="number">1</span>][i] + score[c2[j - <span class="number">1</span>]][<span class="string">&#x27; &#x27;</span>]),</span><br><span class="line">                               dp[j][i - <span class="number">1</span>] + score[c1[i - <span class="number">1</span>]][<span class="string">&#x27; &#x27;</span>]);</span><br><span class="line">        cout &lt;&lt; dp[len2][len1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长公共子串（连续）"><a href="#最长公共子串（连续）" class="headerlink" title="最长公共子串（连续）"></a>最长公共子串（连续）</h1><p>和LCS区别是区别就是因为是连续的，如果两个元素不等，那么就要=0了而不能用之前一个状态的最大元素</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88%E8%BF%9E%E7%BB%AD%EF%BC%89.png"></p><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><p>区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。</p><h2 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段</p><p>For l:=2 to n do // 枚举区间长度<br>for i:=1 to n do // 枚举区间的左端点<br>begin<br>j:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到<br>if j&gt;n then break; // 保证了下标不越界<br>for k:= i to j-1 do // 状态转移，去推出 f[i,j]<br>f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }<br>end;</p><p>作者：Steven1997<br>链接：<a href="https://www.jianshu.com/p/9c6401ea2f9b">https://www.jianshu.com/p/9c6401ea2f9b</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [poj 1651 Multiplication Puzzle (区间dp)](http://poj.org/problem?id=1651)</span><br><span class="line"></span><br><span class="line">**题意**</span><br><span class="line"></span><br><span class="line">​```c++</span><br><span class="line">给出一个数组a，可以将其中除了头尾两个数之外的任何一个数字a[i]取出数列，需要的花费为   a[i-1] * a[i] * a[i+1]，问如果需要把这个数列除了头尾之外的数字都取完，怎样的取出顺序是花费最小的，输出这个最小花费</span><br></pre></td></tr></table></figure></p><p>如果贪心每次取最小的话是错的，看下面一组测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 100 1</span><br></pre></td></tr></table></figure><p><strong>思路</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">首先我们可以考虑最小的一个可以操作的区间为<span class="number">3</span>个数字，是可以直接算出答案的。</span><br><span class="line">对于长度小于<span class="number">3</span>的区间，我们可以直接得到 dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">对于长度大于<span class="number">3</span>的区间，我们可以在其中找到一个中点，例如区间 i ~ j  取中点k 即分为区间  i~k 和 k<span class="number">+1</span>~j, 对于区间 i~k 我们有答案 dp[i][k]  对于区间 k<span class="number">+1</span>~j 我们有答案  dp[k<span class="number">+1</span>][j] ，而在这两个区间运算完之后 会剩下的是 a[i],a[k<span class="number">+1</span>],a[j<span class="number">+1</span>]，所以为了消除k我们会有花费 a[i] * a[k<span class="number">+1</span>] * a[j<span class="number">+1</span>]，即转移方程 ：</span><br><span class="line"></span><br><span class="line">dp[i][j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][j] + arr[i] * arr[k + <span class="number">1</span>] * arr[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先计算ans[i][i + <span class="number">1</span>] ( <span class="number">1</span> &lt;= i &lt; N – <span class="number">1</span> )，ans[i][i + <span class="number">2</span>] ( <span class="number">1</span> &lt;= i &lt; N – <span class="number">2</span> )，……</span><br><span class="line">即计算ans[i][i + j] ( <span class="number">1</span> &lt;= j &lt; N – <span class="number">1</span>, <span class="number">1</span> &lt;= i &lt; N – j )</span><br><span class="line"></span><br><span class="line">那么可以这样写</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) <span class="comment">//看上面j的取值范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - j; i++) <span class="comment">//看上面i的取值范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + j] = INF; <span class="comment">//取的是最小，可以初始化为无穷大</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; i + j; k++) <span class="comment">//从给出的区间[i, i + j]的左边开始,一直到右边</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][i + j] + arr[i] * arr[k + <span class="number">1</span>] * arr[i + j + <span class="number">1</span>], dp[i][i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.voidcn.com/article/p-xcolbvjf-bke.html">http://www.voidcn.com/article/p-xcolbvjf-bke.html</a></p><p><a href="https://111qqz.com/2016/07/poj-1651/">https://111qqz.com/2016/07/poj-1651/</a></p><p><a href="http://www.acmsearch.com/article/show/16953">http://www.acmsearch.com/article/show/16953</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-11 12:08:14</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS Exe.Memory：624k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + j] = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt; i + j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][i + j] + arr[i] * arr[k + <span class="number">1</span>] * arr[i + j + <span class="number">1</span>], dp[i][i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n - <span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LeetCode664-Strange-Printer-奇怪的打印机"><a href="#LeetCode664-Strange-Printer-奇怪的打印机" class="headerlink" title="LeetCode664 Strange Printer 奇怪的打印机"></a><a href="https://www.cnblogs.com/grandyang/p/8319913.html">LeetCode664 Strange Printer 奇怪的打印机</a></h2><p>题解：</p><p><a href="http://www.cnblogs.com/grandyang/p/8319913.html">http://www.cnblogs.com/grandyang/p/8319913.html</a></p><p><a href="https://www.bilibili.com/video/av22290452/?p=30&amp;t=878">刷题找工作—-leetcode 664 —bili</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strangePrinter</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = (i == j) ? <span class="number">1</span> : (<span class="number">1</span> + dp[i + <span class="number">1</span>][j]); <span class="comment">//取的min，可以先考虑最坏情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= j; ++k) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[k] == s[i]) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][k - <span class="number">1</span>] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-813-Largest-Sum-of-Averages"><a href="#Leetcode-813-Largest-Sum-of-Averages" class="headerlink" title="Leetcode 813. Largest Sum of Averages"></a><a href="https://leetcode.com/problems/largest-sum-of-averages/description/">Leetcode 813. Largest Sum of Averages</a></h2><p>题解：</p><p><a href="https://blog.csdn.net/magicbean2/article/details/79893634">https://blog.csdn.net/magicbean2/article/details/79893634</a></p><p><a href="https://www.bilibili.com/video/av22290452/?p=45">刷题找工作—-leetcode 813 —bili</a></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180812161908.png"></p><p><strong>递推版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 4 ms</span></span><br><span class="line"><span class="comment">Submitted: 下午5:16,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        m_ = vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>)); <span class="comment">//下标从1开始，初始化为0，代表没有求解过</span></span><br><span class="line">        sums_ = <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>); <span class="comment">//前i个元素的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sums_[i] = sums_[i - <span class="number">1</span>] + A[i - <span class="number">1</span>]; <span class="comment">//suns_[i]存的是前i个元素和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LSA</span>(A, n, K); <span class="comment">//在A中有n个元素分为k组</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; m_;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; sums_;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">LSA</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_[k][n] &gt; <span class="number">0</span>) <span class="comment">//记忆化，求解过的话就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> m_[k][n];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> sums_[n] / n; <span class="comment">//递归结束</span></span><br><span class="line">        <span class="comment">//i是分割点，将前n个元素分为两半，一个是1～i，另一个是i+1～n</span></span><br><span class="line">        <span class="comment">//递归求解i个元素分成k-1组能取的最大值</span></span><br><span class="line">        <span class="comment">//因为是k-1组，所以得至少有k-1个元素，i从k - 1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">         m_[k][n] = <span class="built_in">max</span>(m_[k][n], <span class="built_in">LSA</span>(A, i, k - <span class="number">1</span>) + (sums_[n] - sums_[i]) / (n - i));</span><br><span class="line">        <span class="comment">//sum_[n] - sums_[i]：i+1～n的和</span></span><br><span class="line">        <span class="keyword">return</span> m_[k][n];                   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DP版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">51 / 51 test cases passed.</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 12 ms</span></span><br><span class="line"><span class="comment">Submitted: 下午5:21,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="type">const</span> <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//下标从1开始，初始化为0，代表没有求解过</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">dp</span>(K + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>));</span><br><span class="line">         <span class="comment">//前i个元素的和</span></span><br><span class="line">         vector&lt;<span class="type">double</span>&gt;<span class="built_in">sums</span>(n + <span class="number">1</span>, <span class="number">0.0</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             sums[i] = sums[i - <span class="number">1</span>] + A[i - <span class="number">1</span>]; <span class="comment">//suns_[i]存的是前i个元素和</span></span><br><span class="line">             dp[<span class="number">1</span>][i] = sums[i] / i; <span class="comment">//前i个元素化分为一组的平均数</span></span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; k++) <span class="comment">//第一组已经分了，组的个数从2开始</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt;= n; i++) <span class="comment">//使用i个元素，化分为k组，至少k个元素</span></span><br><span class="line">                 <span class="comment">//j是分割点，把前i个元素分为两半,一半是1~j,另一半是j+1~i</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">int</span> j = k - <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">//把i个元素分成k组取得的最大值</span></span><br><span class="line">                     dp[k][i] = <span class="built_in">max</span>(dp[k][i], dp[k - <span class="number">1</span>][j] + (sums[i] - sums[j]) / (i - j));</span><br><span class="line">                 &#125;</span><br><span class="line">          <span class="keyword">return</span> dp[K][n];             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为dp[k]只与dp[k - 1]有关。所以可以降维</p><p><strong>降维版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">51 / 51 test cases passed.</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 4 ms</span></span><br><span class="line"><span class="comment">Submitted: Submitted: 下午5:23,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="type">const</span> <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>; <span class="comment">//改</span></span><br><span class="line">         <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             sums[i] = sums[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line">             dp[i] = sums[i] / i; <span class="comment">//改 </span></span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= K; k++) </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">tmp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>; <span class="comment">//tmp存的是当前k的最大值，dp存的是k-1</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt;= n; i++) </span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">int</span> j = k - <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">                 &#123;</span><br><span class="line">                   <span class="comment">//  dp[k][i] = max(dp[k][i], dp[k - 1][j] + (sums[i] - sums[j]) / (i - j));</span></span><br><span class="line">                     tmp[i] = <span class="built_in">max</span>(tmp[i], dp[j] + (sums[i] - sums[j]) / (i - j));</span><br><span class="line">                 &#125;</span><br><span class="line">             dp.<span class="built_in">swap</span>(tmp);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> dp[n];             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="POJ-1160区间DP-平行四边形优化-Post-Office"><a href="#POJ-1160区间DP-平行四边形优化-Post-Office" class="headerlink" title="POJ 1160区间DP+平行四边形优化(Post Office)"></a><a href="http://poj.org/problem?id=1160">POJ 1160区间DP+平行四边形优化(Post Office)</a></h2><p><strong>题意</strong></p><p> 有n个村庄现在要建立m个邮局，问怎么建邮局才能使得村庄到最近的邮局距离和最小。输出距离和即可。</p><p><strong>思路</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般的区间dp是从小区间到大区间，而此题在此之外还有一个限制是m个邮局。对于此类问题可以直接建立dp的时候加上限制条件：dp[i][j]=<span class="built_in">min</span>(dp[k][j−<span class="number">1</span>]+one[k<span class="number">+1</span>][i]) 定义dp含义为前i个村庄建立了j个邮局的最小距离和，那么在建立第j的时候可以枚举之前已经求出的区间，从j<span class="number">-1</span>个邮局的前提下加上现在的<span class="number">1</span>个邮局，one[i][j] 的含义是在区间i到j 的范围之中建立一个邮局，其实也就是中位数的位置，然后递推找出最小的值即可。</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/since_natural_ran/article/details/77629901">https://blog.csdn.net/since_natural_ran/article/details/77629901</a></p><p><strong>未用优化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-27 20:33:12</span></span><br><span class="line"><span class="comment"> Exe.Time:94MS Exe.Memory：5.3MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[len][len]; <span class="comment">//前i个村庄建立了j个邮局的最小距离和</span></span><br><span class="line"><span class="type">int</span> onePost[len][len] = &#123;<span class="number">0</span>&#125;; <span class="comment">//i到j 的范围之中建立一个邮局最小距离</span></span><br><span class="line"><span class="type">int</span> arr[len];</span><br><span class="line"><span class="type">int</span> numV, numP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numV; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= numV; j++)</span><br><span class="line">            onePost[i][j] = onePost[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>]; <span class="comment">//中位数位置，加多一个数，同时取其中位数，则需要添加的距离为 arr[j] - arr[(i + j) / 2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">//因为是取min，所以可以初始化dp数组为较大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= numP; ++i)</span><br><span class="line">        dp[i][i] = <span class="number">0</span>; <span class="comment">//前i个村庄建立了i个邮局，则距离为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; numV &gt;&gt; numP;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numV; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numV; i++) <span class="comment">//村庄数量，[1,numV]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= numP; j++) <span class="comment">//邮局数量，小于等于numP</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i]);</span><br><span class="line">    cout &lt;&lt; dp[numV][numP];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优化</strong></p><p>参考：</p><p><a href="https://blog.csdn.net/since_natural_ran/article/details/77629901">https://blog.csdn.net/since_natural_ran/article/details/77629901</a></p><p><a href="https://blog.csdn.net/u012139398/article/details/43956985">https://blog.csdn.net/u012139398/article/details/43956985</a></p><p><a href="http://www.cnblogs.com/vongang/archive/2013/01/21/2869315.html">http://www.cnblogs.com/vongang/archive/2013/01/21/2869315.html</a></p><p>四边形优化公式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss[i, j<span class="number">-1</span>] &lt;= ss[i,j] &lt;= ss[i + <span class="number">1</span>, j]</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> numVillages, numPost;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> onePost[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> arr[MAXN];</span><br><span class="line"><span class="type">int</span> ss[MAXN][MAXN]; <span class="comment">//ss[i][j]表示dp[i][j]取得最优解时，最后一个邮局设立在城市的编号,即决策变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(ss, <span class="number">0</span>, <span class="built_in">sizeof</span>(ss));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;= numPost; i++)</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= numVillages; j++)</span><br><span class="line">            onePost[i][j] = onePost[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; numVillages &gt;&gt; numPost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= numPost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ss[i + <span class="number">1</span>][j] = i + <span class="number">1</span>; <span class="comment">//不知道i，j关系，默认搜索完所有的村庄</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = ss[i][j - <span class="number">1</span>]; k &lt;= ss[i + <span class="number">1</span>][j]; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i];</span><br><span class="line">                    ss[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[numVillages][numPost] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="压缩二维最大子序列和"><a href="#压缩二维最大子序列和" class="headerlink" title="压缩二维最大子序列和"></a>压缩二维最大子序列和</h1><h2 id="HDU1081-To-The-Max"><a href="#HDU1081-To-The-Max" class="headerlink" title="HDU1081(To The Max)"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1081">HDU1081(To The Max)</a></h2><p><strong>题意:大致是求二维数组的最大矩阵和。</strong></p><p>参考：</p><p><a href="https://www.cnblogs.com/BlackStorm/p/4922207.html">https://www.cnblogs.com/BlackStorm/p/4922207.html</a></p><p><a href="https://blog.csdn.net/linraise/article/details/16349527">https://blog.csdn.net/linraise/article/details/16349527</a></p><p><a href="https://blog.csdn.net/hitwhylz/article/details/11848439">https://blog.csdn.net/hitwhylz/article/details/11848439</a></p><p>二维压缩成一维，然后按照求最大序列和的办法去求最大值就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-09-04 19:59:05</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS Exe.Memory：1892k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> cntRow[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArr</span><span class="params">()</span> <span class="comment">//求一维最大序列和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> MAX = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + cntRow[i], cntRow[i]); <span class="comment">//最大子序列和转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(MAX &lt; dp[i])</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)　<span class="comment">//压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cntRow, <span class="number">0</span>, <span class="built_in">sizeof</span>(cntRow));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; ++j)　</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= n; ++k)</span><br><span class="line">                cntRow[k] += arr[j][k];</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">maxSubArr</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">                ans = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杂项二维dp转移"><a href="#杂项二维dp转移" class="headerlink" title="杂项二维dp转移"></a>杂项二维dp转移</h1><h2 id="POJ2192-Zipper-－－－判断两个字符串能否合成一个字符串"><a href="#POJ2192-Zipper-－－－判断两个字符串能否合成一个字符串" class="headerlink" title="POJ2192 (Zipper)－－－判断两个字符串能否合成一个字符串"></a><a href="https://vjudge.net/problem/POJ-2192">POJ2192 (Zipper)－－－判断两个字符串能否合成一个字符串</a></h2><p>题意：给你三个字符串，问你能否由前两个合成第三个，且要求不改变前两个字符串的顺序。题目保证第三个字符串的长度为前两个字符串的长度之和。</p><p>参考：</p><p><a href="https://www.cnblogs.com/huashanqingzhu/p/7348218.html">https://www.cnblogs.com/huashanqingzhu/p/7348218.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最优子结构分析：如果A、B可以组成C，那么，C最后一个字母，必定是 A 或 B 的最后一个字母组成。</span><br><span class="line">C去除除最后一位，就变成是否可以求出 A<span class="number">-1</span>和B 或者 A与B<span class="number">-1</span> 与 是否可以构成 C<span class="number">-1</span>。。。</span><br><span class="line"> 状态转移方程：</span><br><span class="line">用f[i][j] 表示 A前 i 位 和B 前j 位是否可以组成 C的前i+j位</span><br><span class="line">             dp[i][j]= (dp[i<span class="number">-1</span>][j]&amp;&amp;(a[i]==c[i+j]))||(dp[i][j<span class="number">-1</span>]&amp;&amp;(b[j]==c[i+j]))</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-30 16:52:10</span></span><br><span class="line"><span class="comment"> Exe.Time:407MS Exe.Memory：4048KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">char</span> a[MAXN], b[MAXN], c[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        a[<span class="number">0</span>] = b[<span class="number">0</span>] = c[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cin &gt;&gt; a + <span class="number">1</span>&gt;&gt; b + <span class="number">1</span>&gt;&gt; c + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="type">int</span> lenB = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="type">int</span> lenC = <span class="built_in">strlen</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenA; i++) <span class="comment">//初始化，单独ａ与ｃ匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == c[i])　</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenB; i++) <span class="comment">//初始化，单独ｂ与ｃ匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i] == c[i])</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = ( (dp[i - <span class="number">1</span>][j] &amp;&amp; a[i] == c[i + j]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; b[j] == c[i + j]) );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data set &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[lenA][lenB])</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="POJ3356-AGTC-－－－s2变成s1最少的操作"><a href="#POJ3356-AGTC-－－－s2变成s1最少的操作" class="headerlink" title="POJ3356(AGTC)－－－s2变成s1最少的操作"></a><a href="https://vjudge.net/problem/POJ-3356">POJ3356(AGTC)－－－s2变成s1最少的操作</a></h2><p><strong>题意：</strong>给出两个字符串x 与 y，其中x的长度为n，y的长度为m，并且m&gt;=n.然后y可以经过删除一个字母，添加一个字母，转换一个字母，三种操作得到x.问最少可以经过多少次操作</p><p> 参考：</p><p><a href="https://blog.csdn.net/u013480600/article/details/40780781">https://blog.csdn.net/u013480600/article/details/40780781</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-30 20:55:35</span></span><br><span class="line"><span class="comment"> Exe.Time:32MS Exe.Memory：4188MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[LEN][LEN];</span><br><span class="line"><span class="type">char</span> s1[LEN], s2[LEN];</span><br><span class="line"><span class="type">int</span> n1, n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n1 &gt;&gt; s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n2 &gt;&gt; s2;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n1; i++) <span class="comment">//s2为空，s1删除字符串变成s2</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n2; i++) <span class="comment">//s1为空，s1添加字符串变成s2</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]?<span class="number">0</span>:<span class="number">1</span>),</span><br><span class="line">                              <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]<span class="number">+1</span>,dp[i][j<span class="number">-1</span>]<span class="number">+1</span>));</span><br><span class="line">        cout &lt;&lt; dp[n1][n2] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></Img>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 数位dp </tag>
            
            <tag> 最长上升公共子序列 </tag>
            
            <tag> 最长递增子序列 </tag>
            
            <tag> 最长公共子序列 </tag>
            
            <tag> 最长公共子串 </tag>
            
            <tag> 区间dp </tag>
            
            <tag> 最大序列和 </tag>
            
            <tag> 二维dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对一个整数处理</title>
      <link href="/2018/07/19/%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/19/%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>sprintf,Stringstream</p><span id="more"></span><p>参考：<a href="https://blog.csdn.net/fanyun_01/article/details/66967710">STL之Stringstream字符串流使用总结</a></p><h1 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a>sstream</h1><p><code>&lt;sstream&gt;</code>库定义了三种类：<code>istringstream</code>、<code>ostringstream</code> 和 <code>stringstream</code>，分别用来进行流的输入、输出和输入输出操作。本次主要是讨论<code>stringstream</code></p><p><em>注意，<code>&lt;sstream&gt;</code>使用string对象来代替字符数组。这样可以避免缓冲区溢出的危险。而且，传入参数和目标对象的类型被自动推导出来，即使使用了不正确的格式化符也没有危险。</em></p><h1 id="重复利用stringstream对象"><a href="#重复利用stringstream对象" class="headerlink" title="重复利用stringstream对象"></a>重复利用stringstream对象</h1><p>如果你打算在多次转换中使用同一个<code>stringstream</code>对象，记住再每次转换前要使用<code>clear()</code>方法；</p><p>在多次转换中重复使用同一个<code>stringstream</code>（而不是每次都创建一个新的对象）对象最大的好处在于效率。<code>stringstream</code>对象的构造和析构函数通常是非常耗费CPU时间的。</p><h1 id="常见基本类型互相转换"><a href="#常见基本类型互相转换" class="headerlink" title="常见基本类型互相转换"></a>常见基本类型互相转换</h1><h2 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream stream;</span><br><span class="line">    string s = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    stream &lt;&lt; s;</span><br><span class="line">    stream &gt;&gt; ans;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">out: <span class="number">100</span> <span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>同理可以反过来</strong></p><h1 id="取一个整数k前n位"><a href="#取一个整数k前n位" class="headerlink" title="取一个整数k前n位"></a>取一个整数k前n位</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> <span class="comment">//sprintf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">firstN</span> <span class="params">(LL k, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span> (a, <span class="string">&quot;%ld&quot;</span>, k); <span class="comment">//将k转换为字符串</span></span><br><span class="line">    a [n] = <span class="number">0</span>; <span class="comment">//截断n位</span></span><br><span class="line">    stringstream stream;</span><br><span class="line">    stream &lt;&lt; a;</span><br><span class="line">    LL ans;</span><br><span class="line">    stream &gt;&gt; ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="取一个整数k后n位"><a href="#取一个整数k后n位" class="headerlink" title="取一个整数k后n位"></a>取一个整数k后n位</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> <span class="comment">//sprintf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">//atol</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">//strlen</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">firstN</span> <span class="params">(LL k, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a [<span class="number">30</span>], b[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">sprintf</span> (a, <span class="string">&quot;%ld&quot;</span>, k);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">strlen</span>(a) - n; i &lt; <span class="built_in">strlen</span>(a); i++)</span><br><span class="line">        b[cnt++] = a[i];</span><br><span class="line">    stream &lt;&lt; b;</span><br><span class="line">    LL ans;</span><br><span class="line">    stream &gt;&gt; ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h1><p>头文件：stdio.h</p><p>函数原型：int sprintf(char <em>buffer, const char </em>format, [argument]…)</p><p>参数：  </p><p>（1）buffer：是char类型的指针，指向写入的字符串指针；  </p><p>（2）format：格式化字符串，即在程序中想要的格式；  </p><p>（3）argument：可选参数，可以为任意类型的数据；  </p><p>函数返回值：buffer指向的字符串的长度；  </p><p>更多参考：<a href="https://blog.csdn.net/nopoppy/article/details/52589745">sprintf的使用</a></p><p><a href="https://baike.baidu.com/item/atol/10931326?fr=aladdin">https://baike.baidu.com/item/atol/10931326?fr=aladdin</a>)</p><h1 id="sprintf-sscanf-snprintf区别"><a href="#sprintf-sscanf-snprintf区别" class="headerlink" title="sprintf,sscanf,snprintf区别"></a>sprintf,sscanf,snprintf区别</h1><p><a href="https://www.cnblogs.com/Anker/p/3351168.html">C语言sprintf与sscanf函数总结</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整数处理 </tag>
            
            <tag> sstream </tag>
            
            <tag> sprintf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces水一水</title>
      <link href="/2018/07/07/CodeForces/"/>
      <url>/2018/07/07/CodeForces/</url>
      
        <content type="html"><![CDATA[<p>B. Binary String Constructing（Div3—构造）,CodeForces - 1004C（Div2—思维）,CodeForces - 962D(Div2—较为精辟的解法),1055B - Alice and Hairdresser(思维),1088A. Ehab and another construction problem(暴力与O(1)),</p><p>1088C. Ehab and a 2-operation task(通过操作使数组递增)</p><span id="more"></span><h1 id="B-Binary-String-Constructing（Div3—构造）"><a href="#B-Binary-String-Constructing（Div3—构造）" class="headerlink" title="B. Binary String Constructing（Div3—构造）"></a>B. Binary String Constructing（Div3—构造）</h1><p><a href="http://codeforces.com/contest/1003/problem/B">B. Binary String Constructing</a></p><p>题意：给出a，b，x，构造一个01串，有a个0，b个1。这个01串刚好有x个 S[i] 使得S[i] != S[i+1]。</p><p>思路：对于x，我们很容易就可以想到先输出x/2对0和1（n对0和1交错出现可以提供2*n-1个符合题意的S[i]），然后将剩余的0和剩余的1连续输出（提供1个符合条件的S[i]，这样就刚好是x个符合条件的S[i]了，需要注意的是，我们要优先将个数多的放在前面，例如，有10个1,5个0的话，我们先输出x/2个“10”，否则，输出x/2个“01”）。</p><p>还有一个情况就是x刚好整除2，这时候得额外处理一个。</p><p>比如4 3 2</p><p>就需要输出0111000，而不是0100011</p><p>之前没有判断x刚好整除2，wa了一个</p><p>Input  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 47 18</span><br></pre></td></tr></table></figure><p>Output  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0101010101010101010000000000000000000000000000000000000000011111111111111111111111111111111111111</span><br></pre></td></tr></table></figure><p>Answer  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0101010101010101011111111111111111111111111111111111111100000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> zero, one, x;</span><br><span class="line">    cin &gt;&gt; zero &gt;&gt; one &gt;&gt; x;</span><br><span class="line">    zero -= x / <span class="number">2</span>;</span><br><span class="line">    one -= x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(zero &gt; one)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x / <span class="number">2</span>; i++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; one; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; zero; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; zero; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; one; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; x / <span class="number">2</span>; i++)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; zero; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; one; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; one; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; zero; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CodeForces-1004C（Div2—思维）"><a href="#CodeForces-1004C（Div2—思维）" class="headerlink" title="CodeForces - 1004C（Div2—思维）"></a>CodeForces - 1004C（Div2—思维）</h1><p><a href="https://vjudge.net/problem/1655834/origin">CodeForces - 1004C</a></p><p>题目大意:有n个数,每个数只能与自己后面的数配对,相同的配对只算一个,求配对的数量.</p><p>最开始用set暴力求解，当然是TLE了。</p><p>我们只需从1号位置开始检查，判断1号位置后面有多少个不同的数字，然后再从2号位置开始检查，判断2号位置后面有多少个不同的数字，依此类推，最后将所有的结果加起来就可以了（注意，从i号位置检查后面的数时，需要先判读这个位置的数是否以及出现过）。 如果直接暴力检查的话，肯定会tle，所以，我们先预处理出每个位置后面不同数字的个数，然后累加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status:AcceptedTime:62ms</span></span><br><span class="line"><span class="comment">Memory:117424kBLength:863</span></span><br><span class="line"><span class="comment">2018-07-21 14:57:53</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">10000000</span>;</span><br><span class="line"><span class="type">int</span> arr[maxLen];</span><br><span class="line"><span class="type">int</span> vis[maxLen]; <span class="comment">//记录某个数字有没有被算过了</span></span><br><span class="line"><span class="type">int</span> cnt[maxLen]; <span class="comment">//记录某个数字后面有几个不同的数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) <span class="comment">//求出每个数字后面有几个不同的数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[arr[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i] = cnt[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            vis[arr[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>; <span class="comment">//注意用long long</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[arr[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += cnt[i + <span class="number">1</span>];</span><br><span class="line">            vis[arr[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CodeForces-962D-Div2—较为精辟的解法"><a href="#CodeForces-962D-Div2—较为精辟的解法" class="headerlink" title="CodeForces - 962D(Div2—较为精辟的解法)"></a>CodeForces - 962D(Div2—较为精辟的解法)</h1><p><a href="https://vjudge.net/problem/1484062/origin">CodeForces - 962D</a></p><p>题意：给出一个整数序列。选择其中最小且出现两次（或以上）的数，把最左边的两个从序列中移除， 然后把它们的和放到它们的后面第一位。不断重复上述过程，直到序列中的每个数都是唯一的。 输出最后的序列。</p><p>这道题可以用优先队列，set和map来做，挑了一种比较精辟的解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status:AcceptedTime:171ms</span></span><br><span class="line"><span class="comment">Memory:84344kBLength:593</span></span><br><span class="line"><span class="comment">2018-07-21 16:06:35</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll; <span class="comment">//注意要用long long</span></span><br><span class="line">map&lt;ll, ll&gt;Map; <span class="comment">//Map[i]代表i在数组中出现的位置</span></span><br><span class="line"></span><br><span class="line">ll arr[<span class="number">10000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        <span class="keyword">while</span>(Map[arr[i]])  <span class="comment">//查看前面有没有出现过相同的数字，如果有，那么Map[arr[i]]非0</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[Map[arr[i]]] = <span class="number">0</span>; <span class="comment">//将之前那个位置的数字变为0，为了在后面输出时判断不是0就输出</span></span><br><span class="line">            Map[arr[i]] = <span class="number">0</span>; <span class="comment">//处理完后恢复Map状态</span></span><br><span class="line">            arr[i] += arr[i]; </span><br><span class="line">            cnt--; <span class="comment">//序列个数减一</span></span><br><span class="line">        &#125;</span><br><span class="line">        Map[arr[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i])</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1055B-Alice-and-Hairdresser-div2—思维"><a href="#1055B-Alice-and-Hairdresser-div2—思维" class="headerlink" title="1055B - Alice and Hairdresser(div2—思维)"></a><a href="http://codeforces.com/problemset/problem/1055/B">1055B - Alice and Hairdresser(div2—思维)</a></h1><p>标签是写着并查集和模拟，刚开始想到用并查集，但是后来行不通，知道得分集合，还得合并集合，但是不知道怎么存储，然后看了别的代码才知道不用那么麻烦，直接判断左右数字就可以确定一个集合，还是太年轻。</p><p>题目大意：</p><pre><code>   Alice去剪发，一共有n根头发，长度大于l的头发需要剪，如果一个区间中的头发长度全部大于l，那么可以一次给这个区间的所有头发都剪，输入给出0是询问需要剪几次。给出1是第p根头发长了d长度</code></pre><p>题解：</p><pre><code>  首先总计一下给出的数据需要剪的区间有几个，也就是需要剪的总次数是多少。  当给第p根头发增长了d后，以前小于l，增长之后大于l的话         如果左右两边都大于l，那么现在第p根也大于l了，就可以和左右两边连成片，一次减掉，所以要剪的总次数减一。         如果左右两边都小于等于l，那么第p根现在需要剪了，就要剪的总次数加一。 其他情况都不影响剪的总次数。</code></pre><hr><p>参考：<a href="https://blog.csdn.net/hxxjxw/article/details/83990002">https://blog.csdn.net/hxxjxw/article/details/83990002</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">submit time:2018-11-20 12:39:55</span></span><br><span class="line"><span class="comment">time:109 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E6</span>;</span><br><span class="line">ll arr[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, l, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, arr+i);</span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">-1</span>] &lt;= l &amp;&amp; arr[i] &gt; l)</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q, p, d;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;p, &amp;d);</span><br><span class="line">            <span class="keyword">if</span>(arr[p] &lt;= l &amp;&amp; (arr[p]+d) &gt; l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[p<span class="number">-1</span>] &lt;= l &amp;&amp; arr[p<span class="number">+1</span>]&lt;= l)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[p<span class="number">-1</span>] &gt; l &amp;&amp; arr[p<span class="number">+1</span>] &gt; l)</span><br><span class="line">                    cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[p] += d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1088A-Ehab-and-another-construction-problem-暴力与O-1"><a href="#1088A-Ehab-and-another-construction-problem-暴力与O-1" class="headerlink" title="1088A. Ehab and another construction problem(暴力与O(1))"></a><a href="http://codeforces.com/contest/1088/problem/A">1088A. Ehab and another construction problem(暴力与O(1))</a></h1><p>给定一个n，找到两个数<code>a,b&#123;1 &lt;= a,b &lt;= n&#125;</code>使得a被b整除且<code>ab&gt;n</code>且<code>a/b&lt;n</code><br><em>符合条件的a,b非常多，任意输出一个即可</em></p><h2 id="解法1—-暴力"><a href="#解法1—-暴力" class="headerlink" title="解法1—-暴力"></a>解法1—-暴力</h2><p>暴力的话就是用两个for循环去暴力枚举a，b，然后找出符合条件的a，b输出就行了。</p><h2 id="解法2—-确定一个数"><a href="#解法2—-确定一个数" class="headerlink" title="解法2—-确定一个数"></a>解法2—-确定一个数</h2><p>我们可以确定b为2，那么a的值就是<code>n-n%2</code>，可以得到如下证明：<br>(n-n%2)的意思：就是在小于等于n的范围内找出最大能被模2的数，例如11，<code>n%2=11%2=1</code>，那么<code>n-n%2=10</code>，又如12，<code>n%2=12%2=0</code>，那么<code>n-n%2=12</code>。<br>然后的话可以证明下，首先看范围，当<code>n&gt;=2</code>时，b肯定是满足<code>[1， n]</code>，看上面的两个例子，当n是奇数时，因为a肯定是得到偶数，因为n是奇数，又是减法，故此时a就是<code>a-1</code>了，符合条件，当n是偶数时，那么是根据上式得出的a就是n。<br>当n是奇数时，a为<code>n-1</code>，b为2，那么就有<code>a*b=2*(n-1)</code>，当<code>n&gt;2</code>时满足<code>a*b&gt;n</code>，同时有<code>(n-1)/2&lt;n</code><br>当n是偶数时，a为<code>n</code>， b为2，那么就有<code>a*b=2*n</code>，当<code>n&gt;=1</code>时满足<code>a*b&gt;n</code>，同时有<code>n/2&lt;n</code><br>根据上面可以得出，当n&gt;=2时，固定b为2，那么a的值就是<code>n-n%2</code>。<br><em>可以看出固定b为2的情况容易证明，但是固定b为3（或者3以后）的情况就难以讨论。</em><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">1</span>)</span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; x-x%<span class="number">2</span> &lt;&lt; <span class="string">&#x27;   &#x27;</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="1088C-Ehab-and-a-2-operation-task-通过操作使数组递增"><a href="#1088C-Ehab-and-a-2-operation-task-通过操作使数组递增" class="headerlink" title="1088C. Ehab and a 2-operation task(通过操作使数组递增)"></a><a href="http://codeforces.com/contest/1088/problem/C">1088C. Ehab and a 2-operation task(通过操作使数组递增)</a></h1><p>给定一个序列 两种操作：</p><ol><li>选定一个i，将[1,i]内的所有数加上x</li><li>选定一个i，将[i,j]内所有数模x</li></ol><p>让你在不大于n+1次操作后使序列严格递增，输出所进行的操作</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/_20181205_100439.JPG"></p><p>解法看上图，下面代码用的是Second solution</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">submit time: 2018-12-05 10:02:07</span></span><br><span class="line"><span class="comment">time: 31ms</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num = <span class="number">1e5</span>;</span><br><span class="line">    cout &lt;&lt; n + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1 &quot;</span> &lt;&lt; n  &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; input;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; input + num - i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinuxShell</title>
      <link href="/2018/06/16/LinuxShell/"/>
      <url>/2018/06/16/LinuxShell/</url>
      
        <content type="html"><![CDATA[<p>LinuxShell操作小总结</p><span id="more"></span><h1 id="sed，获取当前路径，强制复制，du的用法"><a href="#sed，获取当前路径，强制复制，du的用法" class="headerlink" title="sed，获取当前路径，强制复制，du的用法"></a>sed，获取当前路径，强制复制，du的用法</h1><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>sed [选项] ‘命令’ 输入文本 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [-nefri] ‘command’ 输入文本   </span><br></pre></td></tr></table></figure><h2 id="选项与参数"><a href="#选项与参数" class="headerlink" title="选项与参数"></a>选项与参数</h2><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-n</td><td style="text-align:left">使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来</td></tr><tr><td style="text-align:center">-e</td><td style="text-align:left">直接在命令列模式上进行 sed 的动作编辑</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:left">直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作</td></tr><tr><td style="text-align:center">-r</td><td style="text-align:left">sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</td></tr><tr><td style="text-align:center">-i</td><td style="text-align:left">直接修改读取的文件内容，而不是输出到终端</td></tr></tbody></table></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td>新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</td></tr><tr><td style="text-align:center">c</td><td>取代， c 的后面可以接字串，这些字串可以取代n1,n2 之间的行！</td></tr><tr><td style="text-align:center">d</td><td>删除，因为是删除啊，所以 d后面通常不接任何咚咚</td></tr><tr><td style="text-align:center">i</td><td>插入， i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)</td></tr><tr><td style="text-align:center">p</td><td>输出，亦即将某个选择的资料输出。通常 p 会与参数 sed-n 一起运作</td></tr><tr><td style="text-align:center">s</td><td>取代，可以直接进行取代的工作哩！通常这个 s的动作可以搭配正则表达式！例如 1,20s/old/new/g 就是啦！</td></tr></tbody></table></div><h2 id="对行操作"><a href="#对行操作" class="headerlink" title="对行操作"></a>对行操作</h2><p>现有一文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> ~/test.sh</span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><h3 id="删除一行"><a href="#删除一行" class="headerlink" title="删除一行"></a>删除一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1d&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><p>举个例子：</p><p>(以后同理)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed <span class="string">&#x27;1d&#x27;</span> ~/test.sh</span></span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> ~/test.sh</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><p>对源文件进行操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed -i <span class="string">&#x27;1d&#x27;</span> ~/test.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> ~/test.sh</span>           </span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><h3 id="删除最后一行"><a href="#删除最后一行" class="headerlink" title="删除最后一行"></a>删除最后一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;$d&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><h3 id="删除第一行到第二行"><a href="#删除第一行到第二行" class="headerlink" title="删除第一行到第二行"></a>删除第一行到第二行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,2d&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><h3 id="删除第二行到最后一行"><a href="#删除第二行到最后一行" class="headerlink" title="删除第二行到最后一行"></a>删除第二行到最后一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;2,$d&#x27; ～/test.sh</span><br></pre></td></tr></table></figure><h3 id="显示某行"><a href="#显示某行" class="headerlink" title="显示某行"></a>显示某行</h3><p>第一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1p&#x27; ～/test.sh</span><br></pre></td></tr></table></figure><p>最后一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;$p&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><p>第一行到第二行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;1,2p&#x27; ～/test.sh</span><br></pre></td></tr></table></figure><p>第二行到最后一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;2,$p&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><p><em>不加-n</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed <span class="string">&#x27;$p&#x27;</span> ~/test.sh</span>  </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br><span class="line">echo &quot;写入完成&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed <span class="string">&#x27;1p&#x27;</span> ~/test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="显示含有某个字符串的所有行"><a href="#显示含有某个字符串的所有行" class="headerlink" title="显示含有某个字符串的所有行"></a>显示含有某个字符串的所有行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#x27;/echo/p&#x27; ~/test.sh </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed -n <span class="string">&#x27;/echo/p&#x27;</span> ~/test.sh</span> </span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><h3 id="在第一行后增加一行"><a href="#在第一行后增加一行" class="headerlink" title="在第一行后增加一行"></a>在第一行后增加一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1a new str1&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed <span class="string">&#x27;1a new str1&#x27;</span> ~/test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">new str1</span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><h3 id="在第一行到第三行后增加一行"><a href="#在第一行到第三行后增加一行" class="headerlink" title="在第一行到第三行后增加一行"></a>在第一行到第三行后增加一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,3a new str&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sed <span class="string">&#x27;1,3a new str&#x27;</span> ~/test.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">new str</span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">new str</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">new str</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="在第一行后增加多行"><a href="#在第一行后增加多行" class="headerlink" title="在第一行后增加多行"></a>在第一行后增加多行</h3><p>使用\n将要增加的每行内容分割开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1a newstr1\nnewstr2&#x27; ~/test.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1a newstr1\nnewstr2&#x27; ~/test.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">newstr1</span><br><span class="line">newstr2</span><br><span class="line">str1=&quot;[archlinuxcn]&quot;</span><br><span class="line">str2=&quot;Server = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch&quot;</span><br><span class="line">echo $&#123;str2&#125;</span><br><span class="line">echo &quot;写入完成&quot;</span><br></pre></td></tr></table></figure><h1 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filepath=$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd)</span><br></pre></td></tr></table></figure><p>dirname $0，取得当前执行的脚本文件的父目录</p><p>cd <code>dirname $0</code>，进入这个目录(切换当前工作目录)</p><p>pwd，显示当前工作目录(cd执行后的)</p><h1 id="cp-f强制复制"><a href="#cp-f强制复制" class="headerlink" title="cp -f强制复制"></a>cp -f强制复制</h1><p>-f 参数是强制复制,比如你在A文件夹里面有个文件名叫B，然后你把C文件夹里面的另一个文件名叫B的复制到A里面,这个时候会照成冲突,然后会提示你要不要继续复制.加上-f 就不会提示你了</p><h1 id="du的用法"><a href="#du的用法" class="headerlink" title="du的用法"></a>du的用法</h1><p>du命令用来查看目录或文件所占用磁盘空间的大小。常用选项组合为：du -sh</p><div class="table-container"><table><thead><tr><th>du常用的选项</th><th>解释</th></tr></thead><tbody><tr><td>-h</td><td>以人类可读的方式显示</td></tr><tr><td>-a</td><td>显示目录占用的磁盘空间大小，还要显示其下目录和文件占用磁盘空间的大小</td></tr><tr><td>-s</td><td>显示目录占用的磁盘空间大小，不要显示其下子目录和文件占用的磁盘空间大小</td></tr><tr><td>—apparent-size</td><td>显示目录或文件自身的大小</td></tr><tr><td>-l</td><td>统计硬链接占用磁盘空间的大小</td></tr><tr><td>-L</td><td>统计符号链接所指向的文件占用的磁盘空间大小</td></tr><tr><td>-c</td><td>显示几个目录或文件占用的磁盘空间大小，还要统计它们的总和</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>du常用命令</th><th>解释</th></tr></thead><tbody><tr><td>du -sh</td><td>查看当前目录总共占的容量。而不单独列出各子项占用的容量</td></tr><tr><td>du -lh —max-depth=1</td><td>查看当前目录下一级子文件和子目录占用的磁盘容量。</td></tr><tr><td>du -sh * \</td><td>sort -n</td><td>统计当前文件夹(目录)大小，并按文件大小排序</td></tr><tr><td>du -sk filename</td><td>查看指定文件大小</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> sed </tag>
            
            <tag> cp </tag>
            
            <tag> du </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集入门</title>
      <link href="/2018/06/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%85%A5%E9%97%A8/"/>
      <url>/2018/06/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>并查集模板</p><span id="more"></span><p>参考：<br><a href="https://www.xuebuyuan.com/3256535.html">https://www.xuebuyuan.com/3256535.html</a></p><h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p><strong>1. 初始化</strong>：</p><p>把每个点所在集合初始化为其自身。  </p><p>通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。  </p><p><strong>2.查找：</strong></p><p>查找元素所在的集合，即根节点</p><p><strong>3.合并：</strong></p><p>两个元素所在的集合合并为一个集合。  </p><p>通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现</p><h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1><p>建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Input</strong></p><p>输入多组数据</p><p>每组数据第一行是两个整数n（1＜＝n＜＝10＾6），m（1＜＝m＜＝10＾6）。分别表示元素数、操作数（初始时每个元素以自己为一个集合元素编号是1-n）  </p><p>接下来m行，每行有如下几种输入:    </p><p>union x y——表示将x所在的集台和y所在的集合合并为一个集合   </p><p>same x y——询问x和y是否为同一个集台，为同一个集合输出1，不同集合输出0     </p><p>num x——询问x所在的集合共有多少个元素   </p><p>max x——询问x所在的集合中元素编号最大是多少    </p><p>setuum 询问现在总共有多少个集合   </p><p><strong>Output</strong></p><p>对于每个操作输出一行，用一个整数表示答案</p><p><strong>SimpleInput</strong></p><p>5 10  </p><p>setnum  </p><p>same 1 2  </p><p>union 1 2  </p><p>same 1 2  </p><p>union 2 3  </p><p>same 1 3  </p><p>union 4 5  </p><p>setnum  </p><p>max 1  </p><p>num 4  </p><p><strong>SimpleOutput</strong></p><p>5<br>0<br>1<br>1<br>2<br>3<br>2  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre[len], Max[len], num[len]; <span class="comment">//数组Max：保存集合最大值，num：保存的是集合个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p, tmp;</span><br><span class="line">    p = x;</span><br><span class="line">    <span class="keyword">while</span>(x != pre[x]) <span class="comment">//判断上一级是不是自己本身</span></span><br><span class="line">        x = pre[x]; <span class="comment">//将x变成x对应的根节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != x) <span class="comment">//如果不是的话，那么就将x连到根节点上面去</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = pre[p];</span><br><span class="line">        pre[p] = x;</span><br><span class="line">        p = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Join</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p, q;</span><br><span class="line">    p = <span class="built_in">Find</span>(x);</span><br><span class="line">    q = <span class="built_in">Find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(p != q)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[p] = q;</span><br><span class="line">        Max[q] = <span class="built_in">max</span>(Max[q], Max[p]); <span class="comment">//求集合最大值，因为现在q是根节点，将根节点和之前p的值想比较</span></span><br><span class="line">        num[q] += num[p]; <span class="comment">//求集合的个数，将原本根节点的数加上后来并上的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] = i;  <span class="comment">//让自己成为根节点，即各自都没有关系</span></span><br><span class="line">        num[i] = <span class="number">1</span>;</span><br><span class="line">        Max[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s; </span><br><span class="line">        <span class="type">int</span> cnt = n; <span class="comment">//初始状态共有n个集合</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;union&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Find</span>(x) != <span class="built_in">Find</span>(y))  <span class="comment">//不在一个集合，合并</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Join</span>(x, y);</span><br><span class="line">                cnt--; <span class="comment">//集合个数减一</span></span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;same&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">Find</span>(x) == <span class="built_in">Find</span>(y))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;num&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; num[<span class="built_in">Find</span>(x)] &lt;&lt; endl; <span class="comment">//找到根结点，然后输出个数</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;max&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; Max[<span class="built_in">Find</span>(x)] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><img src="/2018/06/13/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%85%A5%E9%97%A8/timu.png" alt></p><h2 id="未路径压缩"><a href="#未路径压缩" class="headerlink" title="未路径压缩"></a>未路径压缩</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> pre[Max],People[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x != pre[x])</span><br><span class="line">x = pre[x];</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x);</span><br><span class="line">y = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(x!=y)</span><br><span class="line">pre[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="type">int</span> a,b,num;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">pre[i] = i;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line"><span class="built_in">Union</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">People[i] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">k = <span class="built_in">find</span>(i);</span><br><span class="line">People[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn,People[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxn);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路径压缩，效率更高"><a href="#路径压缩，效率更高" class="headerlink" title="路径压缩，效率更高"></a>路径压缩，效率更高</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">30005</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> par[Max],People[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//找根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(par[x]==x)</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> par[x]=<span class="built_in">find</span>(par[x]);<span class="comment">//路径压缩，使路径上经过的所有节点直接连到根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="built_in">find</span>(x); <span class="comment">//找x的根，</span></span><br><span class="line">y = <span class="built_in">find</span>(y); <span class="comment">//找y的根</span></span><br><span class="line"><span class="keyword">if</span>(x!=y)     <span class="comment">//根不同，可见不在同一棵树</span></span><br><span class="line">par[y] = x;  <span class="comment">//把一棵树的根作为另一棵树的根的儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="type">int</span> a,b,num;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">par[i] = i;  <span class="comment">//初始化，每个节点一开始都各自是根，其par是其自己。</span></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b);</span><br><span class="line"><span class="built_in">Union</span>(a,b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">People[i] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">k = <span class="built_in">find</span>(i);</span><br><span class="line">People[k]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(People[i]&gt;maxn)</span><br><span class="line">            maxn = People[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,maxn);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/2018/05/24/%E6%95%B0%E8%AE%BA/"/>
      <url>/2018/05/24/%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>欧几里得及其扩展，素数，模运算，快速幂，欧拉函数，快速乘。</p><span id="more"></span><h1 id="欧几里得—最大公约数"><a href="#欧几里得—最大公约数" class="headerlink" title="欧几里得—最大公约数"></a>欧几里得—最大公约数</h1><h3 id="gcd（a-b-gcd-b-a-mod-b"><a href="#gcd（a-b-gcd-b-a-mod-b" class="headerlink" title="gcd（a, b) = gcd(b, a mod b)"></a>gcd（a, b) = gcd(b, a mod b)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % )b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一波应用：<a href="https://www.cnblogs.com/kimsimple/p/6680820.html">线段上格点个数—-挑战编程—-欧几里得</a></p><h3 id="algorithm库的std-gcd函数"><a href="#algorithm库的std-gcd函数" class="headerlink" title="algorithm库的std::_gcd函数"></a>algorithm库的std::_gcd函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">    cout &lt;&lt;__gcd(a, b); <span class="comment">//两个&#x27;_&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//out：4   //g++-4.8 </span></span><br></pre></td></tr></table></figure><h3 id="最小公倍数-LCM-和最大公约数-GCD"><a href="#最小公倍数-LCM-和最大公约数-GCD" class="headerlink" title="最小公倍数(LCM)和最大公约数(GCD)"></a>最小公倍数(LCM)和最大公约数(GCD)</h3><p><code>lcm(a, b) = (a*b)/gcd(a,b)</code></p><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><p>基本算法：对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然存在整数对 x，y ，使得 gcd（a，b）=ax+by。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">exgcd</span>(b,a%b,x,y);</span><br><span class="line">    <span class="type">int</span> t=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=t-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h1><p><strong>埃氏筛法</strong>—-求解n以内的素数个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> prime[MAXN]; <span class="comment">//第i个素数的值</span></span><br><span class="line"><span class="type">bool</span> is_prime[MAXN]; <span class="comment">//is_prime[i]为true时表示i是素数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回n以内素数的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//代表素数个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_prime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[p++] = i; <span class="comment">//每有一个素数，p就++，然后prime存的就是素数的值，然后进行筛选</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)</span><br><span class="line">                is_prime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//prime[p - 1]代表n以内最大的素数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h1><p><strong>一些基本规则</strong></p><p><a href="https://blog.csdn.net/x_i_y_u_e/article/details/50823235">https://blog.csdn.net/x_i_y_u_e/article/details/50823235</a></p><p><strong>除法取模与费马小定理</strong></p><p><a href="http://www.cnblogs.com/ECJTUACM-873284962/p/6847672.html">http://www.cnblogs.com/ECJTUACM-873284962/p/6847672.html</a></p><p><a href="https://blog.csdn.net/liangzhaoyang1/article/details/56514028">https://blog.csdn.net/liangzhaoyang1/article/details/56514028</a></p><h1 id="快速幂，快速乘"><a href="#快速幂，快速乘" class="headerlink" title="快速幂，快速乘"></a>快速幂，快速乘</h1><p>参考：<a href="https://blog.xehoth.cc/DurationPlan-modPow/#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E5%B9%82">https://blog.xehoth.cc/DurationPlan-modPow/#%E5%8D%81%E8%BF%9B%E5%88%B6%E5%BF%AB%E9%80%9F%E5%B9%82</a></p><h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>普通快速幂在面对大量数据或单个够大数据时效率很低，这个时候我们就需要十进制快速幂，而如果模数是 <code>long long</code> 以内的数，我们可以用快速幂思想 <em>O</em>(log n)O(log n) 完成快速乘，但我们其实可以 <em>O</em>(1)完成。</p><p>利用 <code>long double</code>，而 <code>long double</code>的精度其实只有 19 位，直接乘是不行的，我们可以先除再乘，这样就不会出现精度问题，而前面直接计算 <em>a</em>×<em>b</em>，再减去后面的部分，即使前面 <em>a</em>×<em>b</em> 爆负，它还会再爆一遍变为正的，保证了答案的正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a * b - (ll)((ld)a / MOD * b) * MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制快速幂"><a href="#二进制快速幂" class="headerlink" title="二进制快速幂"></a>二进制快速幂</h3><p><strong>基本代码，都懂</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">mod_pow</span><span class="params">(ll x, ll n, ll mod)</span> <span class="comment">//x^n % mod</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) <span class="comment">//遍历所有二进制位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="comment">//对应n的二进制位是不是1</span></span><br><span class="line">            ans = ans * x % mod; <span class="comment">//乘上x^(2^i)</span></span><br><span class="line">        x = x * x % mod;  <span class="comment">//x平方</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>蜜汁优化版本（参考ext/numeric.h的power函数）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="title">optimizedModPow</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; ~b &amp; <span class="number">1</span>; b &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a));</span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> ret = a;</span><br><span class="line">    <span class="keyword">for</span> (b &gt;&gt;= <span class="number">1</span>; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        a = <span class="built_in">mul</span>(a, a), (b &amp; <span class="number">1</span>) ? ret = <span class="built_in">mul</span>(a, ret) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//balabala--看不懂系列！！</span></span><br></pre></td></tr></table></figure><h3 id="十进制快速幂"><a href="#十进制快速幂" class="headerlink" title="十进制快速幂"></a>十进制快速幂</h3><p>说白了就是拆成十进制数</p><h1 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h1><p>对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目。例如φ(8)=4，因为1,3,5,7均和8互质。</p><h3 id="欧拉函数公式"><a href="#欧拉函数公式" class="headerlink" title="欧拉函数公式"></a>欧拉函数公式</h3><script type="math/tex; mode=display">euler(x) =x\times(1-\frac{1}{p_1})\times(1-\frac{1}{p_2})\times......\times(1-\frac{1}{p_n})</script><p><em>(其中p1, p2……pn为x的所有质因数，x是不为0的整数)</em></p><p><img src="/2018/05/24/%E6%95%B0%E8%AE%BA/ohiexample.png" alt></p><p><strong>注意：</strong></p><p><code>φ(1) = 1</code>（唯一和1互质的数(小于等于1)就是1本身）。 (注意：每种质因数只一个。比如 <script type="math/tex">12 = 2\times2\times3</script> 那么 <script type="math/tex">φ(12) = 12\times (1-\frac{1}{2}) \times (1-\frac{1}{3})=4  )</script></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>当n为质数时，$φ(n)=n-1$。</li><li>当$n=p^k$时（p是素数），$φ(n)=φ(p^k )=p^k-p^{k-1}=(p-1)p^{k-1}$</li><li>若n,m互质，$φ(nm)=φ(n)φ(m)=(n-1)(m-1)$</li><li>若n是奇数，则$φ(2n)=φ(n)$</li></ol><p><strong>特殊性质</strong></p><ol><li>当a与n互质时(n&gt;2)有:$a^{φ(n)}\  mod\ n=1$ (恒等于)此公式即 <strong>欧拉定理</strong></li><li>当a与n互质且n为质数时(即:gcd(a,n)=1)则上式有:$ a^{(n-1)}\ mod \ n=1$(恒等于)此公式即 <strong>费马小定理</strong></li></ol><h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>小于n且与n互质的数的和：</p><script type="math/tex; mode=display">\frac{φ(n)∗n}2  (n>1)</script><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>求$7^{222}$的个位数。</strong></p><p>因为7和10互质，且$φ(10)=4$</p><p>所以$7^4  mod 10=1$</p><p>所以$7^{222}  mod 10=7^{4∗55}∗7^2  mod 10=7^2  mod 10=9$</p><p>即$7^{222}  mod 10=7^{222\%4}  mod 10=7^2  mod 10=9$</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>参考：</p><p><a href="https://www.cnblogs.com/wkfvawl/p/9317125.html">https://www.cnblogs.com/wkfvawl/p/9317125.html</a></p><h5 id="直接求小于或等于n-且与n互质的个数"><a href="#直接求小于或等于n-且与n互质的个数" class="headerlink" title="直接求小于或等于n,且与n互质的个数"></a>直接求小于或等于n,且与n互质的个数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">eular</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,ret=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ret=ret/i*(i<span class="number">-1</span>);<span class="comment">//这里先使用除法是为了防止溢出，ret=ret*(1-1/p(1))</span></span><br><span class="line">            <span class="comment">//为了完全消除我们已经除完了刚才得到的那个i因子,确保下一个得到的i是n的素因子</span></span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>)<span class="comment">//可能还剩下一个素因子没有除 </span></span><br><span class="line">    &#123;</span><br><span class="line">        ret=ret/n*(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="筛选模板-求-1-n-之间每个数的质因数的个数"><a href="#筛选模板-求-1-n-之间每个数的质因数的个数" class="headerlink" title="筛选模板:求[1,n]之间每个数的质因数的个数"></a>筛选模板:求[1,n]之间每个数的质因数的个数</h5><p>如果我们要求的数比较多，如果一个一个求那么很容易就超时，所以我们自然而然就想到——打表。</p><p>如果我们依照上述思想，来个最朴素的打表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> size 1000001</span></span><br><span class="line"><span class="type">int</span> euler[size];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!euler[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;size; j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!euler[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    euler[j]=j;</span><br><span class="line">                &#125;</span><br><span class="line">                euler[j]=euler[j]/i*(i<span class="number">-1</span>);<span class="comment">//先进行除法是为了防止中间数据的溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> gcd </tag>
            
            <tag> lcm </tag>
            
            <tag> exgcd </tag>
            
            <tag> 埃氏筛法 </tag>
            
            <tag> 模运算 </tag>
            
            <tag> 快速幂 </tag>
            
            <tag> 快速乘 </tag>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 质因数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索入门</title>
      <link href="/2018/05/21/%E6%90%9C%E7%B4%A2%E5%85%A5%E9%97%A8/"/>
      <url>/2018/05/21/%E6%90%9C%E7%B4%A2%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>HDU1241 Oil Deposits(DFS模板题)，HZAU 1097 Yuchang and Zixiang ‘s maze(BFS模板题)，P1683 入门(bfs搜索没有终点)，P1162 填涂颜色(BFS联通块)，Poj-1321(DFS逐层搜索)，HDU-2553(N皇后）</p><span id="more"></span><h1 id="HDU1241-Oil-Deposits-DFS模板题"><a href="#HDU1241-Oil-Deposits-DFS模板题" class="headerlink" title="HDU1241 Oil Deposits(DFS模板题)"></a>HDU1241 Oil Deposits(DFS模板题)</h1><p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1241">HDU1241</a></p><p>大意：和迷宫的输入差不多，‘*’是墙，‘@’是油田，以一个油田为中心，如果它的东南西北一个各个角落，一共八个方向也有油田的话，这些油田就算作一个油田。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line"><span class="type">int</span> row,col;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>]= <span class="comment">//八个方向</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[i][j]=<span class="string">&#x27;*&#x27;</span>; <span class="comment">//扫描过后就将@变成*，防止下次重复搜索</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">8</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=i+dir[k][<span class="number">0</span>]; <span class="comment">//开始搜索</span></span><br><span class="line">        <span class="type">int</span> y=j+dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=row&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=col&amp;&amp;a[x][y]==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            <span class="built_in">dfs</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((cin&gt;&gt;row&gt;&gt;col)&amp;&amp;(row!=<span class="number">0</span>||col!=<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=row;i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=col;j++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j]==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HZAU-1097-Yuchang-and-Zixiang-‘s-maze-BFS模板题"><a href="#HZAU-1097-Yuchang-and-Zixiang-‘s-maze-BFS模板题" class="headerlink" title="HZAU 1097 Yuchang and Zixiang ‘s maze(BFS模板题)"></a>HZAU 1097 Yuchang and Zixiang ‘s maze(BFS模板题)</h1><p>题目：<a href="https://blog.csdn.net/hhu1506010220/article/details/53730637">HZAU 1097 Yuchang and Zixiang ‘s maze</a></p><p>大意：给出起点和终点，还有一些不能走的地方，求走到终点的最短步数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">1100</span>;</span><br><span class="line"><span class="type">int</span> vis[maxLen][maxLen]; <span class="comment">//判断有没有走过了</span></span><br><span class="line"><span class="type">char</span> Map[maxLen][maxLen];</span><br><span class="line"><span class="type">int</span> step[maxLen][maxLen];<span class="comment">//步数计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = <span class="comment">//四个方向</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//位置</span></span><br><span class="line">&#125;in, out, beg;<span class="comment">//入队的值，出队的值，开始的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, X, Y, a, b, c, d; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//检查边界或者是否终点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[x][y] &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m &amp;&amp; Map[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//刚开始哪个都没有访问</span></span><br><span class="line">    <span class="built_in">memset</span>(step, <span class="number">0</span>, <span class="built_in">sizeof</span>(step));<span class="comment">//刚开始步数为0</span></span><br><span class="line">    vis[beg.x][beg.y] = <span class="number">1</span>; <span class="comment">//第一个队列的元素，然后标记为已经访问过了</span></span><br><span class="line">    step[beg.x][beg.y] = <span class="number">0</span>; <span class="comment">//还没有开始走，步数为0</span></span><br><span class="line">    queue&lt;point&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(beg); <span class="comment">//将第一个元素入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        out = q.<span class="built_in">front</span>(); <span class="comment">//将第一个元素出队</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//四个方向开始走</span></span><br><span class="line">        &#123;</span><br><span class="line">            in.x = out.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            in.y = out.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(in.x, in.y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Map[in.x][in.y] == <span class="string">&#x27;E&#x27;</span>) <span class="comment">//终点，直接输出那个元素的步数，因为走到E，step数组还没有+1，所以要+1</span></span><br><span class="line">                    <span class="keyword">return</span> step[out.x][out.y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(in); <span class="comment">//否则入队</span></span><br><span class="line">                vis[in.x][in.y] = <span class="number">1</span>; <span class="comment">//访问过了</span></span><br><span class="line">                step[in.x][in.y] = step[out.x][out.y] + <span class="number">1</span>; <span class="comment">//步数累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//没有找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &gt;&gt; t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                Map[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; X &gt;&gt; Y;</span><br><span class="line">            Map[X][Y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; <span class="comment">//从ab走到cd</span></span><br><span class="line">        <span class="keyword">if</span>(a == c &amp;&amp; b == d) cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl; <span class="comment">//同一个位置不用走</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            beg.x = a;</span><br><span class="line">            beg.y = b;</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P1683-入门-bfs搜索没有终点"><a href="#P1683-入门-bfs搜索没有终点" class="headerlink" title="P1683 入门(bfs搜索没有终点)"></a>P1683 入门(bfs搜索没有终点)</h1><p>题目：<a href="https://www.luogu.org/problemnew/show/P1683">p1683</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Map[len][len];</span><br><span class="line"><span class="type">int</span> vis[len][len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> w, h;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;in, out, beg;</span><br><span class="line">queue&lt;point&gt; q;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[x][y] &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= h &amp;&amp; y &lt;= w</span><br><span class="line">            &amp;&amp; Map[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[beg.x][beg.y] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(beg);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        out = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            in.x = out.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            in.y = out.y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//    cout &lt;&lt; in.x &lt;&lt; &quot; &quot; &lt;&lt; in.y &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(in.x, in.y)) <span class="comment">//这里改了下就行了，如果符合条件就会自己走，不符合条件的话就结束函数</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(in);</span><br><span class="line">                vis[in.x][in.y] = <span class="number">1</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; w &gt;&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= h; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= w; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; Map[i][j];</span><br><span class="line">            <span class="keyword">if</span>(Map[i][j] == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                beg.x = i;</span><br><span class="line">                beg.y = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(beg.x, beg.y);</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P1162-填涂颜色-BFS联通块"><a href="#P1162-填涂颜色-BFS联通块" class="headerlink" title="P1162 填涂颜色(BFS联通块)"></a>P1162 填涂颜色(BFS联通块)</h1><p><a href="https://www.luogu.org/problemnew/show/P1162">p1162</a></p><p><strong>所有不在圈内的0组成的块，必定会触碰边界。  </strong></p><p><strong>所以从边界上的0开始进行广搜，把搜过的进行标记，那么没搜过的也不是1的就是要找的2了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">1100</span>;</span><br><span class="line"><span class="type">int</span> vis[maxLen][maxLen]; <span class="comment">//判断有没有走过了</span></span><br><span class="line"><span class="type">int</span> Map[maxLen][maxLen];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = <span class="comment">//四个方向</span></span><br><span class="line">        &#123;</span><br><span class="line">                &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;<span class="comment">//位置</span></span><br><span class="line">&#125;in, out, beg;<span class="comment">//入队的值，出队的值，开始的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//检查边界或者是否终点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[x][y] &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= n &amp;&amp; Map[x][y] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//刚开始哪个都没有访问</span></span><br><span class="line">    queue&lt;point&gt;q;</span><br><span class="line">    <span class="comment">//下面四个for循环表示搜索最外一层，如果某个位置为0，那么就搜索，没有的话就不用了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[<span class="number">1</span>][i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beg.x = <span class="number">1</span>;</span><br><span class="line">            beg.y = i;</span><br><span class="line">            vis[beg.x][beg.y] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(beg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[i][<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beg.x = i;</span><br><span class="line">            beg.y = <span class="number">1</span>;</span><br><span class="line">            vis[beg.x][beg.y] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(beg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[i][n] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beg.x = i;</span><br><span class="line">            beg.y = n;</span><br><span class="line">            vis[beg.x][beg.y] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(beg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[n][i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            beg.x = n;</span><br><span class="line">            beg.y = i;</span><br><span class="line">            vis[beg.x][beg.y] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(beg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        out = q.<span class="built_in">front</span>(); <span class="comment">//将第一个元素出队</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//四个方向开始走</span></span><br><span class="line">        &#123;</span><br><span class="line">            in.x = out.x + dir[i][<span class="number">0</span>];</span><br><span class="line">            in.y = out.y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(in.x, in.y))</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(in); <span class="comment">//入队</span></span><br><span class="line">                vis[in.x][in.y] = <span class="number">1</span>; <span class="comment">//访问过了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; Map[i][j];</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i][j] &amp;&amp; Map[i][j] == <span class="number">0</span>) <span class="comment">//没被访问过，同时为0，就输出2</span></span><br><span class="line">                cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; Map[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Poj-1321-DFS逐层搜索"><a href="#Poj-1321-DFS逐层搜索" class="headerlink" title="Poj-1321(DFS逐层搜索)"></a>Poj-1321(DFS逐层搜索)</h1><p><a href="https://vjudge.net/problem/15202/origin">POJ - 1321</a></p><p>棋子放在’#’,  ‘.’不能放棋子，求满足条件的摆放方案次数，和八皇后问题相似，这次采用的办法是逐层DFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Code 1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Memory: 672KTime: 47MS</span></span><br><span class="line"><span class="comment">Language: G++Result: Accepted</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> chess[maxLen][maxLen];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//用来记录某一列有没有被标记</span></span><br><span class="line"><span class="type">int</span> row, k, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> cnt)</span> <span class="comment">//r代表行数，cnt代表放的是已经放的棋子的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这两个if能不能调换？</span></span><br><span class="line"><span class="comment">    不能，如果调换了会导致不能ans++，因为已经ruturn，但是dfs是满足条件后才dfs(r + 1, cnt + 1);</span></span><br><span class="line"><span class="comment">    这时候已经满足条件了，得ans++，但是r+1可能会导致r&gt;row</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == k)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &gt; row)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++) <span class="comment">//搜索这一行的全部列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[r][i] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; !vis[i]) <span class="comment">//满足条件</span></span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>; <span class="comment">//标记这一列已经走过了</span></span><br><span class="line">                <span class="built_in">dfs</span>(r + <span class="number">1</span>, cnt + <span class="number">1</span>); <span class="comment">//接着走下一行，对应的棋子数要加1</span></span><br><span class="line">                vis[i] = <span class="literal">false</span>; <span class="comment">//dfs(r + 1, cnt + 1);结束后i继续++，走别的列，那么刚刚那一列就要标记为没有走过</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(r + <span class="number">1</span>, cnt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">##..</span></span><br><span class="line"><span class="comment">...#</span></span><br><span class="line"><span class="comment">..#.</span></span><br><span class="line"><span class="comment">处理这种情况，当k&lt;row时，得走完所有的行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; row &gt;&gt; k &amp;&amp; row != <span class="number">-1</span> &amp;&amp; k != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">                cin &gt;&gt; chess[i][j];</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">//代表从第一行开始逐层dfs，放的棋子的数目为0</span></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//code2(思路一样)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Memory: 672KTime: 47MS</span></span><br><span class="line"><span class="comment">Language: G++Result: Accepted</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> chess[maxLen][maxLen];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">10</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="type">int</span> row, k, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == k)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        不需要</span></span><br><span class="line"><span class="comment">    if(r &gt; row)</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = r + <span class="number">1</span>; j &lt;= row; j++) <span class="comment">//这里代表搜索下一行，所有dfs起始是dfs(0,0)，这样的话就不能搜索完所有的行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[j][i] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; !vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(j, cnt + <span class="number">1</span>);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; row &gt;&gt; k &amp;&amp; row != <span class="number">-1</span> &amp;&amp; k != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= row; j++)</span><br><span class="line">                cin &gt;&gt; chess[i][j];</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line">.#..</span><br><span class="line">#...</span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line">#...</span><br><span class="line">##..</span><br><span class="line">...#</span><br><span class="line">..#.</span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">#.#</span><br><span class="line">##.</span><br><span class="line">#.# </span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">#.</span><br><span class="line">.#</span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line">#.</span><br><span class="line">#. </span><br><span class="line"><span class="number">8</span> <span class="number">8</span></span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">########</span><br><span class="line">######## </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">40320</span></span><br></pre></td></tr></table></figure><h1 id="HDU-2553-N皇后"><a href="#HDU-2553-N皇后" class="headerlink" title="HDU-2553(N皇后)"></a>HDU-2553(N皇后)</h1><p><a href="https://vjudge.net/problem/33634/origin">HDU - 2553</a></p><p>这道题是上道题(poj-1321)的加强版，意思是说多了个限制条件，对角线限制，按照上道题来，我们可以逐层搜索，然后标记列和对角线就行了，但是怎么标记对角线呢？</p><p>参考<a href="https://www.cnblogs.com/chenchengxun/p/3759278.html">HDU 2553 N皇后问题（详细题解）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status:AcceptedTime:46ms</span></span><br><span class="line"><span class="comment">Memory:1808kBLength:753</span></span><br><span class="line"><span class="comment">Lang:C++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">5</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> ANS[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[<span class="number">0</span>][i] &amp;&amp; !vis[<span class="number">1</span>][r + i] &amp;&amp; !vis[<span class="number">2</span>][r - i + n])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][r + i] = vis[<span class="number">2</span>][r - i + n] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(r + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">            vis[<span class="number">0</span>][i] = vis[<span class="number">1</span>][r + i] = vis[<span class="number">2</span>][r - i + n] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(n = <span class="number">1</span>; n &lt;= <span class="number">10</span>; n++) <span class="comment">//这道题得打表，不然超时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ANS[n] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ANS[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> BFS </tag>
            
            <tag> N皇后 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>luogu题目</title>
      <link href="/2018/05/14/luogu%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/05/14/luogu%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>P1022 计算器的改良(解简单一元一次方程), P1583 魔法照片（多个信息多个处理系列（题意比较绕））, P1588 丢失的牛(倒逆思想), P1459 三值的排序, P2386 放苹果(递归、dp、dfs都可以做),  P2562 [AHOI2002]Kitty猫基因编码，P1106 删数问题 （贪心）,P2758 编辑距离(dp)，P2404 自然数的拆分问题（回溯）</p><span id="more"></span><h1 id="P1022-计算器的改良-解简单一元一次方程"><a href="#P1022-计算器的改良-解简单一元一次方程" class="headerlink" title="P1022 计算器的改良(解简单一元一次方程)"></a>P1022 计算器的改良(解简单一元一次方程)</h1><p><a href="https://www.luogu.org/problemnew/show/P1022">P1022</a></p><p>这道题如果直接读入一个字符串再一个个处理的话可以会想复杂，我之前这样的处理的话代码长还wa（菜鸡），如果采用栈的思想，则会简单很多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll nowValue = <span class="number">0</span>; <span class="comment">//当前输入的值</span></span><br><span class="line">ll coefficient; <span class="comment">//表示系数</span></span><br><span class="line">ll position = <span class="number">1</span>;    <span class="comment">//标示是在等式左边还是等式右边</span></span><br><span class="line">ll sign = <span class="number">1</span>;    <span class="comment">//表示符号</span></span><br><span class="line">ll value; <span class="comment">//表示某个操作符前面的值</span></span><br><span class="line"><span class="type">bool</span> is = <span class="literal">false</span>; <span class="comment">//判断有没有读入数据了</span></span><br><span class="line"><span class="type">char</span> x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="comment">//     cout &lt;&lt; nowValue &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; &quot; &lt;&lt; coefficient &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = c;</span><br><span class="line">            <span class="keyword">if</span>(nowValue == <span class="number">0</span> &amp;&amp; !is)</span><br><span class="line">            &#123;</span><br><span class="line">                coefficient += position * sign;</span><br><span class="line">                is = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                coefficient += position * sign * nowValue;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">                nowValue = <span class="number">0</span>;</span><br><span class="line">                is = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有个坑点（虽然数据没有涉及），如果nowValue为0又读入了变量名称有两种情况：一时+0x或-0x，另一种是默认系数为1，is专门判断这两种情况 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nowValue = nowValue * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//将输入的字符串数字转化为整型数字</span></span><br><span class="line">            is = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value += -position * sign * nowValue;    <span class="comment">//将前面的值累加</span></span><br><span class="line">            sign = <span class="number">-1</span>;     <span class="comment">//因为是负号，所以后面的值是负数</span></span><br><span class="line">            nowValue = <span class="number">0</span>;</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value += -position * sign * nowValue;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">            nowValue = <span class="number">0</span>;</span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value += -position * sign * nowValue;   <span class="comment">//算出等号前面那个数字值</span></span><br><span class="line">            nowValue = <span class="number">0</span>;</span><br><span class="line">            sign = <span class="number">1</span>;</span><br><span class="line">            position = <span class="number">-1</span>; <span class="comment">//将一些值恢复为默认状态</span></span><br><span class="line">            is = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//最后的值累加上去</span></span><br><span class="line">        &#123;</span><br><span class="line">            value += -position * sign * nowValue;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//   cout &lt;&lt; nowValue &lt;&lt; &quot; &quot; &lt;&lt; value &lt;&lt; &quot; &quot; &lt;&lt; coefficient &lt;&lt; endl;</span></span><br><span class="line">    <span class="type">double</span> ans = (<span class="type">double</span>)(value) / coefficient;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c=%.3lf&quot;</span>,x,ans==<span class="number">0</span>?<span class="built_in">abs</span>(ans):ans);</span><br><span class="line">    <span class="comment">//这涉及一个很坑的地方：C++里0除以一个负数值为-0，专门避免这种情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1583-魔法照片（多个信息多个处理系列（题意比较绕））"><a href="#P1583-魔法照片（多个信息多个处理系列（题意比较绕））" class="headerlink" title="P1583 魔法照片（多个信息多个处理系列（题意比较绕））"></a>P1583 魔法照片（多个信息多个处理系列（题意比较绕））</h1><p><a href="https://www.luogu.org/problemnew/show/P1583">p1583</a></p><p>这道题如果直接用结构体或者用map和数组模拟的话，原则上是可以，但是比较复杂（因为题目比较绕），后来在评论区看见一个比较方便的解法</p><p>摘自评论区  作者: <a href="https://www.luogu.org/space/show?uid=52913">白井黑子1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">题目实际上指的是先给定你1~n号对应的权值，从大到小排序后根据当前次序再编第二次号，分类别加上对应的e[i]，再次从大到小进行排序后输出前k大权值分别的初始编号。</span><br><span class="line">注意！第二次编号与最终的编号输出无关，仅用于分类。</span><br><span class="line">举个例子：</span><br><span class="line">输入：（测试点#1）</span><br><span class="line"></span><br><span class="line">14 3 9 2 5 4 0 0 0 0 0 0</span><br><span class="line"></span><br><span class="line">1 1 3 4 9 2 8 2 8 8 8 7 1 9</span><br><span class="line"></span><br><span class="line">编号为：1 2 3 4 5 6 7 8 9 10 11 12 13 14</span><br><span class="line"></span><br><span class="line">第一次排序后：（序号小优先）</span><br><span class="line"></span><br><span class="line">9 9 8 8 8 8 7 4 3 2 2 1 1 1</span><br><span class="line"></span><br><span class="line">编号为：5 14 7 9 10 11 12 4 3 6 8 1 2 13</span><br><span class="line"></span><br><span class="line">类别为：1 2 3 4 5 6 7 8 9 10 1 2 3 4</span><br><span class="line"></span><br><span class="line">加上e[i]后：18 11 13 12 8 8 7 4 3 2 11 3 6 5</span><br><span class="line"></span><br><span class="line">第二次排序后：（序号小优先）</span><br><span class="line"></span><br><span class="line">18 13 12 11 11 8 8 7 6 5 4 3 3 2</span><br><span class="line"></span><br><span class="line">编号为：5 7 9 8 14 10 11 12 2 13 4 1 3</span><br><span class="line"></span><br><span class="line">输出：5 7 9</span><br><span class="line"></span><br><span class="line">这就是这道题大概的思路：输入——排号——排序——分类加e[i]——排序——输出</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> e[<span class="number">12</span>],n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    <span class="type">int</span> w;<span class="comment">//权值 </span></span><br><span class="line">    <span class="type">int</span> num;<span class="comment">//编号 </span></span><br><span class="line">    <span class="type">int</span> d;<span class="comment">//类别 </span></span><br><span class="line">&#125;p[<span class="number">20010</span>];<span class="comment">//储存每个人的信息 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">w_comp</span><span class="params">(<span class="type">const</span> person &amp;a,<span class="type">const</span> person &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.w!=b.w)<span class="keyword">return</span> a.w&gt;b.w;<span class="comment">//从大到小排序 </span></span><br><span class="line">    <span class="keyword">return</span> a.num&lt;b.num;<span class="comment">//序号小优先 </span></span><br><span class="line">&#125;<span class="comment">//结构体排序 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i].w);</span><br><span class="line">        p[i].num=i<span class="number">+1</span>;</span><br><span class="line">    &#125;<span class="comment">//读入+编号 </span></span><br><span class="line">    <span class="built_in">sort</span>(p,p+n,w_comp);<span class="comment">//第一次排序 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        p[i].d=i%<span class="number">10</span>;<span class="comment">//分类 </span></span><br><span class="line">        p[i].w+=e[p[i].d];<span class="comment">//加上e[i] </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(p,p+n,w_comp);<span class="comment">//第二次排序 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p[i].num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1588-丢失的牛-倒逆思想"><a href="#P1588-丢失的牛-倒逆思想" class="headerlink" title="P1588 丢失的牛(倒逆思想)"></a>P1588 丢失的牛(倒逆思想)</h1><p><a href="https://www.luogu.org/problemnew/show/P1588">p1588</a></p><p>这道题可以用bfs，但是可能比较复杂，后来在题解发现了比较容易的解法，就倒过来想加上一点贪心。</p><p>作者: <a href="https://www.luogu.org/space/show?uid=19174">我真的要吃酱</a></p><p>看到题解一溜溜全是搜索，这里发个带贪心的解题方法，而且是所有题解中最快的（0ms）  </p><p>原题是FJ追牛，我们可以反过来想，变成牛追FJ，这样子，牛的移动方式有y+1，y-1，和直接y/2，因此我们在移动牛的时候可以<strong>优先</strong>考虑能否y/2，然后再考虑y+1,y-1的移动方式  </p><p>之所以要反过来想是因为 在FJ追牛的时候是不能优先考虑x<em>2再考虑x+1，x-1的，也不能优先考虑x+1,x-1再考虑x</em>2！！  </p><p>举个例子，FJ在25，牛在102，先<em>2再+1再</em>2共三步，FJ追牛的时候没办法优先考虑怎么走。但是如果是牛追FJ，牛可以直接y/2，这个时候牛的位置变成51，可以发现是奇数，没办法优先y/2，所以y-1变成50（y+1也要考虑），然后优先考虑y/2变成25，共三步。  </p><p>然后这个思路我刚开始是用数组写，发现在-1，+1那里要考虑很多东西，然后看下了用队列，瞬间简单了很多。。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; P; <span class="comment">//p.first 表示牛的位置，p.second表示牛走了多少步 </span></span><br><span class="line">    P p;</span><br><span class="line">    queue&lt;P&gt;q;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> Min = <span class="number">100000000</span>;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; p.first;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">P</span>(p.first, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(p.first &lt; n) <span class="comment">////如果牛在FJ的后面，那就直接走到FJ</span></span><br><span class="line">            &#123;</span><br><span class="line">                p.second += n - p.first;</span><br><span class="line">                <span class="keyword">if</span>(Min &gt; p.second) Min = p.second;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p.first % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//牛可以直接除以2，优先考虑除以2 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.first / <span class="number">2</span> &gt; n)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">P</span>(p.first / <span class="number">2</span>, p.second + <span class="number">1</span>)); </span><br><span class="line">                <span class="comment">//这里考虑的是除以2后会超过FJ的情况，然后前进，但是还是比直接走到FJ快</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(n - p.first / <span class="number">2</span> &lt; p.first - n)</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">P</span>(p.first / <span class="number">2</span>, p.second + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//否则直接走到FJ</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p.second += p.first - n;</span><br><span class="line">                    <span class="keyword">if</span>( Min &gt; p.second ) Min = p.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果不能直接y/2，选择y+1，y-1的方式 ，这里是队列方便之处，直接加到队列，然后一一判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>( <span class="built_in">P</span>(p.first<span class="number">+1</span>,p.second<span class="number">+1</span>) );</span><br><span class="line">                q.<span class="built_in">push</span>( <span class="built_in">P</span>(p.first<span class="number">-1</span>,p.second<span class="number">+1</span>) );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; Min &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1459-三值的排序"><a href="#P1459-三值的排序" class="headerlink" title="P1459 三值的排序"></a>P1459 三值的排序</h1><p>题目：<a href="https://www.luogu.org/problemnew/show/P1459">P1459</a></p><p>作者: <a href="https://www.luogu.org/space/show?uid=65602">敌敌畏</a> </p><p>这道题可以用线段树什么的，但是也可以用模拟，先模拟1、2、3各有多少个，发现1区间的2与2区间的1交换，发现1区间的3与3区间的1交换，发现2区间的3与3区间的2交换。  </p><p>剩下的3个区间内的无法一次交换的数也只用两次交换就可以把无法一次交换的三个数换了。</p><p>主要是遍历过程。怎么样才能做到不漏呢。</p><p>下面代码主要思路：  </p><p>区间一：应该存的是1，区间二：存的是应该是2，区间三同理</p><p>从末尾开始遍历区间三，如果是1的话，那么就在区间一找看看有没有3，有的话就交换，没有的话在区间一二搜索不等于1的值，然后交换，接着判断如果是2的话（如果上面找不到3将2与1交换的话，那么同样也可以判断到这个已经交换了的2），然后在区间2找3，如果找不到的话，在区间一找。其实主要是还是上面那个找不到1的话，就将其他值交换了，这样就可以将1换到上面了。</p><p>然后再处理区间二就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> arr[len];</span><br><span class="line"><span class="type">int</span> num[<span class="number">4</span>]; <span class="comment">//num[1]代表大小为1的数量，以后的类推</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        num[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    num[<span class="number">2</span>] = num[<span class="number">1</span>] + num[<span class="number">2</span>];</span><br><span class="line">    num[<span class="number">3</span>] = num[<span class="number">1</span>] + num[<span class="number">2</span>] + num[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; num[<span class="number">2</span>]; i--) <span class="comment">//搜索区间三</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="number">1</span>) <span class="comment">//区间三本来应该是3，如果是1的话，那个得进行交换</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> l = <span class="number">1</span>; <span class="comment">//判断是否找到了3，如果没有就搜索2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[<span class="number">1</span>]; k++) <span class="comment">//1在区间一，在区间1搜索</span></span><br><span class="line">                <span class="keyword">if</span>(arr[k] == <span class="number">3</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr[k], arr[i]);</span><br><span class="line">                    l = <span class="number">0</span>;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(l)   <span class="comment">//在区间一找不到3</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= num[<span class="number">2</span>]; k++) <span class="comment">//然后在区间一，二搜索不等于1的数字</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] != <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">swap</span>(arr[k], arr[i]); <span class="comment">//把1换到区间一，把2或3换到区间三</span></span><br><span class="line">                        ans++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="number">2</span>) <span class="comment">//如果上一步是把2换到区间三，那么就在区间二里面找3，然后两者交换</span></span><br><span class="line">        &#123;               <span class="comment">//或者本来就是2</span></span><br><span class="line">            <span class="type">bool</span> l = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = num[<span class="number">1</span>] + <span class="number">1</span>; k &lt;= num[<span class="number">2</span>]; k++)</span><br><span class="line">                <span class="keyword">if</span>(arr[k] == <span class="number">3</span>) <span class="comment">//找到3，然后交换</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr[k],arr[i]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    l = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(l) <span class="comment">//如果找不到，那就在区间一找</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[<span class="number">1</span>]; k++)</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] == <span class="number">3</span>)&#123;</span><br><span class="line">                        ans ++;</span><br><span class="line">                        <span class="built_in">swap</span>(arr[k], arr[i]);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = num[<span class="number">2</span>]; i &gt;= num[<span class="number">1</span>]<span class="number">+1</span>; i--) <span class="comment">//处理区间三后再处理区间二。这里只要交换1,2，因为3已经全部在区间三了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[<span class="number">1</span>]; k++)</span><br><span class="line">                <span class="keyword">if</span>(arr[k] == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(arr[k], arr[i]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P2386-放苹果"><a href="#P2386-放苹果" class="headerlink" title="P2386 放苹果"></a>P2386 放苹果</h1><p>题目：<a href="https://www.luogu.org/problemnew/show/P2386">P2386 放苹果</a></p><p>题解：作者: <a href="https://www.luogu.org/space/show?uid=45384">ybb756032937</a> 递归</p><p>详细解释思路（当苹果数大于等于盘子数时的分法）：一种是<strong>目前</strong>所有的盘子都放一个苹果，盘子数不变，即：apple(m-n,n);  </p><p>另一种是将一个盘子不放，再来进行思考，即：apple(m,n-1);  </p><p>两种情况的总和就是答案；  </p><p>接下来就用一个例子来详细解释：  </p><p>现在有5个苹果和3个盘子；  </p><p>因为苹果数大于盘子数，所以分成两种：  </p><p>第一种：目前所有盘子放一个苹果（目前盘子数3个）apple(2,3);  </p><p>第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(5,2);  </p><p>apple(2,3):因为苹果数小于盘子数，所以apple(2,2);  </p><p>apple(2,2):因为苹果数等于盘子数，所以又分为两种：  </p><p>第一种：目前所有盘子放一个苹果（目前盘子数2个）apple(0,2); 没有苹果，达到边界，<strong>返回值1</strong>；  </p><p>第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(2,1); 盘子数只有1个，达到边界，<strong>返回值1</strong>；  </p><p>apple(5,2):因为苹果数大于盘子数，所以又分为两种：  </p><p>第一种：目前所有盘子放一个苹果（目前盘子数2个)apple(3,2);  </p><p>第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(5,1); 因为盘子数只有1个，达到边界，<strong>返回值1</strong>；  </p><p>apple(3,2):因为苹果数大于盘子数，所以又分为两种：  </p><p>第一种：目前所有盘子放一个苹果（目前盘子数2个)apple(1,2); 苹果数只有1个，达到边界，<strong>返回值1</strong>；  </p><p>第二种：拿一个盘子不放苹果，剩下的盘子继续考虑，apple(3,1); 盘子数只有1个，达到边界，<strong>返回值1</strong>；  </p><p>所有的值相加得到最后的结果5，记录在数组sum中，最后输出；  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">put</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span> <span class="comment">//m是苹果数，n是盘子数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span> || m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="comment">//边界：当苹果只有一个或者没有苹果时或者盘子只有一个时，只有一种放法，所以达到边界，返回值；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; n) <span class="comment">//当苹果数少于盘子数，就只有m个盘子作用，所以接下来就计算m个苹果和m个盘子；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">put</span>(m, m);</span><br><span class="line">    <span class="keyword">if</span>(m &gt;= n) <span class="comment">//如果苹果数大于等于盘子数，分成两个部分，一种是目前所有的盘子都放一个苹果，另一种是拿一个盘子不放；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">put</span>(m - n, n) + <span class="built_in">put</span>(m, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m ,n, cnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">        cnt = <span class="built_in">put</span>(m, n);</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P2562-AHOI2002-Kitty猫基因编码-递归"><a href="#P2562-AHOI2002-Kitty猫基因编码-递归" class="headerlink" title="P2562 [AHOI2002]Kitty猫基因编码(递归)"></a>P2562 [AHOI2002]Kitty猫基因编码(递归)</h1><p>题目：<a href="https://www.luogu.org/problemnew/show/P2562">p2562</a></p><p>看到这道题一想就是递归题，类似于分段函数的题目都可以想想递归，但是有了别的思路，用队列来做，就是不断出队入队，但是如果提前出队的话这样的结果不对，如果都不出队的话，直接处理完了的话又不知道怎么结束循环，所以还是递归好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">check</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = s.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&#x27;0&#x27;</span>) != string::npos) <span class="comment">//表示找到了0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&#x27;1&#x27;</span>) != string::npos) <span class="comment">//同时找到了1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span> + <span class="built_in">check</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, mid)) +</span><br><span class="line">                    <span class="built_in">check</span>(s.<span class="built_in">substr</span>(mid, mid));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//没有的找到1的话那么就代表全是0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//没有找到0，代表全是1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string in;</span><br><span class="line">    cin &gt;&gt; in;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">check</span>(in);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P1209-USACO1-3-修理牛棚-Barn-Repair（贪心）"><a href="#P1209-USACO1-3-修理牛棚-Barn-Repair（贪心）" class="headerlink" title="P1209 [USACO1.3]修理牛棚 Barn Repair（贪心）"></a>P1209 [USACO1.3]修理牛棚 Barn Repair（贪心）</h1><p>题目：<a href="https://www.luogu.org/problemnew/show/P1209">p1209</a></p><p>题解作者: <a href="https://www.luogu.org/space/show?uid=41165">Starlight_Glimmer</a> </p><p>典型的贪心题目</p><p>我们可以先假设只有一块木板从编号最小的牛棚一直铺到编号最大的牛棚，然后断开m-1处。自然要按相邻牛棚的编号差从大到小断开才能使我们断开的地方可以有效节省木板长度（因为中间省去的要更多）</p><p>另外，要将输入的数据排序，数据可能不是按编号从小到大给的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s, c;</span><br><span class="line">    <span class="type">int</span> C[len], dis[len]; <span class="comment">//dis代表两个牛棚之间的距离</span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; s &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">        cin &gt;&gt; C[i];</span><br><span class="line">    <span class="keyword">if</span>(m &gt; c) <span class="comment">//特判，如果木板数大于牛数，那么每只牛可以有一块木板</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(C, C + c);</span><br><span class="line">    ans = C[c - <span class="number">1</span>] - C[<span class="number">0</span>] + <span class="number">1</span>; <span class="comment">//假设只有一块木板连续地铺着</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c - <span class="number">1</span>; i++)</span><br><span class="line">        dis[i] = C[i + <span class="number">1</span>] - C[i];</span><br><span class="line">    <span class="built_in">sort</span>(dis, dis + c - <span class="number">1</span>, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) <span class="comment">//原来已经假设有一块了，则需要减去m-1个</span></span><br><span class="line">        ans = ans - dis[i] + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P1106-删数问题-（贪心）"><a href="#P1106-删数问题-（贪心）" class="headerlink" title="P1106 删数问题 （贪心）"></a>P1106 删数问题 （贪心）</h1><p><a href="https://www.luogu.org/problemnew/show/P1106">P1106 删数问题</a></p><p>题解参考： <a href="https://www.luogu.org/space/show?uid=39912">书海扬帆</a> </p><p>这道题目是一道非常经典的贪心问题。由于n的位数非常多，而且删除操作改变的是每个数位，所以我们非常自然地能想到用字符串来存储n。  </p><p>本题目的贪心策略：从高位到低位搜索，如果各位数字均递增，则删去最后一个数字，否则删除第一个递减区间的首字符。举个栗子，如果1234567要删除2位的话，我们必定是删除6和7，而3654321如果要删除2位的话，我们则要选择删去6和5.</p><p>重复以上过程s次，剩下的数字串便是问题的解了。</p><p>这里再谈一下0的问题，由于前导0不能输出<del>（你见过有人把123写成0123或是000123嘛）</del>所以我们再来一个布尔变量flag来记录每一位是否为0.但是这个时候还出现了一个问题，就是这个字符串被删除完了，只剩下一个0怎么办？比如说样例7，10删除1位之后，我们还是必须要输出0的。因此我们再建立一个cnt变量来存储输出的数字的个数。如果个数为0，那么说明整个字符串均为0，此时我们还需要输出一个0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>(); <span class="comment">//长度，不能都用s.size()；因为要缩减，数组向前移，但是s.size()不变</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) <span class="comment">//从字符串的第一个字符开始查找，len是字符串的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &gt; s[j + <span class="number">1</span>]) <span class="comment">//如果找到了递减区间</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt; len - <span class="number">1</span>; k++) <span class="comment">//那么就删除字符串n的第j个字符，后面字符往前调整。</span></span><br><span class="line">                    s[k] = s[k + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len--;  <span class="comment">//由于已经删除了一个元素，所以长度-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">//记录被输出字符的个数</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27;0&#x27;</span>) <span class="comment">//如果不是0，则说明可以输出，flag=1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="comment">//如果啥都没输出，就说明整个字符串都是0，此事我们还要输出一个0</span></span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P2758-编辑距离-dp"><a href="#P2758-编辑距离-dp" class="headerlink" title="P2758 编辑距离(dp)"></a>P2758 编辑距离(dp)</h1><p><a href="https://www.luogu.org/problemnew/show/P2758">p2758</a></p><p>题解参考：</p><p><a href="https://www.luogu.org/space/show?uid=36788">4396瞎</a></p><p> <a href="https://www.luogu.org/space/show?uid=22136">qwaszx</a></p><p>做动态规划的题一般分为四个步骤：确定子问题—&gt;定义状态—&gt;转移方程—&gt;避免重复求解  </p><p><strong>1.确定子问题：  </strong>  </p><p>由于对于字符串的操作只有4种情况（删除，添加、更改、不变），所以该题的子问题就是进行了这4种操作后的A字符串变为B字符串需要多少步。  </p><p><strong>2.定义状态： </strong> </p><p>也就是说递归的dp函数需要哪些参数，参数越少越好因为需要建memo。后来想到dp（i，j）代表字符串A的前i个字符（包括第i个）变为字符串B的前j个（包括第j个）需要多少步。也就是说解出来dp（lenA，lenB）就可以了。</p><p> <strong>3.转移方程：  </strong></p><p>假设用f[i][j]表示将串a[1…i]转换为串b[1…j]所需的最少操作次数（最短距离）</p><p>首先是边界：  </p><p>①i==0时，即a为空，那么对应的f[0][j]的值就为j：增加j个字符，使a转化为b  </p><p>②j==0时，即b为空，那么对应的f[i][0]的值就为i：减少i个字符，使a转化为b  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">转移有三种:</span><br><span class="line"></span><br><span class="line">①f[i - 1][j] -&gt; f[i][j],插入即可,f[i][j] = f[i - 1][j] + 1;</span><br><span class="line"></span><br><span class="line">②f[i][j - 1] -&gt;f [i][j],删除即可f[i][j] = f[i][j - 1] + 1;</span><br><span class="line"></span><br><span class="line">③f[i - 1][j - 1] -&gt; f[i][j],要把a[i - 1]换成b[j - 1],如果相同就不用换了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>])</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>,f[i][j - <span class="number">1</span>] + <span class="number">1</span>,f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s1, s2;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxLen = <span class="number">3000</span>;</span><br><span class="line"><span class="type">int</span> arr[maxLen][maxLen];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> lenA, <span class="type">int</span> lenB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++) <span class="comment">//a不为空，长度为i，b为空，则a需要删去i个字母</span></span><br><span class="line">        arr[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= lenB; i++) <span class="comment">//同理</span></span><br><span class="line">        arr[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>])</span><br><span class="line">                arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr[i][j] = <span class="built_in">min</span>(arr[i - <span class="number">1</span>][j] + <span class="number">1</span>, <span class="built_in">min</span>(arr[i][j - <span class="number">1</span>] + <span class="number">1</span>, arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="built_in">dp</span>(s<span class="number">1.</span><span class="built_in">size</span>(), s<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">    cout &lt;&lt; arr[s<span class="number">1.</span><span class="built_in">size</span>()][s<span class="number">2.</span><span class="built_in">size</span>()];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="P2404-自然数的拆分问题（回溯）"><a href="#P2404-自然数的拆分问题（回溯）" class="headerlink" title="P2404 自然数的拆分问题（回溯）"></a>P2404 自然数的拆分问题（回溯）</h1><p><a href="https://www.luogu.org/problemnew/show/P2404">p2404</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">1000</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">//从拆1开始</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    cout &lt;&lt; arr[num] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = arr[num - <span class="number">1</span>]; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n) <span class="keyword">continue</span>; <span class="comment">//防止n进入到数组arr，避免最后输出n</span></span><br><span class="line">        arr[num] = i; <span class="comment">//结果放到arr里面</span></span><br><span class="line">        m -= i; <span class="comment">//已经拆分出了一个i，对应的m要减i</span></span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)  <span class="comment">//说明m已经拆分完成了，直接输出</span></span><br><span class="line">            <span class="built_in">print</span>(num);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//还没有拆分完成，继续拆分</span></span><br><span class="line">            <span class="built_in">dfs</span>(num + <span class="number">1</span>);</span><br><span class="line">        m += i; <span class="comment">//回溯，即进入到下个阶段的拆分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2018/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/2018/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>部分背包，01背包，完全背包，多重背包</p><span id="more"></span><ul><li><p>部分背包问题和01背包问题的区别就是：部分背包问题中的单个物品，可以取一部分装入背包。而0/1背包问题则是要么全部拿走，要么一无所有</p></li><li><p>完全背包与0-1背包问题的区别是：在0-1背包问题中，每个物品仅有一件；在完全背包问题中，每个物品有无限件</p></li><li>多重背包与完全背包问题的区别是：在完全背包问题中，每个物品有无限件；在多重背包问题中，每个物品有Mi件</li><li>混合背包问题相当于上面提到所有背包问题的混合：有的物品仅有1件，有的物品有无限件，有的物品有Mi件（有限件）</li></ul><h1 id="部分背包"><a href="#部分背包" class="headerlink" title="部分背包"></a>部分背包</h1><p>【部分背包】问题描述：n件物品，第i件物品价值 vi 元，重wi 磅。希望用 W磅的背包 拿走最重的物品。第i件物品可以都拿走，也可以拿走一部分。（物品可以分割所以称为部分背包）</p><p>因为每一个物品都可以分割成单位块，单位块的利益越大显然总收益越大，所以它局部最优满足全局最优，可以用贪心法解答。<br>（1）先将单位块收益按从大到小进行排序；<br>（2）初始化背包的剩余体积和当前价值；<br>（3）从前到后考虑所有物品：a.如果可以完全放入，当前价值加上物品总价值，剩余体积减去物品总体积；b.如果可以部分放进，当前价值加上物品价值*剩余体积，使剩余体积为0.</p><h2 id="模板题L2-003-月饼"><a href="#模板题L2-003-月饼" class="headerlink" title="模板题L2-003 月饼"></a>模板题<a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805071789801472">L2-003 月饼</a></h2><p><img src="/2018/05/09/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/bufen.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e4</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> w, v;</span><br><span class="line">&#125;stru[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">double</span> arr[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v/x.w &gt; y.v/y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, d;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; stru[i].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; stru[i].v;</span><br><span class="line">    <span class="built_in">sort</span>(stru, stru + n, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stru[i].w &gt; d)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        d -= stru[i].w;</span><br><span class="line">        arr[i] = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n)</span><br><span class="line">        arr[i] = d / stru[i].w;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        ans += stru[j].v*arr[j];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%0.2lf&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="www.cnblogs.com/fancy-itlife/p/4393213.html">动态规划专题 01背包问题详解【转】 - fancy_boy - 博客园</a></p><p><a href="https://blog.csdn.net/fx677588/article/details/68951593">二维背包</a></p><p><a href="https://blog.csdn.net/qq_33279781/article/details/52073519">一维背包</a></p><h2 id="初始化细节"><a href="#初始化细节" class="headerlink" title="初始化细节"></a>初始化细节</h2><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。</p><p>如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。</p><p>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0</p><p>为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。<br>这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="模板题-HDU2602-Bone-Collector"><a href="#模板题-HDU2602-Bone-Collector" class="headerlink" title="模板题-HDU2602-Bone Collector"></a>模板题-HDU2602-Bone Collector</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602">HDU2602</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="type">int</span> dp[len] = &#123;<span class="number">0</span>&#125;, val[len] = &#123;<span class="number">0</span>&#125;, w[len] = &#123;<span class="number">0</span>&#125;; <span class="comment">//val价值 w体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; val[i];</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;=w[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + val[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01变形-HDU2546-饭卡"><a href="#01变形-HDU2546-饭卡" class="headerlink" title="01变形-HDU2546-饭卡"></a>01变形-HDU2546-饭卡</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2546">hdu2546</a></p><p>比较详细的解析:<a href="https://www.cnblogs.com/fancy-itlife/p/4394398.html">动态规划专题 01背包问题详解 HDU 2546 饭卡 - fancy_boy - 博客园</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n&amp;&amp; n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w[len] = &#123;<span class="number">0</span>&#125;;<span class="comment">//w:菜的价格</span></span><br><span class="line">        <span class="type">int</span> dp[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; w[i];</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= <span class="number">4</span>)<span class="comment">//余额小于4，什么都不能购买，直接输出</span></span><br><span class="line">            cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sort</span>(w + <span class="number">1</span>, w + n + <span class="number">1</span>); <span class="comment">//排序后将最大的留到最后减，将m-1个进行01背包求解</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = m - <span class="number">5</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">                &#123;       </span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= w[i]) </span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j]= <span class="built_in">max</span>(dp[j], dp[j - w[i]] + w[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m<span class="number">-5</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s&lt;dp[j])</span><br><span class="line">                    s=dp[j];</span><br><span class="line">            &#125;  <span class="comment">//挑出花销最大的                </span></span><br><span class="line">            cout &lt;&lt; m - s - w[n] &lt;&lt; endl; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01变形-nyoj860-用价值保存质量"><a href="#01变形-nyoj860-用价值保存质量" class="headerlink" title="01变形-nyoj860-用价值保存质量"></a>01变形-nyoj860-用价值保存质量</h3><p><a href="https://blog.csdn.net/sinat_26019265/article/details/51057698">nyoj860 又见01背包</a></p><h3 id="hdu2639（01背包求第k优解）"><a href="#hdu2639（01背包求第k优解）" class="headerlink" title="hdu2639（01背包求第k优解）"></a>hdu2639（01背包求第k优解）</h3><p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2639">HDU2639-Bone Collector II</a></p><p>题解：<a href="https://blog.csdn.net/martinue/article/details/51427171">csdn</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> val[len], cost[len], dp[len][len];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, v, k;    <span class="comment">//n个物品，体积为v，求解第k个最优值</span></span><br><span class="line">        cin &gt;&gt; n &gt;&gt; v &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; val[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; cost[i];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = v; j &gt;= cost[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> A[len], B[len];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> kk = <span class="number">1</span>; kk &lt;= k; kk++)</span><br><span class="line">                &#123;</span><br><span class="line">                    A[kk] = dp[j - cost[i]][kk] + val[i];</span><br><span class="line">                    B[kk] = dp[j][kk];</span><br><span class="line">                    <span class="comment">//选择与不选择</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">                A[k + <span class="number">1</span>] = <span class="number">-1</span>, B[k + <span class="number">1</span>] = <span class="number">-1</span>; <span class="comment">//结束循环的一个标志</span></span><br><span class="line">                <span class="keyword">while</span>(c &lt;= k &amp;&amp; (A[a] != <span class="number">-1</span> || B[b] != <span class="number">-1</span>)) <span class="comment">//排序过程，当有一个到达地K+1项停止</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(A[a] &gt; B[b])</span><br><span class="line">                        dp[j][c] = A[a++];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        dp[j][c] = B[b++];</span><br><span class="line">                    <span class="keyword">if</span>(dp[j][c] != dp[j][c - <span class="number">1</span>])</span><br><span class="line">                        c++;    <span class="comment">//这里是为了防止相同的数也占用，有可能有几个相同的结果但它们只能有一个名次而已</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; dp[v][k] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="限制条件的01背包"><a href="#限制条件的01背包" class="headerlink" title="限制条件的01背包"></a>限制条件的01背包</h3><p><a href="https://blog.csdn.net/u011663071/article/details/44307273">hdu5188</a></p><h3 id="01变形-洛谷P1802"><a href="#01变形-洛谷P1802" class="headerlink" title="01变形-洛谷P1802"></a>01变形-洛谷P1802</h3><p>参考题解: <a href="https://www.luogu.org/space/show?uid=19842">半仙胡小桃</a> </p><p>一个变形版的01背包。  </p><p>dp[i]表示用i瓶药获得的最多经验。  </p><p>决策？</p><p>当i&gt;=use时，可以选择打败或者不打败</p><p>dp[i]=max(dp[i]+lose,dp[i-use]+win)。</p><p>当i&lt;use时，无法战胜对方。</p><p>dp[i]+=lose</p><p>至于数据范围，最后输出时强制转换一下就行了。(这里需要long long)</p><p>题目：<a href="https://www.luogu.org/problemnew/show/P1802">P1802</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll dp[len];</span><br><span class="line">ll win[len],lose[len],use[len];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     cin &gt;&gt; lose[i] &gt;&gt; win[i] &gt;&gt; use[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= use[i]; j--)</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j] + lose[i], dp[j - use[i]] + win[i]);</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = use[i] - <span class="number">1</span>;j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            dp[j] += lose[i];</span><br><span class="line">     &#125;</span><br><span class="line">     cout &lt;&lt; <span class="number">5</span> * dp[m];</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P1757-通天之分组背包"><a href="#P1757-通天之分组背包" class="headerlink" title="P1757 通天之分组背包"></a>P1757 通天之分组背包</h3><p>题目：<a href="https://www.luogu.org/problemnew/show/P1757">p1757</a></p><p>这一题是分组背包问题。思路是把每一组看做一个物品，转化为01背包做。  </p><p>对于分组背包，可以这样想：虽然分成很多组，但只能选一个，或者不选，这和01背包是一样的，也就是说，对于01背包里每一个独一无二的物品，对应的分组背包就是每一组中选择一个物品，这样来看，完全就是01背包问题。  </p><p>可以想一下01背包的状态方程，和这个外两层的循环是一样的，不一样的是里面又加了一层，这层循环是遍历每一组的物品用的，对于dp[]中每一个状态都是循环了一遍每一组的物品才换到下一个的，所以对后面的没有影响，也就保证了每组物品最多只有一件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[<span class="number">1100</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//重量</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">1100</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">//价值</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">1100</span>][<span class="number">1100</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//用来记录编号的数组，按照输入的顺寻调用所对应的w、v</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m ,n, g;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> Maxg = <span class="number">0</span>; <span class="comment">//最大组数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; g;</span><br><span class="line">        Maxg = <span class="built_in">max</span>(Maxg, g);</span><br><span class="line">        num[g][++num[g][<span class="number">0</span>]] = i; <span class="comment">//p组每有个物品第二维数量就加一并且记下是第几个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Maxg; i++) <span class="comment">//组数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--) <span class="comment">//容量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[i][<span class="number">0</span>]; k++) <span class="comment">//各组中物品的序号</span></span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w[num[i][k]])</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[num[i][k]]] + v[num[i][k]]);</span><br><span class="line">    cout &lt;&lt; dp[m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HDU2955"><a href="#HDU2955" class="headerlink" title="HDU2955"></a>HDU2955</h3><h3 id="HDU3466"><a href="#HDU3466" class="headerlink" title="HDU3466"></a>HDU3466</h3><h3 id="HDU1881"><a href="#HDU1881" class="headerlink" title="HDU1881"></a>HDU1881</h3><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><p><a href="http://www.cnblogs.com/Kalix/p/7622102.html">动态规划之完全背包详解</a></p><h2 id="hdu-1114-Piggy-Bank（完全背包）"><a href="#hdu-1114-Piggy-Bank（完全背包）" class="headerlink" title="hdu 1114 Piggy-Bank（完全背包）"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1114">hdu 1114 Piggy-Bank（完全背包）</a></h2><p>大意：给出存钱罐本身的重量和装钱后的重量，以及存钱罐中钱的面值和重量，求存钱罐装满时，钱的总和最小是多少</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-15 12:32:04</span></span><br><span class="line"><span class="comment"> Exe.Time:46MS Exe.Memory：1828k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1E9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E5</span> + <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> weight[MAXN], value[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++)</span><br><span class="line">        dp[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> empty, full;</span><br><span class="line">        cin &gt;&gt; empty &gt;&gt; full;</span><br><span class="line">        <span class="type">int</span> V = full -empty;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; value[i] &gt;&gt; weight[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= V; j++)</span><br><span class="line">                dp[j] = <span class="built_in">min</span>(dp[j - weight[i]] + value[i], dp[j]);</span><br><span class="line">        <span class="keyword">if</span>(dp[V] == INF)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;This is impossible.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;The minimum amount of money in the piggy-bank is &quot;</span></span><br><span class="line">                &lt;&lt; dp[V] &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2191">HDU2191-悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</a></p><p>此题当中是把重量当成每件物品的价值。把总的钱数当成背包的容量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-25 11:04:19</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS Exe.Memory：1428KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cntValue, cntKind, value[MAXN], weight[MAXN], bag[MAXN], dp[MAXN]; <span class="comment">//bag--每个物品的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        cin &gt;&gt; cntValue &gt;&gt; cntKind;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntKind; i++)</span><br><span class="line">            cin &gt;&gt; value[i] &gt;&gt; weight[i] &gt;&gt; bag[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cntKind; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; bag[i]; j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = cntValue; k &gt;=value[i]; k--)</span><br><span class="line">                    dp[k] = <span class="built_in">max</span>(dp[k], dp[k - value[i]] + weight[i]);</span><br><span class="line">        cout &lt;&lt; dp[cntValue] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM算法 </tag>
            
            <tag> 部分背包 </tag>
            
            <tag> 01背包 </tag>
            
            <tag> 完全背包 </tag>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递推(for beginner)</title>
      <link href="/2018/04/27/%E9%80%92%E6%8E%A8-for-beginner/"/>
      <url>/2018/04/27/%E9%80%92%E6%8E%A8-for-beginner/</url>
      
        <content type="html"><![CDATA[<p>斐波那契兔子问题、斐波那契数－从爬楼梯问题、HDU2046 骨牌铺方格、ＨDU2044 一只小蜜蜂、HDU2048 神、上帝以及老天爷、HDU2049 不容易系列之(4)——考新郎、递推中的平面问题、HDU 2097 Children’s Queue、HDU2045 不容易系列之(3)—— LELE的RPG难题、HDU2047 阿牛的EOF牛肉、for beginner,HDU2563统计问题</p><span id="more"></span><h1 id="递推的基本思想"><a href="#递推的基本思想" class="headerlink" title="递推的基本思想"></a>递推的基本思想</h1><ol><li>首先确认，是否能很容易的得到简单情况的解</li><li><ul><li>假设规模为N-1的情况已经得到解决</li><li>重点分析：当规模扩大到N时，如何枚举出所有的情况，并且要确保对于每一种子情况都能用已经得到的数据解决</li></ul></li><li><ul><li>编程中的空间换时间的思想</li><li>并不一定是从N-1到N的分析</li></ul></li></ol><h1 id="递推中的经典——Fibonacci-sequence-斐波那契数列"><a href="#递推中的经典——Fibonacci-sequence-斐波那契数列" class="headerlink" title="递推中的经典——Fibonacci sequence(斐波那契数列)"></a>递推中的经典——Fibonacci sequence(斐波那契数列)</h1><p>先上递推中的fib数列的解题模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>( cin &gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ll arr[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= num; i++)</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">        cout &lt;&lt; arr[num]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：</p><ol><li><p>最经典当然是兔子繁殖问题 <a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98/1430035">斐波那契兔子问题</a></p></li><li><p>还有一个经典的上楼梯问题<a href="https://blog.csdn.net/bairongdong1/article/details/52270726">斐波那契数－从爬楼梯问题</a></p></li><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2046">HDU2046 骨牌铺方格</a></p><p>解题:<a href="https://blog.csdn.net/hellohelloC/article/details/47699831">HDU 2046 骨牌铺方格(简单递推）</a></p><p>自己代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>( cin &gt;&gt;num)</span><br><span class="line">    &#123;</span><br><span class="line">        ll arr[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= num; i++)</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">        cout &lt;&lt; arr[num]  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   主要还是推出这个状态可以由上次的状态推出。</p><ol><li><p>小变形:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2044">ＨDU2044 一只小蜜蜂</a></p><p>解题:<a href="https://blog.csdn.net/xu_fish/article/details/50128855">一只小蜜蜂</a></p><p>自己代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> arr[<span class="number">10000</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a , b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b)<span class="comment">//保证总是从数字较小的蜂房到数字数字较大的蜂房，直接相减可能会出现负数</span></span><br><span class="line">        &#123;</span><br><span class="line">                temp=a;</span><br><span class="line">                a=b;</span><br><span class="line">                b=temp;</span><br><span class="line">       &#125;</span><br><span class="line">        b = b - a + <span class="number">1</span>;<span class="comment">//化为斐波那契数列模式，即从3走到4可以化为求fib里面的f(2)</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span> ;i &lt;= b; i++)</span><br><span class="line">            arr[i] = arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">        cout &lt;&lt; arr[b];</span><br><span class="line">     <span class="comment">//   if(n != 0)</span></span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="错排公式"><a href="#错排公式" class="headerlink" title="错排公式"></a>错排公式</h1><ol><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2048">HDU2048 神、上帝以及老天爷</a></p><p>解题:<a href="https://blog.csdn.net/a1647566717/article/details/6680001">HDU2048</a></p><p>公式:M(n)=(n-1)[M(n-2)+M(n-1)]，可以考虑参考上面理解</p><p>自己代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        ll arr[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">1</span>; </span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= num; i++) <span class="comment">//所有人抽不到的结果</span></span><br><span class="line">            arr[i] = (arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>]) * (i - <span class="number">1</span>);</span><br><span class="line">        ll all = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= num; i++) <span class="comment">//所有可能出现的结果</span></span><br><span class="line">            all *= i;</span><br><span class="line">        <span class="type">double</span> ans = arr[num] / (<span class="type">double</span>)all; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.02lf%%\n&quot;</span>, ans * <span class="number">100</span>); <span class="comment">//四舍五入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2049">HDU2049 不容易系列之(4)——考新郎</a></p><p>解题:<a href="https://blog.csdn.net/zhouhong1026/article/details/7855919">HDU2049</a></p><p>其实就是部分排错，利用组合公式实现成小部分群体中全部排错的效果，从而可以用公式</p><p>自己代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//求n！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        num *= i;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        ll arr[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= m; i++)<span class="comment">//公式</span></span><br><span class="line">            arr[i] = (i - <span class="number">1</span>) * (arr[i - <span class="number">1</span>] + arr[i <span class="number">-2</span>]);</span><br><span class="line">       cout &lt;&lt; <span class="built_in">fun</span>(n) / <span class="built_in">fun</span>(m) / <span class="built_in">fun</span>(n - m) * arr[m] &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//CMN=N!/M!/(N-M)!,然后再乘上公式得到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>   ​</p><h1 id="递推中的平面问题"><a href="#递推中的平面问题" class="headerlink" title="递推中的平面问题"></a>递推中的平面问题</h1><ol><li><p>n条直线分平面问题</p></li><li><p>封闭曲线分平面问题</p></li><li><p>折线分割平面</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2050">HDU 2050</a></p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin &gt;&gt;num;</span><br><span class="line">    ll arr[<span class="number">100000</span>] = &#123;<span class="number">0</span>&#125;;  </span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= num; i++)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + <span class="number">4</span>*(i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; arr[num]  &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>平面割空间</li><li>圆圈分割平面</li></ol><ul><li>设有n条封闭曲线画在平面上，而任何两条封闭曲线恰好相交于两点，且任何三条封闭曲线不相交于同一点，问这些封闭曲线把平面分割成的区域个数。</li></ul><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E9%80%89%E5%8C%BA_011.png"></p></li></ol><p>   可以看pdf,<a href="https://github.com/GreenHatHG/blog_image/blob/master/%E5%90%84%E7%A7%8D%E5%88%86%E5%89%B2%E9%97%AE%E9%A2%98(hdu2050%261290">github</a>.pdf)</p><h1 id="假装前面排错系列"><a href="#假装前面排错系列" class="headerlink" title="假装前面排错系列"></a>假装前面排错系列</h1><ol><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1297">HDU 2097 Children’s Queue</a></p><p>解析：</p><p>按照最后一个人的性别分析，他要么是男，要么是女，所以可以分两大类讨论：</p></li></ol><ul><li>如果n个人的合法队列的最后一个人是男，则对前面n-1个人的队列没有任何限制，他只要站在最后即可，所以，这种情况一共有F(n-1);</li><li><p>如果n个人的合法队列的最后一个人是女，则要求队列的第n-1个人务必也是女生，这就是说，限定了最后两个人必须都是女生，这又可以分两种情况：</p><ul><li>如果队列的前n-2个人是合法的队列，则显然后面再加两个女生，也一定是合法的，这种情况有F(n-2);</li><li>但是，难点在于，即使前面n-2个人不是合法的队列，加上两个女生也有可能是合法的，当然，这种长度为n-2的不合法队列，不合法的地方必须是尾巴，就是说，这里说的长度是n-2的不合法串的形式必须是“F(n-4)+男+女”，这种情况一共有F(n-4).</li></ul><p>所以，通过以上的分析，可以得到递推的通项公式：F(n)=F(n-1)+F(n-2)+F(n-4)   (n&gt;3)。然后就是对n&lt;=3 的一些特殊情况的处理了，显然：F(0)=1   (没有人也是合法的，这个可以特殊处理，就像0的阶乘定义为1一样)   F(1)=1，F(2)=2，F(3)=4</p><p>根据这个公式计算f(n),其数列值的增长速度太快了，需要构筑一个大整数类来解决。此处选择用java解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextInt())</span><br><span class="line">        &#123;</span><br><span class="line">            num = in.nextInt();</span><br><span class="line">            BigInteger[] arr = <span class="keyword">new</span> <span class="title class_">BigInteger</span>[<span class="number">10000</span>];</span><br><span class="line">            arr[<span class="number">0</span>] =BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">            arr[<span class="number">1</span>] = BigInteger.valueOf(<span class="number">1</span>);</span><br><span class="line">            arr[<span class="number">2</span>] = BigInteger.valueOf(<span class="number">2</span>);</span><br><span class="line">            arr[<span class="number">3</span>] =BigInteger.valueOf(<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>; i &lt;= num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                arr[i] = arr[i - <span class="number">2</span>].add(arr[i  - <span class="number">1</span>]);</span><br><span class="line">                arr[i] = arr[i].add(arr[i - <span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(arr[num]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ol><li><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2045">HDU2045 不容易系列之(3)—— LELE的RPG难题</a></p><p>解题：<a href="https://blog.csdn.net/mengxianglong123/article/details/79881899">HDU2045</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ll arr[<span class="number">100000</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">            arr[i] = <span class="number">2</span> * arr[i - <span class="number">2</span>] + arr[i  - <span class="number">1</span>];</span><br><span class="line">        cout &lt;&lt; arr[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li><a href="https://blog.csdn.net/jarvenman/article/details/53132732">HDU2047 阿牛的EOF牛肉</a></li></ol><p>解题:<a href="https://blog.csdn.net/jarvenman/article/details/53132732">HDU2047</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">    ll arr[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = <span class="number">2</span> * (arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>for beginner:</em></strong></p><ul><li>HDU1290 献给杭电五十周年校庆的礼物 </li><li>HDU1297 Children’s Queue </li><li>HDU1438 钥匙计数之一 </li><li>HDU1465 ~1466 1480 钥匙计数之二 </li><li>HDU2013 蟠桃记 </li><li>HDU2018 母牛的故事 </li><li>HDU2041~2042<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</li><li>HDU2044~2050 (10/5专题练习)</li></ul><h1 id="HDU2563-统计问题"><a href="#HDU2563-统计问题" class="headerlink" title="HDU2563 统计问题"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2563">HDU2563 统计问题</a></h1><p><strong>递推</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目信息转化：当你走完第（n-2)步</span><br><span class="line">           （1）.如果你向左（或向右）走出第(n-1)步，你的第n步只能选择向右（或向左）和向上。（因为你走的前一步路会塌陷而不能再走）</span><br><span class="line">           （2）.如果你向上走出第（n-1）步，那你的第n步可以选择向左向右向上三个方向。</span><br><span class="line">（如果你能理解上面的意思那么推出公式对你来说就是小菜一碟了）</span><br><span class="line"></span><br><span class="line">递推公式思路：当你走完第（n-1）步，你一定有至少两个方向可以选择，故此时能走两个方向的情况为 2*f(n-1)。</span><br><span class="line">           若你想走完第（n-1）步后一定有三个方向可以选择，则要求走完第(n-2)步后必须是向上走出（n-1）步，故此时的情况数为 f(n-2)。</span><br><span class="line"></span><br><span class="line">综上所述： f(n) = 2*f(n-1) + f(n-2)</span><br></pre></td></tr></table></figure><p>参考：<a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=30032&amp;messageid=1&amp;deep=0">http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=30032&amp;messageid=1&amp;deep=0</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Time:  2018-10-17 11:27:08</span></span><br><span class="line"><span class="comment"> Ext.time:  2ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">        arr[i] = <span class="number">2</span> * arr[i - <span class="number">1</span>] + arr[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        cout &lt;&lt; arr[num] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DFS</strong></p><p>DFS的话是超时了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">3</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> has[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; !arr[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, cnt - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[x][y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span> ,<span class="built_in">sizeof</span>(arr));</span><br><span class="line">        has[i] = <span class="built_in">dfs</span>(<span class="number">500</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        cout &lt;&lt; has[num] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前写了一发错误的dfs，首先是dfs方向走错了，搞混了x，y轴，向下是x轴，向右是y轴。其次是状态回溯搞错了，应该是回溯最后一个点，而不是前一个点，因为最后那一个点可能通过别的方式还会走到。还有一个就是每次走过一个点应该标记，那个标记语句应该放在for里面，放在外面的话</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="type">int</span> arr[MAXN][MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">3</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> has[<span class="number">25</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cnt, <span class="type">const</span> <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || cnt &gt; n || arr[i][j])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    arr[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; !arr[x][y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, cnt + <span class="number">1</span>, n);</span><br><span class="line">            <span class="keyword">if</span>(cnt == n)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改正后的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int dfs(int i, int j, int cnt, const int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(cnt == n)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ans++;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    for(int k = 0; k &lt; 3; k++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int x = i + dir[k][0];</span></span><br><span class="line"><span class="comment">        int y = j + dir[k][1];</span></span><br><span class="line"><span class="comment">        if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; !arr[x][y])</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            arr[i][j] = 1;</span></span><br><span class="line"><span class="comment">            dfs(x, y, cnt + 1, n);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        arr[x][y] = 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return ans;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span> ,<span class="built_in">sizeof</span>(arr));</span><br><span class="line">        has[i] = <span class="built_in">dfs</span>(<span class="number">500</span>, <span class="number">500</span>, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        cout &lt;&lt; has[num] &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HDU2044~2050 (10/5专题练习)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推 </tag>
            
            <tag> 错排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字特点</title>
      <link href="/2018/04/26/%E6%95%B0%E5%AD%97%E7%89%B9%E7%82%B9/"/>
      <url>/2018/04/26/%E6%95%B0%E5%AD%97%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>能被整除的那些事</p><span id="more"></span><h1 id="能被2整除"><a href="#能被2整除" class="headerlink" title="能被2整除"></a>能被2整除</h1><p>若一个整数的末位是0、2、4、6或8，则这个数能被2整除。 </p><h1 id="能被3整除"><a href="#能被3整除" class="headerlink" title="能被3整除"></a>能被3整除</h1><p>若一个整数的数字和能被3整除，则这个整数能被3整除。 </p><h1 id="能被4整除"><a href="#能被4整除" class="headerlink" title="能被4整除"></a>能被4整除</h1><p>若一个整数的末尾两位数能被4整除，则这个数能被4整除</p><h1 id="能被5整除"><a href="#能被5整除" class="headerlink" title="能被5整除"></a>能被5整除</h1><p>若一个整数的末位是0或5，则这个数能被5整除</p><h1 id="能被6整除"><a href="#能被6整除" class="headerlink" title="能被6整除"></a>能被6整除</h1><p>能被6整除的数的特征末尾是0、2、4、6、8且各位上数字的和能被3整除<br>能被6整除的数的特征既要符合能被2整除的数的特征,又要符合能被3整除的数的特征  </p><h1 id="能被7整除"><a href="#能被7整除" class="headerlink" title="能被7整除"></a>能被7整除</h1><p>若一个整数的个位数字截去，再从余下的数中，减去个位数的2倍，如果差是7的倍数，则原数能被7整除。如果差太大或心算不易看出是否7的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止。例如，判断133是否7的倍数的过程如下：13－3×2＝7，所以133是7的倍数；又例如判断6139是否7的倍数的过程如下：613－9×2＝595 ， 59－5×2＝49，所以6139是7的倍数，余类推。 </p><h1 id="能被8整除"><a href="#能被8整除" class="headerlink" title="能被8整除"></a>能被8整除</h1><p>若一个整数的未尾三位数能被8整除，则这个数能被8整除</p><h1 id="能被9整除"><a href="#能被9整除" class="headerlink" title="能被9整除"></a>能被9整除</h1><p>若一个整数的数字和能被9整除，则这个整数能被9整除</p><h1 id="能被10整除"><a href="#能被10整除" class="headerlink" title="能被10整除"></a>能被10整除</h1><p>若一个整数的末位是0，则这个数能被10整除。</p><h1 id="能被11整除"><a href="#能被11整除" class="headerlink" title="能被11整除"></a>能被11整除</h1><p>若一个整数的奇位数字之和与偶位数字之和的差能被11整除，则这个数能被11整除。11的倍数检验法也可用上述检查7的「割尾法」处理！过程，唯一不同的是：倍数不是2而是1！</p><h1 id="能被12整除"><a href="#能被12整除" class="headerlink" title="能被12整除"></a>能被12整除</h1><p>若一个整数能被3和4整除，则这个数能被12整除</p><h1 id="能被13整除"><a href="#能被13整除" class="headerlink" title="能被13整除"></a>能被13整除</h1><p>若一个整数的个位数字截去，再从余下的数中，加上个位数的4倍，如果差是13的倍数，则原数能被13整除。如果差太大或心算不易看出是否13的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止。 </p><h1 id="能被17整除"><a href="#能被17整除" class="headerlink" title="能被17整除"></a>能被17整除</h1><ul><li>若一个整数的个位数字截去，再从余下的数中，减去个位数的5倍，如果差是17的倍数，则原数能被17整除。如果差太大或心算不易看出是否17的倍数，就需要继续上述「截尾、倍大、相减、验差」的过程，直到能清楚判断为止</li><li>若一个整数的末三位与3倍的前面的隔出数的差能被17整除，则这个数能被17整除</li></ul><h1 id="能被19整除"><a href="#能被19整除" class="headerlink" title="能被19整除"></a>能被19整除</h1><ul><li>若一个整数的个位数字截去，再从余下的数中，加上个位数的2倍，如果差是19的倍数，则原数能被19整除。如果差太大或心算不易看出是否19的倍数，就需要继续上述「截尾、倍大、相加、验差」的过程，直到能清楚判断为止</li><li>若一个整数的末三位与7倍的前面的隔出数的差能被19整除，则这个数能被19整除</li></ul><h1 id="能被23整除"><a href="#能被23整除" class="headerlink" title="能被23整除"></a>能被23整除</h1><p>若一个整数的末四位与前面5倍的隔出数的差能被23(或29)整除，则这个数能被23整除</p><h1 id="能被43整除"><a href="#能被43整除" class="headerlink" title="能被43整除"></a>能被43整除</h1><ul><li>若一个整数去掉末两位数字后扩大14倍与末两位数字的数的和（得到和后可重复进行），若最后结果能被43整除，则该数就能被43整除，否则不能(如果在重复计算的过程中有重复数出现，则可以判断这个数不能被43整除)。</li><li>一个整数的个位数字扩大13倍与去掉个位数字后的数的和（得到和后可重复进行），若最后结果能被43整除，则该数就能被43整除，否则就不能(如果在重复计算的过程中有重复数出现，则可以判断这个数不能被43整除)。</li></ul><h1 id="能被7-11-13整除"><a href="#能被7-11-13整除" class="headerlink" title="能被7,11,13整除"></a>能被7,11,13整除</h1><p>若一个整数数的末三位数与末三位数以前的数字所组成的数之差能被7、11、13整除，则这个数能被7、11、13整除。</p><h1 id="整除的性质"><a href="#整除的性质" class="headerlink" title="整除的性质"></a>整除的性质</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)若a|b，且b|c，则a|c。</span><br><span class="line">(2)若a|b且a|c，等价于对于任意的整数x、y，有a|(b*x+c*y)。</span><br><span class="line">(3)设m≠0，则a|b等价于(m*a)|(m*b)。</span><br><span class="line">(4)若a|b，且b|a，则a=±b。</span><br><span class="line">(5)若a|b且b≠0，则|a|≤|b|。</span><br><span class="line">(6)设整数x、y满足下式：a*x+b*y=1，且a|n，b|n，那么(a*b)|n。</span><br></pre></td></tr></table></figure><p>参考:<a href="http://acm.sdibt.edu.cn/blog/?p=1204">关于整除</a></p><h1 id="大数被整除的万能公式"><a href="#大数被整除的万能公式" class="headerlink" title="大数被整除的万能公式"></a>大数被整除的万能公式</h1><p>除了用大数整除方法外，可以试试下面的万能公式  </p><p>原理：每一个A都可以分解成n*B+C，其中C为A%B的值，这样的话我们能够想到一个数可以将其前缀每次都modB，最后得到的数如果是0的话，那么能够整除，否者不能整除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str; <span class="comment">//输入被除数</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;   <span class="comment">//输入除数</span></span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp *= <span class="number">10</span>;</span><br><span class="line">        temp += str[i];</span><br><span class="line">        temp %= n;</span><br><span class="line">        <span class="comment">//temp = (temp * 10 + (str[i] - &#x27;0&#x27;)) % n;//整合式子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp % n == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl; <span class="comment">//能被整除</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：  </p><p>要判断的这个数先拆分成两个数的和或者差，要求较大数必须是这个数的倍数，这样我们只要判断较小的数就可以了。如果较小的这个数也能被这个数整除，我们就说原来这个数也一定能被这个数整除。</p><ul><li>936能不能被7整除。  </li></ul><p>我们要判断936这个数能不能被7整除，可以先把936拆成两个数的和：936=910+26。由于较大数910是7的倍数(能被7整除)，因此我们只要判断较小数26能不能被7整除就行了。因为26不是7的倍数，不能被7整除，所以936也一定不能被7整除。   </p><p>所以我们通过拆分法来解释这个问题</p><ul><li>我们随便取一个数289  </li></ul><p>2/17=0…….2相当于289-17*0=289  </p><p>28/17=1…….11相当于289-17*10=119  </p><p>119不能被17整除  </p><ul><li>34    </li></ul><p>3%17=0…….3相当于34-17*0=34  </p><p>34%17=2……0相当于34-17*2=0！  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
            <tag> 整除 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map几道水题</title>
      <link href="/2018/04/06/map%E5%87%A0%E9%81%93%E6%B0%B4%E9%A2%98/"/>
      <url>/2018/04/06/map%E5%87%A0%E9%81%93%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>uva156 codeforces 959B</p><span id="more"></span><h1 id="uva156"><a href="#uva156" class="headerlink" title="uva156"></a>uva156</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中大小写，按照字典序进行排序。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ladder came tape soon leader acme RIDE lone Dreis peat</span><br><span class="line"> ScAlE orb  eye  Rides dealer  NotE derail LaCeS  drIed</span><br><span class="line">noel dire Disk mace Rob dries</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Disk</span><br><span class="line">NotE</span><br><span class="line">derail</span><br><span class="line">drIed</span><br><span class="line">eye</span><br><span class="line">ladder</span><br><span class="line">soon</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>其实这道题挺简单的，把所有单词变成小写，然后排序，然后放到map里面，没有重复的就输出，但是自己写的过程中还是出了点问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将输进来的字符串转换成小写，并且按照字典序从小到大排序</span></span><br><span class="line"><span class="function">string <span class="title">repr</span><span class="params">(<span class="type">const</span> string&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string ans = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">length</span>(); i++)</span><br><span class="line">        ans[i] = <span class="built_in">tolower</span>(ans[i]);</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;   <span class="comment">//接受输入的单词</span></span><br><span class="line">    vector&lt;string&gt; words;   <span class="comment">//储存输入的所有单词</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        words.<span class="built_in">push_back</span>(s);</span><br><span class="line">        string r = <span class="built_in">repr</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(!cnt.<span class="built_in">count</span>(r))</span><br><span class="line">            cnt[r] = <span class="number">0</span>;   <span class="comment">//如果r之前没有被插入到中，则将cnt的第二个值，也就是value变成0</span></span><br><span class="line">        cnt[r]++;   <span class="comment">//这里代表着字符串r出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;string&gt; ans; <span class="comment">//保存满足条件的单词</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="built_in">repr</span>(words[i])] == <span class="number">1</span>) <span class="comment">//如果处理后的单词在cnt只出现一次的话，那么就输出,注意这里不能改words里面的内容。</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());   <span class="comment">//按照字典序输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，差不多就是先把要输入的单词经过处理后放到map里面，然后记录出现的次数，一点注意就是函数不能直接处理存放所有单词的数组，因为要按照原样输出，所以在处理函数里面赋值给了一个新的字符串，然后返回，最后再遍历一次map，把满足条件的输出。其实这里处理了两次，一次在输入后处理后放到map，一次是把words数组里面的元素处理后当做map的key去判断改key有没有满足这个条件。</p><h1 id="codeforces-959B"><a href="#codeforces-959B" class="headerlink" title="codeforces 959B"></a>codeforces 959B</h1><h2 id="题目原文：959B"><a href="#题目原文：959B" class="headerlink" title="题目原文：959B"></a>题目原文：<a href="http://codeforces.com/problemset/problem/959/B">959B</a></h2><p>一个人给另一个人发消息，其中发的消息里面的信息，每一个信息都有对应的价值，也就是发送的成本。 这个想发送的成本最低。输出最低的成本。代表输入n个已知的信息，下面一行对应每个信息的价值。然后是k行，每一行第一个就代表有x个可以互相替换的信息的下标。</p><p>参考：<a href="https://blog.csdn.net/memory_qianxiao/article/details/79828217">csdn</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p> 模拟  这道题两秒  暴力大法好 用map用string longlong 对应值。耐心模拟就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; gr;</span><br><span class="line">string arr[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> cost[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> gcost[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cin &gt;&gt; cost[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        gcost[i]=INT_MIN;   </span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> z;</span><br><span class="line">            cin &gt;&gt; z; z--;</span><br><span class="line">            gcost[i]=<span class="built_in">min</span>(gcost[i],cost[z]);</span><br><span class="line">            gr[arr[z]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        ans+=gcost[gr[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++/java思维导图各两张</title>
      <link href="/2018/04/06/c-java%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%90%84%E4%B8%A4%E5%BC%A0/"/>
      <url>/2018/04/06/c-java%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E5%90%84%E4%B8%A4%E5%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>c++/java思维导图各两张</p><span id="more"></span><h1 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/c%2B%2B%E6%80%9D%E7%BB%B4.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/c%2B%2B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png"></p><h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><p>还有一个网址，里面列出来了比较详细的思维导图</p><p><a href="https://segmentfault.com/a/1190000013700582">Java知识汇总——思维导图</a></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/java%E6%80%9D%E7%BB%B4.jpg"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/java%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.jpg"></p><p>转载自： </p><p><a href="https://blog.csdn.net/jackfrued/article/details/41576837">Java基础知识思维导图</a></p><p><a href="https://www.jianshu.com/p/1480cbf8891e">c++知识思维导图</a></p><p><a href="https://www.2cto.com/kf/201712/703613.html">C++初学者必看的知识思维导图</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习路线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ map</title>
      <link href="/2018/04/03/c-map/"/>
      <url>/2018/04/03/c-map/</url>
      
        <content type="html"><![CDATA[<p> map和multimap</p><span id="more"></span><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ol><li>c++有map和multimap两种容器，区别在于multimap允许重复元素，map则不允许，在头文件中&lt; map &gt;中定义</li><li>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字(key)，每个关键字只能在map中出现一次，第二个可能称为该关键字的值(value)）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的</li></ol><p>&lt;/div&gt;</p><p><div align="center"><br><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/map-example.png"></div></p><ol><li><p>它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。</p></li><li><p>自动建立Key － value的对应。key 和 value可以是任意你需要的类型。  <strong>根据key值快速查找记录，查找的复杂度基本是Log</strong>(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p></li><li><p>什么是一对一的数据映射。比如一个班级中，每个学生的学号跟他的姓名就存在着一一映射的关系，这个模型用map可能轻易描述，很明显学号用int描述，姓名用字符串描述,下面给出map描述代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; mapStudent;</span><br></pre></td></tr></table></figure></li></ol><h1 id="声明初始化"><a href="#声明初始化" class="headerlink" title="声明初始化"></a>声明初始化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name;</span><br><span class="line">map&lt;<span class="type">int</span>, string, op&gt;; <span class="comment">//以op为排序准则。</span></span><br><span class="line"><span class="comment">// 使用&#123;&#125;赋值是从c++11开始的，因此编译器版本过低时会报错，如visual studio 2012</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; ID_Name = &#123;</span><br><span class="line">                &#123; <span class="number">2015</span>, <span class="string">&quot;Jim&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2016</span>, <span class="string">&quot;Tom&quot;</span> &#125;,</span><br><span class="line">                &#123; <span class="number">2017</span>, <span class="string">&quot;Bob&quot;</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h1 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h1><h2 id="使用数组方式插入"><a href="#使用数组方式插入" class="headerlink" title="使用数组方式插入"></a>使用数组方式插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">    mymap[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//如果已经存在键值10，则会作赋值修改操作，如果没有则插入</span></span><br><span class="line">    cout &lt;&lt; mymap.<span class="built_in">begin</span>()-&gt;first &lt;&lt; mymap.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：10hello</span></span><br></pre></td></tr></table></figure><h2 id="使用insert进行单个和多个插入"><a href="#使用insert进行单个和多个插入" class="headerlink" title="使用insert进行单个和多个插入"></a>使用insert进行单个和多个插入</h2><h3 id="插入单个键值对"><a href="#插入单个键值对" class="headerlink" title="插入单个键值对"></a>插入单个键值对</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入单个键值对，并返回插入位置和成功标志，插入位置已经存在值时，插入失败</span></span><br><span class="line"><span class="function">pair&lt;iterator,<span class="type">bool</span>&gt; <span class="title">insert</span> <span class="params">(<span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>一个简单的栗子，使用插入功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>); <span class="comment">//关闭同步，加快速度</span></span><br><span class="line">    </span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>, <span class="number">2010</span>));</span><br><span class="line">    <span class="comment">//mymap.insert(make_pair(&quot;hello world&quot;, 2010));</span></span><br><span class="line">    <span class="comment">//插入单个键值对</span></span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; iter-&gt;second;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：hello world 2010</span></span><br></pre></td></tr></table></figure><p>使用返回值的判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>,  <span class="number">2010</span>));</span><br><span class="line"></span><br><span class="line">    pair&lt;map&lt;string, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello&quot;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="comment">//auto ret = mymap.insert(pair&lt;string, int&gt;(&quot;hello&quot;, 500));</span></span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>)</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;already existed&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         cout &lt;&lt; ret.first-&gt;second ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：hello 500</span></span><br></pre></td></tr></table></figure><p>下面是插入相同的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>,  <span class="number">2010</span>));</span><br><span class="line"></span><br><span class="line">    pair&lt;map&lt;string, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; ret;</span><br><span class="line">    ret = mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>, <span class="number">500</span>));</span><br><span class="line">    <span class="keyword">if</span> (ret.second == <span class="literal">false</span>)</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;already existed&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">         cout &lt;&lt; ret.first-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         cout &lt;&lt; ret.first-&gt;second ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：already existed</span></span><br></pre></td></tr></table></figure><p>可见，key或value与map里面已经存在的内容相同的话，就会不能插入</p><h3 id="在指定位置插入"><a href="#在指定位置插入" class="headerlink" title="在指定位置插入"></a>在指定位置插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定位置插入，在不同位置插入效率是不一样的，因为涉及到重排</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span> <span class="params">(const_iterator position, <span class="type">const</span> value_type&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>, <span class="number">2010</span>));</span><br><span class="line"></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt;::iterator it = mymap.<span class="built_in">begin</span>() ;</span><br><span class="line">     <span class="comment">//auto it = mymap.begin();</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(it, <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;good morning, &quot;</span>, <span class="number">300</span>));</span><br><span class="line"><span class="comment">//在开始位置插入</span></span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; iter-&gt;second;</span></span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：good morning, hello world</span></span><br></pre></td></tr></table></figure><h3 id="插入多个"><a href="#插入多个" class="headerlink" title="插入多个"></a>插入多个</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;z&#x27;</span>, <span class="number">200</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;b&#x27;</span>, <span class="number">300</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;c&#x27;</span>, <span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//范围多值插入</span></span><br><span class="line">    std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; anothermap;</span><br><span class="line">    anothermap.<span class="built_in">insert</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="string">&#x27;z&#x27;</span>));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span> iter = anothermap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != anothermap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：abc</span></span><br><span class="line"><span class="comment">//自己的值插给自己是没有意义的，因为map不能存在相同元素</span></span><br></pre></td></tr></table></figure><h3 id="列表插入"><a href="#列表插入" class="headerlink" title="列表插入"></a>列表插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(&#123;&#123;<span class="string">&#x27;a&#x27;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&#x27;b&#x27;</span>, <span class="number">200</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*程序输出：</span></span><br><span class="line"><span class="comment">a100</span></span><br><span class="line"><span class="comment">b200</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关于更多insert信息以及c++17定义的insert函数可以参考:</p><p><a href="http://zh.cppreference.com/w/cpp/container/map/insert">std::map::insert</a></p><h1 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h1><p>map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">    mymap[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">//使用at会进行关键字检查，因此下面语句会报错</span></span><br><span class="line">    mymap.<span class="built_in">at</span>(<span class="number">2016</span>) = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mymap中没有关键字2017，使用[]取值会导致插入</span></span><br><span class="line"><span class="comment">//因此，下面语句不会报错，但打印结果为空</span></span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">2017</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取key和value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;mymap;</span><br><span class="line">mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(<span class="string">&quot;hello world&quot;</span>, <span class="number">2010</span>));</span><br><span class="line"><span class="keyword">auto</span> pos = mymap,<span class="built_in">begin</span>();</span><br><span class="line">cout &lt;&lt; pos-&gt;first; <span class="comment">//取出key</span></span><br><span class="line">cout &lt;&lt; pos-&gt;second; <span class="comment">//取出value</span></span><br><span class="line"><span class="comment">//pos-&gt;first是(*pos).first的简写形式</span></span><br><span class="line"></span><br><span class="line">pos-&gt;first = <span class="string">&quot;hello&quot;</span>; <span class="comment">//如果尝试改变元素的key，会引发错误</span></span><br><span class="line">pos-&gt;second = <span class="number">13</span>; <span class="comment">//改变value则没有问题</span></span><br></pre></td></tr></table></figure><p>注意：map提供了一种非常方便的方法让你改变元素的key</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert new element with value of old element</span></span><br><span class="line">coll[<span class="string">&quot;new_key&quot;</span>] = coll[<span class="string">&quot;old_key&quot;</span>];</span><br><span class="line"><span class="comment">// remove old element</span></span><br><span class="line">coll.<span class="built_in">erase</span>(<span class="string">&quot;old_key&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="容量查询"><a href="#容量查询" class="headerlink" title="容量查询"></a>容量查询</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询map是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map中键值对的数量</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询map所能包含的最大键值对数量，和系统和应用库有关。</span></span><br><span class="line"><span class="comment">// 此外，这并不意味着用户一定可以存这么多，很可能还没达到就已经开辟内存失败了</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询关键字为key的元素的个数，在map里结果非0即1</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count</span><span class="params">( <span class="type">const</span> Key&amp; key )</span> <span class="type">const</span></span>; </span><br></pre></td></tr></table></figure><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>共有八个获取迭代器的函数：<strong> begin, end, rbegin,rend\</strong> 以及对应的 <strong> cbegin, cend, crbegin,crend\</strong>。</p><p>二者的区别在于，后者一定返回 const_iterator，而前者则根据map的类型返回iterator 或者 const_iterator。const情况下，不允许对值进行修改。如下面代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mmap;</span><br><span class="line"><span class="type">const</span> map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; const_mmap;</span><br><span class="line"></span><br><span class="line">it = mmap.<span class="built_in">begin</span>(); <span class="comment">//iterator</span></span><br><span class="line">mmap.<span class="built_in">cbegin</span>(); <span class="comment">//const_iterator</span></span><br><span class="line"></span><br><span class="line">const_mmap.<span class="built_in">begin</span>(); <span class="comment">//const_iterator</span></span><br><span class="line">const_mmap.<span class="built_in">cbegin</span>(); <span class="comment">//const_iterator</span></span><br></pre></td></tr></table></figure><p>返回的迭代器可以进行加减操作，此外，如果map为空，则 begin = end。</p><h1 id="删除交换"><a href="#删除交换" class="headerlink" title="删除交换"></a>删除交换</h1><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h4 id="删除一定范围内的元素"><a href="#删除一定范围内的元素" class="headerlink" title="删除一定范围内的元素"></a>删除一定范围内的元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除一定范围内的元素，并返回一个指向下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>,<span class="string">&quot;asdf&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>,<span class="string">&quot;qwer&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>,<span class="string">&quot;zxcv&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">erase</span>(mymap.<span class="built_in">begin</span>(), mymap.<span class="built_in">find</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序输出：</span></span><br><span class="line"><span class="number">2</span> qwer</span><br><span class="line"><span class="number">3</span> zxcv</span><br></pre></td></tr></table></figure><h4 id="删除迭代器指向位置的键值对"><a href="#删除迭代器指向位置的键值对" class="headerlink" title="删除迭代器指向位置的键值对"></a>删除迭代器指向位置的键值对</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator pos )</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>,<span class="string">&quot;asdf&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>,<span class="string">&quot;qwer&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>,<span class="string">&quot;zxcv&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">erase</span>(mymap.<span class="built_in">find</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：</span></span><br><span class="line"><span class="number">1</span> asdf</span><br><span class="line"><span class="number">3</span> zxcv</span><br></pre></td></tr></table></figure><h3 id="根据Key来进行删除"><a href="#根据Key来进行删除" class="headerlink" title="根据Key来进行删除"></a>根据Key来进行删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">erase</span><span class="params">( <span class="type">const</span> key_type&amp; key )</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>,<span class="string">&quot;wolrd&quot;</span>));</span><br><span class="line">    mymap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：2world</span></span><br></pre></td></tr></table></figure><h3 id="清空map"><a href="#清空map" class="headerlink" title="清空map"></a>清空map</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清空map，清空后的size为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就是两个map的内容互换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">( map&amp; other )</span></span>;</span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键字(key)查询，找到则返回指向该关键字的迭代器，否则返回指向end的迭代器</span></span><br><span class="line"><span class="comment">// 根据map的类型，返回的迭代器为 iterator 或者 const_iterator</span></span><br><span class="line"><span class="function">iterator <span class="title">find</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span></span>;</span><br><span class="line"><span class="function">const_iterator <span class="title">find</span> <span class="params">(<span class="type">const</span> key_type&amp; k)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mymap;</span><br><span class="line">    mymap[<span class="string">&#x27;a&#x27;</span>]=<span class="number">50</span>;</span><br><span class="line">    mymap[<span class="string">&#x27;b&#x27;</span>]=<span class="number">100</span>;</span><br><span class="line">    mymap[<span class="string">&#x27;c&#x27;</span>]=<span class="number">150</span>;</span><br><span class="line">    mymap[<span class="string">&#x27;d&#x27;</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = mymap.<span class="built_in">find</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(it != mymap.<span class="built_in">end</span>())</span><br><span class="line">        mymap.<span class="built_in">erase</span> (it); <span class="comment">//b被成功删除</span></span><br><span class="line">    <span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(iter != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：</span></span><br><span class="line">a50</span><br><span class="line">c150</span><br><span class="line">d200</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/shuzfan/article/details/53115922">c++常见用法说明</a></p><h1 id="multimap的一些注意事项"><a href="#multimap的一些注意事项" class="headerlink" title="multimap的一些注意事项"></a>multimap的一些注意事项</h1><h2 id="用erase删除重复元素的第一个"><a href="#用erase删除重复元素的第一个" class="headerlink" title="用erase删除重复元素的第一个"></a>用erase删除重复元素的第一个</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multimap&lt;<span class="type">int</span>, <span class="type">char</span>&gt;mymap;</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="comment">/*mymap.erase(2);error</span></span><br><span class="line"><span class="comment">    程序输出：</span></span><br><span class="line"><span class="comment">    1a</span></span><br><span class="line"><span class="comment">    1a</span></span><br><span class="line"><span class="comment">    2c</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mymap.<span class="built_in">erase</span>(mymap.<span class="built_in">find</span>(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">auto</span> it = mymap.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it != mymap.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*程序输出：</span></span><br><span class="line"><span class="comment">1a</span></span><br><span class="line"><span class="comment">1a</span></span><br><span class="line"><span class="comment">2a</span></span><br><span class="line"><span class="comment">3c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="移除所有与x相等的元素"><a href="#移除所有与x相等的元素" class="headerlink" title="移除所有与x相等的元素"></a>移除所有与x相等的元素</h2><p>假如是是移除所有与x相等的key值，可以像上面用erase，如果是value值，则看下面：</p><p>错误做法(c++11之前)：</p><p><em>在C++11中，erase返回下一个迭代器，但之前的版本都返回void</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">char</span>&gt;mymap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); iter++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(iter-&gt;second == value)</span><br><span class="line">    mymap.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对iter所指元素施加erase()，会使pos不再成为一个有效的mymap迭代器。</p><p>正确做法(c++11之前)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">char</span>&gt;mymap;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = mymap.<span class="built_in">begin</span>(); iter != mymap.<span class="built_in">end</span>(); )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(iter-&gt;second == value)</span><br><span class="line">    mymap.<span class="built_in">erase</span>(iter++);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>iter++会将iter移向下一个元素，但返回其原始值（指向原位置）的一个副本。因此，当erase()被调用时，iter已经不再指向那个即将被移除的元素了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> map </tag>
            
            <tag> multimap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量与内存那些简单的事</title>
      <link href="/2018/03/30/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98%E9%82%A3%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B/"/>
      <url>/2018/03/30/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%86%85%E5%AD%98%E9%82%A3%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>内存内存，内存才是永恒的真理</p> <span id="more"></span><p>总的来说：</p><p>新建的对象开在 堆里  </p><p>属性 开在 堆里的对象里  </p><p>局部变量 参数变量 开在 栈里  </p><h1 id="由C-C-编译的程序占用的内存分的几部分"><a href="#由C-C-编译的程序占用的内存分的几部分" class="headerlink" title="由C/C++编译的程序占用的内存分的几部分"></a>由C/C++编译的程序占用的内存分的几部分</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p><h2 id="全局区（静态区）"><a href="#全局区（静态区）" class="headerlink" title="全局区（静态区）"></a>全局区（静态区）</h2><p>全局区（静态区）（static）— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</p><h2 id="文字常量区"><a href="#文字常量区" class="headerlink" title="文字常量区"></a>文字常量区</h2><p>常量字符串就是放在这里的，程序结束后由系统释放 。</p><h2 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h2><p>存放函数体的二进制代码。</p><h1 id="变量，对象，内存"><a href="#变量，对象，内存" class="headerlink" title="变量，对象，内存"></a>变量，对象，内存</h1><ol><li>Java把内存划分成两种：一种是<strong>栈内存</strong>，一种是<strong>堆内存</strong>。在函数中定义的一些基本类型的变量和对象的引用变量都在函数的堆栈中分配 。  </li><li>当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间， 该内存空间可以立即被另作他用。 所以尽量使用基本类型的变量。  </li><li>堆内存用来存放由 new创建的对象和数组。 由Java虚拟机的自动垃圾回收器来管理。</li><li>在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象Java的堆或者说内存堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等 指令建立，它们不需要程序代码来显式的释放。</li><li>堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时 动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</li></ol><h1 id="静态存储分配与动态存储分配"><a href="#静态存储分配与动态存储分配" class="headerlink" title="静态存储分配与动态存储分配"></a>静态存储分配与动态存储分配</h1><p>通常定义变量（或对象），编译器在编译时都可以根据该变量（或对象）的类型知道所需内存空间的大小，从而系统在适当的时候为他们分配确定的存储空间。这种内存分配称为<strong>静态存储分配；</strong>  </p><p>有些操作对象只在程序运行时才能确定，这样编译时就无法为他们预定存储空间，只能在程序运行时，系统根据运行时的要求进行内存分配，这种方法称为<strong>动态存储分配</strong>。所有动态存储分配都在堆区中进行。  </p><p>当程序运行到需要一个动态分配的变量或对象时，必须向系统申请取得堆中的一块所需大小的存贮空间，用于存贮该变量或对象。当不再使用该变量或对象时，也就是它的生命结束时，要显式释放它所占用的存贮空间，这样系统就能对该堆空间进行再次分配，做到重复使用有限的资源。</p><p>参考:<a href="https://blog.csdn.net/susan19890313/article/details/7494143">动态内存分配（new delete）</a>  </p><h1 id="栈的共享性"><a href="#栈的共享性" class="headerlink" title="栈的共享性"></a>栈的共享性</h1><p>假设我们同时定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>; </span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>；</span><br></pre></td></tr></table></figure><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器 会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。</p><h1 id="两种创建String类对象的比较"><a href="#两种创建String类对象的比较" class="headerlink" title="两种创建String类对象的比较"></a>两种创建String类对象的比较</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> <span class="built_in">String</span>(“abc”); <span class="comment">//（1）</span></span><br><span class="line">String str = “abc”; </span><br></pre></td></tr></table></figure><p>首先说下new </p><h2 id="new的那些内存分配的事情"><a href="#new的那些内存分配的事情" class="headerlink" title="new的那些内存分配的事情"></a>new的那些内存分配的事情</h2><p>Java关键字new是一个运算符。与+、-、*、/等运算符具有相同或类似的优先级。  </p><p>创建一个Java对象需要三步：声明引用变量、实例化、初始化对象实例。</p><p>应该说有会产生两个对象，一个为new String(“abc”)的实体对象放到内存堆中， 一个为堆栈对象str也就是类实例对象的引用对象。</p><h3 id="声明Declaration"><a href="#声明Declaration" class="headerlink" title="声明Declaration"></a>声明Declaration</h3><p>把上面代码(1)拆分只留下下面部分，就算是声明部分了，就是将变量名称与对象类型关联的变量声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str</span><br></pre></td></tr></table></figure><p>如同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br></pre></td></tr></table></figure><ul><li>声明一个对象str 时，将在栈内存为对象的引用变量str 分配内存空间，但值为空，称str是一个空对象。空对象不能使用，因为它还没有引用任何”实体”</li></ul><h3 id="实例化Instantiating"><a href="#实例化Instantiating" class="headerlink" title="实例化Instantiating"></a>实例化Instantiating</h3><p>实例化？“实例化一个类的对象”的意思就是“创建对象”。创建对象时，你正在创造一个类的“实例”，因而“实例化”一个类的对象。</p><p>实例化就是“创建一个Java对象”——-分配内存并返回指向该内存的引用。</p><ul><li>在堆内存中为类的成员变量分配内存，并将其初始化为各数据类型的默认值；接着进行显式初始化（类定义时的初始化值）；</li></ul><h3 id="初始化Initialization"><a href="#初始化Initialization" class="headerlink" title="初始化Initialization"></a>初始化Initialization</h3><ul><li>最后调用构造方法，为成员变量赋值。</li><li>返回堆内存中对象的引用（相当于首地址）给引用变量str,以后就可以通过str来引用堆内存中的对象了。</li></ul><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>而第二种（String str = “abc”;）是先在栈中创建一个对String类的对象引用变量str，然后查找栈 中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 </p><p>因此用第二种方式（String str = “abc”;）创建多个”abc”字符串,在内存中其实只存在一个对象而已</p><p>另一方面, 要注意: 我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new()方法才能保证每次都创建一个新的对象。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp  </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; 全局初始化区  </span><br><span class="line"><span class="type">char</span> *p1; 全局未初始化区  </span><br><span class="line"><span class="built_in">main</span>()  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="type">int</span> b; 栈  </span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; 栈  </span><br><span class="line"><span class="type">char</span> *p2; 栈  </span><br><span class="line"><span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="number">123456</span>\<span class="number">0</span>在常量区，p3在栈上。  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>； 全局（静态）初始化区  </span><br><span class="line">p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);  </span><br><span class="line">p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);  </span><br><span class="line">分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。  </span><br><span class="line"><span class="built_in">strcpy</span>(p1, <span class="string">&quot;123456&quot;</span>); <span class="number">123456</span>\<span class="number">0</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">&quot;123456&quot;</span></span><br><span class="line">优化成一个地方。  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>参考:  </p><p><a href="https://blog.csdn.net/a675311/article/details/52293730">Java变量以及内存分配（非常重要）</a></p><p><a href="http://wiki.jikexueyuan.com/project/java-special-topic/platorm-memory.html">Java 内存管理</a></p><p><a href="https://ask.csdn.net/questions/368543">java string什么是字符串常量，什么是字符串数组，什么是字符串常量池？</a></p><p><a href="http://www.360doc.com/content/16/0830/07/36064344_586925087.shtml">java学习笔记之string类型和字符串常量区  </a></p><p><a href="https://wenku.baidu.com/view/c10613bffe4733687f21aa0f.html">Java语言中字符串常量和变量的分析与比较</a>  </p><p><a href="https://blog.csdn.net/ljheee/article/details/52235915">Java关键字new——-对象的内存分配原理  </a></p><p>[<a href="https://blog.csdn.net/daiyutage/article/details/8605580">字符串常量到底存放在哪个存储区</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YXT-第一次工作室面试心得</title>
      <link href="/2018/03/30/YXT-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E5%AE%A4%E9%9D%A2%E8%AF%95%E7%9A%84%E5%BF%83%E5%BE%97/"/>
      <url>/2018/03/30/YXT-%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%B7%A5%E4%BD%9C%E5%AE%A4%E9%9D%A2%E8%AF%95%E7%9A%84%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>一次糟糕的面试<br><span id="more"></span><br>前几天去面试学校的天高工作室，在半小时的一对多面试后，结果不如人意，归纳起来主要是自己的基础有点慌，加上自己总是在面试时开启的“暴走”状态，可算是凉凉。<br>事后问面试过我的一个师兄，对方回答说：”<strong>我们觉得你的知识广度很广，但是深度还不够。</strong>“<br>主要记录下面试时问到的几个不懂的基础部分吧（其实还是自己的基础不够扎实）,以便以后补上漏洞</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>这个问题其实是很经典的问题，堆和栈的区别倒是在大一上学期看过，可是隔了这么久忘了也是很正常。</p><h2 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h2><p>那时候面试的一位老师问我有没有亲自写过动态链表的实现，emmm，上学期倒是学过基本的数据结构，也写过一些数据结构的实现，但是印象中没有学过动态链表这种东西。记得大一上学期倒是用链表解决过一道题，不过到现在，也是忘了，凉了。</p><h2 id="变量，指针，内存"><a href="#变量，指针，内存" class="headerlink" title="变量，指针，内存"></a>变量，指针，内存</h2><p>一位师兄在面试的时候提到过了数组变量在内存中是怎么存在，而且指针在内存是怎么进行运作的，同时还问了下定义一个指针指向数组有什么用？<br>记得那时候回答得可不是很好，内存这方面的知识倒是有点缺乏，最近学java，老师也说过了内存的一点知识，得找个时间巩固了下。</p><h2 id="大数据在开发中的作用"><a href="#大数据在开发中的作用" class="headerlink" title="大数据在开发中的作用"></a>大数据在开发中的作用</h2><p> emmm，这个倒是有点慌，当时是提到了大数据这个方向，可能是不小心吹多了（误），后来就接着来一连串的大数据问题，当时师兄问的大数据问题还好，他知道我对大数据了解不多，提到的问题也是很难，印象记得有几个:  </p><ol><li>大数据的工作方式和你现在的ACM做题有有什么区别</li><li><p>大数据需要很多的数学知识，你认为你的数学怎么样<br>….</p><p>emmm，其实这些还好，后来老师问了个大数据在开发的作用，记得当时只是答了个需求分析，其实还可以答更多，但是好像面试时间有点过长，脑袋有点混乱。</p><h2 id="二进制与位运算"><a href="#二进制与位运算" class="headerlink" title="二进制与位运算"></a>二进制与位运算</h2><p>之前说过自己了解过一些计算机组成原理的问题，后来就问了几道二进制与位运算的问题，虽然能答出来，但是感觉答得也不是很好，有道题还听错了意思。</p><p>其实看起来这些问题很基础，但是自己答不出，基础确实有点糟糕，内存与位运算那方面的知识确定得提升了下，虽然结果还没有出来，但是已经感受到了凉凉，希望大二能继续努力<br>最后面试的师兄建议我学精某一方面的知识。（该死的方向问题（误）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 悠闲谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>异或</title>
      <link href="/2018/03/24/%E5%BC%82%E6%88%96/"/>
      <url>/2018/03/24/%E5%BC%82%E6%88%96/</url>
      
        <content type="html"><![CDATA[<p>异或一些应用</p> <span id="more"></span><p> 参考:<a href="https://www.lijinma.com/blog/2014/05/29/amazing-xor/">感受异或的神奇</a><br>它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即0∧0＝0，0∧1＝1，1∧1＝0</p><h1 id="快速比较两个值"><a href="#快速比较两个值" class="headerlink" title="快速比较两个值"></a>快速比较两个值</h1><p>可以用a^b == 0来快速比较两个值，效率会更高</p><h1 id="使某些特定的位翻转"><a href="#使某些特定的位翻转" class="headerlink" title="使某些特定的位翻转"></a>使某些特定的位翻转</h1><p>0 ^ 1 = 1  </p><p>1 ^ 1 = 0  </p><p> 例如：翻转10100001的第6位，答案：可以将该数与00100000进行按位异或运算：10100001 ^ 00100000 = 10000001</p><h1 id="判断一个二进制数中1的数量是奇数还是偶数"><a href="#判断一个二进制数中1的数量是奇数还是偶数" class="headerlink" title="判断一个二进制数中1的数量是奇数还是偶数"></a>判断一个二进制数中1的数量是奇数还是偶数</h1><p>求10100001中1的数量是奇数还是偶数； 答案：1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1,结果为<code>1</code>就是奇数个1，结果为0就是偶数个1</p><h1 id="不使用其他空间，交换两个值"><a href="#不使用其他空间，交换两个值" class="headerlink" title="不使用其他空间，交换两个值"></a>不使用其他空间，交换两个值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b; <span class="comment">//a ^ b ^ b = a ^ 0 = a;</span></span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure><h1 id="一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字"><a href="#一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字" class="headerlink" title="一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字"></a>一个整型数组里除了N个数字之外，其他的数字都出现了两次，找出这N个数字</h1><p>从{A B C B C D A}找出单个字母的D</p><p>用到：  </p><ol><li>A ^ A = 0;  </li><li>异或满足交换律、结合律</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A ^ B ^ C ^ B ^ C ^ D ^ A</span><br><span class="line">= A ^ A ^ B ^ B ^ C ^ C ^ D</span><br><span class="line">= <span class="number">0</span> ^ <span class="number">0</span> ^ <span class="number">0</span> ^ D</span><br><span class="line">= <span class="number">0</span> ^ D</span><br><span class="line">= D</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，当然是线性的，空间复杂度O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//特殊情况1,2  </span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> A[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        result = result ^ A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一个整型数组里除了两个数字之外，其他的数字都出现了两次。找出这两个只出现一次的数字"><a href="#一个整型数组里除了两个数字之外，其他的数字都出现了两次。找出这两个只出现一次的数字" class="headerlink" title="一个整型数组里除了两个数字之外，其他的数字都出现了两次。找出这两个只出现一次的数字"></a>一个整型数组里除了两个数字之外，其他的数字都出现了两次。找出这两个只出现一次的数字</h1><p>思路：  </p><ol><li>肯定还是像我们上面的解法一样，所有数进行异或，不过最终得到的结果是 a 和 b（假设 a 和 b 是落单的数字）两个值的异或结果 aXORb，没有直接得到 a 和 b 的值；  </li><li>那么我们如何找到两个的真实值呢？根据异或的特点可以发现，两个相同的位异或后结果是0，不同则是1。同时aXORb不可能每一位都是0，那么就可以得知假如有一位是1的话，则对应着a与b在此位上的数值是不同的，由此我们可以根据这个特点进行解题。因为a,b不同，肯定有一个位是1，对应着那个就是0，我们可以先找出aXORb第一位为1的那个位，把它提取出来，然后其他位全为0，然后与数组所有的数进行&amp;运算，这样就能找出与提取出的那个数（其实也只是一个位有用）的位相等的数，比如提取出的是0001，那么1111可以被&amp;找出来。</li><li>aXORb = a ^ b，假设我们已经找到了 a，根据异或特性，我们知道，b = aXORb ^ a；这样我们就可以找出 b；所以我们只需要循环两次 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFirstOneBit</span><span class="params">(<span class="type">int</span> num)</span> <span class="comment">//输出 num 的低位中的第一个 1 的位置  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &amp; ~(num - <span class="number">1</span>);  <span class="comment">// num 与 -num 相与找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findTwo</span><span class="params">(<span class="type">int</span> *array, <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> aXORb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> firstOneBit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        aXORb ^= array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(aXORb != <span class="number">0</span>); <span class="comment">//保证题目要求，有两个single的数字，如果不成立则退出程序</span></span><br><span class="line">    firstOneBit = <span class="built_in">getFirstOneBit</span>(aXORb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &amp; firstOneBit)</span><br><span class="line">        <span class="comment">//与提取出的那个数对应的位相同的数有很多，但是其他的数都有相同的两个，异或后就可以相除了，只留下单独的那一个</span></span><br><span class="line">         &#123;</span><br><span class="line">            a ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b = aXORb ^ a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array1[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">findTwo</span>(array1, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>#</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序函数sort</title>
      <link href="/2018/03/06/%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
      <url>/2018/03/06/%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>声明简介、比较函数、结构体排序</p><span id="more"></span><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>排序用的函数是sort函数，包含在&lt; algorithm &gt;文件中。</li><li>sort()不仅可以用来给数字排序，还可以给字符串排序，默认的是升序，如果需要降序的话，可以自己写一个cmp回调函数（函数名可自拟，通常用cmp），然后在sort函数中，加上（cmp）函数名即可。</li><li>实现原理：sort并不是简单的<strong>快速排序</strong>，它对普通的快速排序进行了优化，此外，它还结合了<strong>插入排序</strong>和<strong>推排序</strong>。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。</li></ul><p>具体函数实现，请参考：<a href="http://www.cnblogs.com/fengcc/p/5256337.html">http://www.cnblogs.com/fengcc/p/5256337.html</a></p><h1 id="声明简介"><a href="#声明简介" class="headerlink" title="声明简介"></a>声明简介</h1><p>函数声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt（随机迭代器) &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>形式：sort(first_pointer,first_pointer+n,cmp);</p><p>参数解释： 第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。最后一个参数是比较函数的名称（自定义函数cmp），这个比较函数可以不写，即第三个参数可以缺省，这样sort会默认按数组<strong>升序排序</strong>。</p><p>简单例子：对数组A的0~n-1元素进行升序排序，只要写sort(A,A+n)即可；对于向量V也一样，sort(v.begin(),v.end())即可。</p><h1 id="sort扩展-比较函数"><a href="#sort扩展-比较函数" class="headerlink" title="sort扩展-比较函数"></a>sort扩展-比较函数</h1><h2 id="自己定义比较函数"><a href="#自己定义比较函数" class="headerlink" title="自己定义比较函数"></a>自己定义比较函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：数组排列</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//int为数组数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">//降序排列</span></span><br><span class="line">    <span class="comment">//return a &lt; b;//默认的升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(A, A<span class="number">+100</span>, cmp1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：结构体排序</span></span><br><span class="line">Student Stu[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Student a, Student b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&gt;b.id;<span class="comment">//按照学号降序排列</span></span><br><span class="line">    <span class="comment">//return a.id&lt;b.id;//按照学号升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(Stu,Stu<span class="number">+100</span>,cmp2);</span><br></pre></td></tr></table></figure><h2 id="使用标准库函数"><a href="#使用标准库函数" class="headerlink" title="使用标准库函数"></a>使用标准库函数</h2><p>functional提供了一堆基于模板的比较函数对象，它们是：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。这些东西的用法看名字就知道了。在这里，我么sort要用到的也只是greater和less就足够了，用法如下：</Type></Type></Type></Type></Type></Type></p><ul><li>升序：sort(begin,end,less<data-type>())</data-type></li><li>降序：sort(begin,end,greater<data-type>())</data-type></li></ul><p>缺点：也只是实现简单的排序，结构体不适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//简单使用方法</span></span><br><span class="line"><span class="built_in">sort</span>(A,A<span class="number">+100</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(A,A<span class="number">+100</span>,<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//升序排列</span></span><br></pre></td></tr></table></figure><h2 id="重载结构体或类的比较运算符"><a href="#重载结构体或类的比较运算符" class="headerlink" title="重载结构体或类的比较运算符"></a>重载结构体或类的比较运算符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：在结构体内部重载</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">double</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id&gt;s.id;<span class="comment">//降序排列</span></span><br><span class="line">        <span class="comment">//return id&lt;s.id;//升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; V;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：在外部重载</span></span><br><span class="line">vector&lt;Student&gt; V;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Student&amp; s1, <span class="type">const</span> Student&amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s<span class="number">1.</span>id&gt;s<span class="number">2.</span>id;<span class="comment">//降序排列</span></span><br><span class="line">    <span class="comment">//return s1.id&lt;s2.id;//升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>注意：一定要重载&lt;运算符，因为系统默认是降序，用的是&lt;运算符。</p><h2 id="声明比较类（少用）"><a href="#声明比较类（少用）" class="headerlink" title="声明比较类（少用）"></a>声明比较类（少用）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Less</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Student&amp; s1, <span class="type">const</span> Student&amp; s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s<span class="number">1.</span>id&lt;s<span class="number">2.</span>id; <span class="comment">//升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(sutVector.<span class="built_in">begin</span>(),stuVector.<span class="built_in">end</span>(),<span class="built_in">Less</span>());</span><br></pre></td></tr></table></figure><p>(参考自:<a href="https://www.cnblogs.com/AlvinZH/p/6784862.html?utm_source=itdadao&amp;utm_medium=referral">sort函数详解</a>)</p><h1 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h1><ol><li>有三个人（Person结构体），每个人都有name（string型）和age（int型）两个属性，现在需要按照下面的规则排序：先以姓名按从小到大排序（如abc&lt;abd)，如果姓名相同，则按照年龄从大到小排序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Person a,Person b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.name!=b.name)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.name&lt;b.name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.age&gt;b.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;p[i].name&gt;&gt;p[i].age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="built_in">sort</span>(p,p<span class="number">+3</span>,cmp);</span><br><span class="line">    <span class="comment">//依次输出</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;p[i].name&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;p[i].age&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对N个人（Person）进行排序，规则如下：每个人有3个属性，name（string型），age（int型），height（int型）。优先按照name由大到小排名，name相同的则按照age由大到小排序，age相同的则按照height由大到小排序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Person a, Person b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.name != b.name)</span><br><span class="line">        <span class="keyword">return</span> a.name &gt; b.name;</span><br><span class="line">    <span class="keyword">if</span>(a.name == b.name &amp;&amp; a.age != b.age)</span><br><span class="line">        <span class="keyword">return</span> a.age &gt; b.age;</span><br><span class="line">    <span class="keyword">if</span>(a.name == b.name &amp;&amp; a.age == b.age)</span><br><span class="line">        <span class="keyword">return</span> a.height &gt; b.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    Person p[n];</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        cin&gt;&gt; p[i].name &gt;&gt; p[i].age &gt;&gt; p[i].height;</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n, cmp);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p[i].name &lt;&lt;<span class="string">&#x27; &#x27;</span></span><br><span class="line">             &lt;&lt; p[i].age &lt;&lt;<span class="string">&#x27; &#x27;</span></span><br><span class="line">             &lt;&lt; p[i].height &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考自：</p><p>[<a href="http://www.cnblogs.com/-beyond/p/5902113.html">结构体或对象排序</a>]</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Good Morning vocation</title>
      <link href="/2018/03/03/YXT-Good-morning-vocationmd/"/>
      <url>/2018/03/03/YXT-Good-morning-vocationmd/</url>
      
        <content type="html"><![CDATA[<p>Good morning, beautiful vocation</p><p>Good bye, beautiful vocation</p><h1 id><a href="#" class="headerlink" title></a><span id="more"></span></h1><h1 id="Good-Morning，beautiful"><a href="#Good-Morning，beautiful" class="headerlink" title="Good Morning，beautiful"></a>Good Morning，beautiful</h1><p>回想放假前各种寒假计划，铺天盖地，雄心壮志，气势昂昂，回个家猛如放虎归山，似乎对未来充满了无限的期望</p><p>既要学这，又要学那，既要折腾这，又要探索那，看来起来很充实的样子。</p><p>然而，哈哈……</p><p>回到家里面的第一个星期到是热情不减，热血沸腾，随手拿起一本《c++ primer plus》就是看，几乎是把吃饭的时间都用上了，每天起来的第一件事就是打开书，边看书边吃早餐，吃完午餐第一件事又是看书，洗完澡又是看书，好像身体早已变成了AC永动机。因此得到的成果也是不少，看了一百二百页的样子</p><p>同时第一个星期干的事情还真不少，完成项目计划的部署，虽然此计划早在12月时就可以行动了，但是最终还是以失败告终。还有就是马马虎虎得翻译了一些官方wiki，说是一些，其实很少量，到不知道有没有400字。</p><p>第一个星期的疯狂，可能是由于期末那段时间没有学过课外的知识，都在放松自己，准备考试，还有一个折腾。折腾啥呢，折腾装linux，期末前几乎拿时间去都装linux了，连考试前几天都连续通宵，早上起床后除了洗澡拿外卖就一直坐着去研究直到凌晨3,4点。说起来也是，那时候刚刚入门就去折腾arch，而且还要双系统，当时又不知道自己的机械硬盘是mbr的，固态的gpt的，导致各种翻车，同时win10也不小心格掉23333</p><p>股票般的疯狂，注定会落入低估，接下来的一星期明显感到动力不足，开始慢慢放松警惕，同时自己也慢慢体会到这种变化——与其在书面前发呆，还不如去做一些有趣的事。于是那时候又折腾起了linux，记得主要是折腾了manjaro，deepin，mint等发行版，还有xfce4，gnome，kde等等桌面环境，当时还是以易用和稳定为主，就选择了待在deepin，主要是当时还是意识到了折腾浪费时间，并且这种状态还持续了半个月多不去各种状态，同时还是linux群劝解群友2333</p><p>与此同时，还开始了视频的学习，但是在bili找到了大量的学习视频，一开始雄心壮志地想要去学完，后来还是太天真，只是学了KMP和BM，看了几道字符串问题。这个星期就tm这样过去了</p><p>到了接近新年那段时间，差不多是年20左右及新年吧。那时候有个高三同学聚会的安排，期间同策划组各位dalao见面商量了下，也是离别半年后的相见，一切安好！只是女的都变漂亮，男的变帅了，而自己还是一个傻逼样2333。那段时间的学习状态也是不温不火，主要是看侯杰老师的c++视频，凑活看完了。看完是看完了，可又记得多少呢？</p><p>年前及年后不久，用hexo和github搭建了个博客，在上一年的11月早已这个计划，拖了这么久我也是不知道说什么了。。。搭建了博客之后热情就来了，各种发博文，大年30还在发，要不是年初一出去躺尸，说不定也会有几篇，年初二都还在发，最疯狂的是年27好像，一天憋出了3,4篇。主要内容是STL，其实我还想放linux等各种别的东西进去，但是时间真的是不够。</p><p>年初八同学聚会，又见到部分高三同学，各种奇花乱放。不过也是吃饭烧烤。还是那句话，只是女的都变漂亮，男的变帅了。聚会后这段时间开始放纵自己，扔下了书本，去折腾linux，主要是折腾i3wm桌面环境，本来想拿一个星期，现在看来，都有两个星期，直到3月1号来学校前那一夜都装了新系统，还好把win10找了回来。</p><p>emmm，流水账地记录了下，该做的还没有做，比如制作了班级网站，想想自己以后的方向，不该做的倒是做了。</p><p>回到学校这两天，倒是把i3wm配置好了，算是完成了自己的一个心愿，然而大作业等等，开始一拥而至，明天还要同sm chen去买属于我的第一辆自行车，哦，不，是今天。</p><p>虽然活得不好，但是一定要有志气</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/2018-03-03%2003-00-36%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/2018-03-03%2003-16-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png"></p>]]></content>
      
      
      <categories>
          
          <category> 悠闲谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日常水题</title>
      <link href="/2018/02/22/%E6%97%A5%E5%B8%B8%E6%B0%B4%E9%A2%98/"/>
      <url>/2018/02/22/%E6%97%A5%E5%B8%B8%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>p1008三连击、UVa340猜数字游戏的提示、Uva1583生成元，POJ-2271（模拟）,fzcoj1787(模拟)<br><span id="more"></span></p><h1 id="p1008三连击"><a href="#p1008三连击" class="headerlink" title="p1008三连击"></a>p1008三连击</h1><p>将1，2，…，9共9个数分成三组，分别组成三个三位数，且使这三个三位数构成1：2：3的比例，试求出所有满足条件的三个三位数。</p><p>一个个遍历过去，判断三个数字的每个位的数字是否重复，这里用的办法是先提取出每个位的数字，然后排序，将其与数组下标对齐，如果不数组的值与下标的值不相等，则出现重复。</p><p><em>这里可以用于构造几个数字，然后判断出现的数字是否重复。</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, a[<span class="number">15</span>];</span><br><span class="line"><span class="type">bool</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">123</span>; i &lt;= <span class="number">329</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[<span class="number">1</span>] = i % <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">2</span>] = i % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">3</span>] = i /<span class="number">1</span> <span class="number">00</span>;</span><br><span class="line">        a[<span class="number">4</span>] = <span class="number">2</span> * i % <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">5</span>] = <span class="number">2</span> * i % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">6</span>] = <span class="number">2</span> * i / <span class="number">100</span>;</span><br><span class="line">        a[<span class="number">7</span>] = <span class="number">3</span> * i % <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">8</span>] = <span class="number">3</span> * i % <span class="number">100</span> / <span class="number">10</span>;</span><br><span class="line">        a[<span class="number">9</span>] = <span class="number">3</span> * i / <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">10</span>);</span><br><span class="line">        ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) <span class="keyword">if</span> (a[j] != j) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans) cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i*<span class="number">2</span> &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; i*<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="UVa340猜数字游戏的提示"><a href="#UVa340猜数字游戏的提示" class="headerlink" title="UVa340猜数字游戏的提示"></a>UVa340猜数字游戏的提示</h1><p>实现一个经典”猜数字”游戏。 给定答案序列和用户猜的序列，统计有多少数字位置正确<br>（A），有多少数字在两个序列都出现过但位置不对（B）。<br>输入包含多组数据。 每组输入第一行为序列长度n，第二行是答案序列，接下来是若干<br>猜测序列。 猜测序列全0时该组数据结束。 n=0时输入结束。  </p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 1<br>3 5 5<br>1 1 2 3<br>4 3 3 5<br>6 5 5 1<br>6 1 3 5<br>1 3 5 5<br>0 0 0 0<br>10<br>1 2 2 2 4 5 6 6 6 9<br>1 2 3 4 5 6 7 8 9 1<br>1 1 2 2 3 3 4 4 5 5<br>1 2 1 3 1 5 1 6 1 9<br>1 2 2 5 5 5 6 6 6 7<br>0 0 0 0 0 0 0 0 0 0<br>0  </p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>Game 1:<br>(1,1)<br>(2,0)<br>(1,2)<br>(1,2)<br>(4,0)<br>Game 2:<br>(2,4)<br>(3,2)<br>(5,0)<br>(7,0)  </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题目求B时难一些。问的是由多少数字在两个序列都出现过，即两个序列都要有，因此可以分别计数2个序列的中1~9的每个数字个数c1,c2，然后选取其中最小的min(c1,c2)，这个最小的值就是1~9中某个数字在2个序列中出现的次数。然后将所有的min(c1,c2)进行相加，就求出了数字在序列中出现过，然后减去数字位置正确的数字，剩下的就是位置不对的数字了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1010</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, a[maxn], b[maxn];</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) &#123; <span class="comment">//n=0时输入结束</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Game %d:\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[i]) A++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//正常的猜测序列不会有0，所以只判断第一个数是否为0即可</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= <span class="number">9</span>; d++) &#123;</span><br><span class="line">                <span class="type">int</span> c1 = <span class="number">0</span>, c2 = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//统计数字d在答案序列和猜测序列中各出现多少次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[i] == d) c1++;</span><br><span class="line">                    <span class="keyword">if</span> (b[i] == d) c2++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(c1 &lt; c2) B += c1; <span class="keyword">else</span> B += c2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; (%d,%d)\n&quot;</span>, A, B - A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Uva1583生成元"><a href="#Uva1583生成元" class="headerlink" title="Uva1583生成元"></a>Uva1583生成元</h1><p>如果x加上x的各个数字之和得到y，就说x是y的生成元。给出n(1 &lt;= 100000)，求最小生成元。无解输出0.例如,n=216, 121, 2005时的解分别为198,0,1979 。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>如果按照常规思路一个个去枚举的话，可能会超时，不妨我们转换思想，先求出所有数的生成元，最后查表即可<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="type">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T,n;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">1</span>;m&lt;maxn;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=m,y=m;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;y+=x%<span class="number">10</span>;x/=<span class="number">10</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(ans[y]==<span class="number">0</span>||m&lt;ans[y])ans[y]=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="POJ-2271-模拟"><a href="#POJ-2271-模拟" class="headerlink" title="POJ-2271(模拟)"></a>POJ-2271(模拟)</h1><p><a href="https://vjudge.net/problem/17766/origin">POJ - 2271</a></p><p>这个模拟可真是。。。刚开始用getline读写了无数个BUG版本代码，后来换cin保平安</p><p>题目大意：</p><p>​        要求翻译一篇HTML文档，文档中只有两种HTML标记<code>&lt;br&gt;</code>和<code>&lt;hr&gt;</code>，分别表示换行和划线板，并将左右连续的空格、制表符、换行符当做一个空格输出，还有就是”abc,123”算作一个单词，而”abc, 123”算作两个单词，分别为”abc,”和”123”，具体要求为：</p><p>​        1. 当读取一个单词，当前行不超过80个字符（包括空格），就直接打印在后面（注意单词直接用空格隔开），否则就另起一行在开头处打印该单词，所有单词的最大长度为80；</p><p>​        2. 当读取<code>&lt;br&gt;</code>时直接开启一新行；</p><p>​        3. 当读取<code>&lt;hr&gt;</code>时，如果<code>&lt;hr&gt;</code>不在新行开头就另起一行连续打印80个’-‘后再开启一新行；</p><p>​        4. 全部翻译完后用一个空行结束；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Memory: 136KTime: 16MS</span></span><br><span class="line"><span class="comment">Language: C++Result: Accepted</span></span><br><span class="line"><span class="comment">Time:  2018-07-19 18:26:23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;&lt;hr&gt;&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//防止两个&lt;hr&gt;相连时出现多余的换行</span></span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++)</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;&lt;br&gt;&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//用来记录空格，因为空格也算一个长度，两个单词之间要有空格</span></span><br><span class="line">            <span class="keyword">if</span>(cnt) <span class="comment">//前面已经有输出了。要加上空格那个长度</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt + s.<span class="built_in">size</span>() + flag &gt; <span class="number">80</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; endl &lt;&lt; s;</span><br><span class="line">                cnt = s.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s;</span><br><span class="line">                    cnt += s.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; s;</span><br><span class="line">                    cnt += s.<span class="built_in">size</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p><h1 id="FZCOJ1787"><a href="#FZCOJ1787" class="headerlink" title="FZCOJ1787"></a><a href="http://fzcoj.hustoj.com/problem.php?id=1787">FZCOJ1787</a></h1><p>普通的一道模拟题，因为考虑不周加上循环判断语句写得很复杂，导致写了100多行的模拟代码，（而且还wa，emmm），看了题解后才知道不要一蹴而就，要一步步判断，当初就是想判断完这个跳过去，导致无限wa</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Ext.Time：13ms</span></span><br><span class="line"><span class="comment">Time:2018-10-03 21:07:26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; len &gt;&gt; s1;</span><br><span class="line">        <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos1 &lt;= pos2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp1 = pos1;</span><br><span class="line">            <span class="type">int</span> tmp2 = pos2;</span><br><span class="line">            <span class="keyword">while</span>(tmp1 &lt; tmp2 &amp;&amp; s1[tmp1] == s1[tmp2])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp1++;</span><br><span class="line">                tmp2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1[tmp1] &gt; s1[tmp2])</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; s1[pos2];</span><br><span class="line">                pos2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; s1[pos1];</span><br><span class="line">                pos1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        s1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上当初bug代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        string s1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        string s2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; len &gt;&gt; s1;</span><br><span class="line">        <span class="type">int</span> pos1 = <span class="number">0</span>, pos2 = s<span class="number">1.</span><span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos1 == pos2)</span><br><span class="line">                flag = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">                    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; (s2 += s1[pos1]) &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1[pos1] &gt; s1[pos2])</span><br><span class="line">            &#123;</span><br><span class="line">                s2 += s1[pos2];</span><br><span class="line">                pos2--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[pos1] &lt; s1[pos2])</span><br><span class="line">            &#123;</span><br><span class="line">                s2 += s1[pos1];</span><br><span class="line">                pos1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">int</span> tmp1 = pos1, tmp2 = pos2;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(s1[pos1] == s1[pos2])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> tmp = pos1;</span><br><span class="line">                    pos1++;</span><br><span class="line">                    pos2--;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(s1[tmp] != s1[pos1])</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt;= <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = tmp1; k &lt; pos1; k++)</span><br><span class="line">                        s2 += s1[k];</span><br><span class="line">                    <span class="keyword">if</span>(pos1 &gt; pos2 || pos1 &gt;= s<span class="number">1.</span><span class="built_in">size</span>() || pos2 &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[pos1] &gt; s1[pos2])</span><br><span class="line">                    &#123;</span><br><span class="line">                        pos1 = tmp1;</span><br><span class="line">                        s2 += s1[pos2];</span><br><span class="line">                        pos2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        pos2 = tmp2;</span><br><span class="line">                        s2 += s1[pos1];</span><br><span class="line">                        pos1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    pos1 = tmp1;</span><br><span class="line">                    pos2 = tmp2;</span><br><span class="line">                    <span class="keyword">if</span>(s1[pos1] &lt; s1[pos2 - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2 += s1[pos1];</span><br><span class="line">                        pos1++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(s1[pos1] &gt; s1[pos2 - <span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        s2 += s1[pos2];</span><br><span class="line">                        pos2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        s2 = s2 + s1[pos1] + s1[pos1];</span><br><span class="line">                        pos1++;</span><br><span class="line">                        pos2--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(pos1 &gt; pos2 || pos1 &gt;= s<span class="number">1.</span><span class="built_in">size</span>() || pos2 &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        flag = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++string</title>
      <link href="/2018/02/21/c++-string/"/>
      <url>/2018/02/21/c++-string/</url>
      
        <content type="html"><![CDATA[<p>string小结</p><span id="more"></span><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ol><li>string类由头文件string支持</li></ol><p><em>（头文件string.h和cstring支持对c-风格字符串进行操纵的c库字符串函数，但不支持string类）</em></p><ol><li>string类将string::nops定义为字符串最大长度，通常为unsigned int最大值</li><li>string与wstring：</li></ol><ul><li>string是针对char而预先定义的特化版本，wstring是针对wchat_t而预先定义的特化版本</li><li>使用wstring可以让你使用宽字符集，例如Unicode或某些亚洲字符集‘</li><li>所有字符串类型都采用相同接口，所以两者用法都一样。</li></ul><ol><li>C++字符串并不以’/0’结尾</li><li>注意对象名不会被看做是对象地址，比如string s(20, ‘x’); s不是指针，s+6没有意义，而&amp;s[6]却是指针。</li></ol><h1 id="字符串各种操作函数"><a href="#字符串各种操作函数" class="headerlink" title="字符串各种操作函数"></a>字符串各种操作函数</h1><div class="table-container"><table><thead><tr><th>Name</th><th>Feature</th></tr></thead><tbody><tr><td>swap()</td><td>交换两个字符串的内容</td></tr><tr><td>=, assign()</td><td>赋以新值</td></tr><tr><td>+=,  append(),  push_back()</td><td>在尾部添加字符</td></tr><tr><td>insert()</td><td>插入字符</td></tr><tr><td>erase()</td><td>删除字符</td></tr><tr><td>clear()</td><td>删除全部字符</td></tr><tr><td>replace()</td><td>替换字符</td></tr><tr><td>+</td><td>串联字符串</td></tr><tr><td>==, != , &lt;, &lt;=, &gt;, &gt;=, compare()</td><td>比较字符串</td></tr><tr><td>size(), length()</td><td>返回字符数量</td></tr><tr><td>max_size()</td><td>返回字符的可能最大个数</td></tr><tr><td>empty()</td><td>判断字符串是否为空</td></tr><tr><td>capacity()</td><td>返回重新分配之前的字符容量</td></tr><tr><td>reserve()</td><td>保留一定量内存以容纳一定数量的字符</td></tr><tr><td>[ ],  at()</td><td>存取单一字符</td></tr><tr><td>&gt;&gt; ,  getline()</td><td>从stream读取某值</td></tr><tr><td>&lt;&lt;</td><td>将谋值写入stream</td></tr><tr><td>copy()</td><td>将某值赋值为一个C_string，不添加’\0’字符</td></tr><tr><td>c_str()</td><td>将内容以C_string返回，在尾端添加’\0’字符</td></tr><tr><td>data()</td><td>将内容以字符数组形式返回，并未追加’\0’字符，所以返回类型并非有效的c-string</td></tr><tr><td>substr()</td><td>返回某个子字符串</td></tr><tr><td>begin() end()</td><td>提供类似STL的迭代器支持</td></tr><tr><td>rbegin()  rend()</td><td>逆向迭代器</td></tr><tr><td>get_allocator()</td><td>返回配置器</td></tr></tbody></table></div><h2 id="转换成c-string或字符数组"><a href="#转换成c-string或字符数组" class="headerlink" title="转换成c-string或字符数组"></a>转换成c-string或字符数组</h2><p>操作函数data(), c_str(), copy()</p><p>注意：</p><ol><li>data()和c_str()返回的字符数组由该字符串拥有，也就是说调用者千万不能修改它或释放其内存</li><li>一般而言，整个程序中应该坚持使用string，直到你必须将其内容转化为char*时才把他们转换成c-string。</li></ol><h2 id="C-字符串存在三种大小"><a href="#C-字符串存在三种大小" class="headerlink" title="C++字符串存在三种大小"></a>C++字符串存在三种大小</h2><ol><li><p>现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。</p></li><li><p>size()是获取容器元素个数的通用成员函数，length()则对应于一般c-string strlen()函数，传回字符串长度。</p></li><li><p>max_size() ：这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。</p><p><em>我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常</em></p></li><li><p>capacity()：重新分配内存之前，string所能包含的最大字符数</p></li></ol><h2 id="元素存取"><a href="#元素存取" class="headerlink" title="元素存取"></a>元素存取</h2><p>使用下标操作符[]和函数at()对元素包含的字符进行访问</p><p>注意：</p><p><em>操作符[]并不检查索引是否有效（有效索引0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用 at()的时候索引无效，会抛出out_of_range异常。</em></p><p><em>str.length()：const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’/0’。其他的各种情况，str.length()索引都是无效的</em></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string <span class="title">Cstr</span><span class="params">(“<span class="type">const</span> string”)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">Str</span><span class="params">(“string”)</span></span>;</span><br><span class="line">Str[<span class="number">3</span>];      <span class="comment">//ok</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">3</span>);    <span class="comment">//ok</span></span><br><span class="line">Str[<span class="number">100</span>]; <span class="comment">//未定义的行为</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">100</span>);    <span class="comment">//throw out_of_range</span></span><br><span class="line">Str[Str.<span class="built_in">length</span>()]    <span class="comment">//未定义行为</span></span><br><span class="line">Cstr[Cstr.<span class="built_in">length</span>()] <span class="comment">//返回 ‘/0&#x27;</span></span><br><span class="line">Str.<span class="built_in">at</span>(Str.<span class="built_in">length</span>());<span class="comment">//throw out_of_range</span></span><br><span class="line">Cstr.<span class="built_in">at</span>(Cstr.<span class="built_in">length</span>()) <span class="comment">////throw out_of_range</span></span><br></pre></td></tr></table></figure><h2 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h2><ol><li>c++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string (“aaaa”) &lt;string(aaaaa)</li><li>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。</li></ol><p>举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(“abcd”)</span></span>;</span><br><span class="line">s.<span class="built_in">compare</span>(“abcd”); <span class="comment">//返回0</span></span><br><span class="line">s.<span class="built_in">compare</span>(“dcba”); <span class="comment">//返回一个小于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(“ab”); <span class="comment">//返回大于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(s); <span class="comment">//相等</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">0</span>,<span class="number">2</span>,s,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//用”ab”和”cd”进行比较 小于零</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,”bcx”,<span class="number">2</span>); <span class="comment">//用”bc”和”bc”比较。</span></span><br></pre></td></tr></table></figure><h2 id="更改内容"><a href="#更改内容" class="headerlink" title="更改内容"></a>更改内容</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>第一个赋值方法当然是使用操作符=，新值可以是string(如：s=ns) 、c_string(如：s=”gaint”)甚至单一字符（如：s=’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。</p><p>举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">assign</span>(str); <span class="comment">//你懂得</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//如果str是”iamangel” 就是把”ama”赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">2</span>,string::npos);<span class="comment">//把字符串str从索引值2开始到结尾赋给s</span></span><br><span class="line">s.<span class="built_in">assign</span>(“gaint”); <span class="comment">//不说</span></span><br><span class="line">s.<span class="built_in">assign</span>(“nico”,<span class="number">5</span>);<span class="comment">//把&#x27;n&#x27; ‘I&#x27; ‘c&#x27; ‘o&#x27; ‘/0&#x27;赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">5</span>,<span class="string">&#x27;x&#x27;</span>);<span class="comment">//把五个x赋给字符串</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//用c类型字符串s赋值</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> n)</span></span>;<span class="comment">//用c字符串s开始的n个字符赋值</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> c)</span></span>;<span class="comment">//用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> start,<span class="type">int</span> n)</span></span>;<span class="comment">//把字符串s中从start开始的n个字符赋给当前字符串</span></span><br><span class="line"><span class="function">string &amp;<span class="title">assign</span><span class="params">(const_iterator first,const_itertor last)</span></span>;<span class="comment">//把first和last迭代器之间的部分赋给字符串</span></span><br></pre></td></tr></table></figure><p>int copy(char *s, int n, int pos = 0) const;</p><p>把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</p><h3 id="清空"><a href="#清空" class="headerlink" title="清空"></a>清空</h3><p>把字符串清空的方法有三个：</p><p>s=””;    s.clear();        s.erase();</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>函数有 +=、append()、push_back()。</p><p>举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=<span class="string">&#x27;a&#x27;</span>;<span class="comment">//加个字符</span></span><br><span class="line">s.<span class="built_in">append</span>(str);</span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">2</span>,string::npos)<span class="comment">//不解释了</span></span><br><span class="line">s.<span class="built_in">append</span>(“my name is jiayp”);</span><br><span class="line">s.<span class="built_in">append</span>(“nico”,<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">s.<span class="built_in">push_back</span>(‘a<span class="string">&#x27;); //这个函数只能增加单个字符对STL熟悉的理解起来很简单</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">//在string中间的某个位置插入字符串</span></span><br><span class="line"><span class="string">//需要指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</span></span><br><span class="line"><span class="string">s.insert(0,”my name”);</span></span><br><span class="line"><span class="string">s.insert(1,str);</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> string &amp;s);<span class="comment">//把字符串s连接到当前字符串的结尾 </span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span>;<span class="comment">//把c类型字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//把c类型字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>;<span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">int</span> pos,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串的结尾</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> c)</span></span>;<span class="comment">//在当前字符串结尾添加n个字符c</span></span><br><span class="line"><span class="function">string &amp;<span class="title">append</span><span class="params">(const_iterator first,const_iterator last)</span></span>;</span><br><span class="line"><span class="comment">//把迭代器first和last之间的部分连接到当前字符串的结尾</span></span><br></pre></td></tr></table></figure><p>注意：</p><p><em>1. 这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式。</em></p><p><em>2. 为了插 入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。</em></p><p><em>3. 其中size_type是无符号整数，iterator是char</em>,所以，你这么调用insert函数是不行的：insert(0,1, ‘j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指 出了使用迭代器安插字符的形式。</p><p><em>4. 顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。</em></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>直接举个栗子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;il8n&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;nternationalizatio&quot;</span>);</span><br><span class="line"><span class="comment">//从索引1开始的2个替换成后面的C_string</span></span><br><span class="line"><span class="comment">//即输出： nternationalization</span></span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,”nternationalizatio”);</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">13</span>);<span class="comment">//从索引13开始往后全删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">//从索引7开始往后删5个</span></span><br></pre></td></tr></table></figure><h3 id="提取子串和字符串连接"><a href="#提取子串和字符串连接" class="headerlink" title="提取子串和字符串连接"></a>提取子串和字符串连接</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>();<span class="comment">//返回s的全部内容</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">11</span>);<span class="comment">//从索引11往后的子串</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//从索引5开始6个字符</span></span><br><span class="line"><span class="comment">//把两个字符串结合起来的函数是+。</span></span><br></pre></td></tr></table></figure><h2 id="搜索和查找"><a href="#搜索和查找" class="headerlink" title="搜索和查找"></a>搜索和查找</h2><div class="table-container"><table><thead><tr><th>Name</th><th>Feature</th></tr></thead><tbody><tr><td>find()</td><td>搜索第一个与value相等的字符</td></tr><tr><td>rfind()</td><td>搜索最后一个与value相等的字符</td></tr><tr><td>find_first_of()</td><td>搜索第一个“与value中某值相等”的字符</td></tr><tr><td>find_last_of()</td><td>搜索最后一个个“与value中某值相等”的字符</td></tr><tr><td>find_first_not_of()</td><td>搜索第一个“与value中任何值都不相等”的字符</td></tr><tr><td>find_last_not_of()</td><td>搜索最后一个“与value中任何值都不相等”的字符</td></tr></tbody></table></div><ol><li><p>所有搜索函数都返回符合条件的字符位置，如果搜索不成功，则返回npos。</p></li><li><p>这些函数都采用下面的参数方案：</p><ul><li>第一参数总是搜索对象</li><li>第二参数（可有可无）指出string搜索起点（字符位置）</li><li>第三参数（可有可无）指出搜索的字符个数</li></ul></li><li><p>遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">char</span>* cArray=<span class="string">&quot;hello, world!&quot;</span>;  </span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(cArray)</span></span>;  </span><br><span class="line">    <span class="comment">//数组方式  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>; j&lt; s.<span class="built_in">size</span>(); j++)  </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;个字符: &quot;</span> &lt;&lt; s[j] &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//迭代器方式  </span></span><br><span class="line">    string::reverse_iterator ri;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;反向打印字符&quot;</span> &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">for</span>(ri=s.<span class="built_in">rbegin</span>(); ri!=s.<span class="built_in">rend</span>(); ri++)  </span><br><span class="line">        cout &lt;&lt; *ri &lt;&lt; <span class="string">&#x27; &#x27;</span> ;  </span><br><span class="line">    cout &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><h2 id="数值npos"><a href="#数值npos" class="headerlink" title="数值npos"></a>数值npos</h2><p>string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)== string::npos)）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">string::size_type idx;</span><br><span class="line">...</span><br><span class="line">idx = s.<span class="built_in">find</span>(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(id == string::nops)</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><h1 id="string的构造和析构"><a href="#string的构造和析构" class="headerlink" title="string的构造和析构"></a>string的构造和析构</h1><div class="table-container"><table><thead><tr><th>Name</th><th>Feature</th></tr></thead><tbody><tr><td>string s</td><td>生成一个空字符串s</td></tr><tr><td>string s(str)</td><td>拷贝构造函数生成str的复制品</td></tr><tr><td>string s(str, stridx)</td><td>将字符串str内”始于位置stridx”的部分当作字符串的初值</td></tr><tr><td>string s(str, stridx, strlen)</td><td>将字符串str内”始于stridx且长度顶多strlen”的部分作为字符串的初值</td></tr><tr><td>string s(cstr)</td><td>将C字符串（以NULL结束）作为s的初值</td></tr><tr><td>string s(chars, chars_len)</td><td>将C字符串前chars_len个字符作为字符串s的初值</td></tr><tr><td>string s(num, ‘c’)</td><td>生成一个字符串，包含num个c字符</td></tr><tr><td>string s(“value”)</td><td>将s初始化为一个字符串string s=“value”字面值副本</td></tr><tr><td>string s=“value”</td><td>将s初始化为一个字符串string s=“value”字面值副本</td></tr><tr><td>string s(begin, end)</td><td>以区间begin/end(不包含end)内的字符作为字符串s的初值</td></tr><tr><td>s.~string()</td><td>销毁所有字符，释放内存2</td></tr></tbody></table></div><p>注意：</p><p><em>不能以单一字符；爱初始化某个字符串</em></p><p>但是可以这么做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">&#x27;x&#x27;</span>)</span></span>; <span class="comment">//error</span></span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>)</span> <span class="comment">//ok,creates a string that has one character &#x27;x&#x27;</span></span></span><br></pre></td></tr></table></figure><p>这表示了编译器提供了一个从const char*到string的自动类型转换功能，但是反过来却不行</p><p>参考自：</p><h1 id="string类的输入"><a href="#string类的输入" class="headerlink" title="string类的输入"></a>string类的输入</h1><h2 id="对于c-风格字符串"><a href="#对于c-风格字符串" class="headerlink" title="对于c-风格字符串"></a>对于c-风格字符串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> info[<span class="number">100</span>];</span><br><span class="line">cin &gt;&gt; info;<span class="comment">//read a word</span></span><br><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>);<span class="comment">//read a line,discard \n</span></span><br><span class="line">cin.<span class="built_in">get</span>(info, <span class="number">100</span>);read a line,leave \n in queue</span><br></pre></td></tr></table></figure><h2 id="对于string对象"><a href="#对于string对象" class="headerlink" title="对于string对象"></a>对于string对象</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string stuff;</span><br><span class="line">cin &gt;&gt; stuff;</span><br><span class="line"><span class="built_in">getline</span>(cin, stuff);</span><br></pre></td></tr></table></figure><h3 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h3><ol><li>两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(info, <span class="number">100</span>, <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line"><span class="built_in">getline</span>(cin, stuff, <span class="string">&#x27;:&#x27;</span>);</span><br></pre></td></tr></table></figure><ol><li>string版本的getline()函数从输入中读取字符，并将其储存到目标string中，直到发生下种情况之一：<ul><li>到达文件结尾，输入流的eofbit将被设置，这意味着方法fail()和eof()将被返回true</li><li>遇到分界字符(默认未\n)，将把分界字符从输出流中删除，但是不储存</li><li>读取的字符数达到最大允许值(string::nops和可供分配的内存字节数较小的一个)，在这种情况下，将设置输入流的failbit，这意味着方法fail()将放回true</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emacs官方文档阅读笔记</title>
      <link href="/2018/02/19/emacs%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/19/emacs%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>基本命令行<br><span id="more"></span></p><h1 id="翻页浏览命令"><a href="#翻页浏览命令" class="headerlink" title="翻页浏览命令"></a>翻页浏览命令</h1><p>C-v    向前移动一屏<br>M-v    向后移动一屏<br>C-l    重绘屏幕，并将光标所在行置于屏幕的中央  </p><h1 id="光标移动命令"><a href="#光标移动命令" class="headerlink" title="光标移动命令"></a>光标移动命令</h1><p>C-f    向右移动一个字符<br>C-b    向左移动一个字符  </p><p>M-f    向右移动一个词【对中文是移动到下一个标点符号】<br>M-b    向左移动一个词【对中文是移动到上一个标点符号】  </p><p>C-n    移动到下一行<br>C-p    移动到上一行  </p><p>C-a    移动到行首<br>C-e    移动到行尾  </p><p>M-a    移动到句首<br>M-e    移动到句尾</p><p>M-&gt;文章末尾</p><p>M-&lt;文章首段</p><h1 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h1><p>&lt; DEL &gt;    删除光标前的一个字符【这里的DEL指键盘上的Backspace键】<br>C-d    删除光标后的一个字符  </p><p>M-&lt; DEL &gt;    移除光标前的一个词<br>M-d    移除光标后的一个词  </p><p>C-k    移除从光标到“行尾”间的字符【移除其实相当于其他编辑器里的剪切】<br>M-k    移除从光标到“句尾”间的字符  </p><p>C-y    在光标所在处插入最后移除的文字【这个召回命令其实相当于其他编辑器里的粘贴】<br>M-y    召回再前一次被移除的内容，连续使用 M-y 直到找到你想要召回的东西。  </p><p>C-/    撤销命令  </p><p>C-x r k : 执行矩形区域的剪切  </p><p>C-x r y : 执行矩形区域的粘贴  </p><h1 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h1><p>C-x C-f    寻找一个文件【如果寻找一个不存在的文件，将创建此文件，只有在存盘的时候，Emacs 才会真正创建这个文件】<br>C-x C-s    储存这个文件  </p><p>C-x C-c    退出Emacs  </p><p>C-g : 取消未完成的命令  </p><h1 id="缓冲区操作命令："><a href="#缓冲区操作命令：" class="headerlink" title="缓冲区操作命令："></a>缓冲区操作命令：</h1><p>C-x C-b    列出缓冲<br>C-x 1    离开缓冲区列【只保留当前光标所在窗格】<br>C-x b    缓冲区名称 &lt; Return&gt;     切换缓冲<br>C-x s    保存多个缓冲  </p><p>C-M-\ : 对选中区域，按照某种格式(比如C程序)进行格式化<br>C-x h : 全部选中  </p><h1 id="搜索命令："><a href="#搜索命令：" class="headerlink" title="搜索命令："></a>搜索命令：</h1><p>C-s    向前搜索【再按一次 C-s，搜索下一个，敲 &lt; Return &gt; 结束搜索】<br>C-r    向后搜索【除了搜索方向与C-s相反之外，其余的操作都一样】  </p><p>M-% : 查询替换，也就是替换前会询问一下<br>M-x replace-string : 普通替换  </p><h1 id="多窗格"><a href="#多窗格" class="headerlink" title="多窗格"></a>多窗格</h1><p>C-x 2    将屏幕划分成两个窗格【数字2可以是其他数字（除1以外）】<br>C-M-v    向下滚动另一个窗格<br>C-M-S-v    向上滚动另一个窗格<br>C-x o    将光标转移到另一个窗格<br>C-x 1    只保留当前光标所在窗格  </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++小总结2</title>
      <link href="/2018/02/18/c++%E5%B0%8F%E6%80%BB%E7%BB%932/"/>
      <url>/2018/02/18/c++%E5%B0%8F%E6%80%BB%E7%BB%932/</url>
      
        <content type="html"><![CDATA[<p>虚函数与继承，转换函数</p><span id="more"></span><h1 id="虚函数与继承"><a href="#虚函数与继承" class="headerlink" title="虚函数与继承"></a>虚函数与继承</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">//pure virtual，一定要定义</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">error</span><span class="params">(<span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line">  <span class="comment">//impure virtual，希望重新定义，而且已有默认定义</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//non-virtual，不希望重新定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E8%99%9A%E5%87%BD%E6%95%B0.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E8%99%9A%E5%87%BD%E6%95%B02.png"></p><h1 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h1><h2 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123; &#125; <span class="comment">//(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//转换函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;<span class="comment">//分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator；<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;<span class="comment">//调用(1)</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">4</span> + f;<span class="comment">//调用operator double将f转为0</span></span><br></pre></td></tr></table></figure><h2 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123; &#125; </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  non-explicit-one-argument ctor</span></span><br><span class="line"><span class="comment">  explicit:可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。</span></span><br><span class="line"><span class="comment">  声明为explicit的构造函数,能在隐式转换中使用</span></span><br><span class="line"><span class="comment">  one-argument:因为den有默认值，所以此处指的是只需要一个参数的值就够了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  Fraction <span class="keyword">operator</span>+ （<span class="type">const</span> Fraction&amp; f） </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;<span class="comment">//分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator；<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d2 = f + <span class="number">4</span>;</span><br><span class="line"><span class="comment">//调用non-explicit ctor将4转化为Fraction(4, 1)，然后调用operator+</span></span><br></pre></td></tr></table></figure><h2 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span><br><span class="line">      : <span class="built_in">m_numerator</span>(num), <span class="built_in">m_denominator</span>(den) &#123; &#125; <span class="comment">//(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span>+ （<span class="type">const</span> Fraction&amp; f） </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;<span class="comment">//分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator；<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;<span class="comment">//调用(1)</span></span><br><span class="line">Fraction d = f + <span class="number">4</span>;<span class="comment">//error, ambiguous</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此情况下，编译器可以按照情况2将4转化为Fraction，即1/4</span></span><br><span class="line"><span class="comment">也可以按照情况1将f转化为0.6(3/5的结果）</span></span><br><span class="line"><span class="comment">此时就会互相矛盾，出现error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">      : m_numerator(num), m_denominator(den) &#123;</span> &#125;  <span class="comment">//(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="type">double</span>)(m_numerator / m_denominator);</span><br><span class="line">    &#125;</span><br><span class="line">    Fraction <span class="keyword">operator</span>+ （<span class="type">const</span> Fraction&amp; f） </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Fraction</span>(...);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_numerator;<span class="comment">//分子</span></span><br><span class="line">  <span class="type">int</span> m_denominator；<span class="comment">//分母</span></span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Fraction d = f + <span class="number">4</span>;<span class="comment">//error:conversion from &#x27;double&#x27; to &#x27;Fraction&#x27; request</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不能调用(1)将4变化Franction类型，同时重载了+法是Fraction类型相加，所以会失败</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++类 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 虚函数 </tag>
            
            <tag> 转换函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++小总结</title>
      <link href="/2018/02/17/c++%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/02/17/c++%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>构造函数不能共存例子、构造函数放在private、const在函数前与后、相同class的各个objects互为友元、设计一个类注意事项、操作符重载、new与delete、static、继承，复合，委托<br><span id="more"></span></p><h1 id="1-构造函数不能共存例子"><a href="#1-构造函数不能共存例子" class="headerlink" title="1. 构造函数不能共存例子"></a>1. 构造函数不能共存例子</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）</span><br><span class="line"><span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">  : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i)</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）</span><br><span class="line"><span class="built_in">complex</span>() : <span class="built_in">re</span>(<span class="number">0</span>), <span class="built_in">im</span>(<span class="number">0</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>当使用complex c1;或complex c2();时，两种创建办法都没有参数，编译器可以调用（1），对于（2），虽然函数有参数，但是有默认值，也可以调用，所以会冲突，不能共存。</p><h1 id="2-构造函数放在private"><a href="#2-构造函数放在private" class="headerlink" title="2. 构造函数放在private"></a>2. 构造函数放在private</h1><p>一般我们不把构造函数放在private里面，因为这样不能被外界调用。其实也有特殊情况，下面列举一种，Meyers Singleton设计模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> A&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">setup</span>() &#123;...&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">A</span>();<span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; rhs);<span class="comment">//构造函数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A&amp; <span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> A a;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用：A::getInstance.<span class="built_in">setup</span>(); <span class="comment">//通过函数来得到唯一的一份</span></span><br></pre></td></tr></table></figure><h1 id="3-const在函数前与后"><a href="#3-const在函数前与后" class="headerlink" title="3. const在函数前与后"></a>3. const在函数前与后</h1><ul><li>概念：当const在函数名前面的时候修饰的是函数返回值，在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。</li><li>原理：我们都知道在调用成员函数的时候编译器会将对象自身的地址作为隐藏参数传递给函数，在const成员函数中，既不能改变this所指向的对象，也不能改变this所保存的地址，this的类型是一个指向const类型对象的const指针。</li><li>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字说明的成员函数不能用来操作常对象。</li><li>const对象只能调用const成员函数。在const函数中调用非const成员函数是语法错误 。</li></ul><h1 id="4-相同class的各个objects互为友元"><a href="#4-相同class的各个objects互为友元" class="headerlink" title="4. 相同class的各个objects互为友元"></a>4. 相同class的各个objects互为友元</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ....</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param.re + param.im; <span class="comment">//直接可以拿封装里面数据</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, <span class="type">double</span> im;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-设计一个类注意事项"><a href="#5-设计一个类注意事项" class="headerlink" title="5. 设计一个类注意事项"></a>5. 设计一个类注意事项</h1><ul><li>数据尽量放在private</li><li>参数和返回值尽量通过引用传递</li><li>考虑const</li><li>构造函数特殊初始化语法</li></ul><h1 id="6-操作符重载"><a href="#6-操作符重载" class="headerlink" title="6. 操作符重载"></a>6. 操作符重载</h1><ul><li>成员函数（有this）：</li></ul><p>&lt;/div&gt;</p><div align="center"><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD.png" width="80%" height="80%"></div><ul><li>非成员函数（无this）：</li></ul><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD2.png" width="90%" height="90%"></p><p><em>注：typename()，创建临时对象，如complex( real (x) + y, imag (x) );</em></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD3.png" width="90%" height="90%"></p><ul><li>取反：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> - (<span class="type">const</span> complex&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span>(-<span class="built_in">real</span> (x), -<span class="built_in">imag</span>(y));<span class="comment">//临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">  complex c2;</span><br><span class="line">  cout &lt;&lt; -c1;</span><br><span class="line">  cout &lt;&lt; +c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-new与delete"><a href="#7-new与delete" class="headerlink" title="7. new与delete"></a>7. new与delete</h1><ul><li>new：先分配memory，再调用ctor。</li></ul><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/new%E4%B8%8Edelete.jpg" width="90%" height="90%"></p><ul><li><p>delete：先调用dtor，再调用memory</p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/new%E4%B8%8Edelete2.png" width="100%" height="100%"></p></li></ul><h1 id="8-static"><a href="#8-static" class="headerlink" title="8. static"></a>8. static</h1><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/Static.png" width="100%" height="100%"></p><ul><li>在没有使用static的情况下，要使用complex创建n个对象，就是在内存里面创建n个非静态数据。函数只有一个，但是要处理n个数据，靠的是this pointer指向数据来引导函数要去处理哪个数据。</li><li>使用static函数和对象后，函数同样有一份，但是静态数据只有一份。静态函数没有this pointer，可见静态函数只能去处理静态数据。</li></ul><p>例如：一个银行中，账户可能有很多个，不必用static，但是利率只有一份，可以用static。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">account</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">double</span> rate; <span class="comment">//利率</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span>&amp; x)</span> </span>&#123; rete = x;&#125; <span class="comment">//设置利率</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  调用static函数的方式有二种：</span></span><br><span class="line"><span class="comment">  1. 通过函数调用；</span></span><br><span class="line"><span class="comment">  2. 通过类名调用；</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  account::<span class="built_in">set_rate</span>(<span class="number">5.0</span>); <span class="comment">//(1)</span></span><br><span class="line"></span><br><span class="line">  account a;</span><br><span class="line">  a.<span class="built_in">set_rate</span>(<span class="number">7.0</span>); <span class="comment">//(2)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-继承，复合，委托"><a href="#9-继承，复合，委托" class="headerlink" title="9. 继承，复合，委托"></a>9. 继承，复合，委托</h1><h2 id="1-复合-has-a"><a href="#1-复合-has-a" class="headerlink" title="1. 复合(has-a)"></a>1. 复合(has-a)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt;</span><br><span class="line">  <span class="keyword">class</span> queue</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    Sequence c;<span class="comment">//底层容器，复合</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> cosnt <span class="type">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">    ....</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%A4%8D%E5%90%88.png" width="100%" height="100%"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%A4%8D%E5%90%882.png"></p><p><em>deque和queue同时出现同时消失</em></p><h2 id="2-委托"><a href="#2-委托" class="headerlink" title="2. 委托"></a>2. 委托</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%A7%94%E6%89%98.png"></p><p><em>StringRep与String没有共存关系</em></p><h2 id="3-继承-is-a"><a href="#3-继承-is-a" class="headerlink" title="3. 继承(is-a)"></a>3. 继承(is-a)</h2><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E7%BB%A7%E6%89%BF.png"></p><p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E7%BB%A7%E6%89%BF2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++类 </tag>
            
            <tag> 复合 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 委托 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过年是不可能过年的</title>
      <link href="/2018/02/15/YXT-%E8%BF%87%E5%B9%B4%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E8%BF%87%E5%B9%B4%E7%9A%84/"/>
      <url>/2018/02/15/YXT-%E8%BF%87%E5%B9%B4%E6%98%AF%E4%B8%8D%E5%8F%AF%E8%83%BD%E8%BF%87%E5%B9%B4%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>如今新年越来月没有年味了，对于我来说，给电脑换个壁纸等于过年</p><p>&lt;/div&gt;</p><div align="center"><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/%E6%82%A0%E9%97%B2%E8%B0%88/Cache_-ea02e3ab8fe8037..jpg" width="80%" height="80%"></div><p>壁纸，当然得骚红，毕竟  </p><p><strong>男人可以不帅，但是不能不骚</strong></p><p>今年春晚有4k源，但是在youtube上面嗨，估计也是给外国佬当做催眠剂把，毕竟</p><p><strong>春晚一分钟，稳睡一晚上</strong></p><p>无聊来谢谢随笔，其实也不算随笔，就是在xjb写</p><p>其实吧，是为了测试下悠闲谈板块而已</p><p>放假后用hexo和github搭建了个博客，这可能是好事，也可能是坏处，毕竟有很多东西都有两面性</p><p>然后，就没有然后了，现在是除夕下午，衣着简陋，无心过年，唯有农药</p><p>（说，农药给了你多少钱）</p>]]></content>
      
      
      <categories>
          
          <category> 悠闲谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STL之set和multiset</title>
      <link href="/2018/02/15/STL%E4%B9%8Bset/"/>
      <url>/2018/02/15/STL%E4%B9%8Bset/</url>
      
        <content type="html"><![CDATA[<p>set和multiset容器的操作函数和一道题：HDU 4989 Summary<br><span id="more"></span></p><h1 id="一、开始"><a href="#一、开始" class="headerlink" title="一、开始"></a>一、开始</h1><ol><li>使用set或multiset之前，必须加入头文件<set></set></li><li>set的含义是集合，它是一个有序的容器，里面的元素都是排序好的，支持插入，删除，查找等操作，就像一个集合一样。所有的操作的都是严格在logn时间之内完成，效率非常高。</li><li><p>set 和multiset容器的内部结构通常由平衡二叉树(balancedbinary tree)来实现。当元素放入容器中时，会按照一定的排序法则自动排序，默认是按照less&lt;&gt;排序规则来排序。两者不同之处在于，multisets允许元素重复，而set不允许重复。<br> 平衡二叉树：<br> &lt;/div&gt;</p><div align="center"><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" width="60%" height="60%"></div></li><li><p>这种自动排序的特性加速了元素查找的过程，但是也带来了一个问题：不可以直接修改set或multiset容器中的元素值，因为这样做就可能违反了元素自动排序的规则。如果你希望修改一个元素的值，必须先删除原有的元素，再插入新的元素。</p></li><li>sets和multisets具有以下特点：</li></ol><ul><li>不提供直接用来存取元素的任何操作元素</li><li>通过迭代器进行元素的存取。<h1 id="二、set和multiset容器的操作函数"><a href="#二、set和multiset容器的操作函数" class="headerlink" title="二、set和multiset容器的操作函数"></a>二、set和multiset容器的操作函数</h1><h2 id="1-构造、拷贝、析构"><a href="#1-构造、拷贝、析构" class="headerlink" title="1.  构造、拷贝、析构"></a>1.  构造、拷贝、析构</h2></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">set c</td><td style="text-align:left">创建一个空的set或multiset容器</td></tr><tr><td style="text-align:left">set c(op)</td><td style="text-align:left">创建一个空的使用op作为排序法则的set或multiset容器</td></tr><tr><td style="text-align:left">set c1(c2)</td><td style="text-align:left">创建一个已存在的set或multiset容器的复制品，容器的类型和所有元素一同复制</td></tr><tr><td style="text-align:left">set c(beg, end)</td><td style="text-align:left">创建一个set或multiset容器，并且以[beg, end)范围中的元素进行初始化</td></tr><tr><td style="text-align:left">set c(beg, end, op)</td><td style="text-align:left">创建一个使用op作为排序法则的set或multiset容器，并且以[beg, end)范围中的元素进行初始化</td></tr><tr><td style="text-align:left">c.~set()</td><td style="text-align:left">容器的析构函数，销毁所有的元素，释放所有的分配内存</td></tr></tbody></table></div><p>上面的set可以是下面几种形式：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">set<type></type></td><td style="text-align:left">以less&lt;&gt;为排序法则的set</td></tr><tr><td style="text-align:left">set<type, op></type,></td><td style="text-align:left">以op为排序法则的set</td></tr><tr><td style="text-align:left">multiset<type></type></td><td style="text-align:left">以less&lt;&gt;为排序法则的multiset</td></tr><tr><td style="text-align:left">multiset<type, op></type,></td><td style="text-align:left">以op为排序法则的multiset</td></tr></tbody></table></div><h2 id="2-非变动性操作"><a href="#2-非变动性操作" class="headerlink" title="2.  非变动性操作"></a>2.  非变动性操作</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">c.size()</td><td style="text-align:left">返回当前的元素数量</td></tr><tr><td style="text-align:left">c.empty ()</td><td style="text-align:left">判断大小是否为零，等同于0 == size()，效率更高</td></tr><tr><td style="text-align:left">c.max_size()</td><td style="text-align:left">返回能容纳的元素最大数量</td></tr><tr><td style="text-align:left">c1 == c2</td><td style="text-align:left">判断c1是否等于c2</td></tr><tr><td style="text-align:left">c1 != c2</td><td style="text-align:left">判断c1是否不等于c2(等同于!(c1==c2))</td></tr><tr><td style="text-align:left">c1 &lt; c2</td><td style="text-align:left">判断c1是否小于c2</td></tr><tr><td style="text-align:left">c1 &gt; c2</td><td style="text-align:left">判断c1是否大于c2</td></tr><tr><td style="text-align:left">c1 &lt;= c2</td><td style="text-align:left">判断c1是否小于等于c2(等同于!(c2&lt;c1))</td></tr><tr><td style="text-align:left">c1 &gt;= c2</td><td style="text-align:left">判断c1是否大于等于c2 (等同于!(c1&lt;c2))</td></tr></tbody></table></div><p><em>值得注意的是比较操作符只针对相同类型的容器，元素类型和排序法则类型都必须相同。</em><br>error例子如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;<span class="type">float</span>&gt; c1;</span><br><span class="line">std::set&lt; <span class="type">float</span>, std::greater&lt;<span class="type">float</span>&gt; &gt; c2;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(c1 == c2) <span class="comment">//error: different types</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="3-特殊的搜寻函数"><a href="#3-特殊的搜寻函数" class="headerlink" title="3. 特殊的搜寻函数"></a>3. 特殊的搜寻函数</h2><p>　sets和multisets在元素快速搜寻方面做了优化设计，提供了特殊的搜寻函数，所以应优先使用这些搜寻函数，可获得对数复杂度，而非STL的线性复杂度。比如在1000个元素搜寻，对数复杂度平均十次，而线性复杂度平均需要500次。</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">count (elem)</td><td style="text-align:left">返回元素值为elem的个数</td></tr><tr><td style="text-align:left">find(elem)</td><td style="text-align:left">返回元素值为elem的第一个元素，如果没有返回end()</td></tr><tr><td style="text-align:left">lower _bound(elem)</td><td style="text-align:left">返回元素值为elem的第一个可安插位置，也就是元素值 &gt;= elem的第一个元素位置</td></tr><tr><td style="text-align:left">upper _bound (elem)</td><td style="text-align:left">返回元素值为elem的最后一个可安插位置，也就是元素值 &gt; elem 的第一个元素位置</td></tr><tr><td style="text-align:left">equal_range (elem)</td><td style="text-align:left">返回elem可安插的第一个位置和最后一个位置，也就是元素值==elem的区间</td></tr></tbody></table></div><p><em>成员函数find()搜寻出与参数值相同的第一个元素，并返回一个迭代器，指向该位置。如果没有找到这样的元素，就返回容器的end()。</em><br>下面我们看一个lower_bound(), upper_bound和equal_range(val)例子，或者看博客介绍<a href="https://greenhathg.github.io/2018/02/13/STL%E4%B9%8B%E4%BA%8C%E5%88%86/#%E5%9B%9B%E3%80%81equal-range-%E5%87%BD%E6%95%B0">STL二分法</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; coll;</span><br><span class="line"></span><br><span class="line">    coll.<span class="built_in">insert</span>(<span class="number">1</span>); <span class="comment">//插入元素</span></span><br><span class="line">    coll.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">    coll.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">    coll.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    coll.<span class="built_in">insert</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower_bound(3):&quot;</span> &lt;&lt; *coll.<span class="built_in">lower_bound</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;upper_bound(3):&quot;</span> &lt;&lt; *coll.<span class="built_in">upper_bound</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;equal_range(3):&quot;</span> &lt;&lt; *coll.<span class="built_in">equal_range</span>(<span class="number">3</span>).first</span><br><span class="line">         &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *coll.<span class="built_in">equal_range</span>(<span class="number">3</span>).second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lower_bound(5):&quot;</span> &lt;&lt; *coll.<span class="built_in">lower_bound</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;upper_bound(5):&quot;</span> &lt;&lt; *coll.<span class="built_in">upper_bound</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;equal_range(5):&quot;</span> &lt;&lt; *coll.<span class="built_in">equal_range</span>(<span class="number">3</span>).first &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; *coll.<span class="built_in">equal_range</span>(<span class="number">3</span>).second&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line"><span class="built_in">lower_bound</span>(<span class="number">3</span>):<span class="number">4</span></span><br><span class="line"><span class="built_in">upper_bound</span>(<span class="number">3</span>):<span class="number">4</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="number">3</span>):<span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="built_in">lower_bound</span>(<span class="number">5</span>):<span class="number">5</span></span><br><span class="line"><span class="built_in">upper_bound</span>(<span class="number">5</span>):<span class="number">6</span></span><br><span class="line"><span class="built_in">equal_range</span>(<span class="number">5</span>):<span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure></p><h2 id="4-赋值操作"><a href="#4-赋值操作" class="headerlink" title="4. 赋值操作"></a>4. 赋值操作</h2><p>set和multiset容器只提供最基本的赋值操作：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">c1 = c2</td><td style="text-align:left">把c2的所有元素复制到c1中，同时c1原有的元素被销毁。</td></tr><tr><td style="text-align:left">c1.swap(c2)</td><td style="text-align:left">交换c1和c2的元素。</td></tr><tr><td style="text-align:left">swap(c1, c2)</td><td style="text-align:left">同上，只不过这是一个通用算法。</td></tr></tbody></table></div><p><em>需要注意的是两个容器的类型要一致（包括元素类型和排序法则类型）。</em></p><h2 id="5-迭代器函数"><a href="#5-迭代器函数" class="headerlink" title="5. 迭代器函数"></a>5. 迭代器函数</h2><ul><li>sets和multisets的迭代器是双向迭代器，对迭代器操作而言，所有的元素都被视为常数，可以确保你不会人为改变元素值，从而打乱既定顺序，所以无法调用变动性算法，如remove()。</li><li>set和multiset不提供元素直接存取，所以只能采用迭代器</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">c.begin()</td><td style="text-align:left">返回一个随机存取迭代器，指向第一个元素</td></tr><tr><td style="text-align:left">c.end()</td><td style="text-align:left">返回一个随机存取迭代器，指向最后一个元素的下一个位置</td></tr><tr><td style="text-align:left">c.rbegin()</td><td style="text-align:left">返回一个逆向迭代器，指向逆向迭代的第一个元素</td></tr><tr><td style="text-align:left">c.rend()</td><td style="text-align:left">返回一个逆向迭代器，指向逆向迭代的最后一个元素的下一个位置</td></tr></tbody></table></div><h2 id="6-安插和删除元素"><a href="#6-安插和删除元素" class="headerlink" title="6. 安插和删除元素"></a>6. 安插和删除元素</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Name</th><th style="text-align:left">Feature</th></tr></thead><tbody><tr><td style="text-align:left">c.insert(elem)</td><td style="text-align:left">插入一个elem副本，返回新元素位置，无论插入成功与否。</td></tr><tr><td style="text-align:left">c.insert(pos, elem)</td><td style="text-align:left">安插一个elem元素副本，返回新元素位置，pos为收索起点，提升插入速度。</td></tr><tr><td style="text-align:left">c.insert(beg,end)</td><td style="text-align:left">将区间[beg,end)所有的元素安插到c，无返回值。</td></tr><tr><td style="text-align:left">c.erase(elem)</td><td style="text-align:left">删除与elem相等的所有元素，返回被移除的元素个数。</td></tr><tr><td style="text-align:left">c.erase(pos)</td><td style="text-align:left">移除迭代器pos所指位置元素，无返回值。</td></tr><tr><td style="text-align:left">c.erase(beg,end)</td><td style="text-align:left">移除区间[beg,end)所有元素，无返回值。</td></tr><tr><td style="text-align:left">c.clear()</td><td style="text-align:left">移除所有元素，将容器清空</td></tr></tbody></table></div><p>删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> to_delete = *it;</span><br><span class="line">      <span class="keyword">auto</span> tmp_it = chop_set.<span class="built_in">find</span>(to_delete);</span><br><span class="line">      <span class="keyword">while</span>(tmp_it != chop_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          <span class="comment">//note: erase will return next avilable it pointer</span></span><br><span class="line">          it = chop_set.<span class="built_in">erase</span>(tmp_it); </span><br><span class="line">          tmp_it = chop_set.<span class="built_in">find</span>(*tmp_it);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="7-set实例："><a href="#7-set实例：" class="headerlink" title="7. set实例："></a>7. set实例：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// empty set container</span></span><br><span class="line">    set &lt;<span class="type">int</span>&gt; gquiz1;</span><br><span class="line"></span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">60</span>);</span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">50</span>); <span class="comment">// only one 50 will be added to the set</span></span><br><span class="line">    gquiz<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printing set gquiz1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nThe set gquiz1 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gquiz1)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assigning the elements from gquiz1 to gquiz2</span></span><br><span class="line">    set &lt;<span class="type">int</span>&gt; <span class="built_in">gquiz2</span>(gquiz<span class="number">1.</span><span class="built_in">begin</span>(), gquiz<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// printing set gquiz1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\nThe set gquiz2 is : &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gquiz2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements up to 30 in gquiz2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ngquiz2 after removal of elements less than 30 : &quot;</span>;</span><br><span class="line">    gquiz<span class="number">2.</span><span class="built_in">erase</span>(gquiz<span class="number">2.</span><span class="built_in">begin</span>(), gquiz<span class="number">2.f</span>ind(<span class="number">30</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gquiz2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all elements with value 50 in gquiz2</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    num = gquiz<span class="number">2.</span><span class="built_in">erase</span> (<span class="number">50</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ngquiz2.erase(50) : &quot;</span>;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; removed \t&quot;</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : gquiz2)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lower bound and upper bound for set gquiz1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gquiz1.lower_bound(40) : &quot;</span></span><br><span class="line">         &lt;&lt; *gquiz<span class="number">1.l</span>ower_bound(<span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gquiz1.upper_bound(40) : &quot;</span></span><br><span class="line">         &lt;&lt; *gquiz<span class="number">1.</span><span class="built_in">upper_bound</span>(<span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lower bound and upper bound for set gquiz2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gquiz2.lower_bound(40) : &quot;</span></span><br><span class="line">         &lt;&lt; *gquiz<span class="number">2.l</span>ower_bound(<span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;gquiz2.upper_bound(40) : &quot;</span></span><br><span class="line">         &lt;&lt; *gquiz<span class="number">2.</span><span class="built_in">upper_bound</span>(<span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line">The set gquiz1 is : <span class="number">10</span>  <span class="number">20</span>  <span class="number">30</span>  <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span></span><br><span class="line"></span><br><span class="line">The set gquiz2 is : <span class="number">10</span>  <span class="number">20</span>  <span class="number">30</span>  <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span></span><br><span class="line"></span><br><span class="line">gquiz2 after removal of elements less than <span class="number">30</span> : <span class="number">30</span>  <span class="number">40</span>  <span class="number">50</span>  <span class="number">60</span></span><br><span class="line"></span><br><span class="line">gquiz<span class="number">2.</span><span class="built_in">erase</span>(<span class="number">50</span>) : <span class="number">1</span> removed <span class="number">30</span>  <span class="number">40</span>  <span class="number">60</span></span><br><span class="line">gquiz<span class="number">1.l</span>ower_bound(<span class="number">40</span>) : <span class="number">40</span></span><br><span class="line">gquiz<span class="number">1.</span><span class="built_in">upper_bound</span>(<span class="number">40</span>) : <span class="number">50</span></span><br><span class="line">gquiz<span class="number">2.l</span>ower_bound(<span class="number">40</span>) : <span class="number">40</span></span><br><span class="line">gquiz<span class="number">2.</span><span class="built_in">upper_bound</span>(<span class="number">40</span>) : <span class="number">60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="三、一道习题"><a href="#三、一道习题" class="headerlink" title="三、一道习题"></a>三、一道习题</h1><h2 id="HDU-4989-Summary"><a href="#HDU-4989-Summary" class="headerlink" title="HDU 4989 Summary"></a>HDU 4989 Summary</h2><p><strong><em>Problem Description</em></strong><br><em>Small W is playing a summary game. Firstly, He takes N numbers. Secondly he takes out every pair of them and add this two numbers, thus he can get N</em>(N - 1)/2 new numbers. Thirdly he deletes the repeated number of the new numbers. Finally he gets the sum of the left numbers. Now small W want you to tell him what is the final sum.<br><strong><em>Input</em></strong><br><em>Multi test cases, every case occupies two lines, the first line contain n, then second line contain n numbers a1, a2, ……an separated by exact one space. Process to the end of file.</em><br><em>[Technical Specification]</em><br><em>2 &lt;= n &lt;= 100</em><br><em>-1000000000 &lt;= ai &lt;= 1000000000</em><br><strong><em>Output</em></strong><br><em>For each case, output the final sum.</em><br><strong><em>Sample Input</em></strong><br><em>4</em><br><em>1 2 3 4</em><br><em>2</em><br><em>5 5</em><br><strong><em>Sample Output</em></strong><br><em>25</em><br><em>10</em><br><strong><em>Hint</em></strong><br><em>Firstly small W takes any pair of 1 2 3 4 and add them, he will get 3 4 5 5 6 7. Then he deletes the repeated numbers, he will get 3 4 5 6 7, Finally he gets the sum=3+4+5+6+7=25</em><br>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll sum = <span class="number">0</span>, arr[<span class="number">110</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n ;k++)</span><br><span class="line">                s.<span class="built_in">insert</span>(arr[k] + arr[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : s)</span><br><span class="line">            sum += x;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> set </tag>
            
            <tag> multiset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之vector</title>
      <link href="/2018/02/14/STL%E4%B9%8Bvector/"/>
      <url>/2018/02/14/STL%E4%B9%8Bvector/</url>
      
        <content type="html"><![CDATA[<p>vector的声明、向量操作、访问方式、赋值操作、安插，移除相关操作、应用实例。一道习题（第k个约数）<br><span id="more"></span></p><h3 id="一、-开始："><a href="#一、-开始：" class="headerlink" title="一、 开始："></a>一、 开始：</h3><ul><li>要使用vector必须包含头文件&lt; vector &gt;</li><li>vector可以看成是动态一维数组</li><li>vector可以存在重复元素(set不能存在)</li><li>vector迭代器是随机存取迭代器，所以对任何一个STL算法都奏效</li><li>在末端附加或删除元素时，vector的性能相当好。但是如果在前端或在中部安插或删除元素，性能就不怎么样了。<br><em>因为操作点之后的每一个元素都必须移到另一个位置，而每一次移动都得调用赋值操作符</em><h3 id="二、-vector的声明"><a href="#二、-vector的声明" class="headerlink" title="二、 vector的声明:"></a>二、 vector的声明:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;type&gt; a;</span><br><span class="line"><span class="comment">/*type可以是int，double等等.</span></span><br><span class="line"><span class="comment">此时a.size()为0，但是因为是动态的，所以大小会可能改变*/</span></span><br><span class="line"><span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;type&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//动态分配</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//声明一个存放了100个0的整数vector，其大小没有被固定为100，还可以加数据</span></span><br><span class="line"><span class="function">vector&lt;type&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//产生另一个同型vector的副本（所有元素都被拷贝）</span></span><br><span class="line"><span class="function">vector&lt;type&gt; <span class="title">a</span><span class="params">(beg,end)</span></span>; <span class="comment">//产生一个vector，以区间[beg,end]做为元素初值</span></span><br><span class="line">a.~<span class="built_in">vector</span>&lt;type&gt;(); <span class="comment">//销毁所有元素并且释放内存</span></span><br></pre></td></tr></table></figure><h3 id="三、-向量操作"><a href="#三、-向量操作" class="headerlink" title="三、 向量操作:"></a>三、 向量操作:</h3></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Feature</th></tr></thead><tbody><tr><td style="text-align:center">push_back()</td><td style="text-align:center">在数组的最后添加一个数据</td></tr><tr><td style="text-align:center">pop_back()</td><td style="text-align:center">去掉数组的最后一个数据</td></tr><tr><td style="text-align:center">at()</td><td style="text-align:center">得到编号位置的数据</td></tr><tr><td style="text-align:center">begin()</td><td style="text-align:center">得到数组头的指针</td></tr><tr><td style="text-align:center">end()</td><td style="text-align:center">得到数组的最后一个单元+1的指针</td></tr><tr><td style="text-align:center">front()</td><td style="text-align:center">得到数组头的引用（返回第一个元素）</td></tr><tr><td style="text-align:center">back()</td><td style="text-align:center">得到数组的最后一个单元的引用（返回最后一个元素）</td></tr><tr><td style="text-align:center">max_size()</td><td style="text-align:center">得到vector最大可以是多大</td></tr><tr><td style="text-align:center">capacity()</td><td style="text-align:center">当前vector分配的大小</td></tr><tr><td style="text-align:center">size()</td><td style="text-align:center">当前使用数据的大小</td></tr><tr><td style="text-align:center">resize()</td><td style="text-align:center">改变当前使用数据的大小，如果它比当前使用的大，则填充默认值</td></tr><tr><td style="text-align:center">reserve()</td><td style="text-align:center">改变当前vecotr所分配空间的大小(如果容量不足，扩大之，但是references，pointers，iterators会失效)</td></tr><tr><td style="text-align:center">erase()</td><td style="text-align:center">删除指针指向的数据项</td></tr><tr><td style="text-align:center">clear()</td><td style="text-align:center">清空当前的vector</td></tr><tr><td style="text-align:center">rbegin()</td><td style="text-align:center">将vector反转后的开始指针返回(其实就是原来的end-1)</td></tr><tr><td style="text-align:center">rend()</td><td style="text-align:center">将vector反转构的结束指针返回(其实就是原来的begin-1)</td></tr><tr><td style="text-align:center">empty()</td><td style="text-align:center">判断vector是否为空</td></tr><tr><td style="text-align:center">swap()</td><td style="text-align:center">与另一个vector交换数据</td></tr></tbody></table></div><p><em>对着一个空vector调用operator[], front(), back(),都会引起未定义行为，所以执行这些函数时必须确定容器不空</em></p><h3 id="四、-访问方式："><a href="#四、-访问方式：" class="headerlink" title="四、 访问方式："></a>四、 访问方式：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; a[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a.<span class="built_in">at</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><em>以上区别在于后者在访问越界时会抛出异常，而前者不会。</em></p><h3 id="五、-vector的赋值操作"><a href="#五、-vector的赋值操作" class="headerlink" title="五、 vector的赋值操作"></a>五、 vector的赋值操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2; <span class="comment">//将c2全部元素赋值给c1</span></span><br><span class="line">c.<span class="built_in">assign</span>(n, elem); <span class="comment">//复制n个elem，赋值给c</span></span><br><span class="line">c.<span class="built_in">assign</span>(beg, end); <span class="comment">//将区间[beg, end]内的元素赋值给c</span></span><br><span class="line">c<span class="number">1.</span><span class="built_in">swap</span>(c2); <span class="comment">//将c1与c2元素互换</span></span><br></pre></td></tr></table></figure><h3 id="六、vector的安插、移除相关操作"><a href="#六、vector的安插、移除相关操作" class="headerlink" title="六、vector的安插、移除相关操作"></a>六、vector的安插、移除相关操作</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Name</th><th style="text-align:center">Feature</th></tr></thead><tbody><tr><td style="text-align:center">c.insert(pos, elem)</td><td style="text-align:center">在pos位置上插入一个elem 副本，并返回新元素的位置</td></tr><tr><td style="text-align:center">c.insert(pos, n, elem)</td><td style="text-align:center">在pos位置上插入n个elem 副本。无返回值</td></tr><tr><td style="text-align:center">c.insert(pos, beg, end)</td><td style="text-align:center">在pos位置上插入区间[beg ; end]内的所有元素的副本，无回传值</td></tr><tr><td style="text-align:center">c.push_back(elem)</td><td style="text-align:center">在尾部添加一个elem副本</td></tr><tr><td style="text-align:center">c.pop_back()</td><td style="text-align:center">移除最后一个元素（但不回传）</td></tr><tr><td style="text-align:center">c.erase(pos)</td><td style="text-align:center">移除pos位置上的元素，返回下一元素的位置</td></tr><tr><td style="text-align:center">c.erase(beg , end)</td><td style="text-align:center">移除[beg , end]区间内的所有元素，返回下一元素的位置</td></tr><tr><td style="text-align:center">c.resize(num)</td><td style="text-align:center">将元素数量改为num（如果size()变大了，多出来的新元素都需要以default构造函数构造完成）</td></tr><tr><td style="text-align:center">c.resize(num , elem)</td><td style="text-align:center">将元素数量改为num（如果size()变大了，多出来的新元素都需要以elem的副本）</td></tr><tr><td style="text-align:center">c.clear()</td><td style="text-align:center">移除所有元素，将容器清空</td></tr></tbody></table></div><h3 id="七、vector应用实例"><a href="#七、vector应用实例" class="headerlink" title="七、vector应用实例"></a>七、vector应用实例</h3><ol><li><p>删除所有的值为val的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sentence;</span><br><span class="line">sentence.<span class="built_in">erase</span>(<span class="built_in">remove</span>(sentence.<span class="built_in">begin</span>() ,</span><br><span class="line">              sentence.<span class="built_in">end</span>() ,val) ,sentence.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>简单解释下：remove()从指定位置开始遍历容器，将后面的元素依次前移，跳过和value相同值的元素，也就是说，所有和value相同值的元素都会被覆盖，而其他的元素都会依次前移，并返回范围新结尾的迭代器，整个过程并没有修改原容器的size,以及end()。如下：<br>我们要从{1,1,9,5,2,1,3}除去1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">//使用remove()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> op =<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//op里面存储的是返回值，可以看成是一个元素指针</span></span><br><span class="line">    cout &lt;&lt; *op &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出返回值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x : c)</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">//输出remove()后的vector</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">9</span> <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>接着这里erase()作用是去除范围内的所有元素，这个范围里面的值就是{2,1,3},所以就可以得到想要的{9,5,2,3}。</p></li><li><p>只是要删除“与某值相等”的第一个元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; sentence;</span><br><span class="line"><span class="keyword">auto</span> pos;</span><br><span class="line"><span class="comment">//或std::vector&lt;string&gt;::iterator sentence;</span></span><br><span class="line">pos=<span class="built_in">find</span>(sentence.<span class="built_in">begin</span>() , sentence.<span class="built_in">end</span>() ,val);</span><br><span class="line"><span class="keyword">if</span>( pos != sentence.<span class="built_in">end</span>() )&#123;</span><br><span class="line">    sentence.<span class="built_in">erase</span>(pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八、一道习题："><a href="#八、一道习题：" class="headerlink" title="八、一道习题："></a>八、一道习题：</h3><p><strong>题目描述</strong><br>给出一个数n和一个数k，按从小到大算出n的第k个约数。<br><strong>输入</strong><br>每一个测试数据包括一个n和一个k (1 &lt;= n &lt;= 10^15, 1 &lt;= 10^9)<br><strong>输出</strong><br>如果n没有第k个约数，则输出-1，如果有则输出第k个约数<br><strong>示例</strong><br>输入：<br>4 2<br>输出：<br>2<br>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, k;</span><br><span class="line">    vector&lt;ll&gt; v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">            v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span> &amp;&amp; i * i != n)</span><br><span class="line">            v.<span class="built_in">push_back</span>(n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(k &gt; v.<span class="built_in">size</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; v[k<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步写出c++带指针类实例(标准库string部分)</title>
      <link href="/2018/02/14/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E5%87%BAc++%E5%B8%A6%E6%8C%87%E9%92%88%E7%B1%BB%E5%AE%9E%E4%BE%8B(%E6%A0%87%E5%87%86%E5%BA%93string%E9%83%A8%E5%88%86)/"/>
      <url>/2018/02/14/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E5%86%99%E5%87%BAc++%E5%B8%A6%E6%8C%87%E9%92%88%E7%B1%BB%E5%AE%9E%E4%BE%8B(%E6%A0%87%E5%87%86%E5%BA%93string%E9%83%A8%E5%88%86)/</url>
      
        <content type="html"><![CDATA[<p>共16步<br><span id="more"></span><br><em>本篇文章注重与complex篇的区别，可能不那么详细</em></p><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol><li>写出主体（行1,2,11)</li><li>考虑private里面要放的数据，字符串，当然是放很多字符，一种想法是里面放一个数组，但是这种数组可能不是很好，因为数组你得指明多大，太大或太小都不好。所以我们选择另一种做法，在里面放一个指针，将来要分配多大内存，就动态去分配，用new的方式。<br>一个指针多大，在传统的32位电脑中是4个字节，所以无论以后字符串里面内容是什么，字符串这个对象本身就是4个字节。(行9,10)</li><li>然后到了准备函数的环节，首先当然是构造函数，要使外界创建string，一定要调用构造函数，而且要放到public（当然也有放在private里面的，只是很少）。</li><li>存进来以后当然不可能要改变里面的东西，我们只是拿来当初值而已，所以加const，并且给默认值为0。（行4）</li><li>class里面有指针，所以要去关注三个重要特殊的函数。</li><li>第一个是拷贝构造函数。既然是拷贝构造，那么就是相当于它自己，则参数里面类型用String。<br>再考虑下引用和const的问题，引用必须的。（行5）<br>我们传进来只是复制个蓝本，没有考虑要去改变，所以加上const。</li><li>第二是拷贝赋值函数。先写名称operator=，赋值的动作是把来源端拷贝到目的端去，来源端是String类型，所以参数也是String,这才叫拷贝。<br>这里和7一样同样考虑引用和const<br>返回值的话理所当然是String类型，因为本来就有目的端，所以可以加引用（行6）</li><li>第三个是析构函数，与类的名称相同并加波浪号</li><li>接着我们还需要加个辅助函数，能让字符串丢到cout，也就是你的屏幕。做法很简单，如果我能够取到private里面那个字符，cout是可以接受这种东西的，所以设置了一个get_str()函数，同时注意const。因为前面那些函数都是要改变目的端的数据，所以不能加const。（行7）</li><li>设计构造函数，首先第一个要考虑的是得分配足够的空间去放初值，这里用new动态分配内存。接着把传进来初值的内容拷贝到已经分配的空间，即data，这就完成了创建新的字符串的内容（注意包含头文件）。加个inline。（行13-26）</li><li>如果没有指定初值的话，我这里是也要分配一个空间去放结束符。</li><li>下一步设计析构函数，这个把分配的内存释放掉就行了，用delete[]。（行28-31）</li><li>然后是拷贝构造函数，同样是用new分配一块先，这里不同的是strlen里面用了str.data，因为传进来的是class，所以用.读取数据。（行33-38）</li><li>看到这么多inline，那到底什么时候用呢？<br>emmm，反正全写行了，不管多长，要是编译器不支持的话自然不会去做，没有副作用。</li><li>接着是拷贝赋值函数,赋值，把来源端赋值到目的端，现在这个目的端是本来已经存在的东西，所以目的端要先把自己用delete清掉，杀掉以后重新分配一块够大的空间，接着把来源端拷贝到目的端。考虑下返回值，如果把返回类型设置为void，则不能连续赋值，所以最好有返回。</li><li>还得考虑一个容易忽略的点，就是判断是是不是自我赋值。（40-49）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="number">0</span>); <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> String&amp; str); <span class="comment">//拷贝构造函数</span></span><br><span class="line">  String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String &amp; str); <span class="comment">//拷贝赋值函数</span></span><br><span class="line">  ~<span class="built_in">String</span>(); <span class="comment">//析构函数</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">get_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125; <span class="comment">//把字符串丢到cout</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">      <span class="type">char</span>* data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str)</span><br><span class="line">  &#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//未指定初值</span></span><br><span class="line">  &#123;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">    *data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">delete</span>[] data;</span><br><span class="line">&#125;<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function"><span class="title">String::String</span><span class="params">(<span class="type">const</span> String &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.data) + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">&#125;<span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">String&amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) <span class="comment">//判断是不是自我赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">delete</span>[] data;</span><br><span class="line">  data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.data + <span class="number">1</span>)];</span><br><span class="line">  <span class="built_in">strcpy</span>(data, str.data);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;<span class="comment">//拷贝赋值函数</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步写出c++不带指针类实例(标准库complex部分)</title>
      <link href="/2018/02/13/c++%E4%B8%8D%E5%B8%A6%E6%8C%87%E9%92%88%E7%B1%BB%E5%AE%9E%E4%BE%8B(complex)/"/>
      <url>/2018/02/13/c++%E4%B8%8D%E5%B8%A6%E6%8C%87%E9%92%88%E7%B1%BB%E5%AE%9E%E4%BE%8B(complex)/</url>
      
        <content type="html"><![CDATA[<p>总共有19步<br><span id="more"></span></p><h3 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h3><ol><li>首先先养成防卫式习惯，在头文件中加入下面三行，防止重复包含(行2,3,19)</li><li>然后写出主体（行4,5,18）</li><li>考虑下这个复数需要什么数据，当然这个数据应该放在私有部分(private)。<br> 复数有实部虚部，可得出private变量的定义（行15,16）</li><li>接下来考虑需要什么函数来实现，这些函数当然需要操作在复数身上，然后<br> 函数是对外发表的，所以放在public里面（行7，行8）</li><li>首先任何一个class都有构造函数，然后构造函数的语法是什么？<br> 构造函数名称与class名称相同，没有返回类型。接着，一个构造函数应该接收什么参数？<br> 在这个例子中，有实部虚部，我们就应该有实部虚部的参数，然后我们就考量要不要默认值。</li><li>我们还要考虑这个函数的传递是按值传递还是按引用传递？<br> 这个函数中传值或者传引用区别不大，所以随便选择一个</li><li>还得想到构造函数有个很特别的语法—初始列，一般最好运用初始列</li><li>然后考虑构造函数还需要干什么，这个例子已经不需要什么操作，在别的地方可能要在构造函数中分配一些内存，开个窗口，或者开个文件等等（行9,10）</li><li>接下来考虑这个class要实现什么功能，在这个例子中，我们实现复数的加法。<br> 对于该函数有两种选择，一种是成为成员函数，另一种则是非成员函数，这两种选择都可以，这里我们选择第一种。（行12）</li><li>还需要准备什么函数呢？需要两个函数去取得private里面实部和虚部的值。对于一个函数，我们考虑是否要加const，在这里只是要取实虚部的值，所以要加const保证安全。（行13,14）</li><li>接下来在class本体外实现复数的加法，先把函数首部除参数之外的东西写出来(complex::operator += )，然后再思考参数是什么？<br>+=，一定有个左边有个右边，由于该函数是一个成员函数，是作用在左边身上，所以左边就有一个隐藏的参数放进来，不知道在参数列表第几个位置，反正就是一定有，所以在参数里面就写右边就好。（行12）</li><li>首先我们要考虑传引用，所以加&amp;，那要不要加const？+=是左边动，右边不动，所以要加const。<br>然后考虑返回值类型，显而易见+=得到左边的是一个复数，所以是complex类型，那么要不要传引用？由于左边本来就存在，不是在函数里面才定义的，所以可以传引用。<br>由于这个函数是在class本体之外，为了提高效率，所以加个inline，至于最终会不会变成内联函数，这个就要看编译器</li><li>然后补充完整函数主体（行22-33）</li><li>然后我们多了三个加法，复数+复数，复数+实数，实数+复数，是在本体外，为什么？（行42-54）<br>如果放在class里面，就只能实现一种加法</li><li>接着考虑输出功能，举个例子，要输出complex c1(9,8)。<br>这里可能需要&lt;&lt;操作符重载，操作符&lt;&lt;只能作用在左边，那么就意味着得是c1 &lt;&lt; cout;为了避免这种情况，我们需要重载运算符，实现cout &lt;&lt; c1;（行56-61）</li><li>由于该重载函数不是成员函数，所以不需要complex::，由于该函数要实现cout &lt;&lt; c1，所以左边是cout，左边参数就得是“cout类型”，查手册得cout属于class ostream（得包含头文件&lt; iostream &gt;，同理右边是complex。<br>然后考虑传引用，class complex和class ostream都是很大东西，传引用速度快。然后考虑要不要加const，右边作用于左边，右边肯定不变，加const，那么左边呢？<br>左边会改变，状态会改变，所以不能加const</li><li>接着考虑返回值对于cout &lt;&lt; c1这种情况，可以设置为void，但是对于cout &lt;&lt; c1 &lt;&lt; endl这种情况呢？</li><li>当cout &lt;&lt; c1执行完毕之后，应该传回一种想cout这种东西让&lt;&lt; endl继续执行，那cout是什么东西，ostream，所以返回值最好设置为ostream。ostream是本来就有的，所以可以传引用</li><li>最后补全函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">本体</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _COMPLEX_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _COMPLEX_</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span> (<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">  : <span class="built_in">re</span> (r), <span class="built_in">im</span> (i)</span><br><span class="line">  &#123; &#125;</span><br><span class="line"></span><br><span class="line">  complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> complex&amp;);</span><br><span class="line">  <span class="function"><span class="type">double</span> real <span class="title">const</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> re;&#125; <span class="comment">//函数完整，是inline</span></span><br><span class="line">  <span class="function"><span class="type">double</span> imag <span class="title">const</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> im;&#125; <span class="comment">//inline</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; _doapl (complex*, <span class="type">const</span> complex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">本体外</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">_doapl(complex* ths, <span class="type">const</span> complex &amp; r) <span class="comment">//左边变，右边不变，所以左边不要const</span></span><br><span class="line">&#123;</span><br><span class="line">  ths-&gt;re += r.re;</span><br><span class="line">  ths-&gt;im += r.im;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex &amp; r)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _doapl (<span class="keyword">this</span>, r); <span class="comment">//让_doapl实现加法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex <span class="comment">//不能传引用</span></span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + <span class="built_in">real</span>(y),</span><br><span class="line">                <span class="built_in">imag</span>(x) + <span class="built_in">imag</span>(y)); <span class="comment">//类名称+小括号创建临时对象</span></span><br><span class="line">&#125;<span class="comment">//复数+复数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x) + y,</span><br><span class="line">                 <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;<span class="comment">//复数+实数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span> + (<span class="type">const</span> complex&amp; x, <span class="type">const</span> complex&amp; y)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">complex</span>(x + <span class="built_in">real</span>(y),</span><br><span class="line">                <span class="built_in">imag</span>(y));</span><br><span class="line">&#125;<span class="comment">//实数+复数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span> &lt;&lt; (ostream&amp; os, <span class="type">const</span> complex &amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; <span class="built_in">real</span>(x) &lt;&lt; <span class="built_in">imag</span>(x) &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道优先队列习题</title>
      <link href="/2018/02/13/%E4%B8%80%E9%81%93%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B9%A0%E9%A2%98/"/>
      <url>/2018/02/13/%E4%B8%80%E9%81%93%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B9%A0%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>hdu1873 看病要排队 优先队列<br><span id="more"></span></p><h3 id="一、hdu1873-看病要排队-优先队列"><a href="#一、hdu1873-看病要排队-优先队列" class="headerlink" title="一、hdu1873 看病要排队 优先队列"></a>一、hdu1873 看病要排队 优先队列</h3><p><strong>题目描述</strong><br>看病要排队这个是地球人都知道的常识。<br>不过经过细心的0068的观察，他发现了医院里排队还是有讲究的。0068所去的医院有三个医生（汗，这么少）同时看病。而看病的人病情有轻重，所以不能根据简单的先来先服务的原则。所以医院对每种病情规定了10种不同的优先级。级别为10的优先权最高，级别为1的优先权最低。医生在看病时，则会在他的队伍里面选择一个优先权最高的人进行诊治。如果遇到两个优先权一样的病人的话，则选择最早来排队的病人。<br>现在就请你帮助医院模拟这个看病过程。<br><strong>输入</strong><br>输入数据包含多组测试，请处理到文件结束。<br>每组数据第一行有一个正整数N(0<N<2000)表示发生事件的数目。 1 2 3 7 接下来有n行分别表示发生的事件。 一共有两种事件： 1:"in a b",表示有一个拥有优先级b的病人要求医生a诊治。(0<a<="3,0<B<=10)" 2:"out a",表示医生a进行了一次诊治，诊治完毕后，病人出院。(0<a<="3)" **输出** 对于每个"out a"事件，请在一行里面输出被诊治人的编号id。如果该事件时无病人需要诊治，则输出"empty"。 诊治人的编号id的定义为：在一组测试中，"in b"事件发生第k次时，进来的病人id即为k。从1开始编号。 **示例** 输入： in out 输出： empty 代码： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> node &amp; a)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x != a.x)</span><br><span class="line">            <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> y &gt; a.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; doctors[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> n, doc, pri;</span><br><span class="line">    string ss;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; ss;</span><br><span class="line">            <span class="keyword">if</span>(ss[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; doc &gt;&gt; pri;</span><br><span class="line">                s.x = pri;</span><br><span class="line">                s.y = t++;</span><br><span class="line">                doctors[doc].<span class="built_in">push</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss[<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; doc;</span><br><span class="line">                <span class="keyword">if</span>(!doctors[doc].<span class="built_in">empty</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; doctors[doc].<span class="built_in">top</span>().y &lt;&lt; endl;</span><br><span class="line">                    doctors[doc].<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;EMPTY&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></N<2000)表示发生事件的数目。></p>]]></content>
      
      
      <categories>
          
          <category> 水题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之stack, queue以及priority_queue</title>
      <link href="/2018/02/13/STL%E4%B9%8Bstack,%20queue%E4%BB%A5%E5%8F%8Apriority%20queue/"/>
      <url>/2018/02/13/STL%E4%B9%8Bstack,%20queue%E4%BB%A5%E5%8F%8Apriority%20queue/</url>
      
        <content type="html"><![CDATA[<p>栈、队列、优先队列基本总结<br><span id="more"></span></p><h3 id="一、stack"><a href="#一、stack" class="headerlink" title="一、stack"></a>一、stack</h3><ol><li>要使用stack，必须要包含头文件&lt; stack &gt;</li><li>实际上stack只是很单纯地把各项操作转化为内部容器的对应调用，可以使用任何序列式容器来支持stack，只要它们支持back(), push_back(), pop_back()等动作就行。例如你可以使用vector或list来容纳元素：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt; <span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt;st;</span><br></pre></td></tr></table></figure>&lt;/div&gt;<div align="center"><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/stack%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3.png" width="70%" height="70%"></div></li></ol><p>stack内部存放元素所用的实际容器，缺省采用deque。之所以采用deque，而非vector，是因为deque移除元素时会释放内存。</p><ol><li>stack核心接口：</li></ol><ul><li>push()：将一个元素置入stack内</li><li>top():返回栈顶元素，但是并不移除它</li><li>pop():从stack移除元素，但是并不将它返回</li><li>empty():检查底层容器是否为空，当栈为空时返回true</li><li>size():返回容纳的元素数</li></ul><p><em>如果stack内没有元素，则执行top()和pop()会导致未定义的行为，可以采用成员函数size()和empty()来检验容器是否为空</em></p><ol><li>stack简单实例:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line">    cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    st.<span class="built_in">top</span>() = <span class="number">77</span>;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; st.<span class="built_in">top</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出: <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">77</span></span><br></pre></td></tr></table></figure>更多了解stack:<br><a href="http://zh.cppreference.com/w/cpp/container/stack">stack- C++ Reference</a><h3 id="二、queue"><a href="#二、queue" class="headerlink" title="二、queue"></a>二、queue</h3></li><li>要使用queue，必须包含头文件&lt; queue &gt;</li><li><p>实际上queue只是很单纯地把各项操作转化为内部容器的对应调用，可以使用任何序列式容器来支持stack，只要它们支持front(), back(), push_back(), pop_front()等动作就行。例如你可以使用vector或list来容纳元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt; std::string, std::list&lt;std::string&gt; &gt; buffer;</span><br></pre></td></tr></table></figure><p>&lt;/div&gt;</p><div align="center"><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/queue%E5%86%85%E9%83%A8%E6%8E%A5%E5%8F%A3.png" width="80%" height="80%"></div></li><li><p>queue核心接口:</p></li></ol><ul><li>push():入队，将一个元素置入队列末端中</li><li>front():返回第一个被置入的元素，但并不移除</li><li>back():返回最后一个元素，但并不移除</li><li>pop():出队，移除队列中第一个元素，但并不返回</li><li>empty():判断队列是否为空，队列为空时，返回true</li><li>size():返回容纳的元素数</li></ul><p><em>如果queue之内没有元素，则front(), back(), pop()的执行行为会导致未定义行为。</em></p><ol><li>queue简单实例:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   queue&lt;string&gt; q;</span><br><span class="line"></span><br><span class="line">   q.<span class="built_in">push</span>(<span class="string">&quot;These &quot;</span>);</span><br><span class="line">   q.<span class="built_in">push</span>(<span class="string">&quot;are &quot;</span>);</span><br><span class="line">   q.<span class="built_in">push</span>(<span class="string">&quot;more than&quot;</span>);</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line">   cout &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">   q.<span class="built_in">push</span>(<span class="string">&quot;four &quot;</span>);</span><br><span class="line">   q.<span class="built_in">push</span>(<span class="string">&quot;words!&quot;</span>);</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; q.<span class="built_in">front</span>();</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line">   cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">   q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;number pf elements in the queue: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line">These are four words!</span><br><span class="line">number pf elements in the queue: <span class="number">0</span></span><br></pre></td></tr></table></figure>更多了解queue:<br><a href="http://zh.cppreference.com/w/cpp/container/queue">queue- C++ Reference</a><h3 id="三、priority-queue"><a href="#三、priority-queue" class="headerlink" title="三、priority_queue"></a>三、priority_queue</h3></li><li>要使用priority_queue，必须包含头文件&lt; queue &gt;</li><li>实际上priority_queue只是很单纯地把各项操作转化为内部容器的对应调用，可以使用任何序列式容器来支持priority_queue，只要它们支持随机存取迭代器和front(), push_back(), pop_front()等动作就行。由于priority_queue需要用到STL的heap算法，所以其内部容器必须支持随机存取迭代器。例如你可以使用deque来容纳元素：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::priority_queue&lt; <span class="type">float</span>, std::deque&lt;<span class="type">float</span>&gt; &gt; pbuffer;</span><br></pre></td></tr></table></figure></li></ol><ul><li>优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权顺序出队（默认为大者优先，也可以通过指定算子来指定自己的优先顺序），如果同时存在若干个数值最大的元素，无法确知究竟哪个会入选。</li><li>priority_queue模板类有三个模板参数，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）<br><em>一点要注意的是priority_queue中的三个参数，后两个可以省去，因为有默认参数，不过如果，有第三个参数的话，必定要写第二个参数。</em></li><li>定义priority_queue的示例代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">priority_queue&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q2; <span class="comment">//注意在两个尖括号之间一定要保留空格</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt;q3; <span class="comment">//定义小的先出队</span></span><br></pre></td></tr></table></figure></li><li>priority_queue与queue基本操作相同。接口有empty(), size(), top(), push(), pop()等等</li></ul><ol><li>priority_queue简单示例：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showpq</span><span class="params">(priority_queue &lt;<span class="type">int</span>&gt; gq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>&gt; g = gq;</span><br><span class="line">    <span class="keyword">while</span> (!g.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; g.<span class="built_in">top</span>();</span><br><span class="line">        g.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>&gt; gquiz;</span><br><span class="line">    gquiz.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    gquiz.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line">    gquiz.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    gquiz.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">    gquiz.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The priority queue gquiz is : &quot;</span>;</span><br><span class="line">    <span class="built_in">showpq</span>(gquiz);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ngquiz.size() : &quot;</span> &lt;&lt; gquiz.<span class="built_in">size</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ngquiz.top() : &quot;</span> &lt;&lt; gquiz.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ngquiz.pop() : &quot;</span>;</span><br><span class="line">    gquiz.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">showpq</span>(gquiz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line">The priority queue gquiz is :     <span class="number">30</span>    <span class="number">20</span>    <span class="number">10</span>    <span class="number">5</span>    <span class="number">1</span></span><br><span class="line"></span><br><span class="line">gquiz.<span class="built_in">size</span>() : <span class="number">5</span></span><br><span class="line">gquiz.<span class="built_in">top</span>() : <span class="number">30</span></span><br><span class="line">gquiz.<span class="built_in">pop</span>() :     <span class="number">20</span>    <span class="number">10</span>    <span class="number">5</span>    <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>算子：<br> 默认为使用less算子。<br> 如果要定义自己的比较算子，则必须自己重载 operator&lt; 或者自己写仿函数，<br> 优先队列试图将两个元素x 和y 代入比较运算符(对less 算子，调用x<y，对greater 算子，调用x>y)，若结果为真，则x 排在y 前面，y 将先于x 出队，反之，则将y 排在x 前面，x 将先出队。<br> 下面程序是针对结构体的，对数据的比较是通过对结构体重载operator()。（转自<a href="http://blog.csdn.net/morewindows/article/details/6976468">博客</a>）<br> 程序功能是模拟排队过程，每人有姓名和优先级，优先级相同则比较姓名，开始有5个人进入队列，然后队头2个人出队，再有3个人进入队列，最后所有人都依次出队，程序会输出离开队伍的顺序。<br> 自定义算子可参考：</y，对greater></p><p><a href="https://www.cnblogs.com/flipped/p/5691430.html">优先队列priority_queue的比较函数</a></p></li></ol><p><a href="https://blog.csdn.net/u014644714/article/details/68924863">优先级队列priority_queue之比较函数</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//by MoreWindows( http://blog.csdn.net/MoreWindows )</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> szName[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span>  priority;</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">int</span> nri, <span class="type">char</span> *pszName)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(szName, pszName);</span><br><span class="line">priority = nri;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//结构体的比较方法 改写operator()</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NodeCmp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node &amp;na, <span class="type">const</span> Node &amp;nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (na.priority != nb.priority)</span><br><span class="line"><span class="keyword">return</span> na.priority &lt;= nb.priority;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcmp</span>(na.szName, nb.szName) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintfNode</span><span class="params">(Node &amp;na)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, na.szName, na.priority);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//优先级队列默认是使用vector作容器，底层数据结构为堆。</span></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, NodeCmp&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有5个人进入队列</span></span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">5</span>, <span class="string">&quot;小谭&quot;</span>));</span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">3</span>, <span class="string">&quot;小刘&quot;</span>));</span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="string">&quot;小涛&quot;</span>));</span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">5</span>, <span class="string">&quot;小王&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//队头的2个人出队</span></span><br><span class="line"><span class="built_in">PrintfNode</span>(a.<span class="built_in">top</span>());</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">PrintfNode</span>(a.<span class="built_in">top</span>());</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;--------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再进入3个人</span></span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">2</span>, <span class="string">&quot;小白&quot;</span>));</span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">2</span>, <span class="string">&quot;小强&quot;</span>));</span><br><span class="line">a.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">3</span>, <span class="string">&quot;小新&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//所有人都依次出队</span></span><br><span class="line"><span class="keyword">while</span> (!a.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrintfNode</span>(a.<span class="built_in">top</span>());</span><br><span class="line">a.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多了解priority_queue:<br><a href="http://zh.cppreference.com/w/cpp/container/priority_queue">priority_queue- C++ Reference</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优先队列 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL之二分法四个函数及两道对应习题</title>
      <link href="/2018/02/12/STL%E4%B9%8B%E4%BA%8C%E5%88%86/"/>
      <url>/2018/02/12/STL%E4%B9%8B%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>STL四个二分搜索操作函数：lower_bound, upper_bound, binary_search, equal_range<br><span id="more"></span><br>注意：</p><ol><li>四个函数都定义在头文件<algorithm>中，要使用它们必须包含这个头文件</algorithm></li><li>这四个函数都运用了有序区间，这也是二分查找前提，可以用sort函数(需要包含<algorithm>头文件)对数组从小到大排序</algorithm></li></ol><h3 id="一、lower-bound-函数"><a href="#一、lower-bound-函数" class="headerlink" title="一、lower_bound()函数"></a>一、lower_bound()函数</h3><p><em>lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置。函数返回的是迭代器。</em><br>函数功能简单实例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len 12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> arr[len]=&#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">51</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">lower_bound</span>(arr, arr, len)- arr;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为函数返回的是元素位置，默认是指针位置，所以要减去第一个位置，即arr(&amp;arr[0]</span></span><br><span class="line"><span class="comment">    才能得出一个整数，这是指针的减法</span></span><br><span class="line"><span class="comment">    auto k = lower_bound(arr, arr + len,  21);  k=0x7ffc399f1ce4(在不同电脑上该值会不同)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cout &lt;&lt; k; <span class="comment">//输出5</span></span><br><span class="line">    <span class="comment">//把val换成11时，程序结果是0</span></span><br><span class="line">    <span class="comment">//把val换成12时，程序结果是0</span></span><br><span class="line">    <span class="comment">//把val换成52时，程序结果是12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<br>lower_bound()在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置，且last的位置是越界的<br><strong>lower_bound()源码以及补充:</strong><br><a href="http://zh.cppreference.com/w/cpp/algorithm/lower_bound">lower_bound - C++ Reference</a></p><h3 id="二、upper-bound-函数"><a href="#二、upper-bound-函数" class="headerlink" title="二、upper_bound()函数"></a>二、upper_bound()函数</h3><p><em>返回指向范围 [first, last) 中首个大于 value 的元素的迭代器，或若找不到这种元素则返回 last 。函数返回的是迭代器。</em><br>函数功能简单实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len 12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> val = <span class="number">21</span>;</span><br><span class="line">  <span class="type">int</span> arr[len]=&#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">51</span>&#125;;</span><br><span class="line">  <span class="type">int</span> k = <span class="built_in">lower_bound</span>(arr, arr + len, <span class="number">21</span>)- arr;</span><br><span class="line">    cout &lt;&lt; k; <span class="comment">//输出5</span></span><br><span class="line">    <span class="comment">//把val换成11时，程序结果是0</span></span><br><span class="line">    <span class="comment">//把val换成12时，程序结果是1</span></span><br><span class="line">    <span class="comment">//把val换成52时，程序结果是12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意：<br>upper_bound()若找不到这种元素则返回 last，此时last的位置的越界的<br><strong>upper_bound()源码以及补充:</strong><br><a href="http://zh.cppreference.com/w/cpp/algorithm/upper_bound">upper_bound - C++ Reference</a></p><h3 id="三、binary-search-函数"><a href="#三、binary-search-函数" class="headerlink" title="三、binary_search()函数"></a>三、binary_search()函数</h3><p><em>检查等价于 value 的元素是否出现于范围 [first, last) 中。</em><br>函数模版:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">binary_search</span> <span class="params">(T arr[ ],  <span class="type">int</span> size,  T target)</span> </span>;</span><br><span class="line">T: 模版参数</span><br><span class="line">arr:  数组首地址</span><br><span class="line">size: 数组元素个数</span><br><span class="line">T target: 需要查找的值</span><br><span class="line">若找到等于 value 的元素则为 <span class="literal">true</span> ，否则为 <span class="literal">false</span> 。</span><br></pre></td></tr></table></figure><br>函数功能简单实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len 12</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> val = <span class="number">51</span>;</span><br><span class="line">  <span class="type">int</span> arr[len]=&#123;<span class="number">12</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">51</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span>( <span class="built_in">binary_search</span>(arr, arr + len, val) )</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; exits in arr&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; does not exist&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出：<span class="number">51</span> exits in arr</span><br></pre></td></tr></table></figure><br>注意：<br>binary_search试图在已排序的[first,last)中寻找元素value，若存在就返回true，若不存在则返回false。返回单纯的布尔值也许不能满足需求，而lower_bound、upper_bound能提供额外的信息。事实上由源码可知binary_search便是利用lower_bound求出元素应该出现的位置，然后再比较该位置的值与value的值。<br><strong>binary_search()源码以及补充:</strong><br><a href="http://zh.cppreference.com/w/cpp/algorithm/binary_search">binary_search() - C++ Reference</a></p><h3 id="四、equal-range-函数"><a href="#四、equal-range-函数" class="headerlink" title="四、equal_range()函数"></a>四、equal_range()函数</h3><p><em>qual_range是C++ STL中的一种二分查找的算法，试图在已排序的[first,last)中寻找value，它返回一对迭代器i和j，其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound），因此，[i,j)内的每个元素都等同于value，而且[i,j)是[first,last)之中符合此一性质的最大子区间</em><br>函数功能简单实例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">100</span>,</span><br><span class="line">                      <span class="number">300</span>, <span class="number">300</span>&#125;;</span><br><span class="line"></span><br><span class="line">    pair&lt;std::vector&lt;<span class="type">int</span>&gt;::iterator,</span><br><span class="line">              std::vector&lt;<span class="type">int</span>&gt;::iterator&gt; ip;</span><br><span class="line"></span><br><span class="line">    ip = <span class="built_in">equal_range</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">12</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;30 is present in the sorted vector from index &quot;</span></span><br><span class="line">         &lt;&lt; (ip.first - v.<span class="built_in">begin</span>()) &lt;&lt; <span class="string">&quot; till &quot;</span></span><br><span class="line">         &lt;&lt; (ip.second - v.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：<span class="number">30</span> is present in the sorted vector from index <span class="number">3</span> till <span class="number">6</span></span><br></pre></td></tr></table></figure><br>注意：</p><ol><li>就是30连续出现的区间是[3,6]（注意容器得是有序的）。</li><li>std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::pair定义于头文件&lt;utility&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T1</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&gt; <span class="keyword">struct</span> <span class="title class_">pair</span>;</span><br></pre></td></tr></table></figure>那么，equal_range()有什么用呢？如果我们想同时使用std :: lower_bound和std :: upper_bound，可以使用这个函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    pair&lt;vector&lt;<span class="type">int</span>&gt;::iterator,</span><br><span class="line">              vector&lt;<span class="type">int</span>&gt;::iterator&gt; ip;</span><br><span class="line"></span><br><span class="line">    ip = <span class="built_in">equal_range</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ip.first - v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ip.second - v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator i1, i2;</span><br><span class="line"></span><br><span class="line">    i1 = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; i1 - v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    i2 = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; i2 - v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">程序输出：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>尾言：<br>关联式容器(set, multiset, map, multimap)分别提供了等效的成员函数，性能更佳<h3 id="五、两道习题："><a href="#五、两道习题：" class="headerlink" title="五、两道习题："></a>五、两道习题：</h3></li><li><h5 id="猜数字游戏"><a href="#猜数字游戏" class="headerlink" title="猜数字游戏"></a>猜数字游戏</h5><strong>题目描述</strong></li></ol><p>有一个由n个数字组成的数列a，且后一个数字严格大于前一个(a[i+1]&gt;a[i])<br>小溜进行Q次猜数，每次他都猜一个x，若这个x在数列里面，小溜的得分加上这个分数的大小，被猜中的数不会从数列消失。<br>如：数列1 2 3 4 5 6，小溜猜5次，分别是1 1 3 5 7 那小溜的得分为1+1+3+5=10<br>现在请你计算出小溜的得分。</p><p><strong>输入</strong></p><p>第一行输入一个T（0 &lt; T &lt;= 100)<br>接下来T组测试数据<br>每组第一行两个数n，q(1 &lt;= n, q &lt;= 1000000)<br>接下来一行n个数a1，a2…an(1 &lt;= a[i] &lt;= 10^9)<br>再接下来一行q个数b1，b2…bq(1 &lt;= b[i] &lt;= 10^9)表示猜的数字</p><p><strong>输出</strong></p><p>输出总分</p><p><strong>例如：</strong></p><p>输入：<br>1<br>6 5<br>1 2 3 4 5 6<br>1 1 3 5 7<br>输出：<br>10</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">1000005</span>;</span><br><span class="line"><span class="type">int</span> p[len], q[len];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> t, n, m;</span><br><span class="line">  ll sum = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="built_in">sizeof</span>(q));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line">    <span class="keyword">for</span>(ll j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[j]);</span><br><span class="line">      <span class="keyword">if</span>(q[j] == p[<span class="built_in">upper_bound</span>(p<span class="number">+1</span>, p+n<span class="number">+1</span>, q[j]) - (p + <span class="number">1</span>)])</span><br><span class="line">      sum+=q[j];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><h5 id="询问"><a href="#询问" class="headerlink" title="询问"></a>询问</h5><strong>题目描述</strong></li></ol><p>每次给出一个整数x，共给出m个，需要找出每个整数在数列c中出现的次数。</p><p><strong>输入</strong></p><p>第一行两个整数n，m。n表示数列c长度，m表示共给出m个数(1 &lt;= n, m &lt;= 100000)<br>第二行为n个空格隔开的整数ci，c表示数列。(-10^9 &lt;= ci &lt;= 10^9)<br>第三行到m+2行，每行一个整数x，表示给出的整数x。（-10^9 &lt;= x &lt;= 10^9)</p><p><strong>输出</strong></p><p>共m行，每行一个整数y，表示整数x在数列c里面出现的次数</p><p><strong>例如:</strong></p><p>输入：<br>5 3<br>9 6 3 3 2<br>1<br>3<br>9<br>输出：<br>0<br>2<br>1</p><p>代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, a[<span class="number">100005</span>], q;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">      <span class="built_in">sort</span>(a<span class="number">+1</span>, a+n<span class="number">+1</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">upper_bound</span>(a<span class="number">+1</span>, a+n<span class="number">+1</span>, q) - <span class="built_in">lower_bound</span>(a<span class="number">+1</span>, a+n<span class="number">+1</span>, q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++构造函数另一种初始值写法</title>
      <link href="/2018/02/07/c++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%A0%87%E5%87%86%E5%8C%96%E5%88%9D%E5%A7%8B%E5%80%BC%E5%86%99%E6%B3%95/"/>
      <url>/2018/02/07/c++%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%A0%87%E5%87%86%E5%8C%96%E5%88%9D%E5%A7%8B%E5%80%BC%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>很多人可能没有注意到，都写成第一种办法的样子，如果有人问我第一种办法可以吗？当然可以，但是效率比较差一些，不够“大气”。<br><span id="more"></span><br>(c++构造函数的概念以及作用本文不简述，具体的概念及作用可以自行百度，请谅解)<br>先放出一段类的定义:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//需要重点讨论的构造函数</span></span><br><span class="line">  <span class="built_in">complex</span> (<span class="type">double</span>  r= <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">  &#123; re = r; im = i; &#125;</span><br><span class="line">  complex&amp; <span class="keyword">operator</span> += (<span class="type">const</span> <span class="keyword">compl</span>&amp;);</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span> <span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">  <span class="keyword">friend</span> complex&amp; _doapl (complex*, <span class="type">const</span> complex&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后我们重点在以下的构造函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> (<span class="type">double</span>  r= <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">&#123; re = r; im = i; &#125;</span><br></pre></td></tr></table></figure><br>  可以看出该构造函数初始化了re和im的值，这是一种初始化办法，然后我们还有另一种比较“大气”的办法：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span> (<span class="type">double</span>  r= <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>)</span><br><span class="line">: <span class="built_in">re</span> (r), <span class="built_in">im</span> (i) <span class="comment">//初始化列，冒号后面的就是初始化列表</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><br>两者办法实现的效果都一样的，都是用r初始化re，用i初始化im，但是两者有什么区别呢？</p><ol><li>第二种办法利用了构造函数很特别的语法（只有构造函数才有），就是第二行初始化re，im值的办法</li><li>第二种办法效率更高<br>因为对于一个对象，其数值的设定有两个阶段：一个是初始化，一个是后面的赋值操作，而初始化列表就是在初始阶段。第二种办法在初始化列已经完成了两种操作，虽然第一种办法在大括号里面也完成了这两种操作，但是结果相同过程不同，第二种办法快一点。</li></ol><p>那么两者该如何选择呢？下面引用侯捷老师（STL源码剖析作者）的话：</p><blockquote><p>很多人可能没有注意到，都写成第一种办法的样子，如果有人问我第一种办法可以吗？当然可以，但是效率比较差一些，不够“大气”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++类 </tag>
            
            <tag> 构造函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>交换字符串</title>
      <link href="/2018/01/28/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2018/01/28/%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串S[0…N-1]，要求把S的前K个字符移动到S的尾部，三种办法。<br><span id="more"></span></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串S[0…N-1]，要求把S的前K个字符移动到S的尾部<br>如把”<strong>abcdef</strong>“其前面的2个字符”<strong>ab</strong>“移动到字符串的尾部，得新字符串”<strong>cdefab</strong>“，即字符串循环左移K。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. 循环左移K位等价于循环右移N-K位(可以自己举个例子理解，比如K=2，N=5)</span><br><span class="line">2. 时间复杂度要求为0(n),空间复杂度位0(l)</span><br></pre></td></tr></table></figure></p><h2 id="办法："><a href="#办法：" class="headerlink" title="办法："></a>办法：</h2><ol><li><h4 id="暴力法："><a href="#暴力法：" class="headerlink" title="暴力法："></a>暴力法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每次循环左移1位，调用K次即可</span><br><span class="line">- 时间复杂度:O(KN),空间复杂度0(l)</span><br></pre></td></tr></table></figure></li><li><h4 id="拷贝法："><a href="#拷贝法：" class="headerlink" title="拷贝法："></a>拷贝法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S[0...K]-&gt;T[0...K]</span><br><span class="line">S[K+1...N-1]-&gt;S[0...N-K-1]</span><br><span class="line">T[0...K]-&gt;S[N-K...N-1]</span><br><span class="line">- 时间复杂度0(N),空间复杂度0(K)</span><br></pre></td></tr></table></figure><p>可以看出，上面两种办法都没有办法同时符合条件，下面给出一种比较灵性的解法。</p><ol><li><h4 id="倒转法："><a href="#倒转法：" class="headerlink" title="倒转法："></a>倒转法：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 原理：（X‘Y’）‘=YX</span><br><span class="line"> 举个栗子:</span><br><span class="line"> 字符串:abcdef</span><br><span class="line"> X=ab  X&#x27;=ba</span><br><span class="line"> Y=cdef  Y&#x27;=fedc</span><br><span class="line">（X‘Y’）‘=(bafedc)&#x27;=cdefab</span><br><span class="line">- 时间复杂度:0(N),空间复杂度0(l)</span><br></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4>前面那两个代码就不贴出来，主要贴第三个办法的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串反转函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> t;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)</span><br><span class="line">        &#123;</span><br><span class="line">        t=s[start];</span><br><span class="line">        s[start++]=s[end];</span><br><span class="line">        s[end--]=t;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将字符串前面两位移到末尾</span></span><br><span class="line">        <span class="type">char</span> arr[]=<span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(arr,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(arr,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(arr,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        cout &lt;&lt; arr;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
