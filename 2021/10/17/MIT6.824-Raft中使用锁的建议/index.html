<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.824-Raft中使用锁的建议 | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Raft Locking Advicehttp://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt If you are wondering how to use locks in the 6.824 Raft labs, here..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.824-Raft中使用锁的建议",
  "url": "https://greenhathg.github.io/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/",
  "image": "https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2021-10-17T14:56:43.000Z",
  "dateModified": "2025-06-14T19:19:50.989Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.824-Raft中使用锁的建议',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">MIT6.824-Raft中使用锁的建议</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.824-Raft中使用锁的建议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-17T14:56:43.000Z" title="发表于 2021-10-17 14:56:43">2021-10-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-14T19:19:50.989Z" title="更新于 2025-06-14 19:19:50">2025-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-14 19:19:50&quot;}" hidden></div><h1 id="Raft-Locking-Advice"><a href="#Raft-Locking-Advice" class="headerlink" title="Raft Locking Advice"></a>Raft Locking Advice</h1><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt">http://nil.csail.mit.edu/6.824/2020/labs/raft-locking.txt</a></p>
<p>If you are wondering how to use locks in the 6.824 Raft labs, here are some rules and ways of thinking that might be helpful.</p>
<p>如果您想知道如何在6.824 Raft labs中使用锁，以下是一些可能会有所帮助的规则和思考方法。</p>
<h1 id="规则1：go-race"><a href="#规则1：go-race" class="headerlink" title="规则1：go race"></a>规则1：go race</h1><p>Rule 1: Whenever you have data that more than one goroutine uses, and at least one goroutine might modify the data, the goroutines should use locks to prevent simultaneous use of the data. The Go race detector is pretty good at detecting violations of this rule (though it won’t help with any of the rules below).</p>
<p>规则1：当您有多个goroutine使用的数据，并且至少有一个goroutine可能会修改数据时，goroutine应该使用锁来防止同时使用数据。<code>Go race</code>检测器非常擅长检测违反此规则的情况（尽管它对下面的任何规则都没有帮助）。</p>
<h1 id="规则2：锁住整个代码sequence"><a href="#规则2：锁住整个代码sequence" class="headerlink" title="规则2：锁住整个代码sequence"></a>规则2：锁住整个代码sequence</h1><p>Rule 2: Whenever code makes a sequence of modifications to shared data, and other goroutines might malfunction if they looked at the data midway through the sequence, you should use a lock around the whole sequence.</p>
<p>规则2：每当代码对共享数据进行一系列修改时，如果其他goroutine查看sequence中间的某个数据，则可能会出现故障，您应该对整个sequence使用锁。</p>
<p>An example:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line">rf.currentTerm += <span class="number">1</span></span><br><span class="line">rf.state = Candidate</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>It would be a mistake for another goroutine to see either of these updates alone (i.e. the old state with the new term, or the new term with the old state). So we need to hold the lock continuously over the whole sequence of updates. All other code that uses rf.currentTerm or rf.state must also hold the lock, in order to ensure exclusive access for all uses.</p>
<p>如果另一个goroutine单独看到这些更新中的任何一个（即旧的state和新的term，或者新的term和旧的state），这将是一个错误。所有其他使用rf.currentTerm或rf.state的代码也必须持有该锁，以确保所有使用的独占性。</p>
<p>The code between Lock() and Unlock() is often called a “critical section.”The locking rules a programmer chooses (e.g.“a goroutine must hold rf.mu when using rf.currentTerm or rf.state”) are often called a “locking protocol”.</p>
<p><code>Lock()</code>和<code>unlock()</code>之间的代码通常被称为“临界区”。程序员选择的锁定规则（例如，当使用rf.currentTerm或rf.state时，goroutine必须持有<code>rf.mu</code>）通常被称为”锁定协议”。</p>
<h1 id="规则3：同规则2"><a href="#规则3：同规则2" class="headerlink" title="规则3：同规则2"></a>规则3：同规则2</h1><p>Rule 3: Whenever code does a sequence of reads of shared data (or reads and writes), and would malfunction if another goroutine modified the data midway through the sequence, you should use a lock around the whole sequence.</p>
<p>规则3：每当代码执行一系列共享数据读取（或读写）时，如果另一个goroutine在该sequence中途修改数据了，则会出现故障，您应该在整个sequence使用锁。</p>
<p>An example that could occur in a Raft RPC handler:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">	 rf.currentTerm = args.Term</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>This code needs to hold the lock continuously for the whole sequence. Raft requires that currentTerm only increases, and never decreases. Another RPC handler could be executing in a separate goroutine; if it were allowed to modify rf.currentTerm between the if statement and the update to rf.currentTerm, this code might end up decreasing rf.currentTerm. Hence the lock must be held continuously over the whole sequence. In addition, every other use of currentTerm must hold the lock, to ensure that no other goroutine modifies currentTerm during our critical section.</p>
<p>此代码需要在整个sequence中连续持有锁。Raft要求currentTerm只增不减。另一个RPC处理程序可以在单独的goroutine中执行；如果允许它在if语句和rf.currentTerm更新之间修改rf.currentTerm，则此代码最终可能会减少rf.currentTerm。因此，必须在整个sequence中连续持有锁。此外，currentTerm的每一次其他使用都必须持有锁，以确保在我们的临界区期间没有其他goroutine修改currentTerm。</p>
<p>Real Raft code would need to use longer critical sections than these examples; for example, a Raft RPC handler should probably hold the lock for the entire handler.</p>
<p>真正的Raft代码需要使用比这些示例更长的临界区；例如，Raft RPC处理程序可能应该持有整个处理程序的锁。</p>
<h1 id="规则4：并发情况下锁释放前后值可能会发生变化"><a href="#规则4：并发情况下锁释放前后值可能会发生变化" class="headerlink" title="规则4：并发情况下锁释放前后值可能会发生变化"></a>规则4：并发情况下锁释放前后值可能会发生变化</h1><p>Rule 4: It’s usually a bad idea to hold a lock while doing anything that might wait: reading a Go channel, sending on a channel, waiting for a timer, calling time.Sleep(), or sending an RPC (and waiting for the reply). One reason is that you probably want other goroutines to make progress during the wait. Another reason is deadlock avoidance. Imagine two peers sending each other RPCs while holding locks; both RPC handlers need the receiving peer’s lock; neither RPC handler can ever complete because it needs the lock held by the waiting RPC call.</p>
<p>规则4：在执行任何可能等待的操作时保持锁定通常不是一个好主意：读取channel、发送channel、等待timer、调用time.sleep()或发送RPC(并等待回复)。其中一个原因是，可能希望其他goroutine在等待期间能够继续执行代码。另一个原因是避免死锁。设想两个peer在持有锁的同时相互发送RPC；两个RPC处理程序都需要接收peer的锁；两个RPC处理程序都无法完成，因为它需要等待的RPC调用持有的锁。</p>
<p>Code that waits should first release locks. If that’s not convenient, sometimes it’s useful to create a separate goroutine to do the wait.</p>
<p>等待的代码应该首先释放锁。如果这不方便，有时创建一个单独的goroutine来执行等待是很有用的。</p>
<p>Rule 5: Be careful about assumptions across a drop and re-acquire of a lock. One place this can arise is when avoiding waiting with locks held. For example, this code to send vote RPCs is incorrect:</p>
<p>对于锁的释放和重新获取的假设（if语句）要小心，可能出现这种情况的一个地方是避免持有锁的等待。例如，发送投票RPC的代码是错误的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rf.mu.Lock()</span><br><span class="line">rf.currentTerm += <span class="number">1</span></span><br><span class="line">rf.state = Candidate</span><br><span class="line"><span class="keyword">for</span> &lt;each peer&gt; &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    args.Term = rf.currentTerm</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">    Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)</span><br><span class="line">    <span class="comment">// handle the reply...</span></span><br><span class="line">  &#125; ()</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br></pre></td></tr></table></figure>
<p>The code sends each RPC in a separate goroutine. It’s incorrect because args.Term may not be the same as the rf.currentTerm at which the surrounding code decided to become a Candidate. Lots of time may pass between when the surrounding code creates the goroutine and when the goroutine reads rf.currentTerm; for example, multiple terms may come and go, and the peer may no longer be a candidate. One way to fix this is for the created goroutine to use a copy of rf.currentTerm made while the outer code holds the lock. Similarly, reply-handling code after the Call() must re-check all relevant assumptions after re-acquiring the lock; for example, it should check that rf.currentTerm hasn’t changed since the decision to become a candidate.</p>
<p>该代码在一个单独的goroutine中发送每个RPC。这是不正确的，因为args.Term可能与周围代码决定成为候选者的rf.currentTerm不一样。从周围的代码创建goroutine到goroutine读取rf.currentTerm之间可能会经过很多时间；例如，多个term可能来来去去去，该peer可能不再是候选人。解决这个问题的一个方法是，创建的goroutine使用在外层代码持有锁的时候创建的rf.currentTerm的副本。类似地，Call()后的应答处理代码必须在重新获取锁后重新检查所有相关假设；例如，它应该检查rf.currentTerm在决定成为候选人之后没有改变。</p>
<h1 id="如何正确加锁"><a href="#如何正确加锁" class="headerlink" title="如何正确加锁"></a>如何正确加锁</h1><p>It can be difficult to interpret and apply these rules. Perhaps most puzzling is the notion in Rules 2 and 3 of code sequences that shouldn’t be interleaved with other goroutines’ reads or writes. How can one recognize such sequences? How should one decide where a sequence ought to start and end?</p>
<p>解释和应用这些规则可能会很困难。也许最令人困惑的是规则2和规则3中的代码sequence的概念，这些代码序列不应该与其他 goroutine 的读或写交错。人们如何识别这样的sequence？我们应该如何决定一个sequence应该从哪里开始和结束？</p>
<p>One approach is to start with code that has no locks, and think carefully about where one needs to add locks to attain correctness. This approach can be difficult since it requires reasoning about the correctness of concurrent code.</p>
<p>一种方法是从没有锁的代码开始，仔细考虑需要在何处添加锁以实现正确性。 这种方法可能很困难，因为它需要对并发代码的正确性进行推理。</p>
<p>A more pragmatic approach starts with the observation that if there were no concurrency (no simultaneously executing goroutines), you would not need locks at all. But you have concurrency forced on you when the RPC system creates goroutines to execute RPC handlers, and because you need to send RPCs in separate goroutines to avoid waiting. You can effectively eliminate this concurrency by identifying all places where goroutines start (RPC handlers, background goroutines you create in Make(), &amp;c), acquiring the lock at the very start of each goroutine, and only releasing the lock when that goroutine has completely finished and returns. This locking protocol ensures that nothing significant ever executes in parallel; </p>
<p>一种更实用的方法首先观察到，如果没有并发(没有同时执行goroutines)，则根本不需要锁。但是，当RPC系统创建goroutine来执行RPC处理程序时，您就会遇到并发问题，因为您需要在单独的goroutine中发送RPC以避免等待。您可以通过确定goroutine开始的所有地方（RPC处理程序，在Make()或者其他地方中创建的后台goroutine），在每个goroutine的最开始获取锁，并仅在该goroutine完全完成并返回时释放锁，从而有效地消除这种并发性。此锁定协议确保不会并行执行任何重要任务；</p>
<p>the locks ensure that each goroutine executes to completion before any other goroutine is allowed to start. With no parallel execution, it’s hard to violate Rules 1, 2, 3, or 5. If each goroutine’s code is correct in isolation (when executed alone, with no concurrent goroutines), it’s likely to still be correct when you use locks to suppress concurrency. So you can avoid explicit reasoning about correctness, or explicitly identifying critical sections.</p>
<p>锁确保每个 goroutine 在允许启动任何其他 goroutine 之前执行完成。由于没有并行执行，很难违反规则1、2、3或5。如果每个goroutine的代码在单独执行时是正确的(单独执行时，没有并发的goroutine)，那么当您使用锁来抑制并发性时，它很可能仍然是正确的。因此，您可以避免对正确性进行显式推理，或显式识别关键部分。</p>
<p>However, Rule 4 is likely to be a problem. So the next step is to find places where the code waits, and to add lock releases and re-acquires (and/or goroutine creation) as needed, being careful to re-establish assumptions after each re-acquire. You may find this process easier to get right than directly identifying sequences that must be locked for correctness.</p>
<p>然而，规则4可能是个问题。因此，下一步是找到代码等待的位置，并根据需要添加锁释放和重新获取(和/或goroutine创建)，在每次重新获取之后小心地重新建立假设。您可能会发现，与直接识别必须锁定以确保正确性的sequence相比，此过程更容易正确。</p>
<p>(As an aside, what this approach sacrifices is any opportunity for better performance via parallel execution on multiple cores: your code is likely to hold locks when it doesn’t need to, and may thus unnecessarily prohibit parallel execution of goroutines. On the other hand, there is not much opportunity for CPU parallelism within a single Raft peer.) </p>
<p>（顺便说一句，这种方法所牺牲的是通过在多个内核上并行执行来获得更好性能的任何机会：你的代码可能会在不需要的时候持有锁，因此可能会不必要地禁止goroutine的并行执行。另一方面，在单个Raft peer中，也没有太多的机会实现CPU并行化。)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/">https://greenhathg.github.io/2021/10/17/MIT6.824-Raft%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%94%81%E7%9A%84%E5%BB%BA%E8%AE%AE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mit6-824/">mit6.824</a><a class="post-meta__tags" href="/tags/raft/">raft</a><a class="post-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/11/09/%E9%80%80%E4%BC%91%E8%AE%A1%E5%88%92p1-%E4%B8%BA%E4%BD%95%E8%AE%B2%E8%B5%B7%E8%B4%A2%E4%BA%A7%E8%87%AA%E7%94%B1/" title="退休计划p1-为何讲起财产自由"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">退休计划p1-为何讲起财产自由</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2021/10/16/%E5%8D%B3%E4%BD%BF%E7%9D%A1%E4%BA%867.5%E4%B8%AA%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%8D%E7%84%B6%E6%84%9F%E8%A7%89%E4%B8%8D%E5%88%B0%E7%B2%BE%E5%8A%9B%E5%85%85%E6%B2%9B/" title="即使睡了7.5个小时，我仍然感觉不到精力充沛"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">即使睡了7.5个小时，我仍然感觉不到精力充沛</div></div><div class="info-2"><div class="info-item-1">翻译自《I Wasn’t Feeling Refreshed Even After 7.5 Hours of Sleep. Here’s How I Fixed It | by Samir S. | In Fitness And In Health | Medium》   https://medium.com/in-fitness-and-in-health/i-wasnt-feeling-refreshed-even-after-7-5-hours-of-sleep-here-s-how-i-fixed-it-f785a51fec15  Getting enough sleep is perhaps one of the most important things we can do for our health and body. Sleep is a chance for the body to repair itself and to reenergize. 充足的睡眠可能是我们能为我们的健康和身体做的最重要的事情之一。睡眠是身体自我修复和重新获得能量的机会。 Ever...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/03/30/MIT6.824-Raft-index%E5%90%AB%E4%B9%89/" title="MIT6.824-Raft-index含义"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-Raft-index含义</div></div><div class="info-2"><div class="info-item-1">nextIndex 官方描述：for each server, index of the next log entry  to send to that server (initialized to leader last log index + 1) leader保存该数组变量，由leader更新。 nextIndex[i]代表着对第i个follower发起Append Entries RPC时尝试replicated log的位置，仅仅是猜测并不是真实的，并且出现log inconsistency会将该值回退。所以nextIndex[i]需要比matchIndex[i]要大。 leader收到Append Entries RPC回复后只有是因为log inconsistency才能更新nextIndex。 更新nextIndex的三个时机 leader election成功时候，需要更新nextIndex为leader last log index + 1 AppendEntries RPC返回success，代表已经成功replicated log log...</div></div></div></a><a class="pagination-related" href="/2020/11/17/MIT6.824-GFS/" title="MIT6.824-GFS"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-GFS</div></div><div class="info-2"><div class="info-item-1">为什么我们要阅读这篇论文?在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的interface/semantics 应该怎么定义，它是怎么并行工作的等。 GFS paper涉及到了很多分布式系统主题：parallel performance, fault tolerance, replication, consistency 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。 为什么分布式存储这么难? high performance→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据 many servers→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复 fault tolerance →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用 replication →有数据不一致的风险 better consistency...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/" title="MIT6.824-LEC10-Cloud Replicated-DB-Aurora"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC10-Cloud Replicated-DB-Aurora</div></div><div class="info-2"><div class="info-item-1">为什么要学习Aurora 作为近几年成功的云服务，解决了严重的问题 设计良好，有性能的优势 使用general-purpose storage架构情况下的局限性 许多关于云基础架构中重要的内容  Amazon EC2，cloud computing，针对于web  租用直接运行在Amazon数据中心物理机器上的virtual machines instances 使用的存储是连接在物理磁盘上的virtual local disk 客户在EC2上面运行着stateless www server或者DB 但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）  Amazon EBS (Elastic Block Store)  使用的是Chain Replication，基于paxos的configuration manager 如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume EBS不是shared...</div></div></div></a><a class="pagination-related" href="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/" title="MIT6.824-LEC11-Cache-Consistency-Frangipani"><img class="cover" src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC11-Cache-Consistency-Frangipani</div></div><div class="info-2"><div class="info-item-1">为什么要阅读这篇论文 cache coherence distributed transactions distributed crash recovery 三者的相互作用  整体的设计 a network file system，与现有的应用程序共同工作，类似普通的unix程序。可以将petal想象成一个磁盘，通过网络将数据共享给Frangipani，看起来就像从普通磁盘上读取数据  预期用途 一个文件系统，能保存自己的home目录以及共享的项目文件，在任何的workstation（可以理解是个人PC）能拿到自己的home目录以及所需要的所有文件。 没有涉及到安全问题，彼此电脑之间互相信任，适用于小群体  Frangipani的设计 强一致性 caching in each workstation — write-back 所有对文件的更新最初只是在workstation cache中完成—速度快 包括创建文件、目录、重命名等 比如ws1(workstation user...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC8-Zookeeper/" title="MIT6.824-LEC8-Zookeeper"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC8-Zookeeper</div></div><div class="info-2"><div class="info-item-1">Zookeeper提出了什么问题 能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？ 我们有N个replica server，能从这个N个server中获得N倍性能吗？  将Zookeer视为基于Raft的service只不过ZooKeeper使用的是zab协议，为ZooKeeper专门设计的一种支持崩溃恢复的一致性协议 当我们添加更多的server时候，replication arrangement是否变得更快replica越多，写入的速度就越慢leader必须将每次写入发送给越来越多的server 可以让follower提供只读服务，这样leader压力就小很多可能会产生log与leader不一致的情况，导致client读取的数据不对，甚至是产生“倒退现象”，client先从up-to-date replica读，再从logging...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/" title="MIT6.824-LEC9-More-Replication-CRAQ"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC9-More-Replication-CRAQ</div></div><div class="info-2"><div class="info-item-1">为什么学习CRAQ Chain Replication(CR)，一种与Raft非常不一样的方法。 CRAQ能够从replica读取数据并且保持强一致性  什么是CR write：   client发送写请求给head server 请求按顺序沿着链下发 每个server用新数据覆盖旧数据 当tail server处理完成后回复给client   read：   client发送读请求给tail server tail server回复给client（不涉及其他server）   为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。 如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。 如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。 不能处理network partition或者spilt...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">198</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Raft-Locking-Advice"><span class="toc-number">1.</span> <span class="toc-text">Raft Locking Advice</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%991%EF%BC%9Ago-race"><span class="toc-number">2.</span> <span class="toc-text">规则1：go race</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%992%EF%BC%9A%E9%94%81%E4%BD%8F%E6%95%B4%E4%B8%AA%E4%BB%A3%E7%A0%81sequence"><span class="toc-number">3.</span> <span class="toc-text">规则2：锁住整个代码sequence</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%993%EF%BC%9A%E5%90%8C%E8%A7%84%E5%88%992"><span class="toc-number">4.</span> <span class="toc-text">规则3：同规则2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%84%E5%88%994%EF%BC%9A%E5%B9%B6%E5%8F%91%E6%83%85%E5%86%B5%E4%B8%8B%E9%94%81%E9%87%8A%E6%94%BE%E5%89%8D%E5%90%8E%E5%80%BC%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">规则4：并发情况下锁释放前后值可能会发生变化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%8A%A0%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">如何正确加锁</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14-19-19-38/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14 19:19"><img src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-14 19:19"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14-19-19-38/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14 19:19">[Xueqiu_Forever] 发言时段总结 - 2025-06-14 19:19</a><time datetime="2025-06-14T19:19:38.000Z" title="发表于 2025-06-14 19:19:38">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14">[Xueqiu_Forever] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T09:16:50.000Z" title="发表于 2025-06-14 09:16:50">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14">[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:15:28.000Z" title="发表于 2025-06-14 08:15:28">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded"><img src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project2-BPlusTree-Delete-Single-threaded"/></a><div class="content"><a class="title" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded">CMU445-Project2-BPlusTree-Delete-Single-threaded</a><time datetime="2024-01-05T12:39:43.000Z" title="发表于 2024-01-05 12:39:43">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玩客云换魔百盒"/></a><div class="content"><a class="title" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒">玩客云换魔百盒</a><time datetime="2023-12-31T12:44:43.000Z" title="发表于 2023-12-31 12:44:43">2023-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>