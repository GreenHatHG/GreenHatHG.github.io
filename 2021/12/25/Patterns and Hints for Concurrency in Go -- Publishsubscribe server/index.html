<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Patterns and Hints for Concurrency in Go -- Publishsubscribe server | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="PubSub interface A classic publish subscribe server operates in three ways: subscribe、publish、cancel. 123456789101112type PubSub interface..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Patterns and Hints for Concurrency in Go -- Publishsubscribe server",
  "url": "https://greenhathg.github.io/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/",
  "image": "https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2021-12-25T18:35:43.000Z",
  "dateModified": "2025-06-14T08:15:38.731Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Patterns and Hints for Concurrency in Go -- Publishsubscribe server',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">236</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">Patterns and Hints for Concurrency in Go -- Publishsubscribe server</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Patterns and Hints for Concurrency in Go -- Publishsubscribe server</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-25T18:35:43.000Z" title="发表于 2021-12-25 18:35:43">2021-12-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-14T08:15:38.731Z" title="更新于 2025-06-14 08:15:38">2025-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-14 08:15:38&quot;}" hidden></div><h1 id="PubSub-interface"><a href="#PubSub-interface" class="headerlink" title="PubSub interface"></a>PubSub interface</h1><ul>
<li><p>A classic publish subscribe server operates in three ways: subscribe、publish、cancel.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PubSub <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// publishes the event e to all current subscriptions.</span></span><br><span class="line">	Publish (e Event)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// registers c to receive future events.</span></span><br><span class="line">	<span class="comment">// if Publish(e1) happens before Publish(e2),</span></span><br><span class="line">	<span class="comment">// subscribers receive e1 before e2.</span></span><br><span class="line">	Subscribe (c <span class="keyword">chan</span>&lt;- Event)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cancels the prior subscription of channel c.</span></span><br><span class="line">	Cancel(c <span class="keyword">chan</span>&lt;- Event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>A simple implementation is as follows：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.Mutex</span><br><span class="line">  	<span class="comment">// key of map represents the channel </span></span><br><span class="line">  	<span class="comment">// used to receive the event.</span></span><br><span class="line">	sub <span class="keyword">map</span>[<span class="keyword">chan</span> &lt;- Event]<span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Init()&#123;</span><br><span class="line">	s.sub = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;-Event]<span class="type">bool</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Publish(e Event)&#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> c := <span class="keyword">range</span> s.sub&#123;</span><br><span class="line">		c &lt;- e</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Subscribe(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.sub[c]&#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;pubsub: already subscribed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	s.sub[c] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Cancel(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !s.sub[c]&#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;pubsub: not subscribed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	<span class="built_in">delete</span>(s.sub, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hint: Prefer defer for unlocking mutexes</p>
</li>
</ul>
<h1 id="One-slow-subscriber-can-slow-down-everyone"><a href="#One-slow-subscriber-can-slow-down-everyone" class="headerlink" title="One slow subscriber can slow down everyone"></a>One slow subscriber can slow down everyone</h1><ul>
<li>If one subscriber falls behind, the next subscriber doesn’t get the event until that slow subscriber wakes up. So <strong>one slow subscriber can slow down everyone.</strong><ul>
<li><strong>One way is to use  channel buffer.</strong><br>As long as they’re not too far behind When you’re publishing. The new event always go into the channel buffer and then the actual publish won’t block for too long.</li>
<li>There’s a better way to deal with arbitrarily slow subscribers in a really big program.</li>
</ul>
</li>
</ul>
<h1 id="Options-for-slow-goroutines"><a href="#Options-for-slow-goroutines" class="headerlink" title="Options for slow goroutines"></a>Options for slow goroutines</h1><ul>
<li><p><strong>Slow down event generation</strong><br>Publish stops until the subscribers catch up.</p>
</li>
<li><p><strong>Coalesce or drop events</strong></p>
<ul>
<li>The subscriber might find out that it missed some events. No one knows what they were because didn’t save them but at least subscriber can see how many events are missing and maybe can do something try to catch up.</li>
<li>Profiler:<ul>
<li>There’s a separate goroutine that fills the profile on a signal handler. Whose job is to read the data back out and write it to disk or send it to a http request or whatever it is you’re doing with profile data.</li>
<li>There’s a buffer in the middle and if the receiver from the profile data falls behind when the buffer fills up we start adding entries to a final profile by call runtime.lost function.</li>
<li>if you go look at the profile you see the program spent five percent of its time in lost profile data. we’re clear about exactly the error rate is in the profile.</li>
</ul>
</li>
<li>OS signal package:<ul>
<li>You have to pass in a channel that will be ready to receive the signal like SIGHUP or SIGQUIT.</li>
<li>When the signal comes in the run time tries to send to each of the channels and if it can’t send to it, it’s just gone.</li>
<li>The callers have to do is they have to pass in a buffered channel which length at least one and they only register that channel to a single signal.</li>
<li>If a signal comes in you’re definitely going to get told about it if it comes in twice you might only get told about it once. That’s actually the same semantics that unix gives to processes for signals.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Save all the events that slow subscriber hasn’t seen</strong></p>
<ul>
<li>There’s always slow computers that have fallen offline or whatever and they might be gone for a while.</li>
<li>In general you want to think very carefully before you do that and think well you know how unbounded is it really and can I tolerate.</li>
</ul>
</li>
</ul>
<h1 id="Implement-the-third-option"><a href="#Implement-the-third-option" class="headerlink" title="Implement the third option"></a>Implement the third option</h1><ul>
<li><p>start a new goroutine handles requests three channels:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">	publish   <span class="keyword">chan</span> Event</span><br><span class="line">	subscribe <span class="keyword">chan</span> subReq</span><br><span class="line">	cancel    <span class="keyword">chan</span> subReq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> subReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	c <span class="keyword">chan</span>&lt;- Event</span><br><span class="line">	ok <span class="keyword">chan</span> <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Init()&#123;</span><br><span class="line">	s.publish = <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line">	s.subscribe = <span class="built_in">make</span>(<span class="keyword">chan</span> subReq)</span><br><span class="line">	s.cancel = <span class="built_in">make</span>(<span class="keyword">chan</span> subReq)</span><br><span class="line">	<span class="keyword">go</span> s.loop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Can’t ever have a publish and subscribe  happening at the same time because it’s just single threaded code.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> loop()&#123;</span><br><span class="line">	sub := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;- Event]<span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-s.publish:</span><br><span class="line">			<span class="keyword">for</span> c := <span class="keyword">range</span> sub &#123;</span><br><span class="line">				c &lt;- e</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> req := &lt;-s.subscribe:</span><br><span class="line">			<span class="keyword">if</span> sub[req.c] &#123;</span><br><span class="line">				req.ok &lt;- <span class="literal">false</span></span><br><span class="line">				<span class="comment">// only break select</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			sub[req.c] = <span class="literal">true</span></span><br><span class="line">			req.ok &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> req := &lt;-s.cancel:</span><br><span class="line">			<span class="keyword">if</span> !sub[req.c] &#123;</span><br><span class="line">				req.ok &lt;- <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(req.c)</span><br><span class="line">			<span class="built_in">delete</span>(sub, req.c)</span><br><span class="line">			req.ok &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Publish(e Event)&#123;</span><br><span class="line">	s.publish &lt;- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Subscribe(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">	req := subReq&#123;</span><br><span class="line">		c:  c,</span><br><span class="line">		ok: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	s.subscribe &lt;- req</span><br><span class="line">	<span class="keyword">if</span> ! &lt;- req.ok&#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;pubsub: already subscribed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span>Cancel(c <span class="keyword">chan</span>&lt;- Event)&#123;</span><br><span class="line">	req := subReq&#123;</span><br><span class="line">		c:  c,</span><br><span class="line">		ok: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	s.cancel &lt;- req</span><br><span class="line">	<span class="keyword">if</span> ! &lt;- req.ok&#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;pubsub: not subscribed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Convert mutexes into goroutines when it makes programs clearer. But implement raft probably prefer the state with the mutex is because raft is so different from most concurrent programs and that like each replica is just kind of profoundly uncertain of its state.</p>
</li>
<li><p>Deal with the slow subscribers, keep the overall program from blocking. Main loop goroutine will send the events to the helper.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> q []Event</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-in:</span><br><span class="line">			q = <span class="built_in">append</span>(q, e)</span><br><span class="line">		<span class="keyword">case</span> out &lt;- q[<span class="number">0</span>]:</span><br><span class="line">			q = q[:<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Improvement: if queue is empty send to empty channel<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> q []Event</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="comment">// Decide whether and what to send.</span></span><br><span class="line">		<span class="keyword">var</span> sendOut <span class="keyword">chan</span>&lt;- Event</span><br><span class="line">		<span class="keyword">var</span> next Event</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line">			sendOut = out</span><br><span class="line">			next = q[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-in:</span><br><span class="line">			q = <span class="built_in">append</span>(q, e)</span><br><span class="line">		<span class="keyword">case</span> sendOut &lt;- next:</span><br><span class="line">			q = q[:<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Improvement: the input channel closes and queue is finally empty we can exit<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helper</span><span class="params">(in &lt;-<span class="keyword">chan</span> Event, out <span class="keyword">chan</span>&lt;- Event)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> q []Event</span><br><span class="line">	<span class="keyword">for</span> in != <span class="literal">nil</span> || <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line">		<span class="comment">// Decide whether and what to send.</span></span><br><span class="line">		<span class="keyword">var</span> sendOut <span class="keyword">chan</span>&lt;- Event</span><br><span class="line">		<span class="keyword">var</span> next Event</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(q) &gt; <span class="number">0</span>&#123;</span><br><span class="line">			sendOut = out</span><br><span class="line">			next = q[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e, ok := &lt;-in:</span><br><span class="line">			<span class="keyword">if</span> !ok&#123;</span><br><span class="line">				in = <span class="literal">nil</span> <span class="comment">// stop receiving from in</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			q = <span class="built_in">append</span>(q, e)</span><br><span class="line">			fmt.Println(<span class="string">&quot;in&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> sendOut &lt;- next:</span><br><span class="line">			q = q[:<span class="number">1</span>]</span><br><span class="line">			fmt.Printf(<span class="string">&quot;out&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Every time we get a new subscription we make a helper channel. If you wanted to have a different strategy for clients that fall too far behind that can modify the code in the helper.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> loop()&#123;</span><br><span class="line">	<span class="comment">//map from subscribe channel to helper in channel</span></span><br><span class="line">	sub := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">chan</span>&lt;- Event]<span class="keyword">chan</span>&lt;- Event)</span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> e := &lt;-s.publish:</span><br><span class="line">			<span class="keyword">for</span> _, helperIn := <span class="keyword">range</span> sub &#123;</span><br><span class="line">				helperIn &lt;- e</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> req := &lt;-s.subscribe:</span><br><span class="line">			<span class="keyword">if</span> sub[req.c] != <span class="literal">nil</span> &#123;</span><br><span class="line">				req.ok &lt;- <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			helperIn := <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line">			<span class="keyword">go</span> helper(helperIn, req.c)</span><br><span class="line">			sub[req.c] = helperIn</span><br><span class="line">			req.ok &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> req := &lt;-s.cancel:</span><br><span class="line">			<span class="keyword">if</span> sub[req.c] != <span class="literal">nil</span>&#123;</span><br><span class="line">				req.ok &lt;- <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(sub[req.c])</span><br><span class="line">			<span class="built_in">delete</span>(sub, req.c)</span><br><span class="line">			req.ok &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Hint: you can use goroutines a lot of the time to separate independent concerns.</p>
</li>
</ul>
<h1 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h1><ul>
<li><p>在上文Russ Cox的代码中，Subscribe的参数使用的是单向channel，但是在实际中subscribe后还应该把值拿出来处理，所以参数改为双向channel就好了。<br>（对于<code>chan&lt;-</code> 和<code>&lt;-chan</code>的提示：因为上面对于订阅者（subscription）来讲，并不需要拿出值消费，所以传一个<code>chan&lt;- Event</code>去让server发送消息给它，因为这个channel只能用来发送，以达到发送的目的）</p>
<blockquote>
<p>The optional <code>&lt;-</code> operator specifies the channel <em>direction</em>, <em>send</em> or <em>receive</em>. If no direction is given, the channel is <em>bidirectional</em>.</p>
<p><code>chan&lt;- float64 // can only be used to send float64s</code><br><code>&lt;-chan int // can only be used to receive ints</code></p>
</blockquote>
</li>
<li><p>下面的代码创建了10个subscription后接着publish 100个event，每个subscription拿到event后会sleep一下再打印出来，模拟不同的消费速度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetFlags(log.LstdFlags | log.Lmicroseconds)</span><br><span class="line">	pubsub := Server&#123;&#125;</span><br><span class="line">	pubsub.Init()</span><br><span class="line"></span><br><span class="line">	subscriptionCount := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;create a lot of subscription channel&quot;</span>)</span><br><span class="line">	subscriptionChannels := <span class="built_in">make</span>([]<span class="keyword">chan</span> Event, subscriptionCount, subscriptionCount)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> subscriptionChannels &#123;</span><br><span class="line">		subscriptionChannels[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> Event)</span><br><span class="line">		pubsub.Subscribe(subscriptionChannels[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	consumer := <span class="function"><span class="keyword">func</span><span class="params">(subscriptionIndex <span class="type">int</span>, c <span class="keyword">chan</span> Event)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> event := <span class="keyword">range</span> c&#123;</span><br><span class="line">			generator := rand.New(rand.NewSource(time.Now().UnixNano() + <span class="type">int64</span>(subscriptionIndex*<span class="number">1000</span>)))</span><br><span class="line">			max, min := <span class="number">15.0</span>, <span class="number">2.0</span> <span class="comment">// random 2~15</span></span><br><span class="line">			n := min + generator.Float64() * (max - min)</span><br><span class="line"></span><br><span class="line">			time.Sleep(time.Duration(n)*time.Second)</span><br><span class="line">			log.Println(<span class="string">&quot;consumer&quot;</span>, subscriptionIndex, <span class="string">&quot;time.sleep&quot;</span>, n, <span class="string">&quot;receive&quot;</span>, event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	log.Println(<span class="string">&quot;start receive from subscription channel handler&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> subscriptionChannels&#123;</span><br><span class="line">		<span class="keyword">go</span> consumer(i, subscriptionChannels[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log.Println(<span class="string">&quot;publish Event to all subscription&quot;</span>)</span><br><span class="line">	publish := <span class="function"><span class="keyword">func</span><span class="params">(publishCount <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; publishCount; i++&#123;</span><br><span class="line">			event := Event(fmt.Sprintf(<span class="string">&quot;test-%d&quot;</span>, i))</span><br><span class="line">			log.Println(<span class="string">&quot;publish&quot;</span>, event)</span><br><span class="line">			pubsub.Publish(event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> publish(subscriptionCount*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1</span>*time.Hour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序的一个简单流程如下：</p>
<ul>
<li>subscribe 10个 subscription channel并启动10个接收Event的goroutine</li>
<li>启动publish goroutine，设置同时publish 100个event</li>
<li>s.loop()处理publish，将event传递给每个subscription的helper</li>
<li>此时消费速度慢于生产速度，但是不会拖延publish进度，因为publish进来的会存到event slice里面再消费</li>
<li>接收event的channel接收到打印数值</li>
</ul>
</li>
<li>所以Russ Cox其实是用channel进行解耦，并使用slice当作缓存解决消费慢的问题。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/">https://greenhathg.github.io/2021/12/25/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Publishsubscribe%20server/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/golang/">golang</a><a class="post-meta__tags" href="/tags/publish-subscribe/">publish-subscribe</a><a class="post-meta__tags" href="/tags/concurrency/">concurrency</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/12/27/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Work%20scheduler/" title="Patterns and Hints for Concurrency in Go -- Work scheduler"><img class="cover" src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Patterns and Hints for Concurrency in Go -- Work scheduler</div></div><div class="info-2"><div class="info-item-1">use channel as synchronized queue Scheduling n machines to execute m tasks, and each task may be different 12func Schedule(servers []string, numTask int,               call func(srv string, task int))  We can use a channel install of stack or queue, because it’s a good synchronized queue. 123456789101112131415func Schedule(servers []string, numTask int, call func(srv string, task int))&#123;    idle := make(chan string, len(servers))    for _, srv := range servers&#123;        idle &lt;- srv...</div></div></div></a><a class="pagination-related" href="/2021/12/12/logseq%E6%90%AD%E9%85%8D%E7%AE%80%E6%82%A6%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93/" title="logseq搭配简悦建立自己的知识库"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">logseq搭配简悦建立自己的知识库</div></div><div class="info-2"><div class="info-item-1">实现效果 网页标注，自动离线到本地（网页内容+标注），logseq 里面建立双链，同时还可以自动跳转到本地文件具体内容处 这样的话可以实现一个工作流：  第一阶段：网页内容标注 第二阶段：logseq整理建立联系 第三阶段：Notion知识整合输出（或者是在logseq里面输出也行，可以用很多相关联的双链直接输出一篇文章，而不用反复复制粘贴） 本地知识库：在第一阶段标注的时候，会自动保存网页内容+标注到本地，个人认为会带来几个好处： 避免内容失效404 搜索相关知识点时候可以先在本地笔记或者缓存目录搜索先，这样相当于是先查找自己的笔记，对知识利用率更高，Windows下可以用FileLocator、Mac可以用DEVONthink 对于一些英文文章的学习，可以先双语翻译，然后做笔记保存，下次查看时候有双语翻译和笔记，效率提高很多 网络上文章都是抄来抄去，复制粘贴，对于某些知识点其实完全可以通过双链引用形成一篇文章，内容可以来自官网、著名书籍pdf等，这样就不会学到很多假知识    实现参考文章： 当简悦变成你的知识库（离线且具有永久链接） · Discussion #2221...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2021/12/30/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Replicated%20service%20client/" title="Patterns and Hints for Concurrency in Go -- Replicated service client"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">Patterns and Hints for Concurrency in Go -- Replicated service client</div></div><div class="info-2"><div class="info-item-1">ReplicatedClient ReplicatedClient interface 12345678910111213type ReplicatedClient interface &#123;    // Init initializes the client to use the given servers.    // To make a particular request later,    // the client can use callOne(srv, args),    // where srv is one of the servers from the list.    Init(servers []string, callOne func(string, Args) Reply)    // Call makes a request an available server.    // Multiple goroutines may call Call concurrently.    // Find an available server and...</div></div></div></a><a class="pagination-related" href="/2021/12/27/Patterns%20and%20Hints%20for%20Concurrency%20in%20Go%20--%20Work%20scheduler/" title="Patterns and Hints for Concurrency in Go -- Work scheduler"><img class="cover" src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">Patterns and Hints for Concurrency in Go -- Work scheduler</div></div><div class="info-2"><div class="info-item-1">use channel as synchronized queue Scheduling n machines to execute m tasks, and each task may be different 12func Schedule(servers []string, numTask int,               call func(srv string, task int))  We can use a channel install of stack or queue, because it’s a good synchronized queue. 123456789101112131415func Schedule(servers []string, numTask int, call func(srv string, task int))&#123;    idle := make(chan string, len(servers))    for _, srv := range servers&#123;        idle &lt;- srv...</div></div></div></a><a class="pagination-related" href="/2020/09/30/Golang-range%E4%B8%AD%E7%9A%84%E5%9D%91/" title="Golang-range中的坑"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">Golang-range中的坑</div></div><div class="info-2"><div class="info-item-1">range遍历指针类型时注意事项  1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main()  &#123;	arr := []int&#123;1,2,3,4,5,6,7,8&#125;	odd := make([]int, 0, 5)	for _, v := range arr&#123;		if v % 2 == 1&#123;			odd = append(odd, v)		&#125;	&#125;	for _, v := range odd&#123;		fmt.Println(v)	&#125;&#125;/*output:1357*/ 1234567891011121314151617181920212223242526package mainimport &quot;fmt&quot;func main()  &#123;	arr := []int&#123;1,2,3,4,5,6,7,8&#125;	**odd :=...</div></div></div></a><a class="pagination-related" href="/2020/09/14/Golang%E7%94%9F%E6%88%90%E5%8D%81%E4%BA%BF%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E7%9A%84%E6%8E%A2%E7%A9%B6/" title="Golang生成十亿手机号码的探究"><img class="cover" src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">Golang生成十亿手机号码的探究</div></div><div class="info-2"><div class="info-item-1">优化大量生成手机号码所使用的时间，取得较好的成果  配置既然是计算时间，那么肯定受电脑配置影响，这里贴下配置 win10  随机字符串生成前景以下省略计算时间的代码 12345678910func main()  &#123;	before := time.Now()	fmt.Println(before.Format(&quot;2006-01-02 15:04:05&quot;))	//...	after := time.Now()	fmt.Println(after.Format(&quot;2006-01-02 15:04:05&quot;))	fmt.Println(after.Sub(before))&#125; 单纯跑十亿次循环12345678idx := 0for i := 0; i &lt; 1000000000; i++&#123;    idx++&#125;//2020-09-14 15:01:22//2020-09-14 15:01:22//232.3817ms 十亿次随机获取手机号码1234567891011121314151617181920var...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">196</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">236</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PubSub-interface"><span class="toc-number">1.</span> <span class="toc-text">PubSub interface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#One-slow-subscriber-can-slow-down-everyone"><span class="toc-number">2.</span> <span class="toc-text">One slow subscriber can slow down everyone</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Options-for-slow-goroutines"><span class="toc-number">3.</span> <span class="toc-text">Options for slow goroutines</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Implement-the-third-option"><span class="toc-number">4.</span> <span class="toc-text">Implement the third option</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">运行示例</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14">[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:15:28.000Z" title="发表于 2025-06-14 08:15:28">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project2-BPlusTree-Delete-Single-threaded"/></a><div class="content"><a class="title" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded">CMU445-Project2-BPlusTree-Delete-Single-threaded</a><time datetime="2024-01-05T12:39:43.000Z" title="发表于 2024-01-05 12:39:43">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒"><img src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玩客云换魔百盒"/></a><div class="content"><a class="title" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒">玩客云换魔百盒</a><time datetime="2023-12-31T12:44:43.000Z" title="发表于 2023-12-31 12:44:43">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BPlusTree-Insert-Single-threaded"/></a><div class="content"><a class="title" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded">CMU445-Project1-BPlusTree-Insert-Single-threaded</a><time datetime="2023-12-12T22:59:43.000Z" title="发表于 2023-12-12 22:59:43">2023-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/" title="CMU445-Project1-BufferPoolManagerInstance总结"><img src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BufferPoolManagerInstance总结"/></a><div class="content"><a class="title" href="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/" title="CMU445-Project1-BufferPoolManagerInstance总结">CMU445-Project1-BufferPoolManagerInstance总结</a><time datetime="2023-07-01T09:23:43.000Z" title="发表于 2023-07-01 09:23:43">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>