<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>DP | GreenHatHGのBlog</title><meta name="keywords" content="dp,数位dp,最长上升公共子序列,最长递增子序列,最长公共子序列,最长公共子串,区间dp,最大序列和,二维dp"><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="动态规划">
<meta property="og:type" content="article">
<meta property="og:title" content="DP">
<meta property="og:url" content="https://greenhathg.github.io/2018/08/02/DP/index.html">
<meta property="og:site_name" content="GreenHatHGのBlog">
<meta property="og:description" content="动态规划">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80">
<meta property="article:published_time" content="2018-08-02T22:52:59.000Z">
<meta property="article:modified_time" content="2024-01-18T11:13:11.705Z">
<meta property="article:author" content="GreenHatHg">
<meta property="article:tag" content="dp">
<meta property="article:tag" content="数位dp">
<meta property="article:tag" content="最长上升公共子序列">
<meta property="article:tag" content="最长递增子序列">
<meta property="article:tag" content="最长公共子序列">
<meta property="article:tag" content="最长公共子串">
<meta property="article:tag" content="区间dp">
<meta property="article:tag" content="最大序列和">
<meta property="article:tag" content="二维dp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80"><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2018/08/02/DP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-116672888-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"已超过","messageNext":"天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-18 11:13:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">234</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">GreenHatHGのBlog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">DP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-08-02T22:52:59.000Z" title="发表于 2018-08-02 22:52:59">2018-08-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-18T11:13:11.705Z" title="更新于 2024-01-18 11:13:11">2024-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="DP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2018/08/02/DP/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>动态规划</p>
<span id="more"></span>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>DP入门参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.sohu.com/a/153858619_466939">漫画：什么是动态规划？</a></p>
<p>进阶参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/cc_again/article/details/25866971">【DP专辑】ACM动态规划总结</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/raichen/p/5772056.html">http://www.cnblogs.com/raichen/p/5772056.html</a></p>
<p> <strong>动态规划原理</strong></p>
<p><strong>1-最优子结构</strong></p>
<p>用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。</p>
<p><strong>2-重叠子问题</strong></p>
<p>在斐波拉契数列，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。</p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/20170715205029376.png"></p>
<p><strong>3-无后效性</strong></p>
<p>将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。</p>
<h1 id="数塔系列"><a href="#数塔系列" class="headerlink" title="数塔系列"></a>数塔系列</h1><p>首先什么是“数塔类型”？从某一点转向另一点或者说是从某一状态转向另一状态，有多种选择方式（比如这里的9-&gt;12 , 9-&gt;15），从中选取一条能产生最优值的路径。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/DiaoCow/archive/2010/04/18/1714859.html">动态规划“数塔”类型题目总结</a></p>
<h2 id="经典数塔HDU-2048"><a href="#经典数塔HDU-2048" class="headerlink" title="经典数塔HDU[2048]"></a>经典数塔<a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=2084">HDU[2048]</a></h2><p>数塔问题 ：要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？</p>
<p>数塔问题的经典解法是从后面算到前面，如果从前面算到后面很麻烦，因为后面一层有很多个数字是由少到多，如果反过来由多到少就简单了</p>
<p>分析：站在位置9，我们可以选择沿12方向移动，也可以选择沿着15方向移动，现在我们假设“已经求的”沿12方向的最大值x和沿15方向的最大值y，那么站在9的最大值必然是：Max(x,y) + 9。</p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/数塔.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 13:05:10</span></span><br><span class="line"><span class="comment"> Exe.Time:171MS	 Exe.Memory：1848k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">int</span> Map[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                Map[i][j] = Map[i][j] + <span class="built_in">max</span>(Map[i + <span class="number">1</span>][j], Map[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; Map[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="HDU1176-免费馅饼"><a href="#HDU1176-免费馅饼" class="headerlink" title="HDU1176[免费馅饼]"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1176">HDU1176[免费馅饼]</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">第0秒                       5                         （这里的数字指的是第N秒可能到达的位置坐标）</span><br><span class="line"></span><br><span class="line">第1秒                     4 5 6</span><br><span class="line"></span><br><span class="line">第2秒                   3 4 5 6 7</span><br><span class="line"></span><br><span class="line">第3秒                 2 3 4 5 6 7 8</span><br><span class="line"></span><br><span class="line">第4秒               1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">第5秒             0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">第6秒             0 1 2 3 4 5 6 7 8 9 10</span><br><span class="line"></span><br><span class="line">第7秒 .................  </span><br><span class="line"></span><br><span class="line">可以发现从第5秒开始之后就都是 0 1 2 3 4 5 6 7 8 9 10 </span><br></pre></td></tr></table></figure>
<p>和“数塔”一样，它也是从某一点出发，有多个选择的问题（往前走一步，呆在原地，往后走一步）从中选择一条最优值路径（获得馅饼最多）。还是按照“数塔”的思考方式，我们可以假设“已经求得”下一个站在位置4获得的最大值x和呆在原地获得的最大值y以及站在位置6获得的最大值z,那么对于起始位置5获得最大值就是Max(x,y,z) ，因此可以得到状态转移方程为:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[t][x] += <span class="built_in">max</span>(<span class="built_in">max</span>(dp[t + <span class="number">1</span>][x - <span class="number">1</span>], dp[t + <span class="number">1</span>][x + <span class="number">1</span>]),dp[t + <span class="number">1</span>][x]);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 17:53:03	</span></span><br><span class="line"><span class="comment"> Exe.Time:265MS	 Exe.Memory：10012k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110000</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Max, t, x;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        Max = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; t;</span><br><span class="line">            <span class="keyword">if</span>(t &gt; Max) <span class="comment">//记录最大时间，时间是纵坐标，落地点是横坐标</span></span><br><span class="line">                Max = t;</span><br><span class="line">            dp[t][x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(t = Max - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[t][<span class="number">0</span>] += <span class="built_in">max</span>(dp[t+<span class="number">1</span>][<span class="number">0</span>],dp[t+<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//每行的第一个只有二种选择</span></span><br><span class="line">            <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[t][x] += <span class="built_in">max</span>( <span class="built_in">max</span>(dp[t + <span class="number">1</span>][x - <span class="number">1</span>],dp[t + <span class="number">1</span>][x]),</span><br><span class="line">                                    dp[t + <span class="number">1</span>][x + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[t][<span class="number">10</span>] += <span class="built_in">max</span>(dp[t + <span class="number">1</span>][<span class="number">9</span>], dp[t + <span class="number">1</span>][<span class="number">10</span>]); <span class="comment">//每行的最后一个只有二种选择</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[<span class="number">0</span>][<span class="number">5</span>] &lt;&lt; endl;<span class="comment">//不是dp[1][5]，刚开始吃的不一定在5，有可能在4,6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj1088-滑雪"><a href="#poj1088-滑雪" class="headerlink" title="poj1088(滑雪)"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://poj.org/problem?id=1088">poj1088(滑雪)</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">依然和“数塔”一样，从某一点出发，面临多个选择（往上，往左，往下，往右）从中选择一条最优值路径（滑雪距离最长）</span><br><span class="line">若对A点求，很显然它的最大值就为： <span class="built_in">Max</span>(上，右，下，左) + <span class="number">1</span></span><br><span class="line">因此对于任意位置[i,j], 其状态转移方程为：m[i][j] = <span class="built_in">Max</span>(m[i<span class="number">-1</span>][j] , m[i][j+<span class="number">1</span>] , m[i+<span class="number">1</span>][j] , m[i][j<span class="number">-1</span>]) + <span class="number">1</span></span><br><span class="line">由于这道题很难画出它的路径图（起点和终点都不知道）因此很难用“列表格”的方式自底向上求解。</span><br><span class="line"></span><br><span class="line">解题思路：设一与输入数组对应的状态数组 dp，其值代表输入数组中此点的最长滑雪路径。使用广搜填表，最后遍历输出最大值即可    </span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-13 23:04:42	</span></span><br><span class="line"><span class="comment"> Exe.Time:79MS	 Exe.Memory：320k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> row, col; <span class="comment">//二维数组的行与列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Map[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX]; <span class="comment">// 记录每一个点的最大滑雪长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">1</span> &amp;&amp; i &lt;= row &amp;&amp; j &lt;= col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断右边能不能走，同时要满足右边的数小</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(i, j + <span class="number">1</span>) &amp;&amp; Map[i][j] &gt; Map[i][j + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][j + <span class="number">1</span>]) <span class="comment">//如果之前走过，那就比较下是现在的线路的值还是之前的大</span></span><br><span class="line">           Max = Max &gt; dp[i][j + <span class="number">1</span>] ? Max : dp[i][j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//没有走过的话，那就需要BFS一遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i, j + <span class="number">1</span>) ? Max : <span class="built_in">BFS</span>(i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i + <span class="number">1</span>, j) &amp;&amp; Map[i][j] &gt; Map[i + <span class="number">1</span>][j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i + <span class="number">1</span>][j] ? Max : dp[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i + <span class="number">1</span>, j) ? Max : <span class="built_in">BFS</span>(i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向左广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i, j - <span class="number">1</span>) &amp;&amp; Map[i][j] &gt; Map[i][j - <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i][j - <span class="number">1</span>] ? Max : dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i, j - <span class="number">1</span>) ? Max : <span class="built_in">BFS</span>(i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上广搜</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, j) &amp;&amp; Map[i][j] &gt; Map[i - <span class="number">1</span>][j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; dp[i - <span class="number">1</span>][j] ? Max : dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Max = Max &gt; <span class="built_in">BFS</span>(i - <span class="number">1</span>, j) ? Max : <span class="built_in">BFS</span>(i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如上下左右均不通，该点路径值为 1；</span></span><br><span class="line">    <span class="comment">// 否则取最大路径值加 1</span></span><br><span class="line">    <span class="comment">//将结果记录在dp数组中(记忆化搜索的重点)</span></span><br><span class="line">    <span class="keyword">if</span> (Max == <span class="number">0</span>)</span><br><span class="line">        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dp[i][j] = <span class="number">1</span> + Max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; row &gt;&gt; col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">                cin &gt;&gt; Map[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="built_in">BFS</span>(i, j);</span><br><span class="line">                <span class="keyword">if</span>(tmp &gt; ans)</span><br><span class="line">                    ans = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><p>数位dp是一种计数用的dp，一般就是要统计一个区间内满足一些条件数的个数。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/wust_zzwh/article/details/52100392">数位dp总结 之 从入门到模板</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/av27156563?from=search&amp;seid=3730573967901251511">数位dp记录——bili</a></p>
<h2 id="HDU3555-Bomb-模板题"><a href="#HDU3555-Bomb-模板题" class="headerlink" title="HDU3555( Bomb )模板题"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=3555">HDU3555( Bomb )模板题</a></h2><p>题目大意：在[0,n]的范围内存在多少个数字含有49</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Judge Status : Accepted		Language : C++  </span></span><br><span class="line"><span class="comment">Submit Time：2018-08-07 15:54:05	</span></span><br><span class="line"><span class="comment">Exe.Time:93MS	 Exe.Memory：1796k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">20</span>]; <span class="comment">//存位数，最长20位</span></span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>]; <span class="comment">//dp[i][j]表示当前第i位，前一位的数字是否是j</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//len:第len个数位，if_num:判断某一位是否到到达约束数位, limit:上一位是否有限制</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="keyword">bool</span> if_num, <span class="keyword">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归边界，既然是按位枚举，最低位是0，那么len == 0说明这个数我枚举完了</span></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//两个约束条件,limit防止前面的dp[len][if_num]让条件为真，比如dp[1][1]时，当百位有限制，</span></span><br><span class="line">    <span class="comment">// 而dp[1][1]之前有值了，如果没有limit，就会多算了。</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num]) <span class="comment">//不用去统计49</span></span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>); <span class="comment">//up:如果到了限制那个数位，那么就限制，否则循环0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(if_num &amp;&amp; i == <span class="number">9</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i == <span class="number">4</span>, limit &amp;&amp; i == up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) <span class="comment">//如果没有约束，说明是完整计算的，那么就记忆下，下次直接就可以返回值了</span></span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="comment">//得到位数，存到k里面</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//从最高位开始枚举</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        ll num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="comment">//solve:算的是没有49的个数</span></span><br><span class="line">        cout &lt;&lt; num + <span class="number">1</span> - <span class="built_in">solve</span>(num) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="稍微修改HDU2089-不要62"><a href="#稍微修改HDU2089-不要62" class="headerlink" title="稍微修改HDU2089(不要62)"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=2089">稍微修改HDU2089(不要62)</a></h2><p>在HDU3555基础上面多了一个区间，开始的时候是给出最大值m，区间是1～m，现在是区间是n～m，那么只要solve(m) - solve(n - 1)就行了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-07 18:22:21	</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS	 Exe.Memory：1792k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">///标有改的注释是说这里相当于3555那道题变了</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="keyword">bool</span> if_num, <span class="keyword">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num]) </span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(if_num &amp;&amp; i == <span class="number">2</span>) <span class="comment">//改</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(if_num ==<span class="number">4</span> || i == <span class="number">4</span>) <span class="comment">//改</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, i == <span class="number">6</span>, limit &amp;&amp; i == up); <span class="comment">//改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) </span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) </span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(m) - <span class="built_in">solve</span>(n - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">//改</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="牛客—区间内数字含有6的个数"><a href="#牛客—区间内数字含有6的个数" class="headerlink" title="牛客—区间内数字含有6的个数"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://ac.nowcoder.com/acm/contest/329/G">牛客—区间内数字含有6的个数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Submit Time 2019-01-27 23:21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll len, <span class="keyword">bool</span> if_num, <span class="keyword">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> if_num;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; dp[len][if_num])</span><br><span class="line">        <span class="keyword">return</span> dp[len][if_num];</span><br><span class="line">    ll cnt = <span class="number">0</span>, up = (limit ? digit[len] : <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= up; i++)</span><br><span class="line">        cnt += <span class="built_in">dfs</span>(len - <span class="number">1</span>, if_num || i == <span class="number">6</span>, limit &amp;&amp;i == digit[len]);</span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">        dp[len][if_num] = cnt;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)</span><br><span class="line">    &#123;</span><br><span class="line">        digit[++k] = num % <span class="number">10</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(k, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n, m;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(m) - <span class="built_in">solve</span>(n - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LCIS—最长上升公共子序列"><a href="#LCIS—最长上升公共子序列" class="headerlink" title="LCIS—最长上升公共子序列"></a>LCIS—最长上升公共子序列</h1><p>讲解：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/wd-one/p/4470844.html">zoj2432 hdoj1423 最长公共上升子序列（LCIS）</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/WArobot/p/7479431.html">LCIS 最长公共上升子序列问题DP算法及优化</a></p>
<h2 id="模板题HDU1423-Greatest-Common-Increasing-Subsequence"><a href="#模板题HDU1423-Greatest-Common-Increasing-Subsequence" class="headerlink" title="模板题HDU1423(Greatest Common Increasing Subsequence)"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1423">模板题HDU1423(Greatest Common Increasing Subsequence)</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-09-07 21:30:12	</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS	 Exe.Memory：5712KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="keyword">int</span> s1[MAXN], s2[MAXN];</span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCIS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[MAXN][MAXN]  = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxdp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[j])</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &gt; s2[j] &amp;&amp; maxdp &lt; dp[i + <span class="number">1</span>][j])</span><br><span class="line">                maxdp = dp[i + <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = maxdp + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i + <span class="number">1</span>][j] &gt; ans)</span><br><span class="line">                ans = dp[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> test;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span>(test--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; len1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">            cin &gt;&gt; s1[i];</span><br><span class="line">        cin &gt;&gt; len2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">            cin &gt;&gt; s2[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LCIS</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(test)</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LIS—最长递增子序列"><a href="#LIS—最长递增子序列" class="headerlink" title="LIS—最长递增子序列"></a>LIS—<strong>最长递增子序列</strong></h1><p>问题描述：找出一个n个数的序列的最长单调递增子序列： 比如<code>A = &#123;5,6,7,1,2,8&#125;</code> 的LIS是<code>5,6,7,8</code></p>
<h2 id="O-n-2-的复杂度"><a href="#O-n-2-的复杂度" class="headerlink" title="O(n^2)的复杂度"></a><code>O(n^2)</code>的复杂度</h2><p><strong>最优子结构</strong></p>
<p> 假设<code>LIS[i]</code> 是以<code>arr[i]</code>为末尾的LIS序列的长度。则：</p>
<p> <code>LIS[i] = &#123;1+Max(LIS(j))&#125;</code>; <code>j&lt;i, arr[j]&lt;arr[i]</code>; </p>
<p><code>LIS[i] = 1, j&lt;i</code>, 但是不存在<code>arr[j]&lt;arr[i]</code>; </p>
<p>所以问题转化为计算<code>Max(LIS(j))</code> <code>0&lt;i&lt;n</code></p>
<p><strong>重叠的子问题</strong></p>
<p>以<code>arr[i] (1&lt;= i &lt;= n)</code>每个元素结尾的LIS序列的值是 重叠的子问题。 </p>
<p>所以填表时候就是建立一个数组<code>DP[i]</code>, 记录以<code>arr[i]</code>为序列末尾的LIS长度。</p>
<p><strong>DP[i]怎么计算？</strong></p>
<p>遍历所有<code>j&lt;i</code>的元素，检查是否<code>DP[j]+1&gt;DP[i] &amp;&amp; arr[j]&lt;arry[i]</code> 若是，则可以更新<code>DP[i]</code></p>
<p><strong>图示</strong></p>
<ul>
<li>arr[1]到arr[9]存值</li>
<li>LIS代表此元素到arr[1]的LIS</li>
<li>LIS来源代表是从哪个继承而来，值为数组下标</li>
</ul>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/LIS.png"></p>
<p><strong>HDU1257(最少拦截系统)模板题</strong></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1257">http://acm.hdu.edu.cn/showproblem.php?pid=1257</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 11:16:58	</span></span><br><span class="line"><span class="comment"> Exe.Time:62MS	 Exe.Memory：1844k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dp_len = len + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[dp_len];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp[<span class="number">0</span>]) * dp_len); <span class="comment">//创建动态数组并且初始化</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// int * dp = new int[dp_len]();</span></span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)  <span class="comment">//找出dp数组中最大的那个值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; MAX)</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000002641054">算法设计 - LCS 最长公共子序列&amp;&amp;最长公共子串 &amp;&amp;LIS 最长递增子序列</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/u011268787/article/details/78675388">【算法知识总结】最长递增子序列</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/av15439338?from=search&amp;seid=17716055664494305815">【算法设计指南】最长递增子序列(微博/微信公众号:@算法时空—bilibili)</a></p>
<h2 id="nlgn的复杂度"><a href="#nlgn的复杂度" class="headerlink" title="nlgn的复杂度"></a><code>nlgn</code>的复杂度</h2><p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/av18339080?from=search&amp;seid=11934838010834623209">HRBU ACM 01背包 LIS 拓扑 凸包—-bilibili——20:41</a></p>
<p>这个比较难讲，看视频比较好理解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 14:27:55	</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS	 Exe.Memory：1884k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *dp = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">10</span>]();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">lower_bound</span>(dp + <span class="number">1</span>, dp + ans + <span class="number">1</span>, arr[i]) - dp; </span><br><span class="line">        <span class="comment">//求最长非递减序列可以将lower_bound变为upper_bound</span></span><br><span class="line">        dp[pos] = arr[i];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图示</strong></p>
<Img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20180803145239.png">

<h2 id="LIS变形—有升有降"><a href="#LIS变形—有升有降" class="headerlink" title="LIS变形—有升有降"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://fzcoj.hustoj.com/problem.php?id=4493">LIS变形—有升有降</a></h2><p><img src="/2018/08/02/DP/timu.png" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Time:54 ms</span></span><br><span class="line"><span class="comment">    Memory:2252 kb</span></span><br><span class="line"><span class="comment">    2019-04-08 16:45:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN], dp[MAXN] = &#123;<span class="number">0</span>&#125;, rdp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;arr[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i<span class="number">-1</span>] &gt;= arr[i])</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i+<span class="number">1</span>] &gt;= arr[i])</span><br><span class="line">            rdp[i] = rdp[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rdp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span> n1, n2;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line">        <span class="keyword">if</span>(dp[n2] + rdp[n1] &gt;= n2-n1+<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大递增子数组和"><a href="#最大递增子数组和" class="headerlink" title="最大递增子数组和"></a>最大递增子数组和</h2><p>这个是由LIS O(n2)的办法变化而来的，因为O(nlgn)的那个代码的dp数组虽然保存的是一个最长递增序列，但是里面是最小的，不是最大的，所以只能由n2那个办法转变而来</p>
<p>这个动态规划可以先看前三项</p>
<ul>
<li><p>dp[1] = num[1]</p>
</li>
<li><p>num[2]如果大于num[1]</p>
<ul>
<li><p>dp[2] = dp[1] + num[2]</p>
</li>
<li><p>否则dp[2] = num[2]</p>
</li>
</ul>
</li>
<li>num[3]如果大于num[2]<ul>
<li>那么dp[3] = dp[2] + num[3]</li>
</ul>
</li>
<li>如果num[3]大于num[1]<ul>
<li>dp[3] = dp[1] + num[3]</li>
</ul>
</li>
<li>如果num[3]不大于num[2]同时也不大于num[1]<ul>
<li>dp[3] = num[3]。</li>
</ul>
</li>
</ul>
<p>说了这么多其实就是一个意思，用之前的每一个数和当前的数比较，比当前数小的就加上dp【之前数】，不然就等于当前数</p>
<p>参考:<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/yopilipala/article/details/74372746">动态规划：HDU1087-Super Jumping! Jumping! Jumping!（最大上升子序列和）</a></p>
<p><strong>HDU1087(Super Jumping! Jumping! Jumping!)模板题</strong></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1087">http://acm.hdu.edu.cn/showproblem.php?pid=1087</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-03 18:38:13</span></span><br><span class="line"><span class="comment"> Exe.Time:31MS	 Exe.Memory：1828k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LIS</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dp_len = len + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> * dp = <span class="keyword">new</span> <span class="keyword">int</span>[dp_len]();</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">int</span> MAX = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j]) <span class="comment">//之前数比当前数小，就加上当前数到之前数的和上面</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i], arr[i]);	<span class="comment">//之前数都不比当前数小的情况下直接就是当前数</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; MAX)	<span class="comment">//记录最大的那个和</span></span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] dp;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">10</span>]();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LIS</span>(arr, n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="LCS—最长公共子序列"><a href="#LCS—最长公共子序列" class="headerlink" title="LCS—最长公共子序列"></a>LCS—最长公共子序列</h1><p>找两个字符串的最长公共子串，这个子串要求在原字符串中是连续的。而最长公共子序列则并不要求连续。</p>
<p>cnblogs与belong，最长公共子序列为blog（cnblogs, belong），最长公共子串为lo（cnblogs, belong）这两个问题都是用空间换空间，创建一个二维数组来记录之前的每个状态</p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/LCS(%E4%B8%8D%E8%BF%9E%E7%BB%AD%EF%BC%89.png"></p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/lcs.png"></p>
<p>解释参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zhuiqiuzhuoyue583/article/details/79178521">LCS（最长公共子序列）注意：是可以不连续的，区别于最长公共子串</a></p>
<p><strong><a target="_blank" rel="noopener external nofollow noreferrer" href="http://poj.org/problem?id=1458">poj1458（Common Subsequence）模板题</a></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-09 11:45:50	</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS	 Exe.Memory：1036k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXDP = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXS = <span class="number">1e7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXDP][MAXDP];</span><br><span class="line"><span class="keyword">char</span> s1[MAXS], s2[MAXS];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCS</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="built_in">strlen</span>(s1) - <span class="number">1</span>;<span class="comment">//因为s1,s2是从1开始存的，所以长度要减1</span></span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(s2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt;= len1 ; i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int j = 0;j &lt;= len2; j++)</span></span><br><span class="line"><span class="comment">                cout &lt;&lt; dp[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>, s2[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 +<span class="number">1</span> &gt;&gt; s2 + <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">LCS</span>(s1, s2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="HDU1503-Advanced-Fruits-还原最长公共子序列、记录路径"><a href="#HDU1503-Advanced-Fruits-还原最长公共子序列、记录路径" class="headerlink" title="HDU1503(Advanced Fruits)还原最长公共子序列、记录路径"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1503">HDU1503(Advanced Fruits)还原最长公共子序列、记录路径</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以用pre[i][j]来记录dp[i][j]状态转移时是从哪种状态转移过来的，一共就三种：dp[i−1][j−1]+1,dp[i−1][j],dp[i][j−1]。然后从dp[len0][len1]开始往前递归，遇到从dp[i−1][j−1]+1状态转移的情况就标记，直到递归到dp[0][]或者dp[][0]结束。</span><br></pre></td></tr></table></figure>
<p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/Ramay7/article/details/52003368">https://blog.csdn.net/Ramay7/article/details/52003368</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-10 11:33:40		</span></span><br><span class="line"><span class="comment"> Exe.Time:62MS	 Exe.Memory：9620k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXDP = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXS = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXDP][MAXDP];</span><br><span class="line"><span class="keyword">char</span> s1[MAXS], s2[MAXS];</span><br><span class="line"><span class="keyword">int</span> pre[MAXDP][MAXDP]; <span class="comment">//dfs需要，记录状态</span></span><br><span class="line"><span class="keyword">int</span> vis[MAXDP];  <span class="comment">//记录第一个串中哪些位置被用掉</span></span><br><span class="line"><span class="keyword">int</span> len_s1, len_s2; <span class="comment">//s1,s2的长度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len1 == <span class="number">0</span> || len2 == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pre[len1][len2] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[len1] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(len1 - <span class="number">1</span>, len2 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pre[len1][len2] == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(len1, len2 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">dfs</span>(len1 - <span class="number">1</span>, len2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCS</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">char</span>* s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len_s1 = <span class="built_in">strlen</span>(s1) - <span class="number">1</span>;</span><br><span class="line">    len_s2 = <span class="built_in">strlen</span>(s2) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len_s1; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len_s2; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                pre[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j - <span class="number">1</span>] &gt; dp[i - <span class="number">1</span>][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    pre[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    pre[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len_s1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = st; j &lt;= len_s2; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i] == s2[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    st = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; s2[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = st; j &lt;= len_s2; ++j)</span><br><span class="line">        cout &lt;&lt; s2[j];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>, s2[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s1 +<span class="number">1</span> &gt;&gt; s2 + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">LCS</span>(s1, s2);</span><br><span class="line">        <span class="built_in">dfs</span>(len_s1, len_s2);</span><br><span class="line">        <span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj1080-Human-Gene-Functions-LCS应用"><a href="#poj1080-Human-Gene-Functions-LCS应用" class="headerlink" title="poj1080(Human Gene Functions)LCS应用"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://poj.org/problem?id=1080">poj1080(Human Gene Functions)LCS应用</a></h2><p>题意</p>
<p>给定两个基因字符串，用A，C，G，T表示其组成成分。若两个基因的长度不一样，可以通过在两个串中分别添加空格使其长度一致。当其长度一样后，分别计算对应位置上的两个字母的分数，并将所有的分数相加便得到两个串的相似度分数。求，两个基因串的最高分数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设dp(i,j)为第一个序列(s1)的前i个数和第二个序列(s2)的前j个数的相似度的最大值。当s1[i-1]==s2[j-1]时，由题目给出的表显然可以得出dp(i,j)=dp(i-1,j-1)+score[s1[i-1]][s2[j-1]];score数组为题目中给出的那个表格。当s1[i-1]!=s2[j-1]时，由普通的LCS显然有dp(i,j)=max(d(i-1,j)+score[s1[i-1]][&#x27;-&#x27;],dp(i,j-1)+score[&#x27;-&#x27;][],d(i-1,j-1)+score[s1[i-1]][s2[j-1]])。于是，两个for就解决问题了。注意初始化数组。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-29 12:43:57	</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS	 Exe.Memory：0.6MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1e3</span>;</span><br><span class="line"><span class="keyword">int</span> dp[LEN][LEN];</span><br><span class="line"><span class="keyword">int</span> score[LEN][LEN];</span><br><span class="line"><span class="keyword">char</span> c1[LEN];</span><br><span class="line"><span class="keyword">char</span> c2[LEN];</span><br><span class="line"><span class="keyword">int</span> len1, len2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=<span class="number">5</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=<span class="number">-1</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;T&#x27;</span>]=score[<span class="string">&#x27;T&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=<span class="number">-2</span>;</span><br><span class="line">    score[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;A&#x27;</span>]=score[<span class="string">&#x27;G&#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;G&#x27;</span>]=<span class="number">-3</span>;</span><br><span class="line">    score[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27; &#x27;</span>]=score[<span class="string">&#x27; &#x27;</span>][<span class="string">&#x27;C&#x27;</span>]=<span class="number">-4</span>;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i + <span class="number">1</span>] = dp[<span class="number">0</span>][i] + score[c1[i]][<span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len2; i++)</span><br><span class="line">        dp[i + <span class="number">1</span>][<span class="number">0</span>] = dp[i][<span class="number">0</span>] + score[c2[i]][<span class="string">&#x27; &#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; len1 &gt;&gt; c1;</span><br><span class="line">        cin &gt;&gt; len2 &gt;&gt; c2;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++)</span><br><span class="line">                dp[j][i] = <span class="built_in">max</span>(<span class="built_in">max</span>(dp[j - <span class="number">1</span>][i - <span class="number">1</span>] + score[c2[j - <span class="number">1</span>]][c1[i - <span class="number">1</span>]], dp[j - <span class="number">1</span>][i] + score[c2[j - <span class="number">1</span>]][<span class="string">&#x27; &#x27;</span>]),</span><br><span class="line">                               dp[j][i - <span class="number">1</span>] + score[c1[i - <span class="number">1</span>]][<span class="string">&#x27; &#x27;</span>]);</span><br><span class="line">        cout &lt;&lt; dp[len2][len1] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子串（连续）"><a href="#最长公共子串（连续）" class="headerlink" title="最长公共子串（连续）"></a>最长公共子串（连续）</h1><p>和LCS区别是区别就是因为是连续的，如果两个元素不等，那么就要=0了而不能用之前一个状态的最大元素</p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88%E8%BF%9E%E7%BB%AD%EF%BC%89.png"></p>
<h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><p>区间dp，顾名思义就是在一段区间上进行动态规划。对于每段区间，他们的最优值都是由几段更小区间的最优值得到，是分治思想的一种应用，将一个区间问题不断划分为更小的区间直至一个元素组成的区间，枚举他们的组合 ，求合并后的最优值。</p>
<h2 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>设F[i,j]（1&lt;=i&lt;=j&lt;=n）表示区间[i,j]内的数字相加的最小代价<br>每次用变量k（i&lt;=k&lt;=j-1）将区间分为[i,k]和[k+1,j]两段</p>
<p>For l:=2 to n do // 枚举区间长度<br>for i:=1 to n do // 枚举区间的左端点<br>begin<br>j:=i+l-1; // 计算区间的右端点,因为区间长度和左端点循环嵌套枚举，保证了[i,j]内的所有子区间都被枚举到<br>if j&gt;n then break; // 保证了下标不越界<br>for k:= i to j-1 do // 状态转移，去推出 f[i,j]<br>f[i , j]= max{f[ i,k]+ f[k+1,j]+ w[i,j] }<br>end;</p>
<p>作者：Steven1997<br>链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/9c6401ea2f9b">https://www.jianshu.com/p/9c6401ea2f9b</a><br>來源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [poj 1651 Multiplication Puzzle (区间dp)](http://poj.org/problem?id=1651)</span><br><span class="line"></span><br><span class="line">**题意**</span><br><span class="line"></span><br><span class="line">​```c++</span><br><span class="line">给出一个数组a，可以将其中除了头尾两个数之外的任何一个数字a[i]取出数列，需要的花费为   a[i-1] * a[i] * a[i+1]，问如果需要把这个数列除了头尾之外的数字都取完，怎样的取出顺序是花费最小的，输出这个最小花费</span><br></pre></td></tr></table></figure></p>
<p>如果贪心每次取最小的话是错的，看下面一组测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 100 1</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">首先我们可以考虑最小的一个可以操作的区间为<span class="number">3</span>个数字，是可以直接算出答案的。</span><br><span class="line">对于长度小于<span class="number">3</span>的区间，我们可以直接得到 dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">对于长度大于<span class="number">3</span>的区间，我们可以在其中找到一个中点，例如区间 i ~ j  取中点k 即分为区间  i~k 和 k+<span class="number">1</span>~j, 对于区间 i~k 我们有答案 dp[i][k]  对于区间 k+<span class="number">1</span>~j 我们有答案  dp[k+<span class="number">1</span>][j] ，而在这两个区间运算完之后 会剩下的是 a[i],a[k+<span class="number">1</span>],a[j+<span class="number">1</span>]，所以为了消除k我们会有花费 a[i] * a[k+<span class="number">1</span>] * a[j+<span class="number">1</span>]，即转移方程 ：</span><br><span class="line"></span><br><span class="line">dp[i][j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][j] + arr[i] * arr[k + <span class="number">1</span>] * arr[j + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先计算ans[i][i + <span class="number">1</span>] ( <span class="number">1</span> &lt;= i &lt; N – <span class="number">1</span> )，ans[i][i + <span class="number">2</span>] ( <span class="number">1</span> &lt;= i &lt; N – <span class="number">2</span> )，……</span><br><span class="line">即计算ans[i][i + j] ( <span class="number">1</span> &lt;= j &lt; N – <span class="number">1</span>, <span class="number">1</span> &lt;= i &lt; N – j )</span><br><span class="line"></span><br><span class="line">那么可以这样写</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++) <span class="comment">//看上面j的取值范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - j; i++) <span class="comment">//看上面i的取值范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + j] = INF; <span class="comment">//取的是最小，可以初始化为无穷大</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + j; k++) <span class="comment">//从给出的区间[i, i + j]的左边开始,一直到右边</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][i + j] + arr[i] * arr[k + <span class="number">1</span>] * arr[i + j + <span class="number">1</span>], dp[i][i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.voidcn.com/article/p-xcolbvjf-bke.html">http://www.voidcn.com/article/p-xcolbvjf-bke.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://111qqz.com/2016/07/poj-1651/">https://111qqz.com/2016/07/poj-1651/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.acmsearch.com/article/show/16953">http://www.acmsearch.com/article/show/16953</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-08-11 12:08:14</span></span><br><span class="line"><span class="comment"> Exe.Time:0MS	 Exe.Memory：624k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> arr[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n - <span class="number">1</span>; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][i + j] = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; i + j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][i + j]= <span class="built_in">min</span>(dp[i][k] + dp[k + <span class="number">1</span>][i + j] + arr[i] * arr[k + <span class="number">1</span>] * arr[i + j + <span class="number">1</span>], dp[i][i + j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n - <span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="LeetCode664-Strange-Printer-奇怪的打印机"><a href="#LeetCode664-Strange-Printer-奇怪的打印机" class="headerlink" title="LeetCode664 Strange Printer 奇怪的打印机"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/grandyang/p/8319913.html">LeetCode664 Strange Printer 奇怪的打印机</a></h2><p>题解：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/grandyang/p/8319913.html">http://www.cnblogs.com/grandyang/p/8319913.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/av22290452/?p=30&amp;t=878">刷题找工作—-leetcode 664 —bili</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strangePrinter</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) </span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = (i == j) ? <span class="number">1</span> : (<span class="number">1</span> + dp[i + <span class="number">1</span>][j]); <span class="comment">//取的min，可以先考虑最坏情况</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= j; ++k) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[k] == s[i]) dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][k - <span class="number">1</span>] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (n == <span class="number">0</span>) ? <span class="number">0</span> : dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Leetcode-813-Largest-Sum-of-Averages"><a href="#Leetcode-813-Largest-Sum-of-Averages" class="headerlink" title="Leetcode 813. Largest Sum of Averages"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode.com/problems/largest-sum-of-averages/description/">Leetcode 813. Largest Sum of Averages</a></h2><p>题解：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/magicbean2/article/details/79893634">https://blog.csdn.net/magicbean2/article/details/79893634</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.bilibili.com/video/av22290452/?p=45">刷题找工作—-leetcode 813 —bili</a></p>
<p><img src="https://raw.githubusercontent.com/GreenHatHG/blog_image/master/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180812161908.png"></p>
<p><strong>递推版本</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 4 ms</span></span><br><span class="line"><span class="comment">Submitted: 下午5:16,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        m_ = vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt;(K + <span class="number">1</span>, vector&lt;<span class="keyword">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>)); <span class="comment">//下标从1开始，初始化为0，代表没有求解过</span></span><br><span class="line">        sums_ = vector&lt;<span class="keyword">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>); <span class="comment">//前i个元素的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            sums_[i] = sums_[i - <span class="number">1</span>] + A[i - <span class="number">1</span>]; <span class="comment">//suns_[i]存的是前i个元素和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LSA</span>(A, n, K); <span class="comment">//在A中有n个元素分为k组</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; m_;</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; sums_;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">LSA</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_[k][n] &gt; <span class="number">0</span>) <span class="comment">//记忆化，求解过的话就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> m_[k][n];</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> sums_[n] / n; <span class="comment">//递归结束</span></span><br><span class="line">        <span class="comment">//i是分割点，将前n个元素分为两半，一个是1～i，另一个是i+1～n</span></span><br><span class="line">        <span class="comment">//递归求解i个元素分成k-1组能取的最大值</span></span><br><span class="line">        <span class="comment">//因为是k-1组，所以得至少有k-1个元素，i从k - 1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k - <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">         	m_[k][n] = <span class="built_in">max</span>(m_[k][n], <span class="built_in">LSA</span>(A, i, k - <span class="number">1</span>) + (sums_[n] - sums_[i]) / (n - i));</span><br><span class="line">        <span class="comment">//sum_[n] - sums_[i]：i+1～n的和</span></span><br><span class="line">        <span class="keyword">return</span> m_[k][n];                   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>DP版本</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">51 / 51 test cases passed.</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 12 ms</span></span><br><span class="line"><span class="comment">Submitted: 下午5:21,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">       	 <span class="comment">//下标从1开始，初始化为0，代表没有求解过</span></span><br><span class="line">       	 vector&lt;vector&lt;<span class="keyword">double</span>&gt;&gt; <span class="built_in">dp</span>(K + <span class="number">1</span>, vector&lt;<span class="keyword">double</span>&gt;(n + <span class="number">1</span>, <span class="number">0.0</span>));</span><br><span class="line">         <span class="comment">//前i个元素的和</span></span><br><span class="line">         vector&lt;<span class="keyword">double</span>&gt;<span class="built_in">sums</span>(n + <span class="number">1</span>, <span class="number">0.0</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             sums[i] = sums[i - <span class="number">1</span>] + A[i - <span class="number">1</span>]; <span class="comment">//suns_[i]存的是前i个元素和</span></span><br><span class="line">             dp[<span class="number">1</span>][i] = sums[i] / i; <span class="comment">//前i个元素化分为一组的平均数</span></span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) <span class="comment">//第一组已经分了，组的个数从2开始</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++) <span class="comment">//使用i个元素，化分为k组，至少k个元素</span></span><br><span class="line">                 <span class="comment">//j是分割点，把前i个元素分为两半,一半是1~j,另一半是j+1~i</span></span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">                 &#123;</span><br><span class="line">                     <span class="comment">//把i个元素分成k组取得的最大值</span></span><br><span class="line">                     dp[k][i] = <span class="built_in">max</span>(dp[k][i], dp[k - <span class="number">1</span>][j] + (sums[i] - sums[j]) / (i - j));</span><br><span class="line">                 &#125;</span><br><span class="line">          <span class="keyword">return</span> dp[K][n];             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为dp[k]只与dp[k - 1]有关。所以可以降维</p>
<p><strong>降维版本</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">51 / 51 test cases passed.</span></span><br><span class="line"><span class="comment">Status: Accepted</span></span><br><span class="line"><span class="comment">Runtime: 4 ms</span></span><br><span class="line"><span class="comment">Submitted: Submitted: 下午5:23,星期日, 2018年8月12日</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestSumOfAverages</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">const</span> <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">       	 <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>; <span class="comment">//改</span></span><br><span class="line">         <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">sums</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">         &#123;</span><br><span class="line">             sums[i] = sums[i - <span class="number">1</span>] + A[i - <span class="number">1</span>];</span><br><span class="line">             dp[i] = sums[i] / i; <span class="comment">//改 </span></span><br><span class="line">         &#125;</span><br><span class="line">          </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt;= K; k++) </span><br><span class="line">         &#123;</span><br><span class="line">             <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">tmp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0.0</span>)</span></span>; <span class="comment">//tmp存的是当前k的最大值，dp存的是k-1</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++) </span><br><span class="line">                 <span class="keyword">for</span>(<span class="keyword">int</span> j = k - <span class="number">1</span>; j &lt; i; j++) </span><br><span class="line">                 &#123;</span><br><span class="line">                   <span class="comment">//  dp[k][i] = max(dp[k][i], dp[k - 1][j] + (sums[i] - sums[j]) / (i - j));</span></span><br><span class="line">                     tmp[i] = <span class="built_in">max</span>(tmp[i], dp[j] + (sums[i] - sums[j]) / (i - j));</span><br><span class="line">                 &#125;</span><br><span class="line">             dp.<span class="built_in">swap</span>(tmp);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> dp[n];             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="POJ-1160区间DP-平行四边形优化-Post-Office"><a href="#POJ-1160区间DP-平行四边形优化-Post-Office" class="headerlink" title="POJ 1160区间DP+平行四边形优化(Post Office)"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://poj.org/problem?id=1160">POJ 1160区间DP+平行四边形优化(Post Office)</a></h2><p><strong>题意</strong></p>
<p> 有n个村庄现在要建立m个邮局，问怎么建邮局才能使得村庄到最近的邮局距离和最小。输出距离和即可。</p>
<p><strong>思路</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般的区间dp是从小区间到大区间，而此题在此之外还有一个限制是m个邮局。对于此类问题可以直接建立dp的时候加上限制条件：dp[i][j]=<span class="built_in">min</span>(dp[k][j−<span class="number">1</span>]+one[k+<span class="number">1</span>][i]) 定义dp含义为前i个村庄建立了j个邮局的最小距离和，那么在建立第j的时候可以枚举之前已经求出的区间，从j<span class="number">-1</span>个邮局的前提下加上现在的<span class="number">1</span>个邮局，one[i][j] 的含义是在区间i到j 的范围之中建立一个邮局，其实也就是中位数的位置，然后递推找出最小的值即可。</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/since_natural_ran/article/details/77629901">https://blog.csdn.net/since_natural_ran/article/details/77629901</a></p>
<p><strong>未用优化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-27 20:33:12		</span></span><br><span class="line"><span class="comment"> Exe.Time:94MS	 Exe.Memory：5.3MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">1e3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[len][len]; <span class="comment">//前i个村庄建立了j个邮局的最小距离和</span></span><br><span class="line"><span class="keyword">int</span> onePost[len][len] = &#123;<span class="number">0</span>&#125;; <span class="comment">//i到j 的范围之中建立一个邮局最小距离</span></span><br><span class="line"><span class="keyword">int</span> arr[len];</span><br><span class="line"><span class="keyword">int</span> numV, numP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numV; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= numV; j++)</span><br><span class="line">            onePost[i][j] = onePost[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>]; <span class="comment">//中位数位置，加多一个数，同时取其中位数，则需要添加的距离为 arr[j] - arr[(i + j) / 2]</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp)); <span class="comment">//因为是取min，所以可以初始化dp数组为较大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= numP; ++i)</span><br><span class="line">        dp[i][i] = <span class="number">0</span>; <span class="comment">//前i个村庄建立了i个邮局，则距离为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; numV &gt;&gt; numP;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numV; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numV; i++) <span class="comment">//村庄数量，[1,numV]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= numP; j++) <span class="comment">//邮局数量，小于等于numP</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i]);</span><br><span class="line">    cout &lt;&lt; dp[numV][numP];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/since_natural_ran/article/details/77629901">https://blog.csdn.net/since_natural_ran/article/details/77629901</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/u012139398/article/details/43956985">https://blog.csdn.net/u012139398/article/details/43956985</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.cnblogs.com/vongang/archive/2013/01/21/2869315.html">http://www.cnblogs.com/vongang/archive/2013/01/21/2869315.html</a></p>
<p>四边形优化公式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss[i, j<span class="number">-1</span>] &lt;= ss[i,j] &lt;= ss[i + <span class="number">1</span>, j]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> numVillages, numPost;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> onePost[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> arr[MAXN];</span><br><span class="line"><span class="keyword">int</span> ss[MAXN][MAXN]; <span class="comment">//ss[i][j]表示dp[i][j]取得最优解时，最后一个邮局设立在城市的编号,即决策变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(ss, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ss));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;= numPost; i++)</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= numVillages; j++)</span><br><span class="line">            onePost[i][j] = onePost[i][j - <span class="number">1</span>] + arr[j] - arr[(i + j) / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; numVillages &gt;&gt; numPost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numVillages; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= numPost; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ss[i + <span class="number">1</span>][j] = i + <span class="number">1</span>; <span class="comment">//不知道i，j关系，默认搜索完所有的村庄</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = ss[i][j - <span class="number">1</span>]; k &lt;= ss[i + <span class="number">1</span>][j]; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[k][j - <span class="number">1</span>] + onePost[k + <span class="number">1</span>][i];</span><br><span class="line">                    ss[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[numVillages][numPost] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="压缩二维最大子序列和"><a href="#压缩二维最大子序列和" class="headerlink" title="压缩二维最大子序列和"></a>压缩二维最大子序列和</h1><h2 id="HDU1081-To-The-Max"><a href="#HDU1081-To-The-Max" class="headerlink" title="HDU1081(To The Max)"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="http://acm.hdu.edu.cn/showproblem.php?pid=1081">HDU1081(To The Max)</a></h2><p><strong>题意:大致是求二维数组的最大矩阵和。</strong></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/BlackStorm/p/4922207.html">https://www.cnblogs.com/BlackStorm/p/4922207.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/linraise/article/details/16349527">https://blog.csdn.net/linraise/article/details/16349527</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/hitwhylz/article/details/11848439">https://blog.csdn.net/hitwhylz/article/details/11848439</a></p>
<p>二维压缩成一维，然后按照求最大序列和的办法去求最大值就行了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-09-04 19:59:05			</span></span><br><span class="line"><span class="comment"> Exe.Time:15MS	 Exe.Memory：1892k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> arr[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> cntRow[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArr</span><span class="params">()</span> <span class="comment">//求一维最大序列和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> MAX = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + cntRow[i], cntRow[i]); <span class="comment">//最大子序列和转移方程</span></span><br><span class="line">        <span class="keyword">if</span>(MAX &lt; dp[i])</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)　<span class="comment">//压缩</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cntRow, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cntRow));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; ++j)　</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n; ++k)</span><br><span class="line">                cntRow[k] += arr[j][k];</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">maxSubArr</span>();</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">                ans = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="杂项二维dp转移"><a href="#杂项二维dp转移" class="headerlink" title="杂项二维dp转移"></a>杂项二维dp转移</h1><h2 id="POJ2192-Zipper-－－－判断两个字符串能否合成一个字符串"><a href="#POJ2192-Zipper-－－－判断两个字符串能否合成一个字符串" class="headerlink" title="POJ2192 (Zipper)－－－判断两个字符串能否合成一个字符串"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vjudge.net/problem/POJ-2192">POJ2192 (Zipper)－－－判断两个字符串能否合成一个字符串</a></h2><p>题意：给你三个字符串，问你能否由前两个合成第三个，且要求不改变前两个字符串的顺序。题目保证第三个字符串的长度为前两个字符串的长度之和。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/huashanqingzhu/p/7348218.html">https://www.cnblogs.com/huashanqingzhu/p/7348218.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最优子结构分析：如果A、B可以组成C，那么，C最后一个字母，必定是 A 或 B 的最后一个字母组成。</span><br><span class="line">C去除除最后一位，就变成是否可以求出 A<span class="number">-1</span>和B 或者 A与B<span class="number">-1</span> 与 是否可以构成 C<span class="number">-1</span>。。。</span><br><span class="line"> 状态转移方程：</span><br><span class="line">用f[i][j] 表示 A前 i 位 和B 前j 位是否可以组成 C的前i+j位</span><br><span class="line">             dp[i][j]= (dp[i<span class="number">-1</span>][j]&amp;&amp;(a[i]==c[i+j]))||(dp[i][j<span class="number">-1</span>]&amp;&amp;(b[j]==c[i+j]))</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-30 16:52:10		</span></span><br><span class="line"><span class="comment"> Exe.Time:407MS	 Exe.Memory：4048KB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1E3</span>;</span><br><span class="line"><span class="keyword">char</span> a[MAXN], b[MAXN], c[MAXN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        a[<span class="number">0</span>] = b[<span class="number">0</span>] = c[<span class="number">0</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cin &gt;&gt; a + <span class="number">1</span>&gt;&gt; b + <span class="number">1</span>&gt;&gt; c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">int</span> lenC = <span class="built_in">strlen</span>(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++) <span class="comment">//初始化，单独ａ与ｃ匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == c[i])　</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenB; i++) <span class="comment">//初始化，单独ｂ与ｃ匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i] == c[i])</span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = ( (dp[i - <span class="number">1</span>][j] &amp;&amp; a[i] == c[i + j]) || (dp[i][j - <span class="number">1</span>] &amp;&amp; b[j] == c[i + j]) );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data set &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[lenA][lenB])</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POJ3356-AGTC-－－－s2变成s1最少的操作"><a href="#POJ3356-AGTC-－－－s2变成s1最少的操作" class="headerlink" title="POJ3356(AGTC)－－－s2变成s1最少的操作"></a><a target="_blank" rel="noopener external nofollow noreferrer" href="https://vjudge.net/problem/POJ-3356">POJ3356(AGTC)－－－s2变成s1最少的操作</a></h2><p><strong>题意：</strong>给出两个字符串x 与 y，其中x的长度为n，y的长度为m，并且m&gt;=n.然后y可以经过删除一个字母，添加一个字母，转换一个字母，三种操作得到x.问最少可以经过多少次操作</p>
<p> 参考：</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/u013480600/article/details/40780781">https://blog.csdn.net/u013480600/article/details/40780781</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Judge Status : Accepted	 Language : C++</span></span><br><span class="line"><span class="comment"> Submit Time：2018-07-30 20:55:35		</span></span><br><span class="line"><span class="comment"> Exe.Time:32MS	 Exe.Memory：4188MB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LEN = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[LEN][LEN];</span><br><span class="line"><span class="keyword">char</span> s1[LEN], s2[LEN];</span><br><span class="line"><span class="keyword">int</span> n1, n2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n1 &gt;&gt; s1)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n2 &gt;&gt; s2;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++) <span class="comment">//s2为空，s1删除字符串变成s2</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n2; i++) <span class="comment">//s1为空，s1添加字符串变成s2</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]?<span class="number">0</span>:<span class="number">1</span>),</span><br><span class="line">                              <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>));</span><br><span class="line">        cout &lt;&lt; dp[n1][n2] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</Img></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2018/08/02/DP/">https://greenhathg.github.io/2018/08/02/DP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/dp/">dp</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E4%BD%8Ddp/">数位dp</a><a class="post-meta__tags" href="/tags/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/">最长上升公共子序列</a><a class="post-meta__tags" href="/tags/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/">最长递增子序列</a><a class="post-meta__tags" href="/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/">最长公共子序列</a><a class="post-meta__tags" href="/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/">最长公共子串</a><a class="post-meta__tags" href="/tags/%E5%8C%BA%E9%97%B4dp/">区间dp</a><a class="post-meta__tags" href="/tags/%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C/">最大序列和</a><a class="post-meta__tags" href="/tags/%E4%BA%8C%E7%BB%B4dp/">二维dp</a></div><div class="post_share"><div class="social-share" data-image="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/07/19/%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E5%A4%84%E7%90%86/"><img class="prev-cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对一个整数处理</div></div></a></div><div class="next-post pull-right"><a href="/2018/08/15/kmp/"><img class="next-cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">kmp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/04/14/HDU1024-m%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/" title="HDU1024-m子段和的最大值"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-18</div><div class="title">HDU1024-m子段和的最大值</div></div></a></div><div><a href="/2019/04/14/hdu-1231%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C-dp-%E8%AE%B0%E5%BD%95%E4%BD%8D%E7%BD%AE/" title="hdu-1231最大连续子序列和-dp-记录位置"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-01-18</div><div class="title">hdu-1231最大连续子序列和-dp-记录位置</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">GreenHatHg</div><div class="author-info__description">巴拉巴拉能量! rm -rf / --no-preserve-root</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">195</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">234</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%A1%94%E7%B3%BB%E5%88%97"><span class="toc-number">2.</span> <span class="toc-text">数塔系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%95%B0%E5%A1%94HDU-2048"><span class="toc-number">2.1.</span> <span class="toc-text">经典数塔HDU[2048]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HDU1176-%E5%85%8D%E8%B4%B9%E9%A6%85%E9%A5%BC"><span class="toc-number">2.2.</span> <span class="toc-text">HDU1176[免费馅饼]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poj1088-%E6%BB%91%E9%9B%AA"><span class="toc-number">2.3.</span> <span class="toc-text">poj1088(滑雪)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E4%BD%8DDP"><span class="toc-number">3.</span> <span class="toc-text">数位DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HDU3555-Bomb-%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">HDU3555( Bomb )模板题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8D%E5%BE%AE%E4%BF%AE%E6%94%B9HDU2089-%E4%B8%8D%E8%A6%8162"><span class="toc-number">3.2.</span> <span class="toc-text">稍微修改HDU2089(不要62)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%9B%E5%AE%A2%E2%80%94%E5%8C%BA%E9%97%B4%E5%86%85%E6%95%B0%E5%AD%97%E5%90%AB%E6%9C%896%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">牛客—区间内数字含有6的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCIS%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">LCIS—最长上升公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E9%A2%98HDU1423-Greatest-Common-Increasing-Subsequence"><span class="toc-number">4.1.</span> <span class="toc-text">模板题HDU1423(Greatest Common Increasing Subsequence)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LIS%E2%80%94%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">LIS—最长递增子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#O-n-2-%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.1.</span> <span class="toc-text">O(n^2)的复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nlgn%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">nlgn的复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIS%E5%8F%98%E5%BD%A2%E2%80%94%E6%9C%89%E5%8D%87%E6%9C%89%E9%99%8D"><span class="toc-number">5.3.</span> <span class="toc-text">LIS变形—有升有降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E9%80%92%E5%A2%9E%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">5.4.</span> <span class="toc-text">最大递增子数组和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCS%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">LCS—最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HDU1503-Advanced-Fruits-%E8%BF%98%E5%8E%9F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%81%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84"><span class="toc-number">6.1.</span> <span class="toc-text">HDU1503(Advanced Fruits)还原最长公共子序列、记录路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poj1080-Human-Gene-Functions-LCS%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">poj1080(Human Gene Functions)LCS应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%EF%BC%88%E8%BF%9E%E7%BB%AD%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">最长公共子串（连续）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">8.</span> <span class="toc-text">区间DP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">算法结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode664-Strange-Printer-%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA"><span class="toc-number">8.2.</span> <span class="toc-text">LeetCode664 Strange Printer 奇怪的打印机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Leetcode-813-Largest-Sum-of-Averages"><span class="toc-number">8.3.</span> <span class="toc-text">Leetcode 813. Largest Sum of Averages</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POJ-1160%E5%8C%BA%E9%97%B4DP-%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%BC%98%E5%8C%96-Post-Office"><span class="toc-number">8.4.</span> <span class="toc-text">POJ 1160区间DP+平行四边形优化(Post Office)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E4%BA%8C%E7%BB%B4%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">9.</span> <span class="toc-text">压缩二维最大子序列和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HDU1081-To-The-Max"><span class="toc-number">9.1.</span> <span class="toc-text">HDU1081(To The Max)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9%E4%BA%8C%E7%BB%B4dp%E8%BD%AC%E7%A7%BB"><span class="toc-number">10.</span> <span class="toc-text">杂项二维dp转移</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#POJ2192-Zipper-%EF%BC%8D%EF%BC%8D%EF%BC%8D%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%83%BD%E5%90%A6%E5%90%88%E6%88%90%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.1.</span> <span class="toc-text">POJ2192 (Zipper)－－－判断两个字符串能否合成一个字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POJ3356-AGTC-%EF%BC%8D%EF%BC%8D%EF%BC%8Ds2%E5%8F%98%E6%88%90s1%E6%9C%80%E5%B0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">10.2.</span> <span class="toc-text">POJ3356(AGTC)－－－s2变成s1最少的操作</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project2-BPlusTree-Delete-Single-threaded"/></a><div class="content"><a class="title" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded">CMU445-Project2-BPlusTree-Delete-Single-threaded</a><time datetime="2024-01-05T12:39:43.000Z" title="发表于 2024-01-05 12:39:43">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玩客云换魔百盒"/></a><div class="content"><a class="title" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒">玩客云换魔百盒</a><time datetime="2023-12-31T12:44:43.000Z" title="发表于 2023-12-31 12:44:43">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded"><img src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BPlusTree-Insert-Single-threaded"/></a><div class="content"><a class="title" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded">CMU445-Project1-BPlusTree-Insert-Single-threaded</a><time datetime="2023-12-12T22:59:43.000Z" title="发表于 2023-12-12 22:59:43">2023-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/" title="CMU445-Project1-BufferPoolManagerInstance总结"><img src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BufferPoolManagerInstance总结"/></a><div class="content"><a class="title" href="/2023/07/01/CMU445-Project1-BufferPoolManagerInstance%E6%80%BB%E7%BB%93/" title="CMU445-Project1-BufferPoolManagerInstance总结">CMU445-Project1-BufferPoolManagerInstance总结</a><time datetime="2023-07-01T09:23:43.000Z" title="发表于 2023-07-01 09:23:43">2023-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/06/CMU445-Project1-LRU-K%E6%80%BB%E7%BB%93/" title="CMU445-Project1-LRU-K总结"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-LRU-K总结"/></a><div class="content"><a class="title" href="/2023/06/06/CMU445-Project1-LRU-K%E6%80%BB%E7%BB%93/" title="CMU445-Project1-LRU-K总结">CMU445-Project1-LRU-K总结</a><time datetime="2023-06-06T08:35:43.000Z" title="发表于 2023-06-06 08:35:43">2023-06-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2024 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>