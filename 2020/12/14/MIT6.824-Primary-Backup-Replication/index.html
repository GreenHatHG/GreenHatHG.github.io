<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.824-Primary-Backup-Replication | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="What kinds of failures can replication deal with? “fail-stop” failure of a single replica fan stops working, CPU overheats and shuts itself..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.824-Primary-Backup-Replication",
  "url": "https://greenhathg.github.io/2020/12/14/MIT6.824-Primary-Backup-Replication/",
  "image": "https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2020-12-14T13:02:46.000Z",
  "dateModified": "2025-06-14T08:46:00.551Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2020/12/14/MIT6.824-Primary-Backup-Replication/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.824-Primary-Backup-Replication',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">197</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">MIT6.824-Primary-Backup-Replication</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.824-Primary-Backup-Replication</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-14T13:02:46.000Z" title="发表于 2020-12-14 13:02:46">2020-12-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-14T08:46:00.551Z" title="更新于 2025-06-14 08:46:00">2025-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">1.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>5分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2020/12/14/MIT6.824-Primary-Backup-Replication/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-14 08:46:00&quot;}" hidden></div><h1 id="What-kinds-of-failures-can-replication-deal-with"><a href="#What-kinds-of-failures-can-replication-deal-with" class="headerlink" title="What kinds of failures can replication deal with?"></a>What kinds of failures can replication deal with?</h1><ul>
<li>“fail-stop” failure of a single replica<ul>
<li>fan stops working, CPU overheats and shuts itself down</li>
<li>someone trips over replica’s power cord or network cable（电源线或网络电缆）</li>
<li>software notices it is out of disk space and stops</li>
</ul>
</li>
<li>Maybe not defects in h/w(Hardware/Software) or bugs in s/w or human configuration errors</li>
</ul>
<h1 id="Two-main-replication-approaches"><a href="#Two-main-replication-approaches" class="headerlink" title="Two main replication approaches"></a>Two main replication approaches</h1><h2 id="State-transfer"><a href="#State-transfer" class="headerlink" title="State transfer"></a>State transfer</h2><ul>
<li>Primary replica executes the service</li>
<li><strong>Primary sends [new] state to backups</strong></li>
</ul>
<h2 id="Replicated-state-machine"><a href="#Replicated-state-machine" class="headerlink" title="Replicated state machine"></a>Replicated state machine</h2><ul>
<li><strong>Clients send operations to primary, primary sequences and sends to backups</strong></li>
<li>All replicas execute all operations</li>
<li>If same start state, same operations, same order, deterministic, then same end state.</li>
<li>support only uni-processor (In fact, vmware has a solution for multi-core processor, but it seems to be based on state transfer)</li>
</ul>
<hr>
<h2 id="Compared"><a href="#Compared" class="headerlink" title="Compared"></a>Compared</h2><ul>
<li>State transfer is simpler, but state may be large, slow to transfer over network</li>
<li>Replicated state machine often generates less network traffice<ul>
<li>Operations are often small compared to state But complex to get right</li>
</ul>
</li>
</ul>
<h1 id="At-what-level-do-we-want-replicas-to-be-identical"><a href="#At-what-level-do-we-want-replicas-to-be-identical" class="headerlink" title="At what level do we want replicas to be identical"></a>At what level do we want replicas to be identical</h1><p>identical: similar in every detail</p>
<ul>
<li><code>VMware vSphere Fault Tolerance (VMware FT)</code>   replicates the low-level memory and machine registers ( <code>Machine level</code> )<ul>
<li>might allow us to replicate any existing server without modification</li>
<li>requires forwarding of machine events (interrupts, DMA（指内存和外设直接存取数据这种内存访问的计算机技术）)</li>
<li>can run any existing O/S and server software. Appears like a single server to clients</li>
</ul>
</li>
<li>Most like GFS where it was replicating much more application level table of chunks<ul>
<li>Can be efficient; primary only sends high-level operations to backup</li>
<li>Application code (server) must understand fault tolerance, to e.g. forward op stream</li>
</ul>
</li>
</ul>
<h1 id="VMware-FT"><a href="#VMware-FT" class="headerlink" title="VMware FT"></a>VMware FT</h1><p><img src="/2020/12/14/MIT6.824-Primary-Backup-Replication/test_1.png" alt></p>
<p>有两台机器，分别是primary和backup，它们都是通过VMM虚拟化运行同一个OS，按照FT来讲，它们运行的内容也是一样的，它们的存储数据的磁盘可能不是在机器上面，而是有个Disk Server，并且有个Client访问数据，这些都通过网路连接在一起。</p>
<p><img src="/2020/12/14/MIT6.824-Primary-Backup-Replication/test_2.png" alt></p>
<ul>
<li>现在Client发送一个网络数据包给Primary，Primary的VMM接收到数据包，并产生一个中断，它会模拟一个网络数据包到达的中断给primary上的os，以将这个数据包发送给应用程序。</li>
<li>同时VMM还将数据包的副本发送给Backup的VMM，Backup的VMM也会做同样的事情。</li>
<li>应用程序会产生Response，并通过VMM所模拟的<code>NIC (Network Interface Card)</code> 将它发送出去。因为Backup也在执行同样的操作，所以Backup也会产生同样的Response，但是FT会将其丢弃，最终只有Primary应答。</li>
</ul>
<p>Primary将所有<code>external events</code>（网络数据包等）都通过称为<code>Logging channel</code>的网络连接发送到Backup，发送的内容称为<code>log entries</code></p>
<p>如果Backup超过一定时间没有从Logging channel中拿到数据，那么VMM会让Backup代替Primary。</p>
<h1 id="What-sources-of-divergence-must-FT-handle"><a href="#What-sources-of-divergence-must-FT-handle" class="headerlink" title="What sources of divergence must FT handle?"></a>What sources of divergence must FT handle?</h1><p>divergence: the process or state of (of opinions or methods) differing</p>
<ul>
<li>Most instructions execute identically on primary and backup<ul>
<li>As long as memory+registers are identical, which we’re assuming by induction</li>
</ul>
</li>
<li>Inputs from external world — just network packets<ul>
<li>These appear as DMA’d data plus an interrupt.</li>
<li>This interrupt will occur somewhere in the instruction stream. So we must know which instruction occurred when primary and backup behave the same.Otherwise they will be different in execution and the state.</li>
</ul>
</li>
<li>Instructions that aren’t functions of state, such as reading current time.</li>
<li>Not multi-core races, since uniprocessor only<ul>
<li>the instructions of the service are interleaved（交错的） in some way which is not predictable（预测的）  ( such as get lock)</li>
</ul>
</li>
</ul>
<h1 id="FT’s-handling-of-timer-interrupts"><a href="#FT’s-handling-of-timer-interrupts" class="headerlink" title="FT’s handling of timer interrupts"></a>FT’s handling of timer interrupts</h1><ul>
<li><strong>Goal</strong>: primary and backup should see interrupt at the same point in the instruction stream</li>
<li><strong>Primary</strong><ol>
<li>FT fields（处理） the timer interrupt</li>
<li>FT reads instruction number from CPU</li>
<li>FT sends “timer interrupt at instruction X” on logging channel</li>
<li>FT delivers interrupt to primary, and resumes（恢复） it（this relies on CPU support to interrupt after the X’th instruction）</li>
</ol>
</li>
<li><strong>Backup</strong><ol>
<li>ignores its own timer hardware</li>
<li>FT sees log entry <em>before</em> backup gets to instruction X</li>
<li>FT tells CPU to interrupt (to FT) at instruction X</li>
<li>FT mimics（模仿） a timer interrupt to backup</li>
</ol>
</li>
</ul>
<h1 id="FT’s-handling-of-network-packet-arrival-input"><a href="#FT’s-handling-of-network-packet-arrival-input" class="headerlink" title="FT’s handling of network packet arrival (input)"></a>FT’s handling of network packet arrival (input)</h1><ul>
<li>Primary<ol>
<li>FT tells NIC to copy packet data into FT’s private “bounce buffer”（When data travels between a device and high memory, it is first copied through the bounce buffer）</li>
<li>FT gets the interrupt from NIC</li>
<li>FT pauses the primary</li>
<li>FT copies the bounce buffer into the primary’s memory</li>
<li>FT simulates（模拟） a NIC interrupt in primary</li>
<li>FT sends the packet data and the instruction id to the backup</li>
</ol>
</li>
<li>Backup<ol>
<li>FT gets data and instruction id from log stream</li>
<li>FT tells CPU to interrupt (to FT) at instruction X</li>
<li>FT copies the data to backup memory, simulates NIC interrupt in backup</li>
</ol>
</li>
</ul>
<h1 id="output-rule"><a href="#output-rule" class="headerlink" title="output rule"></a>output rule</h1><p>Avoid data inconsistency caused by backup not receiving log after primary crash</p>
<ul>
<li>Primary：<ol>
<li>receives client “increment” request</li>
<li>sends client request on logging channel</li>
<li>about to（即将） send  reply to client</li>
<li>first waits for backup to acknowledge（承认） previous log entry</li>
<li>then sends reply to client</li>
</ol>
</li>
</ul>
<p><strong>what if the primary crashed <em>after</em> emitting the output? Will the backup emit the output a second time?</strong></p>
<p>Yes.<br>   OK for TCP, since receivers ignore duplicate sequence numbers.<br>   OK for writes to disk, since backup will write same data to same block id.</p>
<h1 id="could-it-suffer-from-split-brain"><a href="#could-it-suffer-from-split-brain" class="headerlink" title="could it suffer from split brain"></a>could it suffer from split brain</h1><p>The disk server breaks the tie.（打破了僵局）<br>Disk server supports <strong>atomic test-and-set</strong>.<br>If primary or backup thinks other is dead, <strong>attempts test-and-set</strong>.<br>If only one is alive, it will win test-and-set and go live.<br>If both try, one will lose, and halt.</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2020/12/14/MIT6.824-Primary-Backup-Replication/">https://greenhathg.github.io/2020/12/14/MIT6.824-Primary-Backup-Replication/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mit6-824/">mit6.824</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD/">主从备份</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2021/01/30/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" title="MySQL慢查询优化"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MySQL慢查询优化</div></div><div class="info-2"><div class="info-item-1">优化出发点大部分情况下一般是考虑索引，但是其他方面也值得考虑。 数据库级别 表的结构：列是否具有正确的数据类型？表的结构是否设计正确，例如，频繁更新的应用的表结构应该是少列多表，分析大量数据的应用应该是少表多列 是否创建索引？索引是否有用？ 是否选择了合适的存储引擎，这个现在一般是InnoDB 表是否使用正确的行格式(ROW_FORMAT)？特别是ROW_FORMAT为COMPRESSED 的表使用较少的磁盘空间，因此需要较少的磁盘I/O来读写数据 应用程序是否使用了适当的锁策略？例如在某种情况下允许共享读(shared access)，以便数据库操作能够同时进行 缓存大小是否设置正确？足够大的缓存能够容纳经常访问的数据，但是又不能过大，过大导致使用虚拟内存I/O性能下降  硬件级别磁盘种类、速度、CPU、内存等因素 数据类型优化几个简单原则：  更小的通常更好  应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型占用更少磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少。（确保没有低估，如果无法确定哪个数据类型最好，就选择不会超过范围的最小类型）  简单就好  ...</div></div></div></a><a class="pagination-related" href="/2020/11/17/MIT6.824-GFS/" title="MIT6.824-GFS"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MIT6.824-GFS</div></div><div class="info-2"><div class="info-item-1">为什么我们要阅读这篇论文?在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的interface/semantics 应该怎么定义，它是怎么并行工作的等。 GFS paper涉及到了很多分布式系统主题：parallel performance, fault tolerance, replication, consistency 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。 为什么分布式存储这么难? high performance→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据 many servers→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复 fault tolerance →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用 replication →有数据不一致的风险 better consistency...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/11/17/MIT6.824-GFS/" title="MIT6.824-GFS"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-GFS</div></div><div class="info-2"><div class="info-item-1">为什么我们要阅读这篇论文?在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的interface/semantics 应该怎么定义，它是怎么并行工作的等。 GFS paper涉及到了很多分布式系统主题：parallel performance, fault tolerance, replication, consistency 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。 为什么分布式存储这么难? high performance→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据 many servers→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复 fault tolerance →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用 replication →有数据不一致的风险 better consistency...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/" title="MIT6.824-LEC10-Cloud Replicated-DB-Aurora"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC10-Cloud Replicated-DB-Aurora</div></div><div class="info-2"><div class="info-item-1">为什么要学习Aurora 作为近几年成功的云服务，解决了严重的问题 设计良好，有性能的优势 使用general-purpose storage架构情况下的局限性 许多关于云基础架构中重要的内容  Amazon EC2，cloud computing，针对于web  租用直接运行在Amazon数据中心物理机器上的virtual machines instances 使用的存储是连接在物理磁盘上的virtual local disk 客户在EC2上面运行着stateless www server或者DB 但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）  Amazon EBS (Elastic Block Store)  使用的是Chain Replication，基于paxos的configuration manager 如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume EBS不是shared...</div></div></div></a><a class="pagination-related" href="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/" title="MIT6.824-LEC11-Cache-Consistency-Frangipani"><img class="cover" src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC11-Cache-Consistency-Frangipani</div></div><div class="info-2"><div class="info-item-1">为什么要阅读这篇论文 cache coherence distributed transactions distributed crash recovery 三者的相互作用  整体的设计 a network file system，与现有的应用程序共同工作，类似普通的unix程序。可以将petal想象成一个磁盘，通过网络将数据共享给Frangipani，看起来就像从普通磁盘上读取数据  预期用途 一个文件系统，能保存自己的home目录以及共享的项目文件，在任何的workstation（可以理解是个人PC）能拿到自己的home目录以及所需要的所有文件。 没有涉及到安全问题，彼此电脑之间互相信任，适用于小群体  Frangipani的设计 强一致性 caching in each workstation — write-back 所有对文件的更新最初只是在workstation cache中完成—速度快 包括创建文件、目录、重命名等 比如ws1(workstation user...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC8-Zookeeper/" title="MIT6.824-LEC8-Zookeeper"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC8-Zookeeper</div></div><div class="info-2"><div class="info-item-1">Zookeeper提出了什么问题 能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？ 我们有N个replica server，能从这个N个server中获得N倍性能吗？  将Zookeer视为基于Raft的service只不过ZooKeeper使用的是zab协议，为ZooKeeper专门设计的一种支持崩溃恢复的一致性协议 当我们添加更多的server时候，replication arrangement是否变得更快replica越多，写入的速度就越慢leader必须将每次写入发送给越来越多的server 可以让follower提供只读服务，这样leader压力就小很多可能会产生log与leader不一致的情况，导致client读取的数据不对，甚至是产生“倒退现象”，client先从up-to-date replica读，再从logging...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/" title="MIT6.824-LEC9-More-Replication-CRAQ"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC9-More-Replication-CRAQ</div></div><div class="info-2"><div class="info-item-1">为什么学习CRAQ Chain Replication(CR)，一种与Raft非常不一样的方法。 CRAQ能够从replica读取数据并且保持强一致性  什么是CR write：   client发送写请求给head server 请求按顺序沿着链下发 每个server用新数据覆盖旧数据 当tail server处理完成后回复给client   read：   client发送读请求给tail server tail server回复给client（不涉及其他server）   为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。 如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。 如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。 不能处理network partition或者spilt...</div></div></div></a><a class="pagination-related" href="/2020/11/06/MIT6.824-MapReduce/" title="MIT6.824-MapReduce"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-MapReduce</div></div><div class="info-2"><div class="info-item-1">背景有时候我们需要从一批数据中得到一些结果，比如从最频繁查询的结果集，每个单词出现的次数。随着输入的数据越来越多，为了在合理的时间内完成，单台机器可能会完成不了这个任务，所以我们必须将这个计算压力分担到多个机器上面，并行计算。 但是解决计算的标准化，数据的分配，故障处理，负载均衡等问题是个大工程，让原本简单的代码变得复杂起来。 为此，Google发明了MapReduce系统，隔离了复杂的底层，让程序员能够容易使用这个系统进行大数据量的分布式计算。 编程模型将用户的计算分为两个函数处理：Map和Reduce 函数  Map函数：输入数据，处理后生成一组键值对（中间值） Reduce函数：处理前面得到的中间值，然后将这些值合并在一起，形成更小的值集。通常，每次 Reduce调用只生成零个或一个输出值。  简约模型： 123map (k1,v1) → list(k2,v2)//这里是指对应k2的结果有多个reduce (k2,list(v2)) → list(v2)   举个例子： 现有大量的文本数据，想统计每个单词出现的次数 123456789map(string...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">197</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#What-kinds-of-failures-can-replication-deal-with"><span class="toc-number">1.</span> <span class="toc-text">What kinds of failures can replication deal with?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Two-main-replication-approaches"><span class="toc-number">2.</span> <span class="toc-text">Two main replication approaches</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#State-transfer"><span class="toc-number">2.1.</span> <span class="toc-text">State transfer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Replicated-state-machine"><span class="toc-number">2.2.</span> <span class="toc-text">Replicated state machine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compared"><span class="toc-number">2.3.</span> <span class="toc-text">Compared</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#At-what-level-do-we-want-replicas-to-be-identical"><span class="toc-number">3.</span> <span class="toc-text">At what level do we want replicas to be identical</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#VMware-FT"><span class="toc-number">4.</span> <span class="toc-text">VMware FT</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#What-sources-of-divergence-must-FT-handle"><span class="toc-number">5.</span> <span class="toc-text">What sources of divergence must FT handle?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FT%E2%80%99s-handling-of-timer-interrupts"><span class="toc-number">6.</span> <span class="toc-text">FT’s handling of timer interrupts</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FT%E2%80%99s-handling-of-network-packet-arrival-input"><span class="toc-number">7.</span> <span class="toc-text">FT’s handling of network packet arrival (input)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#output-rule"><span class="toc-number">8.</span> <span class="toc-text">output rule</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#could-it-suffer-from-split-brain"><span class="toc-number">9.</span> <span class="toc-text">could it suffer from split brain</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14">[Xueqiu_Forever] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:45:50.000Z" title="发表于 2025-06-14 08:45:50">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14">[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:15:28.000Z" title="发表于 2025-06-14 08:15:28">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded"><img src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project2-BPlusTree-Delete-Single-threaded"/></a><div class="content"><a class="title" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded">CMU445-Project2-BPlusTree-Delete-Single-threaded</a><time datetime="2024-01-05T12:39:43.000Z" title="发表于 2024-01-05 12:39:43">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒"><img src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玩客云换魔百盒"/></a><div class="content"><a class="title" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒">玩客云换魔百盒</a><time datetime="2023-12-31T12:44:43.000Z" title="发表于 2023-12-31 12:44:43">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BPlusTree-Insert-Single-threaded"/></a><div class="content"><a class="title" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded">CMU445-Project1-BPlusTree-Insert-Single-threaded</a><time datetime="2023-12-12T22:59:43.000Z" title="发表于 2023-12-12 22:59:43">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>