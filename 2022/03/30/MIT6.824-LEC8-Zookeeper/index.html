<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.824-LEC8-Zookeeper | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Zookeeper提出了什么问题 能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？ 我们有N个replica..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.824-LEC8-Zookeeper",
  "url": "https://greenhathg.github.io/2022/03/30/MIT6.824-LEC8-Zookeeper/",
  "image": "https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2022-03-30T19:51:43.000Z",
  "dateModified": "2025-06-15T14:31:07.636Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2022/03/30/MIT6.824-LEC8-Zookeeper/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.824-LEC8-Zookeeper',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">242</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">MIT6.824-LEC8-Zookeeper</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.824-LEC8-Zookeeper</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-30T19:51:43.000Z" title="发表于 2022-03-30 19:51:43">2022-03-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-15T14:31:07.636Z" title="更新于 2025-06-15 14:31:07">2025-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/03/30/MIT6.824-LEC8-Zookeeper/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-15 14:31:07&quot;}" hidden></div><h2 id="Zookeeper提出了什么问题"><a href="#Zookeeper提出了什么问题" class="headerlink" title="Zookeeper提出了什么问题"></a>Zookeeper提出了什么问题</h2><ol>
<li>能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？</li>
<li>我们有N个replica server，能从这个N个server中获得N倍性能吗？</li>
</ol>
<h2 id="将Zookeer视为基于Raft的service"><a href="#将Zookeer视为基于Raft的service" class="headerlink" title="将Zookeer视为基于Raft的service"></a>将Zookeer视为基于Raft的service</h2><p><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220305160645.png" alt><br>只不过ZooKeeper使用的是zab协议，为ZooKeeper专门设计的一种支持崩溃恢复的一致性协议</p>
<h2 id="当我们添加更多的server时候，replication-arrangement是否变得更快"><a href="#当我们添加更多的server时候，replication-arrangement是否变得更快" class="headerlink" title="当我们添加更多的server时候，replication arrangement是否变得更快"></a>当我们添加更多的server时候，replication arrangement是否变得更快</h2><p>replica越多，写入的速度就越慢<br>leader必须将每次写入发送给越来越多的server</p>
<h2 id="可以让follower提供只读服务，这样leader压力就小很多"><a href="#可以让follower提供只读服务，这样leader压力就小很多" class="headerlink" title="可以让follower提供只读服务，这样leader压力就小很多"></a>可以让follower提供只读服务，这样leader压力就小很多</h2><p>可能会产生log与leader不一致的情况，导致client读取的数据不对，甚至是产生“倒退现象”，client先从up-to-date replica读，再从logging replica读。这个就不可能是Linearizability<br>Raft和Lab3不会出现这种情况，因为follower不提供只读服务</p>
<h2 id="Zookeeper怎么处理这个"><a href="#Zookeeper怎么处理这个" class="headerlink" title="Zookeeper怎么处理这个"></a>Zookeeper怎么处理这个</h2><p>在性能和强一致性之间保持平衡，不提供强一致性，允许从replica读取数据（写只能是写leader），但是在其他方面则是保证了顺序。</p>
<h2 id="Ordering-guarantees-Section-2-3"><a href="#Ordering-guarantees-Section-2-3" class="headerlink" title="Ordering guarantees (Section 2.3)"></a>Ordering guarantees (Section 2.3)</h2><h3 id="Linearizable-writes"><a href="#Linearizable-writes" class="headerlink" title="Linearizable writes"></a>Linearizable writes</h3><ol>
<li>client发送写入命令到leader</li>
<li>leader选择一个顺序，编号为<code>zxid</code></li>
<li>将该命令发送给replica，所以replica按照zxid顺序去执行。</li>
<li>即使是并发写操作，也会保证按照某个顺序去一一执行。</li>
</ol>
<h3 id="FIFO-client-order"><a href="#FIFO-client-order" class="headerlink" title="FIFO client order"></a>FIFO client order</h3><p>client指定write和read操作的执行顺序</p>
<ul>
<li>write：按照client指定的write order，section2.3 ready file</li>
<li>read：<ul>
<li>每次读都在写入顺序中的某一个点开始执行</li>
<li>client连续读操作，每次读的顺序保证是非递减，这一次读不会读到前面的内容</li>
<li>如果执行读操作的时候，replica挂掉了，client需要将它的读请求发送给另外一个replica，这时候依旧会保证FIFO client order（非递减）。</li>
<li>工作原理是每个log entry都有一个zxid，当一个replica响应client的读请求时会携带上一个log entry的zxid（这里的上一个相对于是下一个读请求），client会记住最新数据的zxid，每次请求会携带上zxid。</li>
<li>如果另外一个replica也没有最新zxid对应的下一个log，replica可能会延迟对读请求回复直到leader同步了log或者是拒绝这个请求，或者是其他。</li>
</ul>
</li>
<li>将write发送给leader，但是leader还没有同步给replica，这时候read replica会被delay（因为指定了命令的执行顺序）或者sync()</li>
<li>只是保证了一个client的FIFO order（同一个clien的Linearizability），即同一个client的命令可以保证下一次读到的是上一次的写。但是对于不同的client来讲，client2不一定能准确读到刚刚client1写的数据</li>
</ul>
<h2 id="尽管Zookeeper不是Linearizability，但是在别的方面还是有用的"><a href="#尽管Zookeeper不是Linearizability，但是在别的方面还是有用的" class="headerlink" title="尽管Zookeeper不是Linearizability，但是在别的方面还是有用的"></a>尽管Zookeeper不是Linearizability，但是在别的方面还是有用的</h2><ul>
<li>sync()能够让后续不同的client看到之前client写入的值。只有该数据在整个系统中处于写状态，不允许其他client读到。想要读取最新数据，需要sync再读。缺点是增加了leader的处理时间，不这样做的话就不是linearizable</li>
<li>场景1 ready file：master在Zookeeper中维护了一个配置文件（描述了分布系统的东西，比如worker ip，master信息等），里面有一堆文件（可以实现原子更新效果），master会去更新配置文件，在更新的过程中worker不能查看配置，只能看到完全更新后的配置。<ul>
<li>正常的操作序列，虽然不是完全linearizable（只有写），但是读只能往前读，所以达了类似linearizable的效果，提高了性能：<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306190528.png" alt></li>
</ul>
</li>
<li>可能会出现的问题：<br>  <img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306190548.png" alt><br>  读f1的时候，执行了写操作，导致读到的f2不是原来应该读的<br>  Zookeeper使用watch事件去解决，当调用exists的时候，除了判断file是否存在，还在这个文件上面设置了watch事件（replicate会创建watch table，文件修改之前查看watch table)，当这个文件被修改时候replica会在一个相对正确的时间点通知client，即会在读操作执行之前。<br>  <img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220306191450.png" alt><br>  当replicate crash时候，对应的watch table也会没有，client切换到新的replicate读的时候就不会有对应的watch table。但是client会在合适的时间收到replica崩溃的通知。</li>
</ul>
<h2 id="几个影响"><a href="#几个影响" class="headerlink" title="几个影响"></a>几个影响</h2><ul>
<li>当leader failed时候leader必须保存client的write order（？</li>
<li>replicate需要保障client的读取顺序按照zxid顺序</li>
<li>client必须跟踪它已读取的最高 zxid</li>
</ul>
<h2 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h2><ul>
<li>client可以让leader发送异步写入，不必等待</li>
<li>leader可以批处理请求以减少磁盘和网络开销</li>
</ul>
<h2 id="Coordination-as-a-service是怎么样的（Zookeeper有什么用）"><a href="#Coordination-as-a-service是怎么样的（Zookeeper有什么用）" class="headerlink" title="Coordination as a service是怎么样的（Zookeeper有什么用）"></a>Coordination as a service是怎么样的（Zookeeper有什么用）</h2><h3 id="VMware-FT’s-test-and-set-server"><a href="#VMware-FT’s-test-and-set-server" class="headerlink" title="VMware-FT’s test-and-set server"></a>VMware-FT’s test-and-set server</h3><ul>
<li>要求：一个replica无法和其他replica通信，则获取t-a-s lock（test-and-set lock），成为sole server。必须是唯一的以避免存在两个primary（如果出现network partition），必须是fault-tolerant。</li>
<li>Zookeeper提供了工具，可以写出fault-tolerant test-and-set服务</li>
</ul>
<h3 id="Config-info"><a href="#Config-info" class="headerlink" title="Config info"></a>Config info</h3><p>通过Zookeeper发布信息给其他服务使用，比如可以将一组worker中作为当前master的那个ip存放在Zookeeper</p>
<h3 id="Mater-elect"><a href="#Mater-elect" class="headerlink" title="Mater elect"></a>Mater elect</h3><p>在test-and-set server中有体现，master可以把state存放在Zookeeper，如果master crash，选出一个新的maser代替它，新的master可以从Zookeeper中读取旧master的状态。</p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>worker可以注册到Zookeeper中，master会在里面记录着worker的任务，worker会从Zookeeper中将任务一件件拿出来，完成后就会移除掉。</p>
<h3 id="Zookeeper-API"><a href="#Zookeeper-API" class="headerlink" title="Zookeeper API"></a>Zookeeper API</h3><ul>
<li>a file-system-like tree of znodes<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220308074546.png" alt><br>each znode has a version number<br>示例：将一组机器和哪个机器是primary的信息存放在znodes</li>
<li>znode的分类：regular、ephemeral、sequential（file name + seqno）</li>
</ul>
<h2 id="Operations-on-znodes"><a href="#Operations-on-znodes" class="headerlink" title="Operations on znodes"></a>Operations on znodes</h2><p>flags：znode type</p>
<ul>
<li>create(path, data, flags)：互斥的（exclusive），只有第一次创建才能成功</li>
<li>delete(path, version)：if znode.version = version, then delete</li>
<li>exists(path, watch)：设置watch后，当path创建或者删除后会发送一个通知。原子操作，两个write之间的watch不会有任何操作，znode完成改变之前不会收到通知</li>
<li>getData(path, watch)</li>
<li>setData(path, data, version)：if znode.version = version, then update</li>
<li>getChildren(path, watch)</li>
<li>sync()</li>
</ul>
<h2 id="Zookeeper-api可以很好地实现同步"><a href="#Zookeeper-api可以很好地实现同步" class="headerlink" title="Zookeeper api可以很好地实现同步"></a>Zookeeper api可以很好地实现同步</h2><ul>
<li>exclusive file creation：并发创建只有一个能返回成功</li>
<li>getData()/setData(x, version)支持mini-transactions</li>
<li>当client fail的时候，session会自动执行操作，例如失败时release lock</li>
<li>sequential znode file可用于并发创建的同时又能指定顺序</li>
<li>watch</li>
</ul>
<h2 id="znode中的数字递增"><a href="#znode中的数字递增" class="headerlink" title="znode中的数字递增"></a>znode中的数字递增</h2><p>mini-transaction保障atomic read-modify-write<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true:</span><br><span class="line">    x, v := getData(&quot;f&quot;)</span><br><span class="line">    if setData(x + 1, version=v):</span><br><span class="line">      break</span><br></pre></td></tr></table></figure><br>当replica不能与leader通信时候，不能退出while循环。只适合少量请求的场景，当有大量的client同时递增时候，性能就会很差，因为同时操作只有一个能完成，复杂度是N^2。使用随机sleep能够减少循环的次数，避免大量的重试。</p>
<h2 id="Simple-Locks-Section-2-4"><a href="#Simple-Locks-Section-2-4" class="headerlink" title="Simple Locks (Section 2.4)"></a>Simple Locks (Section 2.4)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire():</span><br><span class="line">    while true:</span><br><span class="line">      if create(&quot;f&quot;, ephemeral=true), success</span><br><span class="line">      if exists(&quot;f&quot;, watch=true)</span><br><span class="line">        wait for notification</span><br><span class="line">release():</span><br><span class="line">	delete(&quot;f&quot;)</span><br></pre></td></tr></table></figure>
<p>在replica exists执行过程中，lock文件被释放掉，会发生什么情况。exists是个只读请求，可能会发生在replica，与此同时，可能会有别的client在执行delete操作。exists会在两个write请求之间执行。<br><img src="/2022/03/30/MIT6.824-LEC8-Zookeeper/Pasted image 20220309081922.png" alt><br>在完成执行成功的时间点，replica会看到lock文件依旧存在，replica会插入watch信息到watch table，然后才执行delete操作。所以当delete操作执行时，确保watch请求会在replica的watch table中，并且replica会给client发送通知。<br>每次释放锁，所有剩下的client都会收到watch通知，都会返回第一步发送create请求，所以时间复杂度基本上还是N^2。这个就是大量等待client引起的<code>Herd Effect</code>。</p>
<h2 id="Locks-without-Herd-Effect-scalable-lock"><a href="#Locks-without-Herd-Effect-scalable-lock" class="headerlink" title="Locks without Herd Effect(scalable lock)"></a>Locks without Herd Effect(scalable lock)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. create a &quot;sequential&quot; file</span><br><span class="line">2. list files</span><br><span class="line">3. if no lower-numbered, lock is acquired!</span><br><span class="line">4. if exists(next-lower-numbered, watch=true)</span><br><span class="line">5.   wait for event...</span><br><span class="line">6. goto 2</span><br></pre></td></tr></table></figure>
<ul>
<li>大量client请求的话会按顺序产生很多个文件</li>
<li>这些文件代表着获得了锁，如果释放了锁则需要删除文件</li>
<li>为什么需要list files，因为前一个client可能会failed，导致文件被自动删除，这时候就需要关注上一个的上一个的文件是否存在，而不能只是关注上一个文件（相对于client创建的文件序号，比如client创建了f500，不能只是关注f499）是否存在。</li>
<li>如何解决Herd Effect：创建了第501个文件的client在等待第500个文件被释放，创建了第500个文件的client等待第499个文件被释放，每个client都在等待文件被释放。当释放锁的时候，一个client就会收到通知，第三步就会成立，那么这个client就获得了锁。所以一个client的开销只有几次RPC请求的开销，等待锁也可以是异步等待，在另外一个线程通过某种方式查看Zookeeper的状态。其实就相等于锁队列，后一个client都在等待着前面的client释放。<ul>
<li>如果client持有锁的时候，但是它中途操作失败，那么锁会立即释放，导致下一个client获得锁的时候看到的数据不是正确的数据。所以这些锁和语言带的线程锁相比，它们无法提供相同的原子性保证。<ul>
<li>基本上使用这种锁有两种考虑：每个获取到锁的client都应该准备好遇到上一个失败这种情况时的操作（比如推断出是在哪个地方出现错误）；要么就是保护的数据不是很重要，比如MapReduce中的worker失败后，释放锁后下一个worker执行时看到任务没有完成，重新执行即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2022/03/30/MIT6.824-LEC8-Zookeeper/">https://greenhathg.github.io/2022/03/30/MIT6.824-LEC8-Zookeeper/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mit6-824/">mit6.824</a><a class="post-meta__tags" href="/tags/zookeeper/">zookeeper</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/" title="MIT6.824-LEC9-More-Replication-CRAQ"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">MIT6.824-LEC9-More-Replication-CRAQ</div></div><div class="info-2"><div class="info-item-1">为什么学习CRAQ Chain Replication(CR)，一种与Raft非常不一样的方法。 CRAQ能够从replica读取数据并且保持强一致性  什么是CR write：   client发送写请求给head server 请求按顺序沿着链下发 每个server用新数据覆盖旧数据 当tail server处理完成后回复给client   read：   client发送读请求给tail server tail server回复给client（不涉及其他server）   为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。 如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。 如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。 不能处理network partition或者spilt...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-Raft-index%E5%90%AB%E4%B9%89/" title="MIT6.824-Raft-index含义"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MIT6.824-Raft-index含义</div></div><div class="info-2"><div class="info-item-1">nextIndex 官方描述：for each server, index of the next log entry  to send to that server (initialized to leader last log index + 1) leader保存该数组变量，由leader更新。 nextIndex[i]代表着对第i个follower发起Append Entries RPC时尝试replicated log的位置，仅仅是猜测并不是真实的，并且出现log inconsistency会将该值回退。所以nextIndex[i]需要比matchIndex[i]要大。 leader收到Append Entries RPC回复后只有是因为log inconsistency才能更新nextIndex。 更新nextIndex的三个时机 leader election成功时候，需要更新nextIndex为leader last log index + 1 AppendEntries RPC返回success，代表已经成功replicated log log...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/" title="MIT6.824-LEC10-Cloud Replicated-DB-Aurora"><img class="cover" src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-LEC10-Cloud Replicated-DB-Aurora</div></div><div class="info-2"><div class="info-item-1">为什么要学习Aurora 作为近几年成功的云服务，解决了严重的问题 设计良好，有性能的优势 使用general-purpose storage架构情况下的局限性 许多关于云基础架构中重要的内容  Amazon EC2，cloud computing，针对于web  租用直接运行在Amazon数据中心物理机器上的virtual machines instances 使用的存储是连接在物理磁盘上的virtual local disk 客户在EC2上面运行着stateless www server或者DB 但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）  Amazon EBS (Elastic Block Store)  使用的是Chain Replication，基于paxos的configuration manager 如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume EBS不是shared...</div></div></div></a><a class="pagination-related" href="/2020/11/17/MIT6.824-GFS/" title="MIT6.824-GFS"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-GFS</div></div><div class="info-2"><div class="info-item-1">为什么我们要阅读这篇论文?在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的interface/semantics 应该怎么定义，它是怎么并行工作的等。 GFS paper涉及到了很多分布式系统主题：parallel performance, fault tolerance, replication, consistency 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。 为什么分布式存储这么难? high performance→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据 many servers→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复 fault tolerance →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用 replication →有数据不一致的风险 better consistency...</div></div></div></a><a class="pagination-related" href="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/" title="MIT6.824-LEC11-Cache-Consistency-Frangipani"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-LEC11-Cache-Consistency-Frangipani</div></div><div class="info-2"><div class="info-item-1">为什么要阅读这篇论文 cache coherence distributed transactions distributed crash recovery 三者的相互作用  整体的设计 a network file system，与现有的应用程序共同工作，类似普通的unix程序。可以将petal想象成一个磁盘，通过网络将数据共享给Frangipani，看起来就像从普通磁盘上读取数据  预期用途 一个文件系统，能保存自己的home目录以及共享的项目文件，在任何的workstation（可以理解是个人PC）能拿到自己的home目录以及所需要的所有文件。 没有涉及到安全问题，彼此电脑之间互相信任，适用于小群体  Frangipani的设计 强一致性 caching in each workstation — write-back 所有对文件的更新最初只是在workstation cache中完成—速度快 包括创建文件、目录、重命名等 比如ws1(workstation user...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/" title="MIT6.824-LEC9-More-Replication-CRAQ"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-LEC9-More-Replication-CRAQ</div></div><div class="info-2"><div class="info-item-1">为什么学习CRAQ Chain Replication(CR)，一种与Raft非常不一样的方法。 CRAQ能够从replica读取数据并且保持强一致性  什么是CR write：   client发送写请求给head server 请求按顺序沿着链下发 每个server用新数据覆盖旧数据 当tail server处理完成后回复给client   read：   client发送读请求给tail server tail server回复给client（不涉及其他server）   为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。 如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。 如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。 不能处理network partition或者spilt...</div></div></div></a><a class="pagination-related" href="/2020/12/14/MIT6.824-Primary-Backup-Replication/" title="MIT6.824-Primary-Backup-Replication"><img class="cover" src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-Primary-Backup-Replication</div></div><div class="info-2"><div class="info-item-1">What kinds of failures can replication deal with? “fail-stop” failure of a single replica fan stops working, CPU overheats and shuts itself down someone trips over replica’s power cord or network cable（电源线或网络电缆） software notices it is out of disk space and stops   Maybe not defects in h/w(Hardware/Software) or bugs in s/w or human configuration errors  Two main replication approachesState transfer Primary replica executes the service Primary sends [new] state to backups  Replicated state...</div></div></div></a><a class="pagination-related" href="/2020/11/06/MIT6.824-MapReduce/" title="MIT6.824-MapReduce"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">MIT6.824-MapReduce</div></div><div class="info-2"><div class="info-item-1">背景有时候我们需要从一批数据中得到一些结果，比如从最频繁查询的结果集，每个单词出现的次数。随着输入的数据越来越多，为了在合理的时间内完成，单台机器可能会完成不了这个任务，所以我们必须将这个计算压力分担到多个机器上面，并行计算。 但是解决计算的标准化，数据的分配，故障处理，负载均衡等问题是个大工程，让原本简单的代码变得复杂起来。 为此，Google发明了MapReduce系统，隔离了复杂的底层，让程序员能够容易使用这个系统进行大数据量的分布式计算。 编程模型将用户的计算分为两个函数处理：Map和Reduce 函数  Map函数：输入数据，处理后生成一组键值对（中间值） Reduce函数：处理前面得到的中间值，然后将这些值合并在一起，形成更小的值集。通常，每次 Reduce调用只生成零个或一个输出值。  简约模型： 123map (k1,v1) → list(k2,v2)//这里是指对应k2的结果有多个reduce (k2,list(v2)) → list(v2)   举个例子： 现有大量的文本数据，想统计每个单词出现的次数 123456789map(string...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">209</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">242</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E6%8F%90%E5%87%BA%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Zookeeper提出了什么问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86Zookeer%E8%A7%86%E4%B8%BA%E5%9F%BA%E4%BA%8ERaft%E7%9A%84service"><span class="toc-number">2.</span> <span class="toc-text">将Zookeer视为基于Raft的service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%88%91%E4%BB%AC%E6%B7%BB%E5%8A%A0%E6%9B%B4%E5%A4%9A%E7%9A%84server%E6%97%B6%E5%80%99%EF%BC%8Creplication-arrangement%E6%98%AF%E5%90%A6%E5%8F%98%E5%BE%97%E6%9B%B4%E5%BF%AB"><span class="toc-number">3.</span> <span class="toc-text">当我们添加更多的server时候，replication arrangement是否变得更快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E8%AE%A9follower%E6%8F%90%E4%BE%9B%E5%8F%AA%E8%AF%BB%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BF%99%E6%A0%B7leader%E5%8E%8B%E5%8A%9B%E5%B0%B1%E5%B0%8F%E5%BE%88%E5%A4%9A"><span class="toc-number">4.</span> <span class="toc-text">可以让follower提供只读服务，这样leader压力就小很多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA"><span class="toc-number">5.</span> <span class="toc-text">Zookeeper怎么处理这个</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ordering-guarantees-Section-2-3"><span class="toc-number">6.</span> <span class="toc-text">Ordering guarantees (Section 2.3)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linearizable-writes"><span class="toc-number">6.1.</span> <span class="toc-text">Linearizable writes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FIFO-client-order"><span class="toc-number">6.2.</span> <span class="toc-text">FIFO client order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E7%AE%A1Zookeeper%E4%B8%8D%E6%98%AFLinearizability%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8%E5%88%AB%E7%9A%84%E6%96%B9%E9%9D%A2%E8%BF%98%E6%98%AF%E6%9C%89%E7%94%A8%E7%9A%84"><span class="toc-number">7.</span> <span class="toc-text">尽管Zookeeper不是Linearizability，但是在别的方面还是有用的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%BD%B1%E5%93%8D"><span class="toc-number">8.</span> <span class="toc-text">几个影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8A%80%E5%B7%A7"><span class="toc-number">9.</span> <span class="toc-text">提高性能的技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Coordination-as-a-service%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%88Zookeeper%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">Coordination as a service是怎么样的（Zookeeper有什么用）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VMware-FT%E2%80%99s-test-and-set-server"><span class="toc-number">10.1.</span> <span class="toc-text">VMware-FT’s test-and-set server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Config-info"><span class="toc-number">10.2.</span> <span class="toc-text">Config info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mater-elect"><span class="toc-number">10.3.</span> <span class="toc-text">Mater elect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MapReduce"><span class="toc-number">10.4.</span> <span class="toc-text">MapReduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper-API"><span class="toc-number">10.5.</span> <span class="toc-text">Zookeeper API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operations-on-znodes"><span class="toc-number">11.</span> <span class="toc-text">Operations on znodes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zookeeper-api%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A5%BD%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">12.</span> <span class="toc-text">Zookeeper api可以很好地实现同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#znode%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E9%80%92%E5%A2%9E"><span class="toc-number">13.</span> <span class="toc-text">znode中的数字递增</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simple-Locks-Section-2-4"><span class="toc-number">14.</span> <span class="toc-text">Simple Locks (Section 2.4)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locks-without-Herd-Effect-scalable-lock"><span class="toc-number">15.</span> <span class="toc-text">Locks without Herd Effect(scalable lock)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_KaErMei-summary-2025-06-15-14-30-56/" title="[Xueqiu_KaErMei] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_KaErMei] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_KaErMei-summary-2025-06-15-14-30-56/" title="[Xueqiu_KaErMei] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_KaErMei] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:56.000Z" title="发表于 2025-06-15 14:30:56">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_ManBuJiaZhiXian-summary-2025-06-15-14-30-33/" title="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_ManBuJiaZhiXian-summary-2025-06-15-14-30-33/" title="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:33.000Z" title="发表于 2025-06-15 14:30:33">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_ShanXing-summary-2025-06-15-14-30-27/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_ShanXing-summary-2025-06-15-14-30-27/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_ShanXing] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:27.000Z" title="发表于 2025-06-15 14:30:27">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-14-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1618170673668-0eea9c66d40c?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-14-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:24.000Z" title="发表于 2025-06-15 14:30:24">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_OKaSiJiZhangShiFu-summary-2025-06-15-14-30-24/" title="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_OKaSiJiZhangShiFu-summary-2025-06-15-14-30-24/" title="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:24.000Z" title="发表于 2025-06-15 14:30:24">2025-06-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>