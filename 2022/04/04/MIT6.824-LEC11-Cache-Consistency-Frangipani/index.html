<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6.824-LEC11-Cache-Consistency-Frangipani | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么要阅读这篇论文 cache coherence distributed transactions distributed crash recovery 三者的相互作用  整体的设计 a network file..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.824-LEC11-Cache-Consistency-Frangipani",
  "url": "https://greenhathg.github.io/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/",
  "image": "https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2022-04-04T17:17:43.000Z",
  "dateModified": "2025-06-14T08:41:55.133Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6.824-LEC11-Cache-Consistency-Frangipani',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">197</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">MIT6.824-LEC11-Cache-Consistency-Frangipani</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">MIT6.824-LEC11-Cache-Consistency-Frangipani</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-04T17:17:43.000Z" title="发表于 2022-04-04 17:17:43">2022-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-14T08:41:55.133Z" title="更新于 2025-06-14 08:41:55">2025-06-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-14 08:41:55&quot;}" hidden></div><h1 id="为什么要阅读这篇论文"><a href="#为什么要阅读这篇论文" class="headerlink" title="为什么要阅读这篇论文"></a>为什么要阅读这篇论文</h1><ul>
<li>cache coherence</li>
<li>distributed transactions</li>
<li>distributed crash recovery</li>
<li>三者的相互作用</li>
</ul>
<h1 id="整体的设计"><a href="#整体的设计" class="headerlink" title="整体的设计"></a>整体的设计</h1><ul>
<li>a network file system，与现有的应用程序共同工作，类似普通的unix程序。<br><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220326232624.png" alt><br>可以将petal想象成一个磁盘，通过网络将数据共享给Frangipani，看起来就像从普通磁盘上读取数据</li>
</ul>
<h1 id="预期用途"><a href="#预期用途" class="headerlink" title="预期用途"></a>预期用途</h1><ul>
<li>一个文件系统，能保存自己的home目录以及共享的项目文件，在任何的workstation（可以理解是个人PC）能拿到自己的home目录以及所需要的所有文件。</li>
<li>没有涉及到安全问题，彼此电脑之间互相信任，适用于小群体</li>
</ul>
<h1 id="Frangipani的设计"><a href="#Frangipani的设计" class="headerlink" title="Frangipani的设计"></a>Frangipani的设计</h1><ul>
<li>强一致性</li>
<li>caching in each workstation — write-back<ul>
<li>所有对文件的更新最初只是在workstation cache中完成—速度快</li>
<li>包括创建文件、目录、重命名等</li>
<li>比如ws1(workstation user 1)想要创建并读写<code>/grades</code>：Frangipani会从Petal读取<code>/infomation</code>的信息并保存到cache，然后添加<code>/grades</code>到cache，但是并不会立马将修改同步到Petal，因为ws1也许会继续修改<code>/grades</code></li>
</ul>
</li>
<li>所以Frangipani程序应该安装在workstation，而且petal不会知道workstation上面的文件以及目录信息，所有的逻辑处理复杂性都放在了Frangipani中<ul>
<li>这是一种中心化方案（decentralized scheme）</li>
<li>添加更多workstation能添加更多CPU算力，有一定的扩展性，但是存储系统则会增加存储的负载，可能需要更多存储服务器。</li>
</ul>
</li>
</ul>
<h1 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h1><ul>
<li>主要来自caching、decentralized</li>
<li>cache coherence：ws1创建<code>/A</code>，ws2希望能看到<code>/A</code>（本地cache不会立即同步到Petal）</li>
<li>atomic multi-step operations：两个不同的workstation对同一个目录修改，比如ws1创建<code>/A</code>，ws2创建<code>/B</code>，最终<code>/</code>应该有两个目录，不应该出现覆盖的情况（因为中间会有很多更新的步骤），或者是同时创建两个相同的文件。</li>
<li>crash recovery：当一个workstation crash，不应该影响到其他用户，即使浏览crashed workstation目录下的文件，也应该看到正确的内容（没有损坏的，不一定要最新）</li>
<li>Petal里面内置了一套完全独立的容错系统（很像之前讨论的Chain Replication），不在讨论的范围内。</li>
</ul>
<h1 id="cache-coherence"><a href="#cache-coherence" class="headerlink" title="cache coherence"></a>cache coherence</h1><ul>
<li>目标是linearizability和caching，即同时兼备性能和一致性</li>
<li>许多系统使用了cache coherence protocols：多核处理器、file servers、distributed shared memory，但是Frangipani使用的不是这种，而是使用锁实现。</li>
</ul>
<h2 id="Frangipani’s-coherence-protocol"><a href="#Frangipani’s-coherence-protocol" class="headerlink" title="Frangipani’s coherence protocol"></a>Frangipani’s coherence protocol</h2><ul>
<li>lock server (LS), with one lock per file/directory，简化版，实际上Frangipani的锁更复杂，允许一个writer或者多个reader对文件操作<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file  owner</span><br><span class="line">-----------</span><br><span class="line">x     WS1</span><br><span class="line">y     WS1</span><br></pre></td></tr></table></figure></li>
<li>workstation (WS) Frangipani <strong>cache</strong>：每个workstation会去跟踪它持有的锁<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file/dir  lock  content(文件或者目录的实际内容)</span><br><span class="line">-----------------------</span><br><span class="line">x         busy  ...</span><br><span class="line">y         idle  ...</span><br></pre></td></tr></table></figure>
锁的种类：</li>
</ul>
<ol>
<li>busy：正在使用数据</li>
<li>idle：持有锁，但是现在不使用cached data（结束系统调用后由busy变成idle，比如创建文件、重命名、写入读取）</li>
</ol>
<ul>
<li>workstation使用锁的规则，保证缓存一致性<ul>
<li>只有持有该文件锁的时候，才能对这个文件的数据缓存</li>
<li>先获得锁，然后从Petal中读取数据，并保存到缓存</li>
<li>先将修改后的数据写回到Petal，再释放锁（会有定时将缓存写入到磁盘的机制，避免一直没有释放锁后又crash丢失数据）</li>
</ul>
</li>
<li>coherence protocol messages<ul>
<li>request  (WS -&gt; LS)</li>
<li>grant (LS -&gt; WS)</li>
<li>revoke (LS -&gt; WS)：请求ws释放idle锁，一般情况下workstation创建了文件立即释放掉，而是由busy变成idle，因为绝大部分情况下，创建了文件还会对其操作。当ws收到revoke且能释放的时候（也就是ws此时没有对文件进行操作），如果缓存数据修改过，则需要按照第3条规则写回到Petal。</li>
<li>release (WS -&gt; LS)</li>
</ul>
</li>
</ul>
<h2 id="示例-WS1更改文件z，然后WS2读取z"><a href="#示例-WS1更改文件z，然后WS2读取z" class="headerlink" title="示例:WS1更改文件z，然后WS2读取z"></a>示例:WS1更改文件z，然后WS2读取z</h2><p><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220328083733.png" alt></p>
<ol>
<li>WS1向LS请求文件z的锁</li>
<li>WS1拿到锁</li>
<li>从Petal读取文件z的内容，保存到cache</li>
<li>WS2向LS请求文件z的锁</li>
<li>WS1持有这把锁，向WS1发送revoke请求</li>
<li>如果z被修改过，需要将更新后的z的内容写回到Petal</li>
<li>WS1发送release给Petal，释放锁</li>
<li>WS2拿到锁</li>
</ol>
<ul>
<li>锁和使用锁的规则保证最后一次的修改能被别人看到</li>
<li>优化点：<ul>
<li>增加idle锁，避免频繁向LS请求</li>
<li>增加shared read lock、exclusive-write lock，共享读锁，当要写入时候回收读锁，写锁独占。</li>
</ul>
</li>
</ul>
<h1 id="atomic-multi-step-operations"><a href="#atomic-multi-step-operations" class="headerlink" title="atomic multi-step operations"></a>atomic multi-step operations</h1><p>Frangipani实现了transactional file-system operations（创建文件、删除文件、重命名等），以保证原子性</p>
<ol>
<li>获取该操作所需的所有锁</li>
<li>在持有所有锁的情况下执行操作，并将修改后的数据写到Petal</li>
<li>完成后释放锁<br>Frangipani的锁有两种作用：</li>
</ol>
<ul>
<li>cache coherence：同步最新的写入</li>
<li>transactional file-system：避免没有完成的操作让别的ws看到</li>
</ul>
<h1 id="crash-recovery"><a href="#crash-recovery" class="headerlink" title="crash recovery"></a>crash recovery</h1><ul>
<li>ws持有锁的时候崩溃（可能已经写入部分修改的数据到Petal）</li>
<li>此时不能直接释放对应的锁，因为操作还没有完成，释放后别的ws可能看到损坏的或者杂乱的数据，但是不释放锁别的ws就得一直等待锁。</li>
</ul>
<h2 id="write-ahead-logging"><a href="#write-ahead-logging" class="headerlink" title="write-ahead logging"></a>write-ahead logging</h2><p>Frangipani使用write-ahead logging实现crash recovery</p>
<ol>
<li>将cache中的信息写入到Petal的之前，先在Petal写入这组完整操作的log（日志是ws一段段根据offset发送给Petal）</li>
<li>只有这组操作的log已经安全落地到Petal，ws才发送写操作给Petal<ul>
<li>当已经写入部分到Petal的ws crash后，剩余的写入操作可以根据Petal的log完成<br>有两处与传统的logging方法不一样</li>
</ul>
</li>
</ol>
<ul>
<li>在大部分事务系统中，只有一个地方存放log，并且所有的事务日志都存放于此，所以一次crash或者多个操作都可以影响到这段数据。而Frangipani则是每个ws都有单独的log，避免了记录log的瓶颈，但是某个文件的更新日志可能分散存到不同的位置。</li>
<li>在大部分事务系统中，事务log存放位置和执行事务的那台机器是在一起的，基本是存在本地磁盘，但是Frangipani的log存放在共享的Petal中，而不是ws本地磁盘，这样ws2可以读取crash ws1的log并恢复。</li>
</ul>
<h2 id="log中的内容"><a href="#log中的内容" class="headerlink" title="log中的内容"></a>log中的内容</h2><ul>
<li>使用带有编号的block存储每个ws的日志</li>
<li>每个ws以环形队列的方式使用Petal上为它分配的空间，当空间用完的时候，ws可以从头写入，以此复用空间，但是在复用之前需要确保日志已经不需要（该日志的操作被Petal执行过了）<br><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220331073356.png" alt></li>
<li>log entry中的内容：<ul>
<li>LSN(log sequence number)：递增的log entry number，如果ws崩溃了，Frangipani会去扫描它的日志，直到LSN不在递增为止。</li>
<li>描述数据更新的数组，每个元素都有：Petal上的block号、version number和需要写入的内容</li>
</ul>
</li>
<li>log中只有文件系统中的目录、inode、allocation bitmap的元数据修改信息，没有文件中实际的内容的信息，只是包含了crash后恢复文件系统结构的足够信息。比如在目录d下创建了文件f，增加一个log entry，里面有两条关于修改的描述：如何初始化f的inode、该文件在目录d下的新名字。</li>
<li>最初log entry只在ws的内存中，避免频繁写入Petal。</li>
</ul>
<h2 id="revoke"><a href="#revoke" class="headerlink" title="revoke"></a>revoke</h2><p>收到ls的revoke消息的时候，需要释放锁</p>
<ol>
<li>将某些部分日志写到Petal的内存中，得确保日志是完整的</li>
<li>将已经修改的cache数据发送给Petal写入（这组数据修改操作的日志第一步已经发送了）</li>
<li>发送release消息释放锁</li>
</ol>
<h2 id="ws1在持有锁的时候崩溃"><a href="#ws1在持有锁的时候崩溃" class="headerlink" title="ws1在持有锁的时候崩溃"></a>ws1在持有锁的时候崩溃</h2><ul>
<li>ws2请求ws1持有的锁<ul>
<li>ls向ws发送revoke请求，没有得到响应，Frangipani的lock使用了lease的设定，当超过了lease time，就会判定ws肯定崩溃了。</li>
<li>ls告诉ws2根据Petal的日志恢复ws1（根据ws1的log写入到Petal，有一些checksum机制确保每个log entry都是完整的，避免执行没有写完整的log entry）</li>
<li>完成后告诉ls才能释放锁</li>
</ul>
</li>
<li>ws1可能没有将log写回到Petal就崩溃了，或者是在写的过程中崩溃了，那么可能会丢掉ws1做的一些操作，但是其他的ws不会收到影响。</li>
<li>另外一种情况是ws1将日志发送给Petal完成后或者只发送了一点缓存数据后就崩溃了，但是进行恢复工作的ws2并不知道ws1什么时候崩溃了，ws2需要重新执行log（可能会在相同的地方写入相同的内容）</li>
</ul>
<h1 id="版本号机制保证不会执行旧的日志"><a href="#版本号机制保证不会执行旧的日志" class="headerlink" title="版本号机制保证不会执行旧的日志"></a>版本号机制保证不会执行旧的日志</h1><p><img src="/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/Pasted image 20220401090622.png" alt></p>
<ul>
<li>ws1删除完d/f，ws2接着创建d/f，然后ws1崩溃了，接着ws3要恢复ws1</li>
<li>对于Petal中所保存的数据（元数据、目录、数据块等）来说都有一个版本号，当修改元数据并保存更新后的数据的时候会对版本+1。所以如果一个ws没有故障，并且成功的将数据写回到了Petal，这样元数据的版本号会大于等于Log条目中的版本号。如果有其他的工作站之后修改了同一份元数据，版本号会更高。</li>
<li>如果Petal中的版本号大于等于log entry中的版本号，ws3就忽略该日志，所以上述场景ws3不会执行ws1删除的日志，其他的日志同理，选择性的恢复。</li>
<li>当ws3进行恢复工作的时候，ws2可能持有着该目录所对应的锁，此时ws3查看ws1的log时候需要锁，这个应该怎么解决？<ul>
<li>一种不可行的方法是让ws3先获取所有的锁，再执行恢复动作。当发生系统级的供电故障后，所有持有锁的信息都丢失了，就没有了之前锁提供的两种保障，此时就不能随便恢复。</li>
<li>实际上，ws3可以在不关心锁的情况下对Petal进行数据读写。ws1要么释放了锁，要么没有。如果没有，那么没有其他人可以读写该目录，ws3可以放心地写。如果释放了锁，根据版本号比对就知道不用恢复该数据了。</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/">https://greenhathg.github.io/2022/04/04/MIT6.824-LEC11-Cache-Consistency-Frangipani/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mit6-824/">mit6.824</a><a class="post-meta__tags" href="/tags/Frangipani/">Frangipani</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/04/07/Golang-GC%E7%AC%94%E8%AE%B0-Semantics/" title="Golang-GC笔记-Semantics"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Golang-GC笔记-Semantics</div></div><div class="info-2"><div class="info-item-1">来源：https://www.ardanlabs.com/blog/2018/12/garbage-collection-in-go-part1-semantics.html Garbage collectors responsibility tracking heap memory allocations freeing up allocations that are no longer needed keeping allocations that are still in-use  As of version 1.12, the Go programming language uses a non-generational concurrent tri-color mark and sweep collector. 非分代并发三色标记和扫描收集器 Collector Behaviorcollection工作会经历三个阶段  Mark Setup - STW(Stop The World) Marking - Concurrent Mark Termination -...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/" title="MIT6.824-LEC10-Cloud Replicated-DB-Aurora"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">MIT6.824-LEC10-Cloud Replicated-DB-Aurora</div></div><div class="info-2"><div class="info-item-1">为什么要学习Aurora 作为近几年成功的云服务，解决了严重的问题 设计良好，有性能的优势 使用general-purpose storage架构情况下的局限性 许多关于云基础架构中重要的内容  Amazon EC2，cloud computing，针对于web  租用直接运行在Amazon数据中心物理机器上的virtual machines instances 使用的存储是连接在物理磁盘上的virtual local disk 客户在EC2上面运行着stateless www server或者DB 但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）  Amazon EBS (Elastic Block Store)  使用的是Chain Replication，基于paxos的configuration manager 如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume EBS不是shared...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/11/17/MIT6.824-GFS/" title="MIT6.824-GFS"><img class="cover" src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-GFS</div></div><div class="info-2"><div class="info-item-1">为什么我们要阅读这篇论文?在分布式系统中，分布式存储是关键的部分，我们该怎么去设计它，分布式存储的interface/semantics 应该怎么定义，它是怎么并行工作的等。 GFS paper涉及到了很多分布式系统主题：parallel performance, fault tolerance, replication, consistency 。从apps到network都有详细的介绍，并且在现实生活中有着成功的应用。 为什么分布式存储这么难? high performance→将数据拆分到很多服务器上面，通过很多台服务器并行读取数据 many servers→机器一多，机器发生故障的概率会变大，需要容灾机制，能够自动恢复 fault tolerance →最简单的方式就是通过复制得到多个副本，当一个副本出现问题时，其他副本还能用 replication →有数据不一致的风险 better consistency...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC10-Cloud%20Replicated-DB-Aurora/" title="MIT6.824-LEC10-Cloud Replicated-DB-Aurora"><img class="cover" src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC10-Cloud Replicated-DB-Aurora</div></div><div class="info-2"><div class="info-item-1">为什么要学习Aurora 作为近几年成功的云服务，解决了严重的问题 设计良好，有性能的优势 使用general-purpose storage架构情况下的局限性 许多关于云基础架构中重要的内容  Amazon EC2，cloud computing，针对于web  租用直接运行在Amazon数据中心物理机器上的virtual machines instances 使用的存储是连接在物理磁盘上的virtual local disk 客户在EC2上面运行着stateless www server或者DB 但是EC2不适合DB：扩展功能和容错功能有限（可以通过S3大容量存储服务定期存储数据库的snapshot）  Amazon EBS (Elastic Block Store)  使用的是Chain Replication，基于paxos的configuration manager 如果DB EC2崩溃，只需要在另一个EC2上面重新启动一个DB并挂载同一个EBS volume EBS不是shared...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC8-Zookeeper/" title="MIT6.824-LEC8-Zookeeper"><img class="cover" src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC8-Zookeeper</div></div><div class="info-2"><div class="info-item-1">Zookeeper提出了什么问题 能够将coordination作为一种通用服务去提供吗，可以的话，API应该是怎么样的，其他分布式程序应该怎么去使用它？ 我们有N个replica server，能从这个N个server中获得N倍性能吗？  将Zookeer视为基于Raft的service只不过ZooKeeper使用的是zab协议，为ZooKeeper专门设计的一种支持崩溃恢复的一致性协议 当我们添加更多的server时候，replication arrangement是否变得更快replica越多，写入的速度就越慢leader必须将每次写入发送给越来越多的server 可以让follower提供只读服务，这样leader压力就小很多可能会产生log与leader不一致的情况，导致client读取的数据不对，甚至是产生“倒退现象”，client先从up-to-date replica读，再从logging...</div></div></div></a><a class="pagination-related" href="/2022/03/30/MIT6.824-LEC9-More-Replication-CRAQ/" title="MIT6.824-LEC9-More-Replication-CRAQ"><img class="cover" src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-LEC9-More-Replication-CRAQ</div></div><div class="info-2"><div class="info-item-1">为什么学习CRAQ Chain Replication(CR)，一种与Raft非常不一样的方法。 CRAQ能够从replica读取数据并且保持强一致性  什么是CR write：   client发送写请求给head server 请求按顺序沿着链下发 每个server用新数据覆盖旧数据 当tail server处理完成后回复给client   read：   client发送读请求给tail server tail server回复给client（不涉及其他server）   为了让tail回复，这条链的每个节点必须处理写请求，即整个路径上的节点都已经处理了写请求。 如果head server fail，下一个节点可以代替head继续工作（tail server同理，不过是上一个节点）。如果head中途crash，但是数据还没有到tail server，所以就不会回复给client。 如果中间的server fail，需要移除该节点，上一个节点重新发送请求给新的下一个节点。 不能处理network partition或者spilt...</div></div></div></a><a class="pagination-related" href="/2020/12/14/MIT6.824-Primary-Backup-Replication/" title="MIT6.824-Primary-Backup-Replication"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-Primary-Backup-Replication</div></div><div class="info-2"><div class="info-item-1">What kinds of failures can replication deal with? “fail-stop” failure of a single replica fan stops working, CPU overheats and shuts itself down someone trips over replica’s power cord or network cable（电源线或网络电缆） software notices it is out of disk space and stops   Maybe not defects in h/w(Hardware/Software) or bugs in s/w or human configuration errors  Two main replication approachesState transfer Primary replica executes the service Primary sends [new] state to backups  Replicated state...</div></div></div></a><a class="pagination-related" href="/2020/11/06/MIT6.824-MapReduce/" title="MIT6.824-MapReduce"><img class="cover" src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-14</div><div class="info-item-2">MIT6.824-MapReduce</div></div><div class="info-2"><div class="info-item-1">背景有时候我们需要从一批数据中得到一些结果，比如从最频繁查询的结果集，每个单词出现的次数。随着输入的数据越来越多，为了在合理的时间内完成，单台机器可能会完成不了这个任务，所以我们必须将这个计算压力分担到多个机器上面，并行计算。 但是解决计算的标准化，数据的分配，故障处理，负载均衡等问题是个大工程，让原本简单的代码变得复杂起来。 为此，Google发明了MapReduce系统，隔离了复杂的底层，让程序员能够容易使用这个系统进行大数据量的分布式计算。 编程模型将用户的计算分为两个函数处理：Map和Reduce 函数  Map函数：输入数据，处理后生成一组键值对（中间值） Reduce函数：处理前面得到的中间值，然后将这些值合并在一起，形成更小的值集。通常，每次 Reduce调用只生成零个或一个输出值。  简约模型： 123map (k1,v1) → list(k2,v2)//这里是指对应k2的结果有多个reduce (k2,list(v2)) → list(v2)   举个例子： 现有大量的文本数据，想统计每个单词出现的次数 123456789map(string...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">197</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">237</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%98%85%E8%AF%BB%E8%BF%99%E7%AF%87%E8%AE%BA%E6%96%87"><span class="toc-number">1.</span> <span class="toc-text">为什么要阅读这篇论文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">整体的设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E6%9C%9F%E7%94%A8%E9%80%94"><span class="toc-number">3.</span> <span class="toc-text">预期用途</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Frangipani%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">Frangipani的设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%91%E6%88%98"><span class="toc-number">5.</span> <span class="toc-text">挑战</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cache-coherence"><span class="toc-number">6.</span> <span class="toc-text">cache coherence</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Frangipani%E2%80%99s-coherence-protocol"><span class="toc-number">6.1.</span> <span class="toc-text">Frangipani’s coherence protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-WS1%E6%9B%B4%E6%94%B9%E6%96%87%E4%BB%B6z%EF%BC%8C%E7%84%B6%E5%90%8EWS2%E8%AF%BB%E5%8F%96z"><span class="toc-number">6.2.</span> <span class="toc-text">示例:WS1更改文件z，然后WS2读取z</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#atomic-multi-step-operations"><span class="toc-number">7.</span> <span class="toc-text">atomic multi-step operations</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#crash-recovery"><span class="toc-number">8.</span> <span class="toc-text">crash recovery</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#write-ahead-logging"><span class="toc-number">8.1.</span> <span class="toc-text">write-ahead logging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">8.2.</span> <span class="toc-text">log中的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#revoke"><span class="toc-number">8.3.</span> <span class="toc-text">revoke</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ws1%E5%9C%A8%E6%8C%81%E6%9C%89%E9%94%81%E7%9A%84%E6%97%B6%E5%80%99%E5%B4%A9%E6%BA%83"><span class="toc-number">8.4.</span> <span class="toc-text">ws1在持有锁的时候崩溃</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BC%9A%E6%89%A7%E8%A1%8C%E6%97%A7%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">9.</span> <span class="toc-text">版本号机制保证不会执行旧的日志</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_Forever-summary-2025-06-14/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-14">[Xueqiu_Forever] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:41:44.000Z" title="发表于 2025-06-14 08:41:44">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"><img src="https://images.unsplash.com/photo-1619075120066-02024cb853bd?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14"/></a><div class="content"><a class="title" href="/2025/06/14/Xueqiu_ShanXing-summary-2025-06-14/" title="[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14">[Xueqiu_ShanXing] 发言时段总结 - 2025-06-14</a><time datetime="2025-06-14T08:15:28.000Z" title="发表于 2025-06-14 08:15:28">2025-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded"><img src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project2-BPlusTree-Delete-Single-threaded"/></a><div class="content"><a class="title" href="/2024/01/05/CMU445-Project2-BPlusTree-Delete-Single-Threaded/" title="CMU445-Project2-BPlusTree-Delete-Single-threaded">CMU445-Project2-BPlusTree-Delete-Single-threaded</a><time datetime="2024-01-05T12:39:43.000Z" title="发表于 2024-01-05 12:39:43">2024-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒"><img src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="玩客云换魔百盒"/></a><div class="content"><a class="title" href="/2023/12/31/%E7%8E%A9%E5%AE%A2%E4%BA%91%E6%8D%A2%E9%AD%94%E7%99%BE%E7%9B%92/" title="玩客云换魔百盒">玩客云换魔百盒</a><time datetime="2023-12-31T12:44:43.000Z" title="发表于 2023-12-31 12:44:43">2023-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded"><img src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CMU445-Project1-BPlusTree-Insert-Single-threaded"/></a><div class="content"><a class="title" href="/2023/12/12/CMU445-Project2-BPlusTree-Insert/" title="CMU445-Project1-BPlusTree-Insert-Single-threaded">CMU445-Project1-BPlusTree-Insert-Single-threaded</a><time datetime="2023-12-12T22:59:43.000Z" title="发表于 2023-12-12 22:59:43">2023-12-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>