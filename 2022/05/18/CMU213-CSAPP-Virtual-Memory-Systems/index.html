<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CMU213-CSAPP-Virtual-Memory-Systems | GreenHatHGのBlog</title><meta name="author" content="GreenHatHg"><meta name="copyright" content="GreenHatHg"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="18-Virtual-Memory-SystemsSimple memory system exampleAddress Translation Example..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CMU213-CSAPP-Virtual-Memory-Systems",
  "url": "https://greenhathg.github.io/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/",
  "image": "https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80",
  "datePublished": "2022-05-18T14:54:43.000Z",
  "dateModified": "2025-06-15T14:30:35.489Z",
  "author": [
    {
      "@type": "Person",
      "name": "GreenHatHg",
      "url": "https://greenhathg.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://avatars0.githubusercontent.com/u/34258355?s=460&u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&v=4"><link rel="canonical" href="https://greenhathg.github.io/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="&lt;meta name=&quot;google-site-verification&quot; content=&quot;eCt7WHUdmok7J0DG_5L1LtGFqZ_0DeC0ndMY3tBY_rQ&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-116672888-1"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'UA-116672888-1')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'UA-116672888-1', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CMU213-CSAPP-Virtual-Memory-Systems',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">241</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">GreenHatHGのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">CMU213-CSAPP-Virtual-Memory-Systems</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/mood/"><i class="fa-fw fas fa-glass-cheers"></i><span> 自言自语</span></a></div><div class="menus_item"><a class="site-page" href="/message/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">CMU213-CSAPP-Virtual-Memory-Systems</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-18T14:54:43.000Z" title="发表于 2022-05-18 14:54:43">2022-05-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-15T14:30:35.489Z" title="更新于 2025-06-15 14:30:35">2025-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>12分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;已超过&quot;,&quot;messageNext&quot;:&quot;天未更新，某些文章具有时效性，若有错误或已失效，请反馈到greenhat2333@gamil.com&quot;,&quot;postUpdate&quot;:&quot;2025-06-15 14:30:35&quot;}" hidden></div><h1 id="18-Virtual-Memory-Systems"><a href="#18-Virtual-Memory-Systems" class="headerlink" title="18-Virtual-Memory-Systems"></a>18-Virtual-Memory-Systems</h1><h2 id="Simple-memory-system-example"><a href="#Simple-memory-system-example" class="headerlink" title="Simple memory system example"></a>Simple memory system example</h2><h3 id="Address-Translation-Example-1"><a href="#Address-Translation-Example-1" class="headerlink" title="Address Translation Example #1"></a>Address Translation Example #1</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/20220508122617.png" alt="png"></p>
<p>PPN实际不存在页表中</p>
<ol>
<li>MMU做的第一件事是检查TLB，将VA中的VPN的TLBI(0x3)和TLBT(0x03)提取出来。所以会去查set3找到tag为3的line，找到对应的line并且valid为1，TLB将PPN(0D)返回给MMU</li>
<li>MMU使用0D构建物理地址。将VA的VPO复制到PA的PPO，0D作为PA的PPN，由此构成了一个物理地址</li>
<li>将地址发送给cache，提取出CI(0x5)、CT(0x0D)，所以会去查set5找到tag为0xD的line，找到并且valid为1，因为CO为0，所以找到B0(36)</li>
<li>cache将该字节通过MMU返回给CPU，并将其存到一个寄存器中。</li>
</ol>
<h3 id="Address-Translation-Example-2"><a href="#Address-Translation-Example-2" class="headerlink" title="Address Translation Example #2"></a>Address Translation Example #2</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/20220508131850.png" alt="png"></p>
<ol>
<li>VA中的VPN的TLBI=TLBT=0，TLB的set=0&amp;tag=0的line的valid=0，TLB miss</li>
<li>通过VPN=0查找页表，valid=1有效，内存将PTE返回给MMU构造物理地址。</li>
<li>MMU用物理地址请求cache，CI=0x8,CT=0x28，set 8中不存在tag为28的line，cache miss</li>
<li>将物理地址传递给内存获取数据</li>
</ol>
<h2 id="Case-study-Core-i7-Linux-memory-system"><a href="#Case-study-Core-i7-Linux-memory-system" class="headerlink" title="Case study: Core i7/Linux memory system"></a>Case study: Core i7/Linux memory system</h2><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_12.JPG" alt="png"></p>
<p>单个芯片封装了4个核心，每个核都可以看作一个单独的cpu，可以各自独立的执行指令。</p>
<p>每个核心都有：</p>
<ul>
<li>寄存器、获取指令的硬件(instruction fetch)</li>
<li>两个L1 cache：d-cache保存从内存中获取的数据，i-cache保存从code region获取的指令，d-cache只有数据，i-cache只有指令。访问L1大概需要4个CPU周期。</li>
<li>L2 unified cache：既可以保存指令，又可以保存数据。访问L1大概需要10个CPU周期。</li>
</ul>
<h3 id="End-to-end-Core-i7-Address-Translation"><a href="#End-to-end-Core-i7-Address-Translation" class="headerlink" title="End-to-end Core i7 Address Translation"></a>End-to-end Core i7 Address Translation</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_14.JPG" alt="png"></p>
<h3 id="Core-i7-Level-1-4-Page-Table-Entries"><a href="#Core-i7-Level-1-4-Page-Table-Entries" class="headerlink" title="Core i7 Level 1-4 Page Table Entries"></a>Core i7 Level 1-4 Page Table Entries</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_15.JPG" alt="png"></p>
<p>这三级的PTE指向的是下一级的页表的地址</p>
<p>CD表示能不能缓存</p>
<p>XD为disable意味着无法从这个page上加载到任何指令</p>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_16.JPG" alt="png"></p>
<h3 id="Cute-Trick-for-Speeding-Up-L1-Access"><a href="#Cute-Trick-for-Speeding-Up-L1-Access" class="headerlink" title="Cute Trick for Speeding Up L1 Access"></a>Cute Trick for Speeding Up L1 Access</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_18.JPG" alt="png"></p>
<p>因为VPO和PPO都是一样的，所以CI也是一样的。当CPU需要转换虚拟地址时，它会将VPN发送到MMU，将VPO发送到L1 cache，MMU查询TLB的时候cache可以并行做set的查找，找到所有的line后并且MMU完成地址转换，此时就可以根据tag找到特定的line了。</p>
<h3 id="Virtual-Address-Space-of-a-Linux-Process"><a href="#Virtual-Address-Space-of-a-Linux-Process" class="headerlink" title="Virtual Address Space of a Linux Process"></a>Virtual Address Space of a Linux Process</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_19.JPG" alt="png"></p>
<ul>
<li>程序的代码(<code>program .text</code>)总是在相同的地址：0x400000上加载的。</li>
<li><code>.data</code>可执行二进制文件的的初始化数据，<code>.bss</code>二进制文件中定义的未初始化数据</li>
<li>Runtime heap逐渐向上增长，内核通过进程上下文中brk全局变量来跟踪该进程中堆顶(heap top)的位置</li>
<li>User stack：用户程序可访问内存，向下增长，底部由%rsp指向。</li>
<li>User stack与kernel code and data还有一段空间隔开，原因是intel架构虚拟地址只有48位，其他12位被内核利用。</li>
<li>每个进程都有相同的内核部分，内核代码也是一样的，内核为每个进程维护特定的数据结构，所有这些数据结构称为上下文。</li>
</ul>
<h3 id="Linux-Organizes-VM-as-Collection-of-“Areas”"><a href="#Linux-Organizes-VM-as-Collection-of-“Areas”" class="headerlink" title="Linux Organizes VM as Collection of “Areas”"></a>Linux Organizes VM as Collection of “Areas”</h3><ul>
<li><p>Linux organizes the virtual memory as a <strong>collection of areas</strong> (also called segments). An area is a <strong>contiguous chunk</strong> of existing (allocated) virtual memory whose pages are related in some way.</p>
</li>
<li><p>The code segment, data segment, heap, shared library segment, and user stack are all distinct areas.</p>
</li>
<li><p>It allows the virtual address space to have <strong>gaps</strong>. The kernel <strong>does not keep track of virtual pages that do not exist</strong>, and such pages do not consume any additional resources in memory, on disk, or in the kernel itself.</p>
</li>
</ul>
<p>the kernel data structures that keep track of the virtual memory areas in a process:</p>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_20.JPG" alt="png"></p>
<ul>
<li><p>内核为每个进程维护了一个数据结构task_struct，包含或者指向了内核运行该进程需要的所有信息(e.g., the PID, pointer to the user stack, name of the executable object file, and program counter)</p>
</li>
<li><p>task_struct包含了一个指向代表VM当前状态的mm struct的指针，mm_struct包含了指向L1 page table的地址，这是上下文的一部分，当这个进程被调度时，内核把pgd复制到CR3中（通过修改CR3进而修改虚拟地址空间地址）。一旦CR3的值发生了改变，该进程不再有权访问之前进程的页表。</p>
</li>
<li><p>area_struct通过vm_start标识该area的开始位置，通过vm_end标识该area结束的位置。</p>
</li>
<li><p>vm_prot: Describes the read/write permissions for all of the pages contained in the area.</p>
</li>
<li><p>vm_flags: whether the pages in the area are shared with other processes or private to this process.</p>
</li>
<li><p>vm_next: Points to the next area struct in the list(图这里描述是链表，实际上在操作系统中的实现可能是树).</p>
</li>
</ul>
<h3 id="Linux-Page-Fault-Handling"><a href="#Linux-Page-Fault-Handling" class="headerlink" title="Linux Page Fault Handling"></a>Linux Page Fault Handling</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_21.JPG" alt="png"></p>
<p>MMU尝试转换虚拟地址A的时候触发了一个page fault，随后将控制权转向kernel’s page fault handler，该handler会执行以下步骤：</p>
<ol>
<li>判断A是否位于某个area_struct定义的area区间内。handler会搜索所有的area struct，将A与vm_start和vm_end比较。如果不合法，则handler触发segmentation fault，进而终止进程。</li>
<li>判断A是否有权读取或者写入该area中的page。比如写入一个只读的page，或者是运行在用户态的进程访问只能由内核访问的page。如果不合法，则handler触发protection exception，进而终止进程。</li>
<li>否则是normal page fault，即page不在DRAM，执行paging流程。</li>
</ol>
<h2 id="Memory-Mapping"><a href="#Memory-Mapping" class="headerlink" title="Memory Mapping"></a>Memory Mapping</h2><p>Linux <strong>initializes the contents of a virtual memory area</strong> by associating it with <strong>an object on disk</strong>, a process known as <strong>memory mapping</strong>.</p>
<p> Areas can be mapped to one of two types of objects:</p>
<ul>
<li><strong>Regular file on disk</strong> (e.g., an executable object file)<ul>
<li>An area can be mapped to a <strong>contiguous section</strong> of a regular disk file.</li>
<li>The file section is divided into <strong>page-size pieces</strong>, with each piece containing the initial contents of a virtual page.</li>
<li>Demand paging</li>
<li>If the area is larger than the file section, then the area is <strong>padded with zeros</strong>.</li>
</ul>
</li>
<li><strong>Anonymous file</strong> (e.g., nothing, there isn’t a file specified)<ul>
<li>The first time the CPU touches a virtual page in such an area, the kernel finds an appropriate victim page in physical memory, swaps out the victim page if it is dirty, <strong>overwrites the victim page with binary zeros</strong>, and updates the page table to mark the page as resident.</li>
<li>Once the page is written to (dirtied), it is like any other page</li>
<li>No data are actually transferred between disk and memory.</li>
<li>Pages in areas that are mapped to anonymous files are sometimes called <strong>demand-zero pages</strong>.</li>
</ul>
</li>
</ul>
<p>In either case, once a virtual page is initialized, it is swapped back and forth(<em>来回</em>) between a special <strong>swap file</strong> maintained by the kernel.</p>
<h3 id="Shared-Objects"><a href="#Shared-Objects" class="headerlink" title="Shared Objects"></a>Shared Objects</h3><ul>
<li><p>Many programs need to access identical copies of readonly run-time library code. For example, every C program requires functions from the standard C library such as printf.</p>
</li>
<li><p>Memory mapping provides us with a clean mechanism for controlling how objects are shared by multiple processes.</p>
</li>
<li><p>An object can be mapped into an area of virtual memory as either a <strong>shared object</strong> or a <strong>private object</strong>.</p>
</li>
<li><p>Since each object has a unique filename, the kernel can quickly determine that process has already mapped the object.</p>
</li>
</ul>
<p>如果一个进程对共享对象(shared object)对应的虚拟地址空间进行了写操作，那么这个写操作也会同步到磁盘上的文件，并且所有映射了该对象的进程都可见该修改。</p>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/1.png" alt="png"></p>
<p>The key point is that only a single copy of the shared object needs to be stored in physical memory, even though the object is mapped into multiple shared areas.</p>
<h3 id="Private-Copy-on-write-COW-Objects"><a href="#Private-Copy-on-write-COW-Objects" class="headerlink" title="Private Copy-on-write (COW) Objects"></a>Private Copy-on-write (COW) Objects</h3><p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/2.png" alt="png"></p>
<ul>
<li><p>Two processes have mapped a private object into different areas of their virtual memories but share the same physical copy of the object.</p>
</li>
<li><p>Area flagged as private copy-on-<br>write.PTEs in private areas are flagged as read-only.</p>
</li>
<li><p>So long as neither(<em>只要两者都不</em>) process attempts to write to its respective(<em>各自的</em>) private area, they continue to share a single copy of the object in physical memory. </p>
</li>
<li><p>As soon as a process attempts to write to some page in the private area, the write triggers a <strong>protection fault</strong>.</p>
</li>
<li><p>Handler creates a new copy of the page in physical memory, updates the page table entry to point to the new copy, and then restores write permissions to the page. 返回时CPU重新执行写操作，将会在新的page上写。</p>
</li>
<li><p>Copying deferred as long a possible. 更有效利用内存。</p>
</li>
</ul>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork时候会提供一个几乎一样但是独立的虚拟地址空间，如果将所有页表都复制一遍效率很低，COW就提供了一个高效的方法。</p>
<ul>
<li><p>VM and memory mapping explain how fork provides private<br>address space for each process.</p>
</li>
<li><p>To create virtual address for new new process：</p>
<ul>
<li>Create exact copies of current mm_struct, vm_area_struct, and page tables.内核只拷贝所有的内核数据结构，无法避免，但是不大。</li>
<li>Flag each page in both processes as read-only.</li>
<li>Flag each vm_area_struct in both processes as private COW.</li>
</ul>
</li>
<li><p>On return, each process has exact copy of virtual memory</p>
</li>
<li><p>Subsequent(<em>后续</em>) writes create new pages using COW mechanism.</p>
</li>
</ul>
<p>本质是让copy延迟了，只有在写时候才复制。</p>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>Suppose that the program running in the current process makes the following call</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;a.out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>The execve function <strong>loads and runs</strong> the program contained in the executable object file a.out within the current process, effectively replacing the current program with the a.out program.</p>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_29.JPG" alt="png"></p>
<ul>
<li><strong>Delete the existing area</strong> structs in the <strong>user portion</strong> of the current process’s virtual address: vm_area_struct’s and page tables</li>
<li><strong>Create vm_area_struct’s and page tables for new areas</strong><ul>
<li><strong>Map private areas</strong>: Create new area(private copy-on-write) structs<ul>
<li>code, data area: mapped to the .text and .data sections of the a.out file.</li>
<li>bss area: demand-zero, mapped to an anonymous file whose size is contained in a.out.</li>
<li>stack, heap area: demand-zero, initially of zero length.</li>
</ul>
</li>
<li><strong>Map shared areas</strong>: If the a.out program was linked with shared objects, such as the standard C library libc.so , then these objects are dynamically linked into the program, and then mapped into the shared region of the user’s virtual address space.</li>
</ul>
</li>
<li><strong>set the program counter</strong> in the current process’s context to point to the entry point in the code area.</li>
</ul>
<p>The next time this process is scheduled, it will begin execution from the entry point. Linux will <strong>swap in code and data pages as needed</strong>.</p>
<p>只是在内核中创建了数据结构和内存映射，还没有任何内容拷贝到内存。</p>
<h3 id="User-Level-Memory-Mapping"><a href="#User-Level-Memory-Mapping" class="headerlink" title="User-Level Memory Mapping"></a>User-Level Memory Mapping</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">int</span> offset)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Linux processes can use the mmap function to <strong>create new areas of virtual memory and to map objects into these areas</strong>.只是内存映射，没有copy，只是将虚拟地址空间中空闲的部分映射到文件</p>
</li>
<li><p>start：mmap函数尝试将从start处开始，创建长度为length 字节的区域，并映射到由fd确定的某个文件的offset位置。The start address is merely(<em>仅仅</em>) a hint, and is usually specified as NULL.</p>
</li>
<li><p>prot: 对应area_struct中的vm_prot, the access permissions of the newly mapped virtual memory area: PROT_READ, PROT_WRITE…</p>
</li>
<li><p>flags: the type of the mapped object: MAP_ANON(anonymous object, corresponding virtual pages are demand-zero), MAP_PRIVATE(private copy-on-write object), MAP_SHARED(shared object)</p>
</li>
<li><p>Return a pointer to start of mapped area (may not be start)</p>
</li>
</ul>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_31.JPG" alt="png"></p>
<p>Asks the kernel to create a new read-only, private, demand-zero area of virtual memory containing size bytes. If the call is successful, then bufp contains the address of the new area:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bufp = mmap(<span class="literal">NULL</span>, size, PROT_READ, </span><br><span class="line">            MAP_PRIVATEIMAP_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>The <strong>munmap</strong> function deletes the area starting at virtual address start and consisting of the next length bytes. Subsequent references to the deleted region result in segmentation faults.</p>
<h4 id="Example-Using-mmap-to-Copy-Files"><a href="#Example-Using-mmap-to-Copy-Files" class="headerlink" title="Example: Using mmap to Copy Files"></a>Example: Using mmap to Copy Files</h4><p>拷贝文件到标准输出，没有把数据拷贝到用户地址空间。标准做法是读取文件，然后写到标准输出中去，需要用两个系统调用，read和write。但只使用一个系统调用mmap就可以做到这点。</p>
<p>从命令行得到一个文件名，然后打开这个文件，获取到文件的大小。调用mmap，传递fd、大小、长度，设置flag为私有。然后调用write，把buffer指向的内容拷贝到标准输出，设置拷贝的大小。write 函数会从bufp中一个字节一个字节地读取，执行的时候会出现异常，异常处理完成后，write把bufp写入到fd对应的文件，也就是stdout</p>
<p><img src="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/18-vm-systems_32.JPG" alt="png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io">GreenHatHg</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://greenhathg.github.io/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/">https://greenhathg.github.io/2022/05/18/CMU213-CSAPP-Virtual-Memory-Systems/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://greenhathg.github.io" target="_blank">GreenHatHGのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CMU213/">CMU213</a><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a><a class="post-meta__tags" href="/tags/virtual-memory/">virtual-memory</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post-share"><div class="social-share" data-image="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/15/CMU445-Project0-primer/" title="CMU445-Project0-primer"><img class="cover" src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CMU445-Project0-primer</div></div><div class="info-2"><div class="info-item-1">背景 链接：https://15445.courses.cs.cmu.edu/fall2022/project0/ 目的：因为后续的项目都是使用c++编写，所以提供一个入门c++项目给新手熟悉下。 要求：给出基本的代码框架，填充核心代码实现trie树的插入、查找、删除。最终要求为并发版本，但是不要求性能，所以可以一把大锁直接梭哈。 环境：使用clang-12，c++17标准 使用到的常见cpp知识点： unique_ptr管理内存资源 类的常见知识，比如构造函数，类方法等 rvalue与move shared_mutex    trie树简单记录下trie树 作用又称前缀树或字典树，存储公共前缀字符串比较高效，一般用于字符串查找。 在项目中的应用是将(key, value)插入到trie树，类似hashmap的作用，但是使用trie树实现。 普通的trie树如下：  项目中要求实现的trie树：  上面是将(ab, 1)和(ac,...</div></div></div></a><a class="pagination-related" href="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/" title="CMU213-CSAPP-Virtual-Memory-Concepts"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">CMU213-CSAPP-Virtual-Memory-Concepts</div></div><div class="info-2"><div class="info-item-1">17-Virtual-Memory-ConceptsPhysical and Virtual Addressing Main memory: an array of M contiguous(连续的) byte-size cells(单元). Each byte has a unique physical address (PA) &#123;0, 1, 2, 3 … &#125;  The most natural way for a CPU to access memory would be to use physical addresses. We call this approach physical addressing.  When the CPU executes the load instruction, it generates an effective physical address and passes it to main memory over the memory bus. The main memory fetches the 4-byte...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/05/18/CMU213-CSAPP-Virtual-Memory-Concepts/" title="CMU213-CSAPP-Virtual-Memory-Concepts"><img class="cover" src="https://images.unsplash.com/photo-1620880762272-c2bf6b4f1ce2?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-06-15</div><div class="info-item-2">CMU213-CSAPP-Virtual-Memory-Concepts</div></div><div class="info-2"><div class="info-item-1">17-Virtual-Memory-ConceptsPhysical and Virtual Addressing Main memory: an array of M contiguous(连续的) byte-size cells(单元). Each byte has a unique physical address (PA) &#123;0, 1, 2, 3 … &#125;  The most natural way for a CPU to access memory would be to use physical addresses. We call this approach physical addressing.  When the CPU executes the load instruction, it generates an effective physical address and passes it to main memory over the memory bus. The main memory fetches the 4-byte...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://avatars0.githubusercontent.com/u/34258355?s=460&amp;u=eb0a1ce09dd045532464cb42f020e8ba1d025b6c&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">GreenHatHg</div><div class="author-info-description">巴拉巴拉能量! rm -rf / --no-preserve-root</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">205</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">241</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/GreenHatHG"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/GreenHatHG" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:greenhat2333@gmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#18-Virtual-Memory-Systems"><span class="toc-number">1.</span> <span class="toc-text">18-Virtual-Memory-Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Simple-memory-system-example"><span class="toc-number">1.1.</span> <span class="toc-text">Simple memory system example</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Address-Translation-Example-1"><span class="toc-number">1.1.1.</span> <span class="toc-text">Address Translation Example #1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Address-Translation-Example-2"><span class="toc-number">1.1.2.</span> <span class="toc-text">Address Translation Example #2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Case-study-Core-i7-Linux-memory-system"><span class="toc-number">1.2.</span> <span class="toc-text">Case study: Core i7&#x2F;Linux memory system</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#End-to-end-Core-i7-Address-Translation"><span class="toc-number">1.2.1.</span> <span class="toc-text">End-to-end Core i7 Address Translation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Core-i7-Level-1-4-Page-Table-Entries"><span class="toc-number">1.2.2.</span> <span class="toc-text">Core i7 Level 1-4 Page Table Entries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cute-Trick-for-Speeding-Up-L1-Access"><span class="toc-number">1.2.3.</span> <span class="toc-text">Cute Trick for Speeding Up L1 Access</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Virtual-Address-Space-of-a-Linux-Process"><span class="toc-number">1.2.4.</span> <span class="toc-text">Virtual Address Space of a Linux Process</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Organizes-VM-as-Collection-of-%E2%80%9CAreas%E2%80%9D"><span class="toc-number">1.2.5.</span> <span class="toc-text">Linux Organizes VM as Collection of “Areas”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-Page-Fault-Handling"><span class="toc-number">1.2.6.</span> <span class="toc-text">Linux Page Fault Handling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-Mapping"><span class="toc-number">1.3.</span> <span class="toc-text">Memory Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-Objects"><span class="toc-number">1.3.1.</span> <span class="toc-text">Shared Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Private-Copy-on-write-COW-Objects"><span class="toc-number">1.3.2.</span> <span class="toc-text">Private Copy-on-write (COW) Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">1.3.3.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execve"><span class="toc-number">1.3.4.</span> <span class="toc-text">execve</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#User-Level-Memory-Mapping"><span class="toc-number">1.3.5.</span> <span class="toc-text">User-Level Memory Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-Using-mmap-to-Copy-Files"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">Example: Using mmap to Copy Files</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-14-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30"><img src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-14-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30">[Xueqiu_Forever] 发言时段总结 - 2025-06-15 14:30</a><time datetime="2025-06-15T14:30:24.000Z" title="发表于 2025-06-15 14:30:24">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_ManBuJiaZhiXian-summary-2025-06-15-04-30-29/" title="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 04:30"><img src="https://images.unsplash.com/photo-1621761836815-6e43911fbcfc?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 04:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_ManBuJiaZhiXian-summary-2025-06-15-04-30-29/" title="[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 04:30">[Xueqiu_ManBuJiaZhiXian] 发言时段总结 - 2025-06-15 04:30</a><time datetime="2025-06-15T04:30:29.000Z" title="发表于 2025-06-15 04:30:29">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_GuanWoCai-summary-2025-06-15-04-30-27/" title="[Xueqiu_GuanWoCai] 发言时段总结 - 2025-06-15 04:30"><img src="https://images.unsplash.com/photo-1620880762296-f9787c134352?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_GuanWoCai] 发言时段总结 - 2025-06-15 04:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_GuanWoCai-summary-2025-06-15-04-30-27/" title="[Xueqiu_GuanWoCai] 发言时段总结 - 2025-06-15 04:30">[Xueqiu_GuanWoCai] 发言时段总结 - 2025-06-15 04:30</a><time datetime="2025-06-15T04:30:27.000Z" title="发表于 2025-06-15 04:30:27">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-04-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 04:30"><img src="https://images.unsplash.com/photo-1619342802099-027bc73e30eb?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 04:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_Forever-summary-2025-06-15-04-30-24/" title="[Xueqiu_Forever] 发言时段总结 - 2025-06-15 04:30">[Xueqiu_Forever] 发言时段总结 - 2025-06-15 04:30</a><time datetime="2025-06-15T04:30:24.000Z" title="发表于 2025-06-15 04:30:24">2025-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/15/Xueqiu_OKaSiJiZhangShiFu-summary-2025-06-15-04-30-24/" title="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 04:30"><img src="https://images.unsplash.com/photo-1620880762258-273a49958090?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1171&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 04:30"/></a><div class="content"><a class="title" href="/2025/06/15/Xueqiu_OKaSiJiZhangShiFu-summary-2025-06-15-04-30-24/" title="[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 04:30">[Xueqiu_OKaSiJiZhangShiFu] 发言时段总结 - 2025-06-15 04:30</a><time datetime="2025-06-15T04:30:24.000Z" title="发表于 2025-06-15 04:30:24">2025-06-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By GreenHatHg</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://blog-twikoo-khaki.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>